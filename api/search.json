[{"id":"8dd59640d6bc3d377df04d40d6faff25","title":"Linux网络编程（libevent）","content":"libevent的作用对于简单的socket编程，采用阻塞的方式是最基础的。例如，当调用recv函数时，如果没有数据到来就会一直阻塞。这种方式的问题在于，如果只有一个线程，那么就无法同时处理多个连接（处理其中一个连接时被阻塞后，另一个连接将无法被响应直到阻塞解除）。为了解决这个问题，可以采用多线程或者多进程的方式，一个进程负责监听连接，一旦有连接到来就创建一个新的线程或者进程来处理这个连接。但是线程和进程的创建和销毁都需要不小的开销，一旦并发数量大，将导致系统资源耗尽。那么把socket设置为非阻塞然后轮询呢？这样的问题在于，如果没有数据到来，那么就会一直占用CPU资源（还会进行大量系统调用）。\n一个解决问题的原始方法是，使用select函数。让内核帮助我们监视多个文件描述符，当其中一个文件描述符有数据到来时，select函数就会返回。后来的poll函数和epoll函数都能实现对应的功能。但是在不同的操作系统上，并不是都有统一的接口。libevent就是为了解决这个问题而生的。\nevent_baseevent_base结构体是libevent的核心，在使用libevent时，首先需要创建一个event_base对象。每个 event_base 结构体持有一组事件，并且可以通过轮询来确定哪些事件处于活动状态。\n如果要在多个线程中访问 event_base 结构体（如多个线程向里面添加事件），则需要使用锁机制来保证线程安全。但是，它的事件循环只能在单个线程中运行。如果希望多个线程轮询 I/O，则需要为每个线程创建一个 event_base （这也是保证线程安全的最简单的实践）。\nevent_base 有一个“方法”，用来指定事件循环的实现，包括 select、poll、epoll、kqueue 等。libevent 会根据当前系统的支持情况自动选择最合适的实现。也可以通过event_config_avoid_method()函数来指定不使用的方法。\nevent_base_newc#include &lt;event2/event.h&gt;\n\nstruct event_base *event_base_new(void);\nstruct event_base *event_base_new_with_config(const struct event_config *cfg);\nvoid event_base_free(struct event_base *base);使用默认设置在堆上创建一个新的 event_base 对象，并返回指针。如果创建失败，返回 NULL。\n如果要在初始化的时候配置 event_base 对象，则需要使用 event_base_new_with_config() 函数，传入一个 event_config 对象。\nevent_base_free() 用来释放 event_base 对象。\n\n\n\n\n\n\n\n特别注意\nevent_base_free()函数不会释放当前与 base 关联的任何事件，不会关闭它们的任何套接字，也不会释放它们的任何指针。\n\n\nevent_configc#include &lt;event2/event.h&gt;\n\nstruct event_config *event_config_new(void);\nvoid event_config_free(struct event_config *cfg);要配置 event_base ，先调用 event_config_new() 分配一个新的 event_config。然后，在 event_config 上调用其他函数来传入配置。最后，调用 event_base_new_with_config() 获取新的 event_base。完成后，可以使用 event_config_free() 释放 event_config。\ncconst char **event_get_supported_methods(void);//返回一个字符串数组，包含当前系统支持的所有方法的名字。\nint event_config_avoid_method(struct event_config *cfg, const char *method);//传入方法的名字strevent_config_avoid_method() 函数用来指定不使用的方法。传入方法的名字字符串，如 \"select\"、\"poll\"、\"epoll\"、\"kqueue\" 等。\ncenum event_method_feature {\n    EV_FEATURE_ET = 0x01,//需要支持边缘触发 I/O 的后端方法。\n    EV_FEATURE_O1 = 0x02,//需要一种后端方法，其中添加或删除单个事件或单个事件变为活动状态的操作的时间复杂度为 O(1)。\n    EV_FEATURE_FDS = 0x04,//需要一种后端方法，它可以支持任意文件描述符类型，而不仅仅是套接字。\n};\nint event_config_require_features(struct event_config *cfg,\n                                  enum event_method_feature feature);cenum event_base_config_flag {\n    EVENT_BASE_FLAG_NOLOCK = 0x01,//不要为 event_base 分配锁。（导致线程不安全）\n    EVENT_BASE_FLAG_IGNORE_ENV = 0x02,//在选择要使用的后端方法时，不要检查 EVENT_* 环境变量。\n    EVENT_BASE_FLAG_STARTUP_IOCP = 0x04,//在启动时启用任何必要的 IOCP 调度逻辑（仅Windows）\n    EVENT_BASE_FLAG_NO_CACHE_TIME = 0x08,//在每个超时回调之后检查当前时间\n    EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST = 0x10,//使用epoll-changelist 后端\n    EVENT_BASE_FLAG_PRECISE_TIMER = 0x20//使用更精细计时精度的较慢计时机制\n};\nint event_config_set_flag(struct event_config *cfg,\n    enum event_base_config_flag flag);cint event_config_set_max_dispatch_interval(struct event_config *cfg,\n    const struct timeval *max_interval, int max_callbacks,\n    int min_priority);event_config_set_max_dispatch_interval()通过限制在检查更多高优先级事件之前可以调用多少个低优先级事件回调来防止优先级反转。如果 max_interval 不为 NULL，则事件循环在每次回调后检查时间，并在 max_interval 已过时重新扫描高优先级事件。如果 max_callbacks 为非负数，则事件循环还会在调用 max_callbacks 个回调后检查更多事件。这些规则适用于任何优先级等于或高于 min_priority 的事件。\nevent_base_get_c#include &lt;event2/event.h&gt;\n\nconst char **event_get_supported_methods(void);\nconst char *event_base_get_method(const struct event_base *base);\nenum event_method_feature event_base_get_features(const struct event_base *base);\nstruct event *event_base_get_running_event(struct event_base *base);event_base_get_method() 返回 event_base 使用的方法的名字字符串。\nevent_base_get_features() 返回 event_base 使用的方法的特性，如 EV_FEATURE_ET、EV_FEATURE_O1、EV_FEATURE_FDS。\nevent_base_get_running_event() 返回当前正在运行的事件的指针。\n\n\n\n\n\n\n\n特别注意\nevent_base_get_running_event()函数的行为在其提供的 event_base 的事件循环中调用时有效。从另一个线程调用它不受支持，并且会导致未定义的行为。\n\n\nevent_base_priorityc#include &lt;event2/event.h&gt;\n\nint event_base_priority_init(struct event_base *base, int n_priorities);默认情况下，event_base 只支持单个优先级。您可以通过调用 event_base_priority_init() 函数来设置 event_base 上的优先级数量。\n在成功时返回 0，失败时返回 -1。base 参数是要修改的 event_base，n_priorities 是要支持的优先级数量。它必须至少为 1。新事件的可用优先级将从 0（最重要）到 n_priorities-1（最不重要）进行编号。\n常量 EVENT_MAX_PRIORITIES 设置了 n_priorities 值的上限。使用高于此值的 n_priorities 调用此函数是错误的。\n\n\n\n\n\n\n\n注意\n如果要调用此函数，最好在创建 event_base 后立即调用它，避免在添加事件之后调用。\n\n\ncint event_base_get_npriorities(struct event_base *base);查找 base 当前支持的优先级数量，如果没使用 event_base_priority_init() 设置优先级数量，则返回默认值 1。\n\n\n\n\n\n\n提示\n默认情况下，与此 base 关联的所有新事件都将初始化为优先级等于 n_priorities / 2。\n\n\nevent_reinitc#include &lt;event2/event.h&gt;\n\nint event_reinit(struct event_base *base);在 Forking 之后，子进程会继承父进程 event_base 的副本。此时必须在子进程中调用 event_reinit()，然后才能使用继承的 event_base。这很关键，因为：\n\n文件描述符： 子进程会继承打开的文件描述符，而 libevent 的后端可能依赖于这些描述符（例如，epoll、kqueue）。 event_reinit() 确保在子进程上下文中正确地重新初始化后端。\n信号处理程序： 信号处理程序可能无法正确继承。 event_reinit() 帮助重置子进程中事件循环的信号处理。\n\n在成功时返回 0，失败时返回 -1。\nevent在 libevent 中，事件代表一组条件：\n\n文件描述符已准备好进行读取或写入。\n文件描述符变为可读取或写入状态（仅限边缘触发 IO）。\n超时到期。\n发生信号。\n用户触发的事件。\n\n添加到 event_base 的事件一开始是待处理状态，如果满足条件，就会变为活动状态并运行用户指定的回调函数。\n回调函数执行后，如果事件配置为持久性，它将回到待处理状态。如果不是持久性的事件，则在运行回调函数时将变成非待处理状态。\n\n\n\n\n\n\n提示\n在 libevent 中：\n\n非持久性事件 被触发并且其回调函数执行后，它会自动从事件队列中移除，不再等待下次触发。\n\n持久性事件 被触发并且其回调函数执行后，它仍然会继续保留在事件队列中等待下次触发。简单来说，持久性事件在每次被触发后不会自动移除，需要手动停止或删除。\n\n\n\n\nevent_newc#define EV_TIMEOUT      0x01//在超时过后变为活动状态，（构造事件时，将被忽略）\n#define EV_READ         0x02//准备好进行读取时变为活动状态\n#define EV_WRITE        0x04//准备好进行写入时变为活动状态\n#define EV_SIGNAL       0x08//实现信号检测功能\n#define EV_PERSIST      0x10//持久性事件\n#define EV_ET           0x20//指示事件为边缘触发的\n\ntypedef void (*event_callback_fn)(evutil_socket_t, short, void *);\n\nstruct event *event_new(struct event_base *base, evutil_socket_t fd,\n    short what, event_callback_fn cb,\n    void *arg);\n\nvoid event_free(struct event *event);event_new() 函数尝试分配和构造一个新事件，以便与 base 一起使用。 \nwhat 参数是上面列出的标志集。如果 fd 为非负数，则它是我们将观察读取或写入事件的文件。当事件处于活动状态时，Libevent 将调用提供的 cb 函数，并将以下作为参数传递：文件描述符 fd、触发所有事件的位字段what以及在构造函数时为 arg 传递的值。\n如果出现内部错误或参数无效，event_new() 将返回 NULL。\n要释放事件，请调用 event_free()。\n所有新事件都已初始化且未处于待处理状态。要使事件处于待处理状态，请调用 event_add()。\n\n\n\n\n\n\n\n注意\n\n传入event_new()的fd必须先设置为非阻塞模式。防止在事件循环中因为阻塞I/O操作而导致整个应用程序挂起。\n在处于待处理或活动状态的事件上调用 event_free() 是安全的：这样做会在释放事件之前使其变为非待处理和非活动状态。\n参数fd为-1时，将不与任何文件描述符绑定，该事件可以作为用户触发事件（用event_active()手动激活）或者是接收自身作为回调参数的事件（允许回调函数在运行时能够访问并修改与该事件相关的信息或对该事件进行进一步的操作如：访问事件的上下文信息、重新配置或重新添加、停止或删除），特别注意如果要创建接收自身作为回调参数的事件，arg参数必须是event_self_cbarg()，event_self_cbarg() 函数返回一个“魔法”指针，当将其作为事件回调参数传递时，会告诉 event_new() 创建一个接收自身作为回调参数的事件。\n\n\n\nc#define evtimer_new(base, callback, arg) \\\n    event_new((base), -1, 0, (callback), (arg))\n#define evtimer_add(ev, tv) \\\n    event_add((ev),(tv))\n#define evtimer_del(ev) \\\n    event_del(ev)\n#define evtimer_pending(ev, tv_out) \\\n    event_pending((ev), EV_TIMEOUT, (tv_out))这些宏用来分配和操作纯超时事件。可以提高代码的可读性。\nc#define evsignal_new(base, signum, cb, arg) \\\n    event_new(base, signum, EV_SIGNAL|EV_PERSIST, cb, arg)\n#define evsignal_add(ev, tv) \\\n    event_add((ev),(tv))\n#define evsignal_del(ev) \\\n    event_del(ev)\n#define evsignal_pending(ev, what, tv_out) \\\n    event_pending((ev), (what), (tv_out))这个宏用来分配一个新的信号事件。signum 是信号的编号。使用它可以提高代码的可读性（由此可窥探，当event_new()传入EV_SIGNAL时fd参数代表信号编号）。\n\n\n\n\n\n\n\n注意\n每个进程一次只能有一个 event_base 监听信号。如果您将信号事件添加到两个 event_base 中（即使信号不同！），也只有一个 event_base 会收到信号。\n\n\n\n\n\n\n\n\n提示\nevent_new()将event分配在堆上，该event的内存由libevent管理。如果要将event内存分配在栈上，或者手动管理event的内存，可以使用event_assign()函数。（可能会破坏与其他版本 Libevent 的二进制兼容性，因为其他版本的事件结构体大小可能不同）\ncint event_assign(struct event *event, struct event_base *base,\n    evutil_socket_t fd, short what,\n    void (*callback)(evutil_socket_t, short, void *), void *arg);event_assign() 的所有参数都与 event_new() 相同，但 event 参数除外，它必须指向一个未初始化的事件。成功返回 0，内部错误或参数错误返回 -1。\n永远不要在已在事件循环中待处理的事件上调用 event_assign()，请先对其调用 event_del()\n\n\nevent_addcint event_add(struct event *ev, const struct timeval *tv);event_add() 函数将事件添加到其配置的 base 的监听事件队列中。tv 是以秒和微秒为单位的超时时间，如果 tv 不为 NULL，则事件将在 tv 指定的时间后变为活动状态，如果 tv 为 NULL，则添加事件时不设置超时。\n对已经添加到事件监听队列中的事件再次调用 event_add()，将会重新设置超时时间（超时为NULL时，该函数不会有任何作用，也就是说并不会设置为不超时）。\n\n\n\n\n\n\n提示\n要删除超时，需要调用event_remove_timer()（见下文）\n\n\nevent_delcint event_del(struct event *ev);将ev指向的事件从其配置的event_base的监听队列中删除（如果不在监听队列中，该函数不会有任何作用）返回值在成功时为 0，失败时为 -1。\n\n\n\n\n\n\n\n注意\n如果在一个事件变为活动状态后但在其回调有机会执行之前将其删除，则不会执行该回调。\n\n\ncint event_remove_timer(struct event *ev);删除事件超时属性的正确做法，如果没有超时属性则函数不起作用。（如果事件只有超时但没有 IO 或信号组件，即fd为-1，此时效果与 event_del()相同）\nevent_prioritycint event_priority_set(struct event *event, int priority);如果要设置事件的优先级（默认优先级为n_priorities / 2）请在初始化事件之后，调用event_add()之前。该函数在成功时返回 0，失败时返回 -1。\n当多个具有不同优先级的事件变为活动状态时，Libevent会运行高优先级事件，然后再次检查事件。只有当没有高优先级事件处于活动状态时，才会运行低优先级事件。（详细逻辑见下文event_loop的描述）\nevent_get_cint event_pending(const struct event *ev, short what, struct timeval *tv_out);\n\n#define event_get_signal(ev) /* ... */\nevutil_socket_t event_get_fd(const struct event *ev);\nstruct event_base *event_get_base(const struct event *ev);\nshort event_get_events(const struct event *ev);\nevent_callback_fn event_get_callback(const struct event *ev);\nvoid *event_get_callback_arg(const struct event *ev);\nint event_get_priority(const struct event *ev);\n\nvoid event_get_assignment(const struct event *event,\n        struct event_base **base_out,\n        evutil_socket_t *fd_out,\n        short *events_out,\n        event_callback_fn *callback_out,\n        void **arg_out);event_pending() 函数用于检查事件是否处于待处理状态，用返回值表示。what 参数是要检查的事件类型，可以是 EV_TIMEOUT、EV_READ、EV_WRITE、EV_SIGNAL 中的一个或多个。如果提供了 tv_out 参数，并且在 what 中设置了 EV_TIMEOUT，并且事件当前处于基于时间的待处理或活动状态，则tv_out用于存储设置的超时时间。\nevent_base_oncecint event_base_once(struct event_base *, evutil_socket_t, short,\n  void (*)(evutil_socket_t, short, void *), void *, const struct timeval *);如果事件不需要被添加多次、在添加后不需要被删除，并且不需要是持久的，则可以使用 event_base_once() 函数。\n此函数的接口与 event_new() 相同，除了它不支持 EV_SIGNAL 或 EV_PERSIST。 调度的事件将以默认优先级插入并运行。当回调最终完成时，Libevent 会自动释放内部事件结构。 成功返回 0，失败返回 -1。\nevent_loopevent_base_loopc//循环将等待，直到某些事件变为活动状态，然后运行活动事件，直到没有更多事件要运行，然后返回。\n#define EVLOOP_ONCE             0x01\n//循环不会等待事件触发，只检查是否有任何事件准备好立即触发，如果是，则运行它们的回调函数\n#define EVLOOP_NONBLOCK         0x02\n//循环在没有待处理或活动事件时不会立即退出\n#define EVLOOP_NO_EXIT_ON_EMPTY 0x04\n\nint event_base_loop(struct event_base *base, int flags);\nint event_base_dispatch(struct event_base *base);创建完event_base并向其中添加了event后，就可以让event_base开始监听事件的到来并在到来的时候进行处理。\nevent_base_loop() 函数会运行一个 event_base 直到其中没有要处理的事件为止。\nevent_base_loop() 正常退出返回 0；如果由于后端中的一些未处理错误而退出，返回 -1；如果由于没有更多待处理或活动事件而退出，则返回 1。\n下面是 event_base_loop() 的大致逻辑：\ncwhile (有事件在监视队列 or EVLOOP_NO_EXIT_ON_EMPTY) {\n\n    if (EVLOOP_NONBLOCK or 有事件已经处于活动状态)\n        如果在监视队列中的事件已触发，则将其标记为活动状态。\n    else\n        阻塞等待到至少有一个事件触发，并将其标记为活动状态。\n\n    for (p = 0; p &lt; n_priorities; ++p) {\n       if (优先级为 p 的事件处于活动状态) {\n          运行所有优先级为 p 的活动事件。\n          break; /* 不要运行任何优先级较低的事件 */\n       }\n    }\n\n    if (EVLOOP_ONCE or EVLOOP_NONBLOCK)\n       break;\n}event_base_dispatch() 函数是flags为0的 event_base_loop() 。\nevent_base_loopexitcint event_base_loopexit(struct event_base *base,\n                        const struct timeval *tv);\nint event_base_loopbreak(struct event_base *base);event_base_loopexit() 函数通知 event_base 在经过给定时间后停止循环。如果 tv 参数为 NULL，则 event_base 会立即停止循环。如果 event_base 当前正在为任何活动事件运行回调函数，它将继续运行它们，直到它们全部运行完毕才会退出。\nevent_base_loopbreak() 函数通知 event_base 立即退出其循环。它与 event_base_loopexit(base, NULL) 的区别在于，如果 event_base 当前正在为任何活动事件运行回调函数，它将在完成当前正在处理的回调函数后立即退出。\n\n\n\n\n\n\n提示\n即使事件循环当前没有运行，event_base_loopexit() 仍然有效。它会影响下一次事件循环运行的行为，确保事件循环启动后会按照设定的时间退出。\n如果事件循环当前没有运行，event_base_loopbreak() 不会有任何效果。它只影响当前正在运行的事件循环。\n\n\ncint event_base_got_exit(struct event_base *base);\nint event_base_got_break(struct event_base *base);这两个函数用于查看 event_base 是被上面哪个函数通知退出的。如果没有退出或不是对应的函数通知退出的，返回 0；否则返回 1。\nevent_base_loopcontinuecint event_base_loopcontinue(struct event_base *);通常情况下，Libevent 会扫描事件，然后以最高优先级运行所有活动事件，然后再扫描事件，依此类推。\n如果需要在当前回调运行后立即停止 Libevent，并告诉它再次扫描，可以使用 event_base_loopcontinue() 函数来实现。\n如果当前没有运行事件回调，则调用 event_base_loopcontinue() 没有效果。\nevent_base_foreach_eventctypedef int (*event_base_foreach_event_cb)(const struct event_base *,\n    const struct event *, void *);\n\nint event_base_foreach_event(struct event_base *base,\n                             event_base_foreach_event_cb fn,\n                             void *arg);遍历每个与 event_base 关联的事件，将其作为回调函数的参数传入并执行回调函数，顺序不定。event_base_foreach_event() 的第三个参数将作为第三个参数传递给每次回调函数调用。\n回调函数必须返回 0 以继续迭代，或者返回其他整数以停止迭代。回调函数最终返回的任何值都将由 event_base_foreach_function() 返回。\n\n\n\n\n\n\n\n特别注意\n传入的回调函数不得修改它接收的任何事件，也不得向事件库添加或从中删除任何事件，或者以其他方式修改与事件库关联的任何事件，否则可能会发生未定义的行为，包括崩溃和堆栈溢出。\nevent_base 锁将在调用 event_base_foreach_event() 期间保持——这将阻止其他线程对 event_base 执行任何有用的操作，因此请确保您的回调函数不会花费很长时间。\n\n\nbufferevent除了响应事件之外，还希望执行一定数量的数据读写。为了避免手动管理缓冲区的复杂性，libevent 提供了 bufferevent 接口。\n与event不同，event在底层传输层准备好读取或写入时提供回调，而 bufferevent 在读取或写入足够数据时调用用户提供的回调。\nbufferevent_socket_newcstruct bufferevent *bufferevent_socket_new(\n    struct event_base *base,\n    evutil_socket_t fd,\n    enum bufferevent_options options);bufferevent_socket_new()创建基于套接字的 bufferevent，base 是一个 event_base，options 是 bufferevent 选项的位掩码（BEV_OPT_CLOSE_ON_FREE 等）。fd 参数是套接字的可选文件描述符。如果要稍后设置文件描述符，可以将 fd 设置为 -1。\n\n\n\n\n\n\n\n注意\n确保提供给 bufferevent_socket_new() 的套接字处于非阻塞模式。\n\n\ncvoid bufferevent_free(struct bufferevent *bev);此函数释放一个 bufferevent。Bufferevent 在内部是引用计数的，因此如果您在释放 bufferevent 时它有挂起的延迟回调，则在回调完成之前不会删除它。\n\n\n\n\n\n\n\n注意\n但是，bufferevent_free() 函数会尝试尽快释放 bufferevent。所以如果 bufferevent 上有待写入的数据，则在释放 bufferevent 之前可能不会刷新这些数据。\n如果设置了 BEV_OPT_CLOSE_ON_FREE 标志，并且此 bufferevent 的套接字或底层 bufferevent 与其关联为其传输层，则在释放 bufferevent 时将关闭该传输层。\n\n\nbufferevent_socket_connectcint bufferevent_socket_connect(struct bufferevent *bev,\n    struct sockaddr *address, int addrlen);address 和 addrlen 参数与标准调用 connect() 相同。如果 bufferevent 还没有设置套接字，则调用此函数会为其分配一个新的流套接字，并使其非阻塞。\n此函数在连接成功启动时返回 0，如果发生错误则返回 -1。\n\n\n\n\n\n\n提示\n在连接完成之前将数据添加到输出缓冲区是可以的。\n\n\ncint bufferevent_socket_connect_hostname(struct bufferevent *bev,\n    struct evdns_base *dns_base, int family, const char *hostname,\n    int port);\nint bufferevent_socket_get_dns_error(struct bufferevent *bev);便捷接口解析主机名和连接到主机名合并到一个操作中。\n如果发生错误，则可能是 DNS 主机名查找错误。通过调用 bufferevent_socket_get_dns_error() 来找出最近的错误是什么。如果返回的错误代码为 0，则表示未检测到 DNS 错误。\nbufferevent_setcbctypedef void (*bufferevent_data_cb)(struct bufferevent *bev, void *ctx);\ntypedef void (*bufferevent_event_cb)(struct bufferevent *bev,\n    short events, void *ctx);\n\nvoid bufferevent_setcb(struct bufferevent *bufev,\n    bufferevent_data_cb readcb, bufferevent_data_cb writecb,\n    bufferevent_event_cb eventcb, void *cbarg);\n\nvoid bufferevent_getcb(struct bufferevent *bufev,\n    bufferevent_data_cb *readcb_ptr,\n    bufferevent_data_cb *writecb_ptr,\n    bufferevent_event_cb *eventcb_ptr,\n    void **cbarg_ptr);bufferevent_setcb() 函数更改 bufferevent 的一个或多个回调。当读取足够的数据、写入足够的数据或发生事件时，将分别调用 readcb、writecb 和 eventcb 函数。每个函数的第一个参数是已发生事件的 bufferevent。最后一个参数是用户在 bufferevent_callcb() 的 cbarg 参数中提供的值：您可以使用它将数据传递给回调。event 回调的 events 参数是事件标志的位掩码。\n传入NULL指针将禁用相应的回调。所有回调函数共享一个 cbarg 值。\nbufferevent_enablecvoid bufferevent_enable(struct bufferevent *bufev, short events);\nvoid bufferevent_disable(struct bufferevent *bufev, short events);\n\nshort bufferevent_get_enabled(struct bufferevent *bufev);上述函数在 bufferevent 上启用或禁用事件 EV_READ、EV_WRITE 或 EV_READ|EV_WRITE。未启用读取或写入时，bufferevent 将不会尝试读取或写入数据。\n当输出缓冲区为空时，无需禁用写入：bufferevent 会自动停止写入，并在有数据要写入时再次启动。\n同样，当输入缓冲区达到其高水位时，无需禁用读取：bufferevent 会自动停止读取，并在有空间读取时再次启动。\n默认情况下，新创建的 bufferevent 启用了写入，但未启用读取。\n调用 bufferevent_get_enabled() 来查看当前在 bufferevent 上启用了哪些事件。\nbufferevent_setwatermarkcvoid bufferevent_setwatermark(struct bufferevent *bufev, short events,\n    size_t lowmark, size_t highmark);bufferevent_setwatermark() 函数调整单个 bufferevent 的读取水位、写入水位或两者。（如果在 events 字段中设置了 EV_READ，则调整读取水位。如果在 events 字段中设置了 EV_WRITE，则调整写入水位。）\n高水位 0 等效于“无限制”。\nbufferevent I/Ocint bufferevent_write(struct bufferevent *bufev,\n    const void *data, size_t size);\nint bufferevent_write_buffer(struct bufferevent *bufev,\n    struct evbuffer *buf);这些函数将数据添加到 bufferevent 的输出缓冲区。调用 bufferevent_write() 会将 data 处的内存中的 size 个字节添加到输出缓冲区的末尾。调用 bufferevent_write_buffer() 会删除 buf 的全部内容，并将它们放在输出缓冲区的末尾。两者在成功时都返回 0，如果发生错误则返回 -1。\ncsize_t bufferevent_read(struct bufferevent *bufev, void *data, size_t size);\nint bufferevent_read_buffer(struct bufferevent *bufev,\n    struct evbuffer *buf);这些函数从 bufferevent 的输入缓冲区中删除数据。bufferevent_read() 函数从输入缓冲区中删除最多 size 个字节，并将它们存储到 data 处的内存中。它返回实际删除的字节数。bufferevent_read_buffer() 函数清空输入缓冲区的全部内容，并将它们放入 buf 中；它在成功时返回 0，在失败时返回 -1。\n\n\n\n\n\n\n提示\nbufferevent_read()一般在读取回调函数中使用。\n注意，在使用bufferevent_write()的时候，只管将数据写入到输出缓冲区，不用担心缓冲区大小（会自己变大的）。（所以写入回调函数不像读取回调函数要完成读取任务，一般就做做检查什么的）。\n\n\nbufferevent_flushcint bufferevent_flush(struct bufferevent *bufev,\n    short iotype, enum bufferevent_flush_mode state);尽可能将输出缓冲区中的数据写入到底层传输。\nbufferevent_set_cint bufferevent_priority_set(struct bufferevent *bufev, int pri);\nint bufferevent_get_priority(struct bufferevent *bufev);用于设置和获取 bufferevent 的优先级。\ncint bufferevent_set_timeouts(struct bufferevent *bufev,\n    const struct timeval *timeout_read, const struct timeval *timeout_write);设置 bufferevent 的读取和写入超时。如果超时时间为 NULL，则不设置超时。\nevconnlistenerevconnlistener 提供了一种监听和接受传入 TCP 连接的方法。\nevconnlistener_newctypedef void (*evconnlistener_cb)(struct evconnlistener *listener,\n    evutil_socket_t sock, struct sockaddr *addr, int len, void *ptr);\n//sock 参数是新套接字本身。addr 和 len 参数分别是接收连接的地址和该地址的长度。ptr 参数是传递给 evconnlistener_new() 的用户提供的指针。\n\nstruct evconnlistener *evconnlistener_new(struct event_base *base,\n    evconnlistener_cb cb, void *ptr, unsigned flags, int backlog,\n    evutil_socket_t fd);\nstruct evconnlistener *evconnlistener_new_bind(struct event_base *base,\n    evconnlistener_cb cb, void *ptr, unsigned flags, int backlog,\n    const struct sockaddr *sa, int socklen);\nvoid evconnlistener_free(struct evconnlistener *lev);这两个 evconnlistener_new*() 函数都分配并返回一个新的连接监听器对象。连接监听器使用 event_base 来注意给定监听器套接字上何时存在新的 TCP 连接。当新连接到达时，它会调用您提供的回调函数。\n在这两个函数中，base 参数是一个 event_base，监听器应该使用它来监听连接。cb 函数是在收到新连接时调用的回调；如果 cb 为 NULL，则监听器将被视为禁用，直到设置回调。ptr 指针将被传递给回调。flags 参数控制监听器的行为。\n\n\n\nFlag\nDescription\nAvailability\n\n\n\nLEV_OPT_LEAVE_SOCKETS_BLOCKING\n默认情况下，当连接侦听器接受新的传入套接字时，它会将其设置为非阻塞模式，以便您可以将其与 Libevent 的其余部分一起使用。如果您不希望这种行为，请设置此标志。\n所有版本\n\n\nLEV_OPT_CLOSE_ON_FREE\n如果设置了此选项，则连接侦听器会在您释放它时关闭其底层套接字。\n所有版本\n\n\nLEV_OPT_CLOSE_ON_EXEC\n如果设置了此选项，则连接侦听器会在底层监听器套接字上设置 close-on-exec 标志。有关更多信息，请参阅您的平台文档以获取 fcntl 和 FD_CLOEXEC。\n所有版本\n\n\nLEV_OPT_REUSEABLE\n默认情况下，在某些平台上，一旦监听器套接字关闭，在一段时间过去之前，其他任何套接字都无法绑定到同一个端口。设置此选项会使 Libevent 将套接字标记为可重用，因此一旦它关闭，就可以打开另一个套接字来监听同一个端口。\n所有版本\n\n\nLEV_OPT_THREADSAFE\n为侦听器分配锁，以便可以从多个线程安全地使用它。\nLibevent 2.0.8-rc 起\n\n\nLEV_OPT_DISABLED\n将侦听器初始化为禁用状态，而不是启用状态。您可以使用 evconnlistener_enable() 手动启用它。\nLibevent 2.1.1-alpha 起\n\n\nLEV_OPT_DEFERRED_ACCEPT\n如果可能，告诉内核不要宣布套接字已被接受，直到收到一些数据并且它们准备好读取。如果您的协议不是从客户端传输数据开始的，请不要使用此选项，因为在这种情况下，此选项有时会导致内核永远不会告诉您连接。并非所有操作系统都支持此选项：在不支持的操作系统上，此选项无效。\nLibevent 2.1.1-alpha 起\n\n\nbacklog 参数相当于listen()函数的第二个参数。\nevconnlistener_new() 函数假定您已经将套接字绑定到要监听的端口，并且您将套接字作为 fd 传入。如果您希望 Libevent 自行分配和绑定到套接字，请调用 evconnlistener_new_bind()，并传入要绑定到的 sockaddr 及其长度。\n\n\n\n\n\n\n\n注意\n使用 evconnlistener_new() 时，请确保监听套接字处于非阻塞模式。\n\n\n要释放连接监听器，请将其传递给 evconnlistener_free()。\nevconnlistener_enablecint evconnlistener_disable(struct evconnlistener *lev);\nint evconnlistener_enable(struct evconnlistener *lev);这些函数临时禁用或重新启用对新连接的侦听。\nevconnlistener_set_cbcvoid evconnlistener_set_cb(struct evconnlistener *lev,\n    evconnlistener_cb cb, void *arg);此函数调整现有 evconnlistener 的回调和回调参数。\nevconnlistener_getcevutil_socket_t evconnlistener_get_fd(struct evconnlistener *lev);\nstruct event_base *evconnlistener_get_base(struct evconnlistener *lev);这些函数分别返回 evconnlistener 的底层套接字和 event_base。\necho_serverc#include &lt;event2/buffer.h&gt;\n#include &lt;event2/bufferevent.h&gt;\n#include &lt;event2/listener.h&gt;\n\n#include &lt;arpa/inet.h&gt;\n\n#include &lt;errno.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nstatic void echo_read_cb(struct bufferevent *bev, void *ctx) {\n  /* This callback is invoked when there is data to read on bev. */\n  struct evbuffer *input = bufferevent_get_input(bev);\n  struct evbuffer *output = bufferevent_get_output(bev);\n\n  /* Copy all the data from the input buffer to the output buffer. */\n  evbuffer_add_buffer(output, input);\n}\n\nstatic void echo_event_cb(struct bufferevent *bev, short events, void *ctx) {\n  if (events &amp; BEV_EVENT_ERROR)\n    perror(\"Error from bufferevent\");\n  if (events &amp; (BEV_EVENT_EOF | BEV_EVENT_ERROR)) {\n    bufferevent_free(bev);\n  }\n}\n\nstatic void accept_conn_cb(struct evconnlistener *listener, evutil_socket_t fd,\n                           struct sockaddr *address, int socklen, void *ctx) {\n  /* We got a new connection! Set up a bufferevent for it. */\n  struct event_base *base = evconnlistener_get_base(listener);\n  struct bufferevent *bev =\n      bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);\n\n  bufferevent_setcb(bev, echo_read_cb, NULL, echo_event_cb, NULL);\n\n  bufferevent_enable(bev, EV_READ | EV_WRITE);\n}\n\nstatic void accept_error_cb(struct evconnlistener *listener, void *ctx) {\n  struct event_base *base = evconnlistener_get_base(listener);\n  int err = EVUTIL_SOCKET_ERROR();\n  fprintf(stderr,\n          \"Got an error %d (%s) on the listener. \"\n          \"Shutting down.\\n\",\n          err, evutil_socket_error_to_string(err));\n\n  event_base_loopexit(base, NULL);\n}\n\nint main(int argc, char **argv) {\n  struct event_base *base;\n  struct evconnlistener *listener;\n  struct sockaddr_in sin;\n\n  int port = 9876;\n\n  if (argc &gt; 1) {\n    port = atoi(argv[1]);\n  }\n  if (port &lt;= 0 || port &gt; 65535) {\n    puts(\"Invalid port\");\n    return 1;\n  }\n\n  base = event_base_new();\n  if (!base) {\n    puts(\"Couldn't open event base\");\n    return 1;\n  }\n\n  /* Clear the sockaddr before using it, in case there are extra\n   * platform-specific fields that can mess us up. */\n  memset(&amp;sin, 0, sizeof(sin));\n  /* This is an INET address */\n  sin.sin_family = AF_INET;\n  /* Listen on 0.0.0.0 */\n  sin.sin_addr.s_addr = htonl(0);\n  /* Listen on the given port. */\n  sin.sin_port = htons(port);\n\n  listener = evconnlistener_new_bind(base, accept_conn_cb, NULL,\n                                     LEV_OPT_CLOSE_ON_FREE | LEV_OPT_REUSEABLE,\n                                     -1, (struct sockaddr *)&amp;sin, sizeof(sin));\n  if (!listener) {\n    perror(\"Couldn't create listener\");\n    return 1;\n  }\n  evconnlistener_set_error_cb(listener, accept_error_cb);\n\n  event_base_dispatch(base);\n  return 0;\n}文件传输c//recvfile.c\n#include &lt;arpa/inet.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;event2/bufferevent.h&gt;\n#include &lt;event2/event.h&gt;\n#include &lt;event2/listener.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;netinet/in.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\n\n#define PORT 9090\n#define BUFFER_SIZE 1024\n\nvoid on_read(struct bufferevent *bev, void *ctx) {\n  char data[BUFFER_SIZE];\n  size_t n;\n\n  int f_fd = (int)ctx;\n\n  while ((n = bufferevent_read(bev, data, BUFFER_SIZE)) &gt; 0) {\n    if (write(f_fd, data, n) == -1) {\n      perror(\"fwrite\");\n      exit(1);\n    }\n  }\n}\n\nvoid on_error(struct bufferevent *bev, short what, void *ctx) {\n  int f_fd = (int)ctx;\n  if (what &amp; BEV_EVENT_CONNECTED) {\n    fprintf(stderr, \"Connection established.\\n\");\n  } else if (what &amp; BEV_EVENT_EOF) {\n    close(f_fd);\n    fprintf(stderr, \"Client disconnected.\\n\");\n  } else if (what &amp; BEV_EVENT_ERROR) {\n    perror(\"Error from bufferevent\");\n  }\n  bufferevent_free(bev);\n}\n\nvoid on_accept(struct evconnlistener *listener, evutil_socket_t fd,\n               struct sockaddr *address, int socklen, void *ctx) {\n  struct event_base *base = evconnlistener_get_base(listener);\n  struct bufferevent *bev;\n\n  bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);\n  if (!bev) {\n    fprintf(stderr, \"Error constructing bufferevent!\");\n    event_base_loopbreak(base);\n    return;\n  }\n\n  int f_fd = open(\"abc.png\", O_CREAT | O_WRONLY | O_TRUNC, 0644);\n  if (f_fd &lt; 0) {\n    perror(\"open\");\n    exit(1);\n  }\n\n  bufferevent_setcb(bev, on_read, NULL, on_error, (void *)f_fd);\n  bufferevent_enable(bev, EV_READ | EV_WRITE );\n}\n\nint main() {\n  struct event_base *base;\n  struct evconnlistener *listener;\n  struct sockaddr_in sin;\n\n  base = event_base_new();\n  if (!base) {\n    fprintf(stderr, \"Could not initialize libevent!\\n\");\n    return 1;\n  }\n\n  memset(&amp;sin, 0, sizeof(sin));\n  sin.sin_family = AF_INET;\n  sin.sin_addr.s_addr = INADDR_ANY;\n  sin.sin_port = htons(PORT);\n\n  listener = evconnlistener_new_bind(base, on_accept, NULL,\n                                     LEV_OPT_REUSEABLE | LEV_OPT_CLOSE_ON_FREE,\n                                     -1, (struct sockaddr *)&amp;sin, sizeof(sin));\n  if (!listener) {\n    fprintf(stderr, \"Could not create a listener!\\n\");\n    return 1;\n  }\n\n  event_base_dispatch(base);\n  evconnlistener_free(listener);\n  event_base_free(base);\n\n  return 0;\n}c//sendfile.c\n#include &lt;arpa/inet.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;event2/bufferevent.h&gt;\n#include &lt;event2/event.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;netinet/in.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\n\n#define SERVER_ADDRESS \"127.0.0.1\"\n#define PORT 9090\n#define BUFFER_SIZE 512\n\nvoid on_write(struct bufferevent *bev, void *ctx) { printf(\"on_write\\n\"); }\n\nvoid on_error(struct bufferevent *bev, short what, void *ctx) {\n  // int fd = (int)ctx;\n  if (what &amp; BEV_EVENT_CONNECTED) {\n    fprintf(stderr, \"Connection established.\\n\");\n    return;\n  } else if (what &amp; BEV_EVENT_EOF) {\n    fprintf(stderr, \"Connection closed.\\n\");\n  } else if (what &amp; BEV_EVENT_ERROR) {\n    perror(\"Error from bufferevent\");\n  }\n  bufferevent_free(bev);\n}\n\nint main() {\n  struct event_base *base;\n  struct bufferevent *bev;\n  struct sockaddr_in server_addr;\n  char data[BUFFER_SIZE];\n  size_t n;\n\n  base = event_base_new();\n  if (!base) {\n    fprintf(stderr, \"Could not initialize libevent!\\n\");\n    return 1;\n  }\n\n  memset(&amp;server_addr, 0, sizeof(server_addr));\n  server_addr.sin_family = AF_INET;\n  server_addr.sin_port = htons(PORT);\n  if (inet_pton(AF_INET, SERVER_ADDRESS, &amp;server_addr.sin_addr) &lt;= 0) {\n    fprintf(stderr, \"Invalid address/ Address not supported \\n\");\n    return -1;\n  }\n\n  bev = bufferevent_socket_new(base, -1, BEV_OPT_CLOSE_ON_FREE);\n  if (!bev) {\n    fprintf(stderr, \"Error creating bufferevent socket\\n\");\n    return -1;\n  }\n\n  int fd =\n      open(\"/home/ac/Pictures/aef76ab12c95da4281a10bf42fc61e1c.png\", O_RDONLY);\n  if (fd &lt; 0) {\n    perror(\"fopen\");\n    return 1;\n  }\n\n  bufferevent_setcb(bev, NULL, on_write, on_error, (void *)fd);\n\n  if (bufferevent_socket_connect(bev, (struct sockaddr *)&amp;server_addr,\n                                 sizeof(server_addr)) &lt; 0) {\n    fprintf(stderr, \"Error connecting\\n\");\n    return -1;\n  }\n\n  while ((n = read(fd, data, BUFFER_SIZE)) &gt; 0) {\n    bufferevent_write(bev, data, n);\n  }\n\n  event_base_dispatch(base);\n\n  close(fd);\n  event_base_free(base);\n\n  return 0;\n}","slug":"Linux网络编程（libevent）","date":"2024-07-19T12:26:18.000Z","categories_index":"Linux","tags_index":"Linux,C++","author_index":"Ac-Accelerator"},{"id":"49a0a815b68a3a838049f5994375a9d3","title":"Linux网络编程（UDP）","content":"创建UDP套接字cint sockfd = socket(AF_INET, SOCK_DGRAM, 0);使用socket函数创建一个UDP套接字，注意第二个参数为SOCK_DGRAM，表示使用报式传输，第三个参数为0，表示使用报式传输默认的UDP协议。\n绑定端口对于 UDP 服务器来说，bind() 函数是必要的，它确保了服务器有一个固定的、已知的端口号，客户端才能将数据发送到正确的目的地。这个和 TCP 一样。\n发送数据c#include &lt;sys/socket.h&gt;\n\nssize_t sendto(int socket, const void *message, size_t length,\n    int flags, const struct sockaddr *dest_addr,\n    socklen_t dest_len);sendto() 函数应通过连接模式或无连接模式套接字发送消息。\n如果套接字是无连接模式套接字，并且尚未设置预先指定的对等地址，则消息应发送到 dest_addr 指定的地址。如果已预先指定对等地址（用connect()），则消息应发送到 dest_addr 指定的地址（覆盖预先指定的对等地址），不然函数应返回 -1 并将 errno 设置为 EISCONN。\n如果套接字是连接模式套接字，则 dest_addr 应被忽略。\nsendto() 函数接受以下参数：\nsocket：指定套接字文件描述符。message：指向包含要发送的消息的缓冲区。length：以字节为单位指定消息的大小。dest_addr：指向包含目标地址的 sockaddr 结构。地址的长度和格式取决于套接字的地址族。dest_len：指定 dest_addr 参数指向的 sockaddr 结构的长度。flags：指定消息传输的类型。此参数的值通过对以下一个或多个标志进行逻辑 OR 运算形成：\n\n\n\nflags\n作用\n\n\n\nMSG_EOR\n终止记录（如果协议支持）。\n\n\nMSG_OOB\n在支持带外数据的套接字上发送带外数据。带外数据的意义和语义取决于具体的协议。\n\n\nMSG_NOSIGNAL\n请求在不再连接的面向流的套接字上尝试发送时，不要发送 SIGPIPE 信号。仍然会返回 [EPIPE] 错误。\n\n\n如果套接字协议支持广播，并且指定的地址是套接字协议的广播地址，则如果未为套接字设置 SO_BROADCAST 选项，sendto() 将失败。\n调用 sendto() 成功完成并不能保证消息传递成功。返回值 -1 仅表示本地检测到的错误。\n如果发送套接字没有足够的空间来保存要传输的消息，并且套接字文件描述符没有设置 O_NONBLOCK，则 sendto() 将阻塞，直到有可用空间为止。如果发送套接字没有足够的空间来保存要传输的消息，并且套接字文件描述符设置了 O_NONBLOCK，则 sendto() 将失败。\n正在使用的套接字可能要求进程具有适当的特权才能使用 sendto() 函数。\n和write()、sent()一样，成功将返回发送的字节数。否则，将返回 -1 并设置 errno 以指示错误。\n\n\n\n\n\n\n提示\n创建 UDP 套接字时，其本地和远程地址未指定。可以使用 sendto() 或 sendmsg() 立即发送数据报，并以有效的目标地址作为参数。当在套接字上调用 connect() 时，将设置默认目标地址，并且可以使用 send() 或 write() 发送数据报，而无需指定目标地址。仍然可以通过将地址传递给 sendto() 或 sendmsg() 来发送到其他目标。为了接收数据包，套接字可以先使用 bind() 绑定到本地地址。否则，套接字层将自动分配一个空闲的本地端口，并将套接字绑定到 INADDR_ANY。\n\n\n接收数据c#include &lt;sys/socket.h&gt;\n\nssize_t recvfrom(int socket, void *restrict buffer, size_t length,\n    int flags, struct sockaddr *restrict address,\n    socklen_t *restrict address_len)recvfrom() 函数从连接模式或无连接模式套接字接收消息。它通常与无连接模式套接字一起使用，因为它允许应用程序检索接收数据的源地址。\nrecvfrom() 函数接受以下参数：\nsocket：指定套接字文件描述符。buffer：指向应该存储消息的缓冲区。length：以字节为单位指定 buffer 参数指向的缓冲区的长度。address：空指针，或指向要存储发送地址的 sockaddr 结构。地址的长度和格式取决于套接字的地址族。address_len：如果 address 为空指针，则为空指针；否则为指向 socklen_t 对象的指针，该对象在输入时指定提供的 sockaddr 结构的长度，在输出时指定存储的地址的长度。flags：指定消息接收的类型。此参数的值通过对以下一个或多个值进行逻辑 OR 运算形成：\n\n\n\nfalgs\n作用\n\n\n\nMSG_PEEK\n窥视传入消息。数据将被视为未读，并且下一个 recvfrom() 或类似函数仍将返回此数据。\n\n\nMSG_OOB\n请求带外数据。带外数据的意义和语义取决于具体的协议。\n\n\nMSG_WAITALL\n在 SOCK_STREAM 套接字上，这将请求函数阻塞，直到可以返回全部数据。如果套接字是基于消息的套接字，如果捕获到信号，如果连接终止，如果指定了 MSG_PEEK，或者如果套接字有待处理的错误，则函数可能会返回较少的数据量。\n\n\nrecvfrom() 函数应返回写入 buffer 参数指向的缓冲区的消息长度。对于基于消息的套接字（例如 SOCK_RAW、SOCK_DGRAM 和 SOCK_SEQPACKET），应在单个操作中读取整个消息。如果消息太长而无法放入提供的缓冲区，并且 flags 参数中未设置 MSG_PEEK，则应丢弃多余的字节。对于基于流的套接字（例如 SOCK_STREAM），消息边界应被忽略。在这种情况下，数据应在可用时立即返回给用户，并且不应丢弃任何数据。\n如果未设置 MSG_WAITALL 标志，则仅返回到第一条消息结尾的数据。\n并非所有协议都提供消息的源地址。如果 address 参数不是空指针，并且协议提供了消息的源地址，则接收到的消息的源地址应存储在 address 参数指向的 sockaddr 结构中，并且此地址的长度应存储在 address_len 参数指向的对象中。\n如果地址的实际长度大于提供的 sockaddr 结构的长度，则存储的地址将被截断。\n如果 address 参数不是空指针，并且协议不提供消息的源地址，则 address 指向的对象中存储的值未指定。\n如果套接字上没有可用的消息，并且套接字的文件描述符上未设置 O_NONBLOCK，则 recvfrom() 将阻塞，直到消息到达。如果套接字上没有可用的消息，并且套接字的文件描述符上设置了 O_NONBLOCK，则 recvfrom() 将失败并将 errno 设置为 EAGAIN 或 EWOULDBLOCK。\n成功则返回消息的长度（以字节为单位）。如果没有可接收的消息，并且对等方已执行有序关闭，则返回 0。否则，该函数应返回 -1 并设置 errno 以指示错误。\n一个简单的 UDP 通信示例：\nc//服务器端\n#include &lt;arpa/inet.h&gt;\n#include &lt;netinet/in.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;unistd.h&gt;\n\n#define PORT 8080\n\nint main() {\n  int sockfd;\n  struct sockaddr_in server_addr, client_addr;\n  socklen_t addr_len = sizeof(client_addr);\n  char buffer[1024];\n\n  // 创建 UDP socket\n  sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n  if (sockfd &lt; 0) {\n    perror(\"Failed to create socket\");\n    exit(1);\n  }\n\n  // 设置服务器地址\n  memset(&amp;server_addr, 0, sizeof(server_addr));\n  server_addr.sin_family = AF_INET;\n  server_addr.sin_port = htons(PORT);\n  server_addr.sin_addr.s_addr = INADDR_ANY;\n\n  // 绑定 socket 到地址\n  if (bind(sockfd, (struct sockaddr *)&amp;server_addr, sizeof(server_addr)) &lt; 0) {\n    perror(\"Failed to bind socket\");\n    exit(1);\n  }\n\n  // 接收数据\n  int char_num = recvfrom(sockfd, buffer, sizeof(buffer), 0,\n                          (struct sockaddr *)&amp;client_addr, &amp;addr_len);\n  if (char_num &gt; 0) {\n    buffer[char_num] = 0;\n    printf(\"Received  message: %s\\n\", buffer);\n  }\n\n  close(sockfd);\n  return 0;\n}c//客户端\n#include &lt;arpa/inet.h&gt;\n#include &lt;netinet/in.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;unistd.h&gt;\n\n#define SERVER_IP \"127.0.0.1\"\n#define PORT 8080\n\nint main() {\n  int sockfd;\n  struct sockaddr_in server_addr;\n  char *message = \"Hello from sender!\";\n\n  // 创建 UDP socket\n  sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n  if (sockfd &lt; 0) {\n    perror(\"Failed to create socket\");\n    exit(1);\n  }\n\n  // 设置服务器地址\n  memset(&amp;server_addr, 0, sizeof(server_addr));\n  server_addr.sin_family = AF_INET;\n  server_addr.sin_port = htons(PORT);\n  server_addr.sin_addr.s_addr = inet_addr(SERVER_IP);\n\n  // 发送数据\n  sendto(sockfd, message, strlen(message), 0, (struct sockaddr *)&amp;server_addr,\n         sizeof(server_addr));\n\n  printf(\"Message sent.\\n\");\n\n  close(sockfd);\n  return 0;\n}UDP广播只要将目标地址设置为广播地址，使用socket_ctl() 设置 SO_BROADCAST 选项即可。\n这是一个简单的 UDP 广播示例：\nc//广播端\n#include &lt;arpa/inet.h&gt;\n#include &lt;netinet/in.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;unistd.h&gt;\n\n#define BROADCAST_ADDR \"255.255.255.255\"\n#define PORT 8888\n\nint main() {\n  int sockfd;\n  struct sockaddr_in broadcast_addr;\n  char message[1024];\n\n  // 创建UDP套接字\n  sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n  if (sockfd &lt; 0) {\n    perror(\"socket creation failed\");\n    exit(1);\n  }\n\n  // 设置广播选项\n  int broadcastEnable = 1;\n  int ret = setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &amp;broadcastEnable,\n                       sizeof(broadcastEnable));\n  if (ret &lt; 0) {\n    perror(\"setsockopt failed\");\n    close(sockfd);\n    exit(1);\n  }\n\n  // 设置广播地址信息\n  memset(&amp;broadcast_addr, 0, sizeof(broadcast_addr));\n  broadcast_addr.sin_family = AF_INET;\n  broadcast_addr.sin_port = htons(PORT);\n  broadcast_addr.sin_addr.s_addr = inet_addr(BROADCAST_ADDR);\n\n  // 发送广播消息\n  while (1) {\n    printf(\"请输入要广播的消息: \");\n    fgets(message, sizeof(message), stdin);\n\n    ssize_t bytes_sent =\n        sendto(sockfd, message, strlen(message), 0,\n               (struct sockaddr *)&amp;broadcast_addr, sizeof(broadcast_addr));\n    if (bytes_sent &lt; 0) {\n      perror(\"sendto failed\");\n      break;\n    }\n    printf(\"已广播消息: %s\\n\", message);\n  }\n\n  close(sockfd);\n  return 0;\n}c//接收端\n#include &lt;arpa/inet.h&gt;\n#include &lt;netinet/in.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;unistd.h&gt;\n\n#define PORT 8888\n#define BUFFER_SIZE 1024\n\nint main() {\n  int sockfd;\n  struct sockaddr_in server_addr, client_addr;\n  socklen_t client_addr_len;\n  char buffer[BUFFER_SIZE];\n\n  // 创建UDP套接字\n  sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n  if (sockfd &lt; 0) {\n    perror(\"socket creation failed\");\n    exit(1);\n  }\n\n  // 设置服务器地址信息\n  memset(&amp;server_addr, 0, sizeof(server_addr));\n  server_addr.sin_family = AF_INET;\n  server_addr.sin_port = htons(PORT);\n  server_addr.sin_addr.s_addr = INADDR_ANY;\n\n  // 绑定套接字到指定端口\n  if (bind(sockfd, (struct sockaddr *)&amp;server_addr, sizeof(server_addr)) &lt; 0) {\n    perror(\"bind failed\");\n    close(sockfd);\n    exit(1);\n  }\n\n  printf(\"监听广播端口：%d\\n\", PORT);\n\n  while (1) {\n    client_addr_len = sizeof(client_addr);\n    ssize_t bytes_received =\n        recvfrom(sockfd, buffer, BUFFER_SIZE, 0,\n                 (struct sockaddr *)&amp;client_addr, &amp;client_addr_len);\n\n    if (bytes_received &lt; 0) {\n      perror(\"recvfrom failed\");\n      break;\n    }\n\n    buffer[bytes_received] = '\\0';\n\n    printf(\"接收到来自 %s:%d 的广播消息: %s\\n\", inet_ntoa(client_addr.sin_addr),\n           ntohs(client_addr.sin_port), buffer);\n  }\n\n  close(sockfd);\n  return 0;\n}\n\n\n\n\n\n\n注意\n注意，广播端指定的端口 必须和 接收端绑定的端口 一致，否则接收端将无法接收到广播消息。因为广播只是对IP地址来说的。\n\n\nUDP组播组播地址是D类地址。\n这是一个简单的 UDP 组播示例：\nc//发送端\n#include &lt;arpa/inet.h&gt;\n#include &lt;netinet/in.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\n\n#define MULTICAST_ADDR \"224.0.1.100\"\n#define MULTICAST_PORT 8080\n#define TTL 64\n#define LOCALIP \"192.168.168.248\"\nint main() {\n  int sockfd;\n  struct sockaddr_in multicast_addr;\n  char message[] = \"Hello, this is a multicast message!\";\n  int ttl = TTL;\n\n  // 创建 UDP socket\n  sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n  if (sockfd &lt; 0) {\n    perror(\"socket creation failed\");\n    exit(1);\n  }\n\n  // 设置组播 TTL 值\n  if (setsockopt(sockfd, IPPROTO_IP, IP_MULTICAST_TTL, &amp;ttl, sizeof(ttl)) &lt; 0) {\n    perror(\"setting TTL failed\");\n    close(sockfd);\n    exit(1);\n  }\n\n  struct in_addr ip;\n  ip.s_addr = inet_addr(LOCALIP);\n  if (setsockopt(sockfd, IPPROTO_IP, IP_MULTICAST_IF, &amp;ip, sizeof(ip))) {\n    perror(\"setting IP_MULTICAST_IF failed\");\n    close(sockfd);\n    exit(1);\n  }\n\n  memset(&amp;multicast_addr, 0, sizeof(multicast_addr));\n  multicast_addr.sin_family = AF_INET;\n  multicast_addr.sin_addr.s_addr = inet_addr(MULTICAST_ADDR);\n  multicast_addr.sin_port = htons(MULTICAST_PORT);\n\n  // 发送组播消息\n  while (1) {\n    if (sendto(sockfd, message, strlen(message), 0,\n               (struct sockaddr *)&amp;multicast_addr,\n               sizeof(multicast_addr)) &lt; 0) {\n      perror(\"sendto failed\");\n      close(sockfd);\n      exit(1);\n    }\n    printf(\"Sent message: %s\\n\", message);\n    sleep(1); // 每秒发送一次\n  }\n\n  close(sockfd);\n  return 0;\n}c//接收端\n#include &lt;arpa/inet.h&gt;\n#include &lt;net/if.h&gt;\n#include &lt;netinet/in.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\n\n#define MULTICAST_ADDR \"224.0.1.100\"\n#define MULTICAST_PORT 8080\n#define IFNAME \"wlp1s0\"\n\nint main() {\n  int sockfd;\n  struct sockaddr_in multicast_addr;\n  char buffer[1024];\n  struct ip_mreqn mreq;\n\n  // 创建 UDP socket\n  sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n  if (sockfd &lt; 0) {\n    perror(\"socket creation failed\");\n    exit(1);\n  }\n\n  memset(&amp;multicast_addr, 0, sizeof(multicast_addr));\n  multicast_addr.sin_family = AF_INET;\n  multicast_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n  multicast_addr.sin_port = htons(MULTICAST_PORT);\n\n  // 绑定 socket 到地址和端口\n  if (bind(sockfd, (struct sockaddr *)&amp;multicast_addr, sizeof(multicast_addr)) &lt;\n      0) {\n    perror(\"bind failed\");\n    close(sockfd);\n    exit(1);\n  }\n\n  // 加入组播组\n  mreq.imr_multiaddr.s_addr = inet_addr(MULTICAST_ADDR);\n  mreq.imr_address.s_addr = htonl(INADDR_ANY);\n  mreq.imr_ifindex = if_nametoindex(IFNAME);\n  if (setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreq, sizeof(mreq)) &lt;\n      0) {\n    perror(\"setsockopt failed\");\n    close(sockfd);\n    exit(1);\n  }\n\n  // 接收组播消息\n  while (1) {\n    socklen_t addrlen = sizeof(multicast_addr);\n    int n = recvfrom(sockfd, buffer, sizeof(buffer), 0,\n                     (struct sockaddr *)&amp;multicast_addr, &amp;addrlen);\n    if (n &lt; 0) {\n      perror(\"recvfrom failed\");\n      close(sockfd);\n      exit(1);\n    }\n    buffer[n] = '\\0';\n    printf(\"Received message from %s:%d: %s\\n\",\n           inet_ntoa(multicast_addr.sin_addr), ntohs(multicast_addr.sin_port),\n           buffer);\n  }\n\n  close(sockfd);\n  return 0;\n}\n\n\n\n\n\n\n注意\n对于 UDP 组播接收端，加入组播组的操作应该在 bind 函数之后进行。\n如果先调用 setsockopt(IP_ADD_MEMBERSHIP) 加入组播组，但还没有调用 bind 绑定端口，操作系统无法确定将接收到的组播数据包传递给哪个应用程序，因为此时还没有与该端口关联的套接字。\n\n\n\n\n\n\n\n\n\n注意\n对于 UDP 组播发送端，需要设置组播 TTL 值，以及设置组播接口。\n通过设置setsockopt(IP_MULTICAST_IF),可以指定组播数据包从哪个网络接口发送出去。如果不设置，那么组播数据包将从默认的网络接口发送出去（因为不知道默认的网络接口是什么，所以这个得控制一下）。\n另外，组播数据包的 TTL 值默认是 1 ，这样组播数据包只能在本地网络中传播，如果想要组播数据包能够在多个网络中传播，需要通过设置setsockopt(IP_MULTICAST_TTL)，设置组播数据包的 TTL 值。\n\n\n","slug":"Linux网络编程（UDP）","date":"2024-07-17T12:28:55.000Z","categories_index":"Linux","tags_index":"Linux,C++","author_index":"Ac-Accelerator"},{"id":"c49d0f0683cb7b900e98e175f46fbdbf","title":"Linux网络编程（TCP进阶）","content":"shutdown函数c#include &lt;sys/socket.h&gt;\n\nint shutdown(int sockfd, int how);shutdown() 调用可以关闭 sockfd 关联的套接字上的全双工连接的全部或部分。如果 how 参数为 SHUT_RD，则将禁止未来的读操作。如果 how 为 SHUT_WR，则将禁止未来的写操作。如果 how 为 SHUT_RDWR，则将禁止进一步的读写操作。\n成功返回0；失败返回-1，设置 errno。\n\n\n\n\n\n\n\n\n\n如果 how 为 SHUT_WR ，则将发送一个FIN包给对端，对端收到FIN包后，会回复一个ACK包。此时TCP连接进入半关闭状态。此时对端还可以发送数据，本端可以进行读取，但是本端不能再发送数据。\nsetsockopt函数c#include &lt;sys/socket.h&gt;\n\nint getsockopt(int sockfd, int level, int optname,\n              void *optval, socklen_t *optlen);\nint setsockopt(int sockfd, int level, int optname,\n              const void *optval, socklen_t optlen);getsockopt() 和 setsockopt() 函数用于操作文件描述符 sockfd 所指向的套接字的选项。选项可以存在于多个协议层级，但它们始终存在于最高层的套接字层级。\n当操作套接字选项时，必须指定选项所在的层级和选项的名称。要在套接字 API 层级操作选项，请将 level 参数指定为 SOL_SOCKET。要在任何其他层级操作选项，请提供控制该选项的相应协议的协议号。例如，要指示 TCP 协议解释某个选项，则应将 level 设置为 TCP 的协议号；参见 getprotoent(3)。\n参数 optval 和 optlen 用于访问 setsockopt() 的选项值。对于 getsockopt()，它们标识一个缓冲区，用于返回所请求选项的值。对于 getsockopt()，optlen 是一个值结果参数，最初包含 optval 指向的缓冲区的大小，并在返回时进行修改以指示返回的实际值的大小。如果没有要提供或返回的选项值，则 optval 可以为 NULL。\noptname 和任何指定的选项都会不加解释地传递给相应的协议模块进行解释。头文件 &lt;sys/socket.h&gt; 包含套接字级别选项的定义，如下所述。其他协议级别的选项在格式和名称上有所不同；请参阅手册第 4 节中的相应条目。\n大多数套接字级别的选项都使用 int 参数作为 optval。对于 setsockopt()，如果要启用布尔选项，则该参数应为非零值；如果要禁用该选项，则该参数应为零。\n对于标准选项，成功时返回零。出错时返回 -1，并将 errno 设置为相应的值。\n\n\n\n\n\n\n\n\n\n端口复用的实现是通过 setsockopt() 函数设置 SO_REUSEADDR 或者 SO_REUSEPORT 选项来实现的。\nSO_REUSEADDR 允许将一个地址和端口绑定到一个新的 socket 上，即使该地址和端口已经有处于 TIME_WAIT 状态的 socket 绑定。\nSO_REUSEPORT 允许多个 socket 绑定到完全相同的地址和端口。操作系统会负责在这些 socket 之间负载均衡传入的连接。\nSO_KEEPALIVE 启用 TCP keepalive 机制。当启用后，如果一段时间内没有数据传输，TCP 会定期发送探测包，以检测连接是否仍然存活。（接收方不需要进行任何特殊的 socket 设置来处理 keepalive 探测包，当接收方收到 TCP keepalive 探测包时，它会自动回复一个 ACK 包）\n\n\n\n\n\n\n\n注意\n必须要在 bind() 之前调用 setsockopt(SO_REUSEADDR)来设置端口复用。\n对于其他 Socket 选项，例如 SO_KEEPALIVE，在 bind() 之前或之后调用 setsockopt() 函数都无所谓。最佳实践是在创建 socket 之后，并在任何与该选项相关的操作（例如 listen() 或 connect()）之前设置 Socket 选项。\n\n\nIO多路转接使用多线程/多进程处理并发, 其实本质就是使用不同的线程/进程检测文件描述符的缓冲区（阻塞直到发生变化）。这导致了不必要的线程/进程切换开销。\nIO多路转接就是调用一个系统函数委托内核帮助我们去检测程序中的一些列文件描述符的状态，文件描述符发生变化后，内核设置对应的标志位，并返回用户态，这样我们就可以知道哪些文件描述符发生了变化。从而进行对应处理。\nselect函数c#include &lt;sys/select.h&gt;\n\nint select(int nfds, fd_set *readfds, fd_set *writefds,\n          fd_set *exceptfds, struct timeval *timeout);\n\nvoid FD_CLR(int fd, fd_set *set);\nint  FD_ISSET(int fd, fd_set *set);\nvoid FD_SET(int fd, fd_set *set);\nvoid FD_ZERO(fd_set *set);\n\nstruct timeval {\n    time_t      tv_sec;         /* seconds */\n    suseconds_t tv_usec;        /* microseconds */\n};\nreadfds\n此集合中的文件描述符会被监视，以确定它们是否已准备好进行读取操作。\n如果读取操作不会阻塞，则文件描述符已准备好进行读取；特别地，文件描述符在文件结尾也处于可读状态。\nselect() 返回后，readfds 将清除除已准备好进行读取操作的文件描述符之外的所有文件描述符。\n\n\nwritefds\n此集合中的文件描述符会被监视，以确定它们是否已准备好进行写入操作。\n如果写入操作不会阻塞，则文件描述符已准备好进行写入。但是，即使文件描述符指示为可写，大型写入操作仍可能会阻塞。\nselect() 返回后，writefds 将清除除已准备好进行写入操作的文件描述符之外的所有文件描述符。\n一般情况下, 文件描述符的写缓冲区都是可写的(有存储空间), 因此这集合很少用\n\n\nexceptfds\n此集合中的文件描述符会被监视“异常情况”。\n有关某些异常情况的示例，请参阅 poll(2) 中有关 POLLPRI 的讨论。\nselect() 返回后，exceptfds 将清除除发生异常情况的文件描述符之外的所有文件描述符。\n一般情况下, 这个集合也很少用\n\n\nnfds\n此参数应设置为三个集合中任何一个集合中编号最高的文件描述符加 1。\n将检查每个集合中指示的文件描述符，直至达到此限制（但请参阅“错误”部分）。\n\n\ntimeout\n超时参数是一个 timeval 结构，它指定 select() 应该阻塞等待文件描述符变为就绪状态的时间间隔。\n调用将一直阻塞，直到：\n文件描述符变为就绪状态；\n调用被信号处理程序中断；或\n超时时间到期。\n\n\n请注意，超时时间间隔将向上舍入到系统时钟粒度，并且内核调度延迟意味着阻塞时间间隔可能会稍微超过指定的时间。\n如果 timeval 结构的两个字段都为零，则 select() 立即返回。（这对于轮询很有用。）\n如果 timeout 指定为 NULL，则 select() 将无限期阻塞，等待文件描述符变为就绪状态。\n\n\n\n成功时，select() 返回三个返回描述符集中包含的文件描述符的数量（即，在 readfds，writefds，exceptfds 中设置的位总数）。如果在任何文件描述符变为就绪状态之前超时已到期，则返回值可能为零。出错时，返回 -1，并将 errno 设置为指示错误的值；文件描述符集保持不变，并且 timeout 变得未定义。\n一个简单的echo服务器示例：\nc#include &lt;arpa/inet.h&gt;\n#include &lt;cerrno&gt;\n#include &lt;netinet/in.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;unistd.h&gt;\n\n#define PORT 8080        // 服务器监听端口\n#define MAX_CLIENTS 10   // 最大客户端连接数\n#define BUFFER_SIZE 1024 // 数据缓冲区大小\n\nint main() {\n  int server_socket, client_socket[MAX_CLIENTS];\n  struct sockaddr_in server_addr, client_addr;\n  socklen_t addr_len = sizeof(client_addr);\n  char buffer[BUFFER_SIZE];\n\n  // 初始化客户端套接字数组\n  for (int i = 0; i &lt; MAX_CLIENTS; i++) {\n    client_socket[i] = 0;\n  }\n\n  // 创建套接字\n  server_socket = socket(AF_INET, SOCK_STREAM, 0);\n  if (server_socket == -1) {\n    perror(\"创建套接字失败\");\n    exit(EXIT_FAILURE);\n  }\n\n  // 设置服务器地址信息\n  memset(&amp;server_addr, 0, sizeof(server_addr));\n  server_addr.sin_family = AF_INET;\n  server_addr.sin_addr.s_addr = INADDR_ANY;\n  server_addr.sin_port = htons(PORT);\n\n  // 绑定套接字到地址\n  if (bind(server_socket, (struct sockaddr *)&amp;server_addr,\n           sizeof(server_addr)) == -1) {\n    perror(\"绑定套接字失败\");\n    close(server_socket);\n    exit(EXIT_FAILURE);\n  }\n\n  // 监听连接请求\n  if (listen(server_socket, MAX_CLIENTS) == -1) {\n    perror(\"监听连接请求失败\");\n    close(server_socket);\n    exit(EXIT_FAILURE);\n  }\n\n  printf(\"服务器启动，监听端口: %d\\n\", PORT);\n\n  fd_set readfds;\n  int max_sd = server_socket;\n  int activity, valread;\n\n  while (1) {\n    FD_ZERO(&amp;readfds);\n    FD_SET(server_socket, &amp;readfds);\n\n    // 将活动连接添加到select监听\n    for (int i = 0; i &lt; MAX_CLIENTS; i++) {\n      int sd = client_socket[i];\n      if (sd &gt; 0) {\n        FD_SET(sd, &amp;readfds);\n      }\n      // 更新最大文件描述符\n      if (sd &gt; max_sd) {\n        max_sd = sd;\n      }\n    }\n\n    // 使用select监听文件描述符\n    activity = select(max_sd + 1, &amp;readfds, NULL, NULL, NULL);\n\n    if ((activity &lt; 0) &amp;&amp; (errno != EINTR)) {\n      printf(\"select error\");\n    }\n\n    // 处理新的连接请求\n    if (FD_ISSET(server_socket, &amp;readfds)) {\n      int new_socket =\n          accept(server_socket, (struct sockaddr *)&amp;client_addr, &amp;addr_len);\n      if (new_socket == -1) {\n        perror(\"接受连接失败\");\n      } else {\n        printf(\"新连接: socket fd %d , ip %s , port %d \\n\", new_socket,\n               inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));\n        // 将新套接字添加到数组中\n        for (int i = 0; i &lt; MAX_CLIENTS; i++) {\n          if (client_socket[i] == 0) {// 找到空闲位置\n            client_socket[i] = new_socket;\n            break;\n          }\n        }\n      }\n    }\n\n    // 处理来自客户端的数据\n    for (int i = 0; i &lt; MAX_CLIENTS; i++) {\n      int sd = client_socket[i];\n      if (FD_ISSET(sd, &amp;readfds)) {\n        valread = read(sd, buffer, BUFFER_SIZE);\n        if (valread == 0) {\n          // 连接已关闭\n          printf(\"主机断开连接: socket fd %d \\n\", sd);\n          close(sd);\n          client_socket[i] = 0;\n        } else {\n          // 将接收到的数据回显给客户端\n          send(sd, buffer, valread, 0);\n        }\n      }\n    }\n  }\n\n  // 关闭套接字\n  close(server_socket);\n\n  return 0;\n}\n\n\n\n\n\n\n注意\n注意，内核判断文件描述符是否就绪是通过判断其对应的数据缓冲区的状态。举个例子，从select返回后，如果不去读取数据，那么下次select还会返回这个文件描述符！！！\n\n\npoll函数c#include &lt;poll.h&gt;\n\nint poll(struct pollfd *fds, nfds_t nfds, int timeout);\n\nstruct pollfd\n{\n  int fd;\t\t\t/* File descriptor to poll.  */\n  short int events;\t\t/* Types of events poller cares about.  */\n  short int revents;\t\t/* Types of events that actually occurred.  */\n};poll() 函数与 select() 函数执行类似的任务：等待一组文件描述符中的一个变为就绪状态，以便执行 I/O 操作。特定于 Linux 的 epoll() API 也执行类似的任务，但提供了 poll() 中没有的功能。\n要监控的文件描述符集在 fds 参数中指定， fds 是一个指向 pollfd 结构的指针数组。\n对于pollfd结构体：\n\nfd 字段包含一个打开文件的文件描述符。如果此字段为负数，则将忽略相应的 events 字段，并且 revents 字段返回零。（这提供了一种在单个 poll() 调用中忽略文件描述符的简单方法：只需将 fd 字段设置为其按位补码即可。）\nevents 字段是一个输入参数，一个位掩码，指定应用程序对文件描述符 fd 感兴趣的事件，通常是POLLIN 或 POLLOUT 。此字段可以指定为零，在这种情况下，revents 中可以返回的唯一事件是 POLLHUP、POLLERR 和 POLLNVAL。\nrevents 字段是一个输出参数，由内核填充实际发生的事件。revents 中返回的位可以包括在 events 中指定的任何位，或者 POLLERR、POLLHUP 或 POLLNVAL 中的一个值。（这三位在 events 字段中没有意义，并且只要相应的条件为真，就会在 revents 字段中设置。）\n\n调用者应在 nfds 参数中指定 fds 数组中的元素数量。\ntimeout参数指定 poll()的阻塞时长，单位是毫秒。特别地，为负数表示无限期阻塞，为0表示立即返回。\n返回值和 select() 函数类似，成功时返回就绪的文件描述符数量，出错时返回-1，并设置 errno。\n一个简单的echo服务器示例：\nc#include &lt;arpa/inet.h&gt;\n#include &lt;netinet/in.h&gt;\n#include &lt;poll.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;unistd.h&gt;\n\n#define PORT 8080\n#define MAX_CLIENTS 10\n#define BUFFER_SIZE 1024\n\nint main() {\n  int server_socket, client_sockets[MAX_CLIENTS];\n  struct sockaddr_in address;\n  int i, sd, valread;\n  char buffer[BUFFER_SIZE];\n  struct pollfd fds[MAX_CLIENTS + 1]; // 使用 pollfd 结构体存储文件描述符和事件\n  int nfds = 1; // 当前监控的文件描述符数量，初始为1（只包含server_socket）\n\n  // 初始化所有客户端套接字\n  for (i = 0; i &lt; MAX_CLIENTS; i++) {\n    client_sockets[i] = -1; // 使用 -1 表示空闲的客户端槽位\n  }\n\n  // 创建服务器套接字\n  if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n    perror(\"socket failed\");\n    exit(EXIT_FAILURE);\n  }\n\n  address.sin_family = AF_INET;\n  address.sin_addr.s_addr = INADDR_ANY;\n  address.sin_port = htons(PORT);\n\n  // 绑定地址和端口\n  if (bind(server_socket, (struct sockaddr *)&amp;address, sizeof(address)) &lt; 0) {\n    perror(\"bind failed\");\n    exit(EXIT_FAILURE);\n  }\n\n  // 监听连接\n  if (listen(server_socket, 3) &lt; 0) {\n    perror(\"listen failed\");\n    exit(EXIT_FAILURE);\n  }\n\n  printf(\"Echo server started on port %d\\n\", PORT);\n\n  // 初始化 pollfd 结构体数组\n  fds[0].fd = server_socket;\n  fds[0].events = POLLIN;\n\n  while (1) {\n    // 使用 poll 监控文件描述符\n    int activity = poll(fds, nfds, -1); // -1 表示无限等待\n\n    if (activity &lt; 0) {\n      perror(\"poll failed\");\n      exit(EXIT_FAILURE);\n    }\n\n    // 处理服务器套接字事件\n    if (fds[0].revents &amp; POLLIN) {\n      socklen_t addrlen = sizeof(address);\n      int new_socket =\n          accept(server_socket, (struct sockaddr *)&amp;address, &amp;addrlen);\n\n      if (new_socket &lt; 0) {\n        perror(\"accept failed\");\n        exit(EXIT_FAILURE);\n      }\n\n      printf(\"New connection , socket fd is %d , ip is : %s , port : %d \\n\",\n             new_socket, inet_ntoa(address.sin_addr), ntohs(address.sin_port));\n\n      // 找到空闲的客户端槽位\n      for (i = 0; i &lt; MAX_CLIENTS; i++) {\n        if (client_sockets[i] == -1) {\n          client_sockets[i] = new_socket;\n          // 添加新的文件描述符到 poll 监控列表\n          fds[nfds].fd = new_socket;\n          fds[nfds].events = POLLIN;\n          nfds++;\n          break;\n        }\n      }\n\n      if (i == MAX_CLIENTS) {\n        printf(\"Too many clients connected\\n\");\n        close(new_socket);\n      }\n    }\n\n    // 处理客户端数据\n    for (i = 1; i &lt; nfds; i++) {\n      sd = fds[i].fd;\n\n      if (fds[i].revents &amp; POLLIN) {\n        if ((valread = read(sd, buffer, BUFFER_SIZE)) == 0) {\n          // 连接已关闭\n          getpeername(sd, (struct sockaddr *)&amp;address,\n                      (socklen_t *)sizeof(address));\n          printf(\"Host disconnected , ip %s , port %d \\n\",\n                 inet_ntoa(address.sin_addr), ntohs(address.sin_port));\n          close(sd);\n          client_sockets[i - 1] = -1;\n          // 从 poll 监控列表中移除\n          fds[i] = fds[nfds - 1];\n          nfds--;\n          i--;\n        } else {\n          // 回写数据到客户端\n          send(sd, buffer, valread, 0);\n        }\n      }\n    }\n  }\n  return 0;\n}epoll函数c#include &lt;sys/epoll.h&gt;\n\nint epoll_create(int size);size 参数是一个提示，指定要与新实例关联的文件描述符的数量，不影响。\nepoll_create() 返回一个指向新的 epoll 实例的文件描述符。此文件描述符用于所有后续对 epoll 接口的调用。当不再需要时，应该使用 close() 关闭由 epoll_create() 返回的文件描述符。当所有指向 epoll 实例的文件描述符都已关闭时，内核将销毁该实例并释放相关资源以供重用。\n如果成功，这些系统调用将返回一个文件描述符（一个非负整数）。如果出错，则返回 -1，并且 errno 会被设置为指示错误的值。 \nc#include &lt;sys/epoll.h&gt;\n\nint epoll_ctl(int epfd, int op, int fd,\n              struct epoll_event *_Nullable event);\n\ntypedef union epoll_data {\n  void        *ptr;\n  int          fd;\t\t// 常用的一个成员\n  uint32_t     u32;\n  uint64_t     u64;\n} epoll_data_t;\n\nstruct epoll_event {\n  uint32_t     events;      /* Epoll events */\n  epoll_data_t data;        /* User data variable */\n};epoll_ctl() 系统调用用于在文件描述符 epfd 引用的 epoll 实例的兴趣列表中添加、修改或删除条目。它请求对目标文件描述符 fd 执行操作 op 。\n其中op的取值有：\n\n\n\n操作\n描述\n\n\n\nEPOLL_CTL_ADD\n将一个条目添加到 epoll 文件描述符 epfd 的兴趣列表中。该条目包括文件描述符 fd、对相应打开文件描述符的引用 以及 event 中指定的设置。\n\n\nEPOLL_CTL_MOD\n将兴趣列表中与 fd 关联的设置更改为 event 中指定的新设置。\n\n\nEPOLL_CTL_DEL\n从兴趣列表中移除（取消注册）目标文件描述符 fd。event 参数将被忽略，并且可以是 NULL\n\n\nevent.events 可以是以下值的按位或：EPOLLOUT、EPOLLIN；分别表示关联的文件描述符可写、可读。\nevent.data 指定了当此文件描述符变为就绪状态时，内核应该保存并（通过 epoll_wait()）随后返回的数据。\nepoll_ctl() 成功时返回零。发生错误时，epoll_ctl() 返回 -1，并且 errno 会被设置为指示错误的值。 \nc#include &lt;sys/epoll.h&gt;\n\nint epoll_wait(int epfd, struct epoll_event *events,\n               int maxevents, int timeout);epoll_wait() 系统调用 会 阻塞 等待文件描述符 epfd 所引用的实例中 的事件。events是一个epoll_event数组，用于传出返回值。epoll_wait() 最多返回 maxevents 个事件。maxevents 参数必须大于零（通常是events数组所容纳元素的数量）。\ntimeout 参数指定 epoll_wait() 将阻塞的毫秒数。和 poll() 的参数一样。\n每个返回的 epoll_event 结构的 data 字段包含与最近一次调用 epoll_ctl() (EPOLL_CTL_ADD、EPOLL_CTL_MOD) 时为相应打开文件描述符指定的数据相同的数据。\nevents 字段是一个位掩码，指示已发生的相应打开文件描述符的事件。\nepoll_wait() 成功时返回就绪的文件描述符数量。如果超时时间到期，则返回0。出错时，返回-1，并设置 errno。\n一个简单的echo服务器示例：\nc#include &lt;arpa/inet.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;netinet/in.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/epoll.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\n\n#define MAX_EVENTS 10    // epoll监听的最大事件数\n#define BUFFER_SIZE 1024 // 数据缓冲区大小\n#define PORT 8080\n\nint main() {\n  // 1. 创建socket\n  int server_socket = socket(AF_INET, SOCK_STREAM, 0);\n  if (server_socket == -1) {\n    perror(\"socket creation failed\");\n    exit(1);\n  }\n\n  // 2. 绑定地址和端口\n  struct sockaddr_in server_addr;\n  memset(&amp;server_addr, 0, sizeof(server_addr));\n  server_addr.sin_family = AF_INET;\n  server_addr.sin_addr.s_addr = INADDR_ANY;\n  server_addr.sin_port = htons(PORT);\n\n  if (bind(server_socket, (struct sockaddr *)&amp;server_addr,\n           sizeof(server_addr)) == -1) {\n    perror(\"bind failed\");\n    exit(1);\n  }\n\n  // 3. 监听连接\n  if (listen(server_socket, 5) == -1) {\n    perror(\"listen failed\");\n    exit(1);\n  }\n\n  printf(\"Server listening on :%d\\n\", PORT);\n\n  // 4. 创建epoll实例\n  int epoll_fd = epoll_create(1);\n  if (epoll_fd == -1) {\n    perror(\"epoll_create1 failed\");\n    exit(1);\n  }\n\n  // 5. 将监听socket添加到epoll实例中\n  struct epoll_event event;\n  event.events = EPOLLIN; // 监听可读事件\n  event.data.fd = server_socket;\n  if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, server_socket, &amp;event) == -1) {\n    perror(\"epoll_ctl failed\");\n    exit(1);\n  }\n\n  // 6. 事件循环\n  struct epoll_event events[MAX_EVENTS];\n  char buffer[BUFFER_SIZE];\n  while (1) {\n    // 6.1 等待事件发生\n    int num_events = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);\n    if (num_events == -1) {\n      perror(\"epoll_wait failed\");\n      break;\n    }\n\n    // 6.2 处理事件\n    for (int i = 0; i &lt; num_events; ++i) {\n      if (events[i].data.fd == server_socket) {\n        // 6.2.1 处理新连接\n        struct sockaddr_in client_addr;\n        socklen_t client_addr_len = sizeof(client_addr);\n        int client_socket = accept(\n            server_socket, (struct sockaddr *)&amp;client_addr, &amp;client_addr_len);\n        if (client_socket == -1) {\n          perror(\"accept failed\");\n          continue;\n        }\n\n        printf(\"New connection from %s:%d\\n\", inet_ntoa(client_addr.sin_addr),\n               ntohs(client_addr.sin_port));\n\n        // 6.2.2 将新连接的socket添加到epoll实例中\n        event.events = EPOLLIN;\n        event.data.fd = client_socket;\n        if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, client_socket, &amp;event) == -1) {\n          perror(\"epoll_ctl failed\");\n          close(client_socket);\n          continue;\n        }\n      } else {\n        // 6.2.3 处理已连接socket上的数据\n        int client_socket = events[i].data.fd;\n        ssize_t bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);\n        if (bytes_received == -1) {\n          perror(\"recv failed\");\n          close(client_socket);\n          continue;\n        } else if (bytes_received == 0) {\n          // 客户端断开连接\n          printf(\"Client disconnected\\n\");\n          close(client_socket);\n          continue;\n        }\n\n        // 回显数据\n        send(client_socket, buffer, bytes_received, 0);\n      }\n    }\n  }\n\n  // 7. 关闭socket和epoll实例\n  close(server_socket);\n  close(epoll_fd);\n  return 0;\n}\n\n\n\n\n\n\n注意\n与上述 select() 和 poll() 函数不同，epoll 有两种工作模式：水平触发（LT）和边缘触发（ET）。其缺省模式和上述两者一样，是水平触发（LT）。\n\n水平触发（LT）：当文件描述符就绪时，epoll_wait() 会返回，但是如果文件描述符还有数据未读取完，下次调用 epoll_wait() 时还会返回就绪状态。\n\n边缘触发（ET）：当文件描述符就绪时，epoll_wait() 会返回，但是如果文件描述符还有数据未读取完，下次调用 epoll_wait() 时不会返回就绪状态，直到文件描述符状态发生变化。（特别注意边缘触发 要使用非阻塞IO）\n\n\ncevent.events |=  EPOLLET; // 边缘触发模式\n\nint flag = fcntl(cfd, F_GETFL);\nflag |= O_NONBLOCK;\nfcntl(cfd, F_SETFL, flag);\n\n","slug":"Linux网络编程（TCP进阶）","date":"2024-07-13T12:26:18.000Z","categories_index":"Linux","tags_index":"Linux,C++","author_index":"Ac-Accelerator"},{"id":"b7ae202389bc9c445e0505a76dbc19f8","title":"Linux网络编程（TCP）","content":"数据的大端和小端所谓的字节序，指的是超过一个字节的数据在内存中的存储顺序。如果一个数据只占用一个字节，则字节序的问题就不存在了。\n数据的大端存储比较贴近我们人类的感官。在我们查看内存里的数据的时候，内存地址低数据的一般被打印在屏幕的左边，内存地址高数据的一般被打印在屏幕的右边。大端存储的数据的高字节存储在低地址，低字节存储在高地址，正好和我们的阅读习惯一致。因此大端存储的数据我们比较好阅读。\n数据的小端存储和大端存储相反。小端存储的数据的低字节存储在低地址，高字节存储在高地址。虽然和我们的阅读习惯不一致，但是却符合计算机的处理方式。\n\n\n\n\n\n\n\n\n\n注意不论是大端还是小端，指向数据的指针都是指向它的低地址。\n互联网的初期设计主要是由一群习惯使用大端字节序的计算机科学家完成的。由于这个历史原因，网络协议的设计也用的是大端字节序。这和主机的字节序不一致，在头文件&lt;arpa/inet.h&gt; 中定义了一些函数可以进行转换。\nc#include &lt;arpa/inet.h&gt;\n\nuint32_t htonl(uint32_t hostlong);\n\nuint16_t htons(uint16_t hostshort);\n\nuint32_t ntohl(uint32_t netlong);\n\nuint16_t ntohs(uint16_t netshort);htonl() 函数将无符号整型数 hostlong 从主机字节序转换为网络字节序。\nhtons() 函数将无符号短整型数 hostshort 从主机字节序转换为网络字节序。\nntohl() 函数将无符号整型数 netlong 从网络字节序转换为主机字节序。\nntohs() 函数将无符号短整型数 netshort 从网络字节序转换为主机字节序。\n这些函数主要用于处理 IP 地址和端口号。其中以l结尾的函数用于处理IP地址，以s结尾的函数用于处理端口号。\n字符串和IP地址之间的转换c#include &lt;arpa/inet.h&gt;\n\nint inet_pton(int af, const char *src, void *dst);此函数将字符串 src 转换为 af 地址族中的网络地址结构，然后将该网络地址结构复制到 dst。af 参数必须是 AF_INET 或 AF_INET6。**dst 将以网络字节序写入**。\n成功转换网络地址时返回 1。如果 src 不包含表示指定地址族中有效网络地址的字符串，则返回 0。如果 af 不包含有效的地址族，则返回 -1，并将 errno 设置为 EAFNOSUPPORT。\nc#include &lt;arpa/inet.h&gt;\n\nconst char *inet_ntop(int af, const void *src,\n                      char *dst, socklen_t size);此函数将 af 地址族中的网络地址结构 src 转换为字符串。 生成的字符串将被复制到 dst 指向的缓冲区，该缓冲区必须是非空指针。调用者在参数 size 中指定此缓冲区可用的字节数。\n成功时，函数返回一个指向 dst 的非空指针。如果出现错误，则返回 NULL，并将 errno 设置为指示错误的值。\n套接字地址结构cstruct sockaddr\n{\n  sa_family_t (sa_);\t/* Common data: address family and length. 16bit */\n  char sa_data[14];\t\t/* Address data. 14bit */\n};\n\n/* Structure describing an Internet socket address.  */\nstruct sockaddr_in\n{\n  sa_family_t (sin_); /* Common data: address family and length. 16bit */\n  in_port_t sin_port;\t\t\t/* Port number. 16bit */\n  struct in_addr sin_addr;\t\t/* Internet address. 32bit */\n\n  /* Pad to size of `struct sockaddr'.  */\n  unsigned char sin_zero[sizeof (struct sockaddr)\n        - sa_family_t\n        - sizeof (in_port_t)\n        - sizeof (struct in_addr)];\n};sockaddr 结构体是一个通用的套接字地址结构体,而sockaddr_in 结构体对 sockaddr 结构体的sa_data字段进行了细化，将其分为了sin_port、sin_addr和sin_zero三个字段。分别用于存储端口号、IP地址和填充字节。在socket编程中，这两个结构体是等价的，只不过后者更加方便使用。\n如果是服务器端，IP地址可以设置为INADDR_ANY，表示本机在网络上所有的ip地址。\n创建套接字c#include &lt;sys/socket.h&gt;\n\nint socket(int domain, int type, int protocol);socket() 函数创建一个用于通信的端点，并返回一个指向该端点的文件描述符。成功调用返回的文件描述符将是该进程当前未打开的最小编号的文件描述符。\ndomain 参数指定通信域；它选择将用于通信的协议族。这些协议族定义在 &lt;sys/socket.h&gt; 头文件中。常用的协议族有：\n\nAF_INET: 使用ipv4的网络协议\nAF_INET6: 使用ipv6的网络协议\n\nsocket 具有指定的type，该type指定了通信语义。常见取值有：\n\nSOCK_STREAM: 使用流式传输协议\nSOCK_DGRAM: 使用报式传输协议\n\nprotocol 参数指定要与此 socket 一起使用的特定协议。通常，在给定的协议族中，只有一种协议支持特定的 socket 类型，在这种情况下，**protocol 参数可以指定为 0**。但是，也可能存在多种协议，在这种情况下，必须以这种方式指定特定的协议。\n\n流式协议默认使用tcp\n报式协议默认使用udp\n\n成功时，返回新 socket 的文件描述符。发生错误时，返回 -1，并将 errno 设置为适当的值。\n绑定套接字c#include &lt;sys/socket.h&gt;\n\nint bind(int sockfd, const struct sockaddr *addr,\n        socklen_t addrlen);使用 socket() 函数创建 socket 时，它存在于一个命名空间（地址族）中，但没有分配地址。bind() 函数将 addr 指定的地址分配给文件描述符 sockfd 引用的 socket。addrlen 指定 addr 指向的地址结构的大小（sizeof(struct sockaddr)）。传统上，此操作称为“为 socket 命名”。\n通常，在 SOCK_STREAM 类型的 socket 可以接收连接之前，需要使用 bind() 函数分配一个本地地址（请参阅 accept(2)）。\n成功时，返回 0。发生错误时，返回 -1，并将 errno 设置为适当的值。\n监听套接字c#include &lt;sys/socket.h&gt;\n\nint listen(int sockfd, int backlog);listen() 函数将 sockfd 引用的 socket 标记为被动 socket，即用作通过 accept() 函数接受传入连接请求的 socket。\nsockfd 参数是一个文件描述符，它引用一个类型为 SOCK_STREAM 或 SOCK_SEQPACKET 的 socket。\nbacklog 参数定义 sockfd 的待处理连接队列可能增长的最大长度。如果在队列已满时到达连接请求，则客户端可能会收到指示 ECONNREFUSED 的错误，或者，如果底层协议支持重传，则请求可能会被忽略，以便稍后再次尝试连接时成功。（这个值超过128就按照128算，因为是写死在内核中的）\n成功时，返回 0。发生错误时，返回 -1，并将 errno 设置为适当的值。\n接受连接c#include &lt;sys/socket.h&gt;\n\nint accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);accept() 系统调用从监听 socket sockfd 的待处理连接队列中提取第一个连接请求，创建一个新的已连接 socket，并返回一个指向该 socket 的新文件描述符。新创建的 socket 不会处于监听状态。原始 socket sockfd 不受此调用的影响。\n参数 sockfd 是一个已使用 socket() 函数创建、使用 bind() 函数绑定到本地地址，并在调用 listen() 函数后处于监听连接状态的 socket。\n参数 addr 是一个指向 sockaddr 结构的指针。此结构填充了通信层已知的对等 socket 的地址。返回地址 addr 的确切格式由 socket 的地址族决定（请参阅 socket(2) 函数和相应的协议手册页）。当 addr 为 NULL 时，不会填充任何内容；在这种情况下，不使用 addrlen，并且它也应该为 NULL。\n参数 addrlen 是一个值结果参数：调用者必须将其初始化为包含 addr 指向的结构的大小（以字节为单位）；返回时，它将包含对等地址的实际大小。\n如果提供的缓冲区太小，则返回的地址将被截断；在这种情况下，addrlen 将返回一个大于调用时提供的值。\n如果队列中没有待处理的连接，并且 socket 标记为阻塞，则 accept() 函数将阻塞调用者，直到有连接出现。如果 socket 被标记为非阻塞，并且队列中没有待处理的连接，则 accept() 函数将失败，并返回错误 EAGAIN 或 EWOULDBLOCK。\n为了接收 socket 上传入连接的通知，可以使用 select()、poll() 或 epoll() 函数。当尝试建立新连接时，将传递一个可读事件，然后可以调用 accept() 函数以获取该连接的 socket。或者，可以将 socket 设置为在 socket 上发生活动时发送 SIGIO 信号；有关详细信息，请参阅 socket(7) 手册页。\n成功时，这些系统调用返回已接受套接字的文件描述符（一个非负整数）。 出错时，返回 -1，并相应地设置 errno，addrlen 保持不变。\n连接套接字c#include &lt;sys/socket.h&gt;\n\nint connect(int sockfd, const struct sockaddr *addr,\n            socklen_t addrlen);connect() 系统调用将文件描述符 sockfd 引用的套接字连接到 addr 指定的地址。 addrlen 参数指定 addr 的大小（sizeof(struct sockaddr)）。 addr 中地址的格式由套接字 sockfd 的地址空间决定；\n如果套接字 sockfd 的类型为 SOCK_DGRAM，则 addr 是默认情况下发送数据报的地址，也是接收数据报的唯一地址。 如果套接字类型为 SOCK_STREAM 或 SOCK_SEQPACKET，则此调用会尝试连接到绑定到 addr 指定地址的套接字。\n某些协议套接字（例如，UNIX 域流套接字）可能只能成功调用 connect() 一次。\n某些协议套接字（例如，UNIX 和 Internet 域中的数据报套接字）可以使用 connect() 多次更改其关联。\n某些协议套接字（例如，TCP 套接字以及 UNIX 和 Internet 域中的数据报套接字）可以通过连接到 sockaddr 的 sa_family 成员设置为 AF_UNSPEC 的地址来解除关联； 此后，套接字可以连接到另一个地址。 （自内核 2.2 起，Linux 上支持 AF_UNSPEC。）\n如果连接或绑定成功，则返回 0。 出错时，返回 -1，并相应地设置 errno。\n发送和接收数据c#include &lt;sys/socket.h&gt;\n\nssize_t send(int sockfd, const void *buf, size_t len, int flags);\nssize_t write(int fd, const void *buf, size_t len);\n\nssize_t recv(int sockfd, void *buf, size_t len, int flags);\nssize_t read(int sockfd, void *buf, size_t size);只有当套接字处于连接状态（以便知道预期的接收者）时，才能使用 send() 调用。 send() 和 write() 之间的唯一区别在于是否存在 flags 参数。 当 flags 参数为零时，send() 等效于 write()。\nrecv()调用用于从套接字接收消息。它们可用于在无连接和面向连接的套接字上接收数据。recv() 和 read() 之间的唯一区别在于是否存在 flags 参数。 当 flags 参数为零时，recv() 通常等效于 read()。\n\n\n\n\n\n\n\n\n\n如果存在一个长度为零的数据报，则 flags 参数为零的 read() 和 recv() 将提供不同的行为。 在这种情况下，read() 不会产生任何效果（数据报保持待处理状态），而 recv() 会消耗待处理的数据报。\n下面是客户端和服务器端的代码：\nc// 服务器端\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;netinet/in.h&gt;\n\n#define PORT 8080  // 端口号\n#define BUFFER_SIZE 1024\n\nint main() {\n    int server_fd, client_fd;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    char buffer[BUFFER_SIZE] = {0};// 缓冲区\n\n    // 1. 创建 socket (socket())\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // 2. 绑定地址和端口 (bind())，将文件描述符和地址绑定\n    address.sin_family = AF_INET;//IPv4\n    address.sin_addr.s_addr = INADDR_ANY; // 监听所有网卡\n    address.sin_port = htons(PORT);// 端口号（大端保存）\n\n    if (bind(server_fd, (struct sockaddr *)&amp;address, sizeof(address)) &lt; 0) {\n        perror(\"bind failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // 3. 监听连接请求 (listen())，将这个socket设置为监听状态，最多允许3个连接\n    if (listen(server_fd, 3) &lt; 0) {\n        perror(\"listen failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // 4. 接受连接请求 (accept())，在接收到连接请求之前会一直阻塞\n    if ((client_fd = accept(server_fd, (struct sockaddr *)&amp;address, (socklen_t*)&amp;addrlen)) &lt; 0) {\n        perror(\"accept failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // 5. 接收数据 (recv())，读取的是客户端的socket\n    int valread = read(client_fd, buffer, BUFFER_SIZE);\n    printf(\"服务器接收到消息: %s\\n\", buffer);\n\n    // 6. 发送数据 (send())，发送的是客户端的socket\n    char message[] = \"Hello from server!\";\n    send(client_fd, message, strlen(message), 0);\n    printf(\"服务器已发送消息\\n\");\n\n    // 7.  接收更多数据 (recv())，读取的是客户端的socket\n    memset(buffer, 0, sizeof(buffer));\n    valread = read(client_fd, buffer, BUFFER_SIZE);\n    printf(\"服务器接收到消息: %s\\n\", buffer);\n\n    // 8. 关闭连接 (close())\n    close(client_fd);\n    close(server_fd);\n\n    return 0;\n}c//客户端代码\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;arpa/inet.h&gt;\n\n#define PORT 8080\n#define BUFFER_SIZE 1024\n\nint main() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[BUFFER_SIZE] = {0};\n\n    // 1. 创建 socket (socket())，指向服务器的socket\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) {\n        perror(\"socket failed\");\n        return -1;\n    }\n\n    // 2. 连接服务器 (connect())\n    serv_addr.sin_family = AF_INET;//IPv4\n    serv_addr.sin_port = htons(PORT);// 端口号（大端保存）\n    if (inet_pton(AF_INET, \"127.0.0.1\", &amp;serv_addr.sin_addr) &lt;= 0) {\n        perror(\"invalid address\");\n        return -1;\n    }\n    if (connect(sock, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) &lt; 0) {\n        perror(\"connection failed\");\n        return -1;\n    }\n\n    // 3. 发送数据 (send()), 发送的是服务器的socket\n    char message[] = \"Hello from client!\";\n    send(sock, message, strlen(message), 0);\n    printf(\"客户端已发送消息\\n\");\n\n    // 4. 接收数据 (recv()), 读取的是服务器的socket\n    int valread = read(sock, buffer, BUFFER_SIZE);\n    printf(\"客户端接收到消息: %s\\n\", buffer);\n \n    // 5. 发送更多数据 (send()), 发送的是服务器的socket\n    char message2[] = \"This is another message from client!\";\n    send(sock, message2, strlen(message2), 0);\n    printf(\"客户端已发送消息\\n\");\n\n    // 6. 关闭连接 (close())\n    close(sock);\n    return 0;\n}如何并发处理多个客户端上面代码中，由于只有一个accept()函数，所以只能处理一个客户端。如果要处理多个客户端，可以使用多线程或者多进程的方式。\n对于多进程来说，父进程用于监听请求，子进程用于处理请求。这里要注意的点有：\n\n子进程需要关闭父进程的server_fd文件描述符，父进程需要关闭子进程的client_fd文件描述符。\n子进程处理完请求后需要被回收，否则会变成僵尸进程。\n由于父进程既要要负责监听请求，又要负责回收子进程，这两个会导致阻塞的操作不能同时进行，所以需要使用信号处理函数利用SIGCHLD信号来回收子进程。\n在accept()阻塞等待请求的时候，如果有子进程结束，正在阻塞accept()函数可能会被SIGCHLD中断并产生EINTR错误，所以sa_flags要使用SA_RESTART标志自动重启系统调用，使其不返回错误。\nsig_chld() 函数使用 waitpid() 非阻塞地回收结束的子进程，避免阻塞主循环。\n\n多进程服务端代码（不推荐）：\nc#include &lt;errno.h&gt;\n#include &lt;netinet/in.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/wait.h&gt;\n#include &lt;unistd.h&gt;\n\n#define PORT 8080\n#define BUFFER_SIZE 1024\n\nvoid sig_chld(int signo) {\n  pid_t pid;\n  int stat;\n  while ((pid = waitpid(-1, &amp;stat, WNOHANG)) &gt; 0) {//非阻塞回收所有子进程\n    printf(\"子进程 %d 结束\\n\", pid);\n  }\n}\n\nvoid handle_client(int client_fd) {//注意这里如何判断客户端是否关闭连接！！\n  char buffer[BUFFER_SIZE] = {0};\n  int valread;\n\n  while (1) {\n    // 接收数据\n    valread = read(client_fd, buffer, BUFFER_SIZE);\n    if (valread == 0) {\n      printf(\"客户端已关闭连接\\n\");\n      break;\n    } else if (valread &lt; 0) {\n      perror(\"recv failed\");\n      break;\n    }\n\n    printf(\"服务器接收到消息: %s\\n\", buffer);\n\n    // 发送数据\n    char message[] = \"Hello from server!\";\n    int sent_bytes = send(client_fd, message, strlen(message), 0);\n    if (sent_bytes &lt; 0) {\n      if (errno == EPIPE || errno == ECONNRESET) {\n        printf(\"客户端已断开连接\\n\");\n      } else {\n        perror(\"send failed\");\n      }\n      break;\n    }\n  }\n\n  close(client_fd);\n  exit(0); // 子进程退出，产生 SIGCHLD 信号\n}\n\nint main() {\n  // 安装 SIGCHLD 信号处理函数\n  struct sigaction sa;\n  sa.sa_handler = sig_chld;\n  sigemptyset(&amp;sa.sa_mask);\n  sa.sa_flags = SA_RESTART; // 使被信号中断的系统调用自动重启\n  if (sigaction(SIGCHLD, &amp;sa, NULL) == -1) {\n    perror(\"sigaction failed\");\n    exit(1);\n  }\n\n  int server_fd, client_fd;\n  struct sockaddr_in address;\n  int addrlen = sizeof(address);\n  pid_t pid;\n\n  // 1. 创建 socket\n  if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n    perror(\"socket failed\");\n    exit(EXIT_FAILURE);\n  }\n\n  // 2. 绑定地址和端口\n  address.sin_family = AF_INET;//IPv4\n  address.sin_addr.s_addr = INADDR_ANY;// 监听所有网卡\n  address.sin_port = htons(PORT);// 端口号（大端保存）\n  if (bind(server_fd, (struct sockaddr *)&amp;address, sizeof(address)) &lt; 0) {\n    perror(\"bind failed\");\n    exit(EXIT_FAILURE);\n  }\n\n  // 3. 监听连接请求，最多同时允许3个连接\n  if (listen(server_fd, 3) &lt; 0) {\n    perror(\"listen failed\");\n    exit(EXIT_FAILURE);\n  }\n\n  while (1) {\n    // 4. 接受连接请求\n    if ((client_fd = accept(server_fd, (struct sockaddr *)&amp;address,\n                            (socklen_t *)&amp;addrlen)) &lt; 0) {\n      perror(\"accept failed\");\n      exit(EXIT_FAILURE);\n    }\n\n    // 5. 创建子进程处理客户端连接\n    pid = fork();\n\n    if (pid &lt; 0) {\n      perror(\"fork failed\");\n      exit(EXIT_FAILURE);\n    } else if (pid == 0) {\n      // 子进程: 处理客户端连接\n      close(server_fd); // 子进程关闭server_fd\n      handle_client(client_fd);\n    } else {\n      // 父进程: 关闭client_fd，继续监听\n      close(client_fd);// 父进程关闭client_fd\n    }\n  }\n\n  return 0;\n}对于多线程的实现方式来说，每个客户端连接都会创建一个新的线程来处理。这样可以避免多进程的开销、子进程的回收等问题。多线程方式要注意的点有：\n\n线程函数的参数必须是void *类型，所以需要将client_fd和client_addr打包成一个结构体传递给线程函数。\n由于线程之间共享进程的内存空间，所以thread_args要在堆上分配，否则会出现数据错误。\n记得回收堆上分配的内存。\n\n多线程服务端代码：\nc#include &lt;arpa/inet.h&gt;\n#include &lt;netinet/in.h&gt;\n#include &lt;pthread.h&gt; // 引入线程库\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;unistd.h&gt;\n\n#define PORT 8080\n#define BUFFER_SIZE 1024\n\n// 定义一个结构体，用于传递客户端信息到线程\nstruct ThreadArgs {\n  int client_fd;\n  struct sockaddr_in client_addr;\n};\n\n// 线程函数，处理每个客户端的通信\nvoid *client_handler(void *arg) {\n  struct ThreadArgs *args = (struct ThreadArgs *)arg;\n  int client_fd = args-&gt;client_fd;\n  char client_ip[INET_ADDRSTRLEN];\n  inet_ntop(AF_INET, &amp;(args-&gt;client_addr.sin_addr), client_ip, INET_ADDRSTRLEN);\n  int client_port = ntohs(args-&gt;client_addr.sin_port);\n  free(args);//注意是args不是arg\n  printf(\"新客户端连接：IP: %s, 端口: %d\\n\", client_ip, client_port);\n\n  char buffer[BUFFER_SIZE] = {0};\n  int valread;\n\n  while (1) {\n    // 接收数据\n    memset(buffer, 0, BUFFER_SIZE);\n    valread = read(client_fd, buffer, BUFFER_SIZE);\n    if (valread &lt;= 0) {\n      // 连接关闭或出错\n      printf(\"客户端断开连接: IP: %s, 端口: %d\\n\", client_ip, client_port);\n      close(client_fd);\n      pthread_exit(NULL);\n    }\n\n    printf(\"从 %s:%d 收到消息: %s\\n\", client_ip, client_port, buffer);\n\n    // 处理数据并发送响应 (这里可以根据实际需求修改)\n    char message[] = \"来自服务器的消息\";\n    send(client_fd, message, strlen(message), 0);\n  }\n  return NULL;\n}\n\nint main() {\n  int server_fd, client_fd;\n  struct sockaddr_in address;\n  int addrlen = sizeof(address);\n\n  // 1. 创建 socket\n  if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n    perror(\"socket failed\");\n    exit(EXIT_FAILURE);\n  }\n\n  // 2. 绑定地址和端口\n  address.sin_family = AF_INET;\n  address.sin_addr.s_addr = INADDR_ANY;\n  address.sin_port = htons(PORT);\n  if (bind(server_fd, (struct sockaddr *)&amp;address, sizeof(address)) &lt; 0) {\n    perror(\"bind failed\");\n    exit(EXIT_FAILURE);\n  }\n\n  // 3. 监听连接请求\n  if (listen(server_fd, 3) &lt; 0) {\n    perror(\"listen failed\");\n    exit(EXIT_FAILURE);\n  }\n\n  while (1) {\n    struct ThreadArgs *thread_args =\n        (struct ThreadArgs *)malloc(sizeof(struct ThreadArgs));\n    if (thread_args == NULL) {\n      perror(\"内存分配失败\");\n      continue; // 尝试继续处理下一个连接\n    }\n\n    // 4. 接受连接请求\n    thread_args-&gt;client_fd =\n        accept(server_fd, (struct sockaddr *)&amp;thread_args-&gt;client_addr,\n               (socklen_t *)&amp;addrlen);\n    if (thread_args-&gt;client_fd &lt; 0) {\n      perror(\"accept failed\");\n      free(thread_args); // 释放内存\n      continue;          // 尝试继续处理下一个连接\n    }\n\n    // 5. 创建新线程处理客户端连接\n    pthread_t thread_id;\n    if (pthread_create(&amp;thread_id, NULL, client_handler, (void *)thread_args) !=\n        0) {\n      perror(\"pthread_create failed\");\n      close(thread_args-&gt;client_fd);\n      free(thread_args); // 释放内存\n      continue;          // 尝试继续处理下一个连接\n    }\n    // 父线程继续循环接受新的连接\n  }\n\n  return 0;\n}","slug":"Linux网络编程（TCP）","date":"2024-07-11T12:26:18.000Z","categories_index":"Linux","tags_index":"Linux,C++","author_index":"Ac-Accelerator"},{"id":"ffc7901ba136221db8bdbec1296c9feb","title":"Linux系统编程（信号与多线程）","content":"信号信号概述在Linux操作系统中，信号（Signal）是一种用于进程间通信的机制，可以用来通知进程某些事件的发生。信号的主要作用是让操作系统或其他进程可以向进程发送某种信息，以便该进程可以采取相应的动作。\n\n概念：信号是一种软件中断，通过信号，内核和进程可以通知进程某些事件的发生。例如，当用户按下 Ctrl+C 时，系统会向前台进程发送 SIGINT 信号。\n作用：\n通知事件：信号可以通知进程发生了某些事件，例如非法内存访问（SIGSEGV）、定时器到期（SIGALRM）等。\n控制进程：信号可以用来控制进程的行为，例如终止进程（SIGKILL）、暂停进程（SIGSTOP）、继续进程（SIGCONT）等。\n进程间通信：信号可以用作进程间通信的手段，以实现进程之间的协作和同步。\n\n\n\n信号可以由多种途径产生，包括：\n\n用户输入：例如，用户按下 Ctrl+C 组合键会产生 SIGINT 信号。\n系统调用：进程可以通过系统调用（如 kill）向自身或其他进程发送信号。\n硬件异常：例如非法内存访问会产生 SIGSEGV 信号、除以0。\n软件条件：例如定时器到期会产生 SIGALRM 信号。\n\n信号的处理过程可以概括为以下几个步骤：\n\n发送信号：信号可以由内核、其他进程或进程自身发送。\n捕获信号：进程可以通过设置信号处理程序（signal handler）来捕获和处理信号。信号处理程序是一段代码，当进程收到某个信号时，系统会自动调用该程序。\n默认动作：如果进程没有设置信号处理程序，系统会执行该信号的默认动作。不同信号有不同的默认动作，例如终止进程、忽略信号等。\n处理信号：信号处理程序执行完毕后，进程会恢复到原来的状态，继续执行。\n\n在使用信号之前，先要确定其编号、名称、对应事件、默认处理动作。再去使用。\n以下是一个简单的示例代码，展示了如何在C语言中处理信号：\nc#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;unistd.h&gt;\n\n// 信号处理程序\nvoid handle_signal(int signal) {\n    if (signal == SIGINT) {\n        printf(\"Received SIGINT (Ctrl+C). Exiting gracefully...\\n\");\n        exit(0);\n    }\n}\n\nint main() {\n    // 设置信号处理程序\n    signal(SIGINT, handle_signal);\n\n    // 无限循环，等待信号\n    while (1) {\n        printf(\"Running... Press Ctrl+C to exit.\\n\");\n        sleep(1);\n    }\n\n    return 0;\n}在这个例子中，程序设置了一个信号处理程序 handle_signal 来捕获 SIGINT 信号。当用户按下 Ctrl+C 时，程序会捕获该信号并执行相应的处理程序，输出一条消息并退出程序。\n信号屏蔽字（Signal Mask）信号屏蔽字是一组信号，它们被进程当前屏蔽或阻塞。被屏蔽的信号在它们到达时不会立即被处理，而是保持待处理状态（进入未决信号集），直到它们被从信号屏蔽字中移除。\n作用：\n\n阻止信号的处理：当一个信号被屏蔽时，即使它被发送到进程，进程也不会立即处理它。这允许进程在关键代码段中阻止信号的干扰。\n管理信号处理：通过屏蔽和解除屏蔽信号，进程可以更好地控制何时处理信号。\n\n未决信号集（Pending Signals）未决信号集是进程已经接收到但尚未处理的信号的集合。即使这些信号被送达进程，但如果它们在信号屏蔽字中被屏蔽，它们会保持未决状态，直到信号屏蔽字解除。\n功能：\n\n保持信号待处理状态：当信号被屏蔽时，它们不会被丢弃，而是进入未决信号集，等待被处理。\n保证信号处理：未决信号集确保所有发送到进程的信号在适当的时候都会被处理。\n\nLinux内核信号捕捉机制详细解析1. 信号的产生和递送\n信号可以由多种事件产生，内核在生成信号后，会使用 send_signal() 将其添加到目标进程的信号队列中。\n2. 检查信号阻塞状态\n内核会使用isig_deliver()检查目标进程的信号掩码 (signal mask)。递送没有被阻塞的信号。如果目标进程阻塞了信号，内核会将信号添加到进程的未决信号集中，等待信号解除阻塞后再递送。\n3. 选择信号递送时机\n内核在以下情况下使用handle_signal()将信号递送给进程：\n\n进程从内核态返回用户态时： 这是最常见的信号递送时机。当进程执行完系统调用、中断处理程序等内核代码，准备返回用户态执行用户代码时，内核会检查进程的信号队列，并将未阻塞的信号递送给进程。\n进程处于可中断睡眠状态时： 如果进程正在等待某个事件发生（例如等待IO完成），并且该等待是可中断的，则内核可以在此时递送信号，唤醒进程。\n\n4. 信号处理函数的执行\n当内核决定将信号递送给进程时，setup_sigcontext()会像中断一样保存进程的上下文，然后执行信号处理函数。\n5. 从信号处理函数返回\n当信号处理函数执行完成后，会执行 sys_sigreturn() 系统调用。该系统调用会通知内核信号处理函数已经执行完毕。内核会执行以下操作：\n\n恢复进程上下文：  restore_sigcontext()内核从内核栈中恢复进程之前保存的执行状态，包括寄存器的值、程序计数器等。\n清理用户态堆栈：  内核会清理掉之前为执行信号处理函数创建的栈帧。\n恢复进程执行：  进程恢复执行被信号中断前的代码。\n\n\n\n\n\n\n\n\n\n\n是说这两个玩意是不是和中断处理有点像？\nsignal函数c#include &lt;signal.h&gt;\n\ntypedef void (*sighandler_t)(int);\n\nsighandler_t signal(int signum, sighandler_t handler);signal() 函数将信号 signum 的处理方式设置为 handler，handler 可以是 SIG_IGN、SIG_DFL 或程序员定义的函数（即“信号处理程序”）的地址。\n如果信号 signum 被递送到进程，则会发生以下情况之一：\n\n如果处理方式设置为 SIG_IGN，则忽略该信号。\n如果处理方式设置为 SIG_DFL，则执行与该信号关联的默认操作（参见 signal(7)）。\n如果处理方式设置为一个函数，则首先将处理方式重置为 SIG_DFL，或者阻塞该信号（参见下文的“可移植性”），然后使用参数 signum 调用 handler。如果调用 handler 导致信号被阻塞，则在从 handler 返回时解除对该信号的阻塞。\n\nSIGKILL 和 SIGSTOP 信号不能被捕获或忽略。\n\n\n\n\n\n\n\n特别注意\n在一些系统上（特别是较旧的Unix系统），信号处理函数默认在信号处理期间被重置为 SIG_DFL，这意味着在处理信号后必须再次设置信号处理函数。这种行为确保信号处理函数不会重复调用，但也需要在每次处理完信号后重新设置信号处理函数。\n在现代系统中（如POSIX兼容系统），可以使用 sigaction 来设置信号处理函数。sigaction 提供了更多的控制选项，包括在处理函数执行期间不重置信号处理函数，也可以指定信号在处理期间是否阻塞。\n\n将处理方式重置为 SIG_DFL 会导致信号在处理函数返回后按照默认方式处理。\n阻塞该信号可以防止处理函数被同一信号的多个实例中断，并在处理函数返回后解除阻塞。\n\n\n\nsigaction函数c#include &lt;signal.h&gt;\n\nstruct sigaction {\n    void     (*sa_handler)(int);//SIG_DFL SIG_IGN 指向信号处理函数的指针\n    /*如果在 sa_flags 中指定了 SA_SIGINFO，则 \n    sa_sigaction（而不是 sa_handler）指定 signum 的信号处理函数。*/\n    void     (*sa_sigaction)(int, siginfo_t *, void *);\n    sigset_t   sa_mask;//指定在执行信号处理程序期间应阻塞的信号掩码\n    int        sa_flags;//指定一组修改信号行为的标志\n    void     (*sa_restorer)(void);//不推荐使用\n};\n\nint sigaction(int signum,\n              const struct sigaction *_Nullable restrict act,\n              struct sigaction *_Nullable restrict oldact);sigaction() 系统调用用于更改进程在接收到特定信号时采取的操作。（有关信号的概述，请参见 signal(7)\nsignum 指定信号，并且可以是除 SIGKILL 和 SIGSTOP 以外的任何有效信号。\n如果 act 不为空，则将从 act 安装信号 signum 的新操作。 如果 oldact 不为空，则将先前操作保存在 oldact 中。\nsigaction() 函数成功时返回 0；出错时返回 -1，并将 errno 设置为指示错误。\nsa_flags 可以是以下标志的按位或（一般最常用的是0）：\n\n\n\n标志位\n描述\n\n\n\nSA_NOCLDSTOP\n如果 signum 是 SIGCHLD，当子进程停止（即接收到 SIGSTOP、SIGTSTP、SIGTTIN 或 SIGTTOU 之一）或恢复（即接收到 SIGCONT）时，不接收通知（参见 wait(2)）。此标志仅在为 SIGCHLD 建立处理程序时才有意义。\n\n\nSA_NOCLDWAIT (Linux 2.6 起)\n如果 signum 是 SIGCHLD，当子进程终止时，不要将其转换为僵尸进程。另请参阅 waitpid(2)。此标志仅在为 SIGCHLD 建立处理程序或将该信号的处理方式设置为 SIG_DFL 时才有意义。如果在为 SIGCHLD 建立处理程序时设置了 SA_NOCLDWAIT 标志，则 POSIX.1 未指定当子进程终止时是否生成 SIGCHLD 信号。在 Linux 上，在这种情况下会生成 SIGCHLD 信号；在其他一些实现中则不会。\n\n\nSA_NODEFER\n在处理程序执行期间，不要将信号添加到线程的信号掩码中，除非在 act.sa_mask 中指定了该信号。因此，在处理程序执行期间，可能会将该信号的另一个实例传递给线程。此标志仅在建立信号处理程序时才有意义。SA_NOMASK 是此标志的已过时且非标准的同义词。\n\n\nSA_ONSTACK\n在 sigaltstack(2) 提供的备用信号堆栈上调用信号处理程序。如果没有可用的备用堆栈，则将使用默认堆栈。此标志仅在建立信号处理程序时才有意义。\n\n\nSA_RESETHAND\n在进入信号处理程序时，将信号操作恢复为默认值。此标志仅在建立信号处理程序时才有意义。SA_ONESHOT 是此标志的已过时且非标准的同义词。\n\n\nSA_RESTART\n通过使某些系统调用在信号之间可重新启动，提供与 BSD 信号语义兼容的行为。此标志仅在建立信号处理程序时才有意义。有关系统调用重新启动的讨论，请参阅 signal(7)。\n\n\nSA_RESTORER\n不适用于应用程序。C 库使用此标志来指示 sa_restorer 字段包含“信号蹦床”的地址。有关更多详细信息，请参阅 sigreturn(2)。\n\n\nSA_SIGINFO (Linux 2.2 起)\n信号处理程序接受三个参数，而不是一个。在这种情况下，应该设置 sa_sigaction 而不是 sa_handler。此标志仅在建立信号处理程序时才有意义。\n\n\nSA_UNSUPPORTED (Linux 5.11 起)\n用于动态探测标志位支持。如果尝试注册处理程序时，在 act-&gt;sa_flags 中设置了此标志以及内核可能不支持的其他标志，并且紧接着调用 sigaction()（指定相同的信号编号并且 oldact 参数为非 NULL）会在 oldact-&gt;sa_flags 中清除 SA_UNSUPPORTED，则可以使用 oldact-&gt;sa_flags 作为位掩码，描述实际上支持哪些可能不受支持的标志。有关更多详细信息，请参阅下面的“动态探测标志位支持”部分。\n\n\nSA_EXPOSE_TAGBITS (Linux 5.11 起)\n通常，在传递信号时，会从 siginfo_t 的 si_addr 字段中清除一组特定于体系结构的标记位。如果设置了此标志，则将在 si_addr 中保留特定于体系结构的标记位子集。\n\n\nkill函数c#include &lt;sys/types.h&gt;\n#include &lt;signal.h&gt;\n\nint kill(pid_t pid, int sig);kill() 系统调用可用于向任何进程组或进程发送任何信号。\n如果 pid 为正数，则信号 sig 会被发送到 ID 为 pid 的进程。\n如果 pid 等于 0，则 sig 会被发送到调用进程所在进程组中的每个进程。\n如果 pid 等于 -1，则 sig 会被发送到调用进程有权发送信号的每个进程，但进程 1（init）除外，详情请参阅下文。\n如果 pid 小于 -1，则 sig 会被发送到 ID 为 -pid 的进程组中的每个进程。\n如果 sig 为 0，则不发送任何信号，但仍然会执行存在性和权限检查；这可用于检查调用方有权发送信号的进程 ID 或进程组 ID 是否存在。\n进程要获得发送信号的权限，它必须是特权进程（在 Linux 下：在目标进程的用户命名空间中拥有 CAP_KILL 功能），或者发送进程的真实或有效用户 ID 必须等于目标进程的真实或保存设置用户 ID。对于 SIGCONT 信号，如果发送进程和接收进程属于同一个会话，则满足条件。（历史上，规则有所不同；请参阅“注释”部分。）\n成功发送至少一个信号后，返回 0。发生错误时，返回 -1，并将 errno 设置为指示错误的原因。\n子进程杀死父进程：\nc#include &lt;signal.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n  pid_t pid = fork();\n  if(pid==0){\n    sleep(1);\n    printf(\"kill parent\\n\");\n    kill(getppid(), SIGKILL);\n  }\n  else{\n    printf(\"parent\\n\");\n    sleep(20);\n  }\n}alarm函数c#include &lt;unistd.h&gt;\n\nunsigned int alarm(unsigned int seconds);alarm() 函数安排在 seconds 秒后向调用进程发送一个 SIGALRM 信号。\n如果 seconds 为零，则取消任何挂起的闹钟。\n无论如何，任何先前设置的 alarm() 都将被取消。\nalarm() 返回距离任何先前设置的闹钟被递送剩余的秒数，如果没有先前设置的闹钟，则返回零。\n\n\n\n\n\n\n\n注意\nalarm() 和 setitimer(2) 共享同一个定时器；对其中一个函数的调用会干扰另一个函数的使用。\n由 alarm() 创建的闹钟在 execve(2) 系统调用之后仍然保留，但不会被 fork(2) 创建的子进程继承。\nsleep(3) 的实现可能使用了 SIGALRM 信号；因此，混合调用 alarm() 和 sleep(3) 并不可取。\n与以往一样，调度延迟会导致进程执行延迟任意时间。\n\n\n这是一个使用 alarm() 函数的示例：\nc#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;signal.h&gt;\n\n// 信号处理函数\nvoid handle_alarm(int sig) {\n    printf(\"Alarm received! Signal number: %d\\n\", sig);\n    exit(0);\n}\n\nint main() {\n    // 注册信号处理函数\n    signal(SIGALRM, handle_alarm);\n\n    // 设置闹钟，5秒后发送SIGALRM信号\n    alarm(5);\n\n    printf(\"Alarm set for 5 seconds.\\n\");\n\n    // 无限循环等待信号\n    while (1) {\n        // 打印消息表示程序正在运行\n        printf(\"Waiting for alarm...\\n\");\n        sleep(1); // 每秒钟打印一次\n    }\n\n    return 0;\n}getitimer, setitimer函数c#include &lt;sys/time.h&gt;\n\nstruct timeval\n{\n  __time_t tv_sec;\t\t/* Seconds.  */\n  __suseconds_t tv_usec;\t/* Microseconds.  */\n};\n\nstruct itimerval\n{\n  /* Value to put into `it_value' when the timer expires.  */\n  struct timeval it_interval;\n  /* Time to the next timer expiration.  */\n  struct timeval it_value;\n};\n\nint getitimer(int which, struct itimerval *value);\nint setitimer(int which, const struct itimerval *restrict value,\n    struct itimerval *restrict ovalue);getitimer() 函数应将 which 指定的计时器的当前值存储到 value 指向的结构体中。setitimer() 函数应将 which 指定的计时器设置为 value 指向的结构体中指定的值，如果 ovalue 不是空指针，则将计时器的先前值存储到 ovalue 指向的结构体中。\n计时器值由 &lt;sys/time.h&gt; 中指定的 itimerval 结构体定义。如果 it_value 非零，则它表示到下一次计时器到期的时间。如果 it_interval 非零，则它指定计时器到期时用于重新加载 it_value 的值。无论 it_interval 的值如何，将 it_value 设置为 0 都将禁用计时器。将 it_interval 设置为 0 将在下一次到期后禁用计时器（假设 it_value 非零）。\n实现可能会对计时器值的粒度施加限制。对于每个间隔计时器，如果请求的计时器值需要的粒度比实现支持的粒度更精细，则实际计时器值应向上舍入到下一个支持的值。\n符合 XSI 标准的实现至少为每个进程提供三个间隔计时器，这些计时器由 which 参数指示：\nITIMER_PROF 在进程虚拟时间和系统代表进程运行时递减。它旨在供解释器在统计分析解释程序的执行情况时使用。每次 ITIMER_PROF 计时器到期时，都会发送 SIGPROF 信号。\nITIMER_REAL 实时递减。当此计时器到期时，将发送 SIGALRM 信号。\nITIMER_VIRTUAL 在进程虚拟时间内递减。它仅在进程执行时运行。当它到期时，将发送 SIGVTALRM 信号。\nsetitimer() 与 alarm() 或 sleep() 之间的交互未指定。\n当 getitimer() 或 setitimer() 函数成功执行完成后，返回值为 0；否则，返回值为 -1，并将 errno 设置为相应的错误码。\n这是一个使用 setitimer() 函数的示例：\nc#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;sys/time.h&gt;\n#include &lt;unistd.h&gt;\n\nvoid timer_handler(int signum) {\n    static int count = 0;\n    printf(\"Timer expired %d times\\n\", ++count);\n}\n\nint main() {\n    struct sigaction sa;\n    struct itimerval timer;\n\n    // Install timer_handler as the signal handler for SIGALRM.\n    sa.sa_handler = &amp;timer_handler;\n    sa.sa_flags = SA_RESTART;\n    sigemptyset(&amp;sa.sa_mask);//initial signal set to empty\n    if (sigaction(SIGALRM, &amp;sa, NULL) == -1) {\n        perror(\"sigaction\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Configure the timer to expire after 1 sec... \n    timer.it_value.tv_sec = 3;\n    timer.it_value.tv_usec = 0;\n\n    // ... and every 1 sec after that.\n    timer.it_interval.tv_sec = 1;\n    timer.it_interval.tv_usec = 0;\n\n    // Start a virtual timer. It counts down whenever this process is executing.\n    if (setitimer(ITIMER_REAL, &amp;timer, NULL) == -1) {\n        perror(\"setitimer\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Do busy work. \n    while (1) {\n        pause(); // Wait for signals.\n    }\n\n    return 0;\n}信号集操作函数c#include &lt;signal.h&gt;\n\nint sigemptyset(sigset_t *set);\n\nint sigfillset(sigset_t *set);\n\nint sigaddset(sigset_t *set, int signum);\n\nint sigdelset(sigset_t *set, int signum);\n\nint sigismember(const sigset_t *set, int signum);这些函数允许操作 POSIX 信号集。\nsigemptyset() 函数将由 set 指定的信号集初始化为空，排除所有信号。\nsigfillset() 函数将 set 初始化为满，包含所有信号。\nsigaddset() 和 sigdelset() 函数分别将信号 signum 添加到 set 和从 set 中删除。\nsigismember() 函数测试 signum 是否是 set 的成员。\nsigemptyset()、sigfillset()、sigaddset() 和 sigdelset() 成功时返回 0，出错时返回 -1。\n返回值：\n如果 signum 是 set 的成员，则 sigismember() 返回 1；如果 signum 不是 set 的成员，则返回 0；出错时返回 -1。\n\n\n\n\n\n\n\n注意\nsigset_t 类型的对象在传递给函数 sigaddset()、sigdelset() 和 sigismember() 或下述 glibc 附加函数（sigisemptyset()、sigandset() 和 sigorset()）之前，必须通过调用 sigemptyset() 或 sigfillset() 进行初始化。 否则，结果将不确定。\n\n\nsigprocmask函数c#include &lt;signal.h&gt;\n\n/* Prototype for the glibc wrapper function */\nint sigprocmask(int how, const sigset_t *_Nullable restrict set,\n                          sigset_t *_Nullable restrict oldset);sigprocmask() 函数用于获取和/或更改调用线程的信号掩码。信号掩码是指当前被调用者阻塞的一组信号（更多详细信息请参阅 signal(7)）。\n函数的行为取决于 how 的值，具体如下：\n\nSIG_BLOCK：阻塞信号集是当前信号集和 set 参数的并集。\nSIG_UNBLOCK：从当前阻塞信号集中移除 set 中的信号。允许尝试解除未被阻塞的信号的阻塞。\nSIG_SETMASK：将阻塞信号集设置为 set 参数。\n\n如果 oldset 不为 NULL，则会将先前的信号掩码值存储在 oldset 中。如果 set 为 NULL，则信号掩码保持不变（即忽略 how 参数），但当前的信号掩码值仍将返回到 oldset 中（如果它不为 NULL）。\nsigsetops(3) 中描述了一组用于修改和检查 sigset_t 类型变量（“信号集”）的函数。在多线程进程中，sigprocmask() 的使用未指定；请参阅 pthread_sigmask(3)。\nsigprocmask() 函数成功时返回 0。失败时返回 -1，并将 errno 设置为指示错误。\n\n\n\n\n\n\n\n注意\n在使用 sigprocmask() 函数时，set 和 oldset 不能是同一个变量。\n\n\nsigpending函数c#include &lt;signal.h&gt;\n\nint sigpending(sigset_t *set);sigpending() 函数返回等待传递给调用线程的信号集（即，在阻塞时引发的信号）。未决信号掩码将在 set 中返回。\nsigpending() 函数成功时返回 0。失败时返回 -1，并将 errno 设置为指示错误。\n\n\n\n\n\n\n提示\n\n有关操作信号集的详细信息，请参阅 sigsetops(3)。\n如果一个信号既被阻塞又设置为“忽略”处理，则在生成该信号时，它不会被添加到未决信号掩码中。\n线程的未决信号集是该线程的未决信号集与整个进程的未决信号集的并集；请参阅 signal(7)。\n通过 fork(2) 创建的子进程最初具有空的未决信号集；未决信号集在 execve(2) 中得以保留。\n\n\n\n这是一个使用 sigpending() 函数的示例：\nc#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;unistd.h&gt;\n\n// 信号处理函数\nvoid signal_handler(int sig) {\n    printf(\"Caught signal %d\\n\", sig);\n}\n\nint main() {\n    sigset_t set, oldset;\n    struct sigaction sa;\n\n    // 设置信号处理函数\n    sa.sa_handler = signal_handler;\n    sa.sa_flags = 0;\n    sigemptyset(&amp;sa.sa_mask);\n    if (sigaction(SIGINT, &amp;sa, NULL) == -1) {\n        perror(\"sigaction\");\n        exit(EXIT_FAILURE);\n    }\n\n    sigemptyset(&amp;set);// 初始化信号集为空\n\n    sigaddset(&amp;set, SIGINT);// 将SIGINT添加到信号集中\n\n    // 阻塞SIGINT信号，并保存旧的信号集\n    if (sigprocmask(SIG_BLOCK, &amp;set, &amp;oldset) == -1) {\n        perror(\"sigprocmask\");\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"SIGINT is blocked. Try pressing Ctrl+C now...\\n\");\n    sleep(5);\n\n    // 恢复原来的信号集，解除对SIGINT的阻塞\n    if (sigprocmask(SIG_SETMASK, &amp;oldset, NULL) == -1) {\n        perror(\"sigprocmask\");\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"SIGINT is unblocked. Try pressing Ctrl+C now...\\n\");\n    sleep(5);\n\n    return 0;\n}sigsuspend函数c#include &lt;signal.h&gt;\n\nint sigsuspend(const sigset_t *mask);sigsuspend() 函数会将调用线程的信号掩码临时替换为 mask 参数所指定的掩码，然后挂起该线程，直到传递来一个信号，该信号的动作是调用信号处理程序或终止进程。如果信号终止了进程，那么 sigsuspend() 不会返回。如果信号被捕获，那么 sigsuspend() 会在信号处理程序返回后返回，并将信号掩码恢复到调用 sigsuspend() 之前的状态。无法阻塞 SIGKILL 或 SIGSTOP 信号；在 mask 中指定这些信号对线程的信号掩码没有影响。\nsigsuspend() 函数总是返回 -1，并将 errno 设置为相应的错误码（通常是 EINTR）。\n\n\n\n\n\n\n提示\n通常，sigsuspend() 会与 sigprocmask(2) 函数结合使用，以防止在执行关键代码段时传递信号。调用方首先使用 sigprocmask(2) 函数阻塞信号。当关键代码执行完毕后，调用方接着调用 sigsuspend() 函数，并将 sigprocmask(2) 函数返回的信号掩码（在 oldset 参数中）传递给它，以等待信号。\n父进程回收子进程资源：\nc#include &lt;signal.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/wait.h&gt;\n#include &lt;unistd.h&gt;\n\nvoid wait_child(int sig) {\n  printf(\"wait child\\n\");\n  int status;\n  wait(&amp;status);\n}\n\nint main() {\n  sigset_t sig, oldsig;\n  \n  sigemptyset(&amp;sig);\n  sigaddset(&amp;sig, SIGCHLD);\n  sigprocmask(SIG_BLOCK, &amp;sig, &amp;oldsig);// 在fork之前阻塞SIGCHLD信号，等到wait_child函数注册完成后解除阻塞\n\n  pid_t pid = fork();\n  if (pid == 0) {\n    printf(\"here is child\\n\");//子进程结束后会产生SIGCHLD信号\n  } else {\n    //这里的关键代码不会被SIGCHLD信号中断\n    printf(\"parent setting sigmask\\n\");\n    struct sigaction sa;\n    sa.sa_flags = 0;\n    sa.sa_handler = wait_child;\n    sigemptyset(&amp;sa.sa_mask);\n    sigaction(SIGCHLD, &amp;sa, NULL);\n        \n    sigsuspend(&amp;oldsig); //使用sigsuspend解除SIGINT信号阻塞 并挂起进程，直到收到信号\n    // sigprocmask(SIG_SETMASK, &amp;oldsig, NULL);//这样也行\n    // sleep(1);\n  }\n}\n\n进程组（作业）\n进程组是多个进程的集合，每个进程都属于一个进程组，以简化对多个进程的管理， waitpid() 函数和kill 函数的参数都可以对进程组进行操作。\n父进程创建子进程的时候默认父子进程属于同一进程组。当一个进程创建新的进程组时，它会自动成为该进程组的组长，并且其进程 ID 会被用作进程组 ID。\n即使组长进程终止，进程组依然存在，且进程组 ID 仍然保持不变，直到进程组中的所有进程都终止。在这期间进程组变成孤儿进程组，与任何终端会话分离，如果进程组中的某个进程试图执行需要终端的操作（例如调用 wait() 或 openpty()），则该进程将收到 SIGHUP 信号。\nkill -SIGKILL -&lt;进程组id&gt; 杀掉整个进程组。\n一个进程可以为自己或子进程设置进程组 id。\n\n进程组操作函数c#include &lt;unistd.h&gt;\n\nint setpgid(pid_t pid, pid_t pgid);\npid_t getpgid(pid_t pid);setpgid() 函数将 pid 指定的进程的 PGID 设置为 pgid。如果 pid 为零，则使用调用进程的进程 ID。如果 pgid 为零，则将 pid 指定的进程的 PGID 设置为与其进程 ID 相同。如果使用 setpgid() 将进程从一个进程组移动到另一个进程组（例如某些 shell 在创建管道时所做的），则两个进程组必须属于同一个会话（参见 setsid(2) 和 credentials(7)）。在这种情况下，pgid 指定要加入的现有进程组，并且该组的会话 ID 必须与加入进程的会话 ID 相匹配。\ngetpgid() 函数返回 pid 指定的进程的 PGID。如果 pid 为零，则使用调用进程的进程 ID。\n如果成功，setpgid() 和 setpgrp() 返回零。如果出错，则返回 -1，并设置 errno 以指示错误。\n\n\n\n\n\n\n提示\n通过 fork(2) 创建的子进程会继承其父进程的进程组 ID。在执行 execve(2) 后，PGID 仍会被保留。\n每个进程组都是某个会话的成员，并且每个进程都是其进程组所属会话的成员。（参见 credentials(7)。）\n一个会话可以有一个控制终端。在任何时候，会话中只能有一个进程组是终端的前台进程组；其余进程组处于后台。如果从终端生成信号（例如，键入中断键以生成 SIGINT 信号），则该信号将发送到前台进程组。（有关生成信号的字符的说明，请参见 termios(3)。）只有前台进程组可以从终端读取数据 (read(2))；如果后台进程组尝试从终端读取数据 (read(2))，则会向该组发送 SIGTTIN 信号，从而将其挂起。 tcgetpgrp(3) 和 tcsetpgrp(3) 函数用于获取/设置控制终端的前台进程组。\nsetpgid() 和 getpgrp() 调用由 bash(1) 等程序用于创建进程组，以便实现 shell 作业控制。\n如果某个进程终止导致一个进程组变为孤儿进程组，并且如果新成为孤儿的进程组中的任何成员已停止，则会向新成为孤儿的进程组中的每个进程发送一个 SIGHUP 信号，然后再发送一个 SIGCONT 信号。孤儿进程组是指其中每个成员的父进程要么是该进程组本身的成员，要么是不同会话中某个进程组的成员（另请参见 credentials(7)）。\n\n\n\n\n\n\n\n\n\n注意\n可以使用setpgid()函数来将本进程添加到其他随便一个已有的进程组吗？\nsetpgid() 函数用于将一个进程加入到一个进程组中，但是并不能随意地将本进程加入到任何已有的进程组中。使用 setpgid() 时有一些限制：\n\n相同的会话：目标进程组和调用 setpgid() 的进程必须属于同一个会话（session）。会话是由 setsid 系统调用创建的，所有属于同一会话的进程共享一个会话 ID。\n权限要求：调用 setpgid() 的进程必须对目标进程组有适当的权限。通常，这意味着调用进程和目标进程组中的进程必须由同一个用户拥有，或者调用进程具有超级用户权限。\n进程组领导者的限制：如果一个进程是其自身进程组的组长（即其进程组 ID 等于其进程 ID），则不能改变其进程组。\n\n\n\n会话在 Linux 系统内部，会话是一个更抽象的概念，它代表一组拥有相同控制终端的进程。\n每个会话都拥有一个唯一的 会话 ID (Session ID, SID)。\n一个会话可以包含多个 进程组 (Process Group)，每个进程组也拥有一个唯一的 进程组 ID (Process Group ID, PGID)。\n会话首进程 (session leader) 的进程 ID 就是会话 ID。\nsetsid函数c#include &lt;unistd.h&gt;\n\npid_t setsid(void);setsid() 函数会在调用进程不是进程组组长的情况下创建一个新的会话。调用进程会成为新会话的首进程 (也就是说，其会话 ID 会被设置为与其进程 ID 相同)。调用进程同时也会成为该会话中一个新的进程组的组长进程 (也就是说，其进程组 ID 会被设置为与其进程 ID 相同)。\n调用进程将成为新的进程组和新会话中唯一的进程。\n新会话初始时没有控制终端。关于会话如何获取控制终端的详细信息，请参阅 credentials(7)。\n若调用成功，则返回调用进程的（新）会话 ID。若调用失败，则返回 (pid_t) -1，并将 errno 设置为指示错误的值。\n\n\n\n\n\n\n\n\n\n这是创建守护进程的常用方法之一。首先调用 fork() 创建一个子进程，父进程随后退出。在子进程中调用 setsid()创建新的会话，即可使其脱离该终端的控制，且其ppid变为1。 \npthread_create函数c#include &lt;pthread.h&gt;\n\nint pthread_create(pthread_t *restrict thread,\n                    const pthread_attr_t *restrict attr,\n                    void *(*start_routine)(void *),\n                    void *restrict arg);pthread_create() 函数用于在调用进程中创建一个新线程。新线程将通过调用 start_routine() 函数开始执行；arg 将作为 start_routine() 函数的唯一参数被传递。\n新线程可以通过以下几种方式终止：\n\n调用 pthread_exit(3) 函数，并指定一个退出状态码。该状态码可由同一进程中调用 pthread_join(3) 函数的其它线程获取。\n从 start_routine() 函数返回。这等效于调用 pthread_exit(3) 函数，并使用 return 语句中提供的值作为退出状态码。\n被取消 (参见 pthread_cancel(3))。\n进程中的任何线程调用 exit(3) 函数，或 主线程从 main() 函数返回 。这将导致进程中所有线程终止。\n\nattr 参数指向一个 pthread_attr_t 结构体，该结构体的内容将在线程创建时用于确定新线程的属性；可以使用 pthread_attr_init(3) 函数及相关函数对该结构体进行初始化。如果 attr 为 NULL，则将使用默认属性创建线程。\n如果 pthread_create() 函数调用成功，它将在返回之前将新线程的 ID 存储到 thread 指向的缓冲区中；该标识符可在后续调用其它 pthreads 函数时用于引用该线程。\n新线程将继承创建线程的信号掩码副本 (pthread_sigmask(3))。新线程的未决信号集为空 (sigpending(2))。新线程不会继承创建线程的备用信号栈 (sigaltstack(2))。\n新线程将继承调用线程的浮点环境 (fenv(3))。\n新线程的 CPU 时间计数器的初始值为 0 (参见 pthread_getcpuclockid(3))。\n如果 pthread_create() 函数调用成功，将返回 0；如果发生错误，将返回一个错误码，并且 *thread 的内容将是未定义的。\npthread_exit函数c#include &lt;pthread.h&gt;\n\n[[noreturn]] void pthread_exit(void *retval);pthread_exit() 函数终止调用线程，并通过 retval 返回一个值（如果该线程是可连接的），该值可由同一进程中调用 pthread_join(3) 函数的另一个线程获取。\n所有已建立但尚未被弹出的、由 pthread_cleanup_push(3) 函数设置的清理处理程序都将被弹出（顺序与压入顺序相反）并执行。如果线程有任何线程私有数据，则在清理处理程序执行完毕后，将以未指定的顺序调用相应的析构函数。\n当线程终止时，进程共享资源（例如，互斥量、条件变量、信号量和文件描述符）不会被释放，并且使用 atexit(3) 函数注册的函数也不会被调用。\n在进程中的最后一个线程终止后，该进程将像调用 exit(3) 函数并传入退出状态 0 一样终止；因此，进程共享资源会被释放，并且使用 atexit(3) 函数注册的函数会被调用。\n该函数不会返回到调用者。\npthread_join函数c#include &lt;pthread.h&gt;\n\nint pthread_join(pthread_t thread, void **retval);pthread_join() 函数等待由 thread 指定的线程终止。如果该线程已经终止，则 pthread_join() 会立即返回。由 thread 指定的线程必须是可连接的。\n如果 retval 不为 NULL，则 pthread_join() 会将目标线程的退出状态（即目标线程提供给 pthread_exit(3) 的值）复制到 retval 指向的位置。如果目标线程被取消，则 PTHREAD_CANCELED 将被放置到 retval 指向的位置。\n如果多个线程同时尝试连接到同一个线程，则结果将是未定义的。如果调用 pthread_join() 的线程被取消，则目标线程将保持可连接状态（即它不会被分离）。\npthread_cancel函数c#include &lt;pthread.h&gt;\n\nint pthread_cancel(pthread_t thread);pthread_cancel() 函数向 thread 线程发送一个取消请求。目标线程是否以及何时响应取消请求取决于该线程控制下的两个属性：可取消状态和取消类型。\n线程的可取消状态由 pthread_setcancelstate(3) 确定，可以启用（新线程的默认设置）或禁用。如果线程禁用了取消，则取消请求将一直排队，直到线程启用取消。如果线程启用了取消，则其取消类型将决定何时发生取消。\n线程的取消类型由 pthread_setcanceltype(3) 确定，可以是异步的或延迟的（新线程的默认设置）。异步取消意味着线程可以随时被取消（通常是立即取消，但系统不保证这一点）。延迟取消意味着取消将被延迟，直到线程下次调用一个取消点函数。pthreads(7) 中提供了一个可取消点函数列表。\n当取消请求被执行时，thread 线程将按以下顺序执行以下步骤：\n\n取消清理处理程序将被弹出（顺序与压入顺序相反）并被调用。（参见 pthread_cleanup_push(3)）。\n线程私有数据析构函数将以未指定的顺序被调用。（参见 pthread_key_create(3)）。\n线程被终止。（参见 pthread_exit(3)）。\n\n以上步骤相对于 pthread_cancel() 调用是异步发生的；pthread_cancel() 的返回值仅通知调用者取消请求是否已成功排队。\n在一个被取消的线程终止后，使用 pthread_join(3) 与该线程进行连接将会获得 PTHREAD_CANCELED 作为线程的退出状态。（与线程连接是知道取消已完成的唯一方法）。\n如果 pthread_cancel() 函数调用成功，将返回 0；如果发生错误，将返回一个非零错误码。\n\n\n\n\n\n\n提示\n线程在执行某些系统调用（如I/O操作、锁操作等）时，会进入内核态。这些系统调用本身就是取消点，即在这些系统调用的过程中，线程会检查是否有取消请求并作出响应。如果一个线程从未进行任何系统调用（即从未进入内核态），它就不会遇到这些默认的取消点，从而不会响应取消请求,为了确保这种线程也能响应取消请求，需要手动设置取消点。这可以通过调用pthread_testcancel()函数来实现。pthread_testcancel()是一个显式的取消点，当线程调用它时，会检查是否有取消请求。如果有，它会响应取消请求并终止线程。\n\n\npthread_detach函数c#include &lt;pthread.h&gt;\n\nint pthread_detach(pthread_t thread);pthread_detach() 函数将由 thread 标识的线程标记为分离线程。当分离线程终止时，它的资源会自动释放回系统，而不需要其他线程与该终止线程进行连接。\n尝试分离一个已经分离的线程将导致未指定的行为。\n如果 pthread_detach() 函数调用成功，将返回 0；如果发生错误，将返回一个错误码。\n线程属性设置cpthread_attr_init(3)//初始化线程属性对象\npthread_attr_setaffinity_np(3)//设置线程的亲和性\npthread_attr_setdetachstate(3)//设置线程的分离状态\npthread_attr_setguardsize(3)//设置线程的警戒缓冲区大小\npthread_attr_setinheritsched(3)//设置线程的继承调度策略\npthread_attr_setschedparam(3)//设置线程的调度参数\npthread_attr_setschedpolicy(3)//设置线程的调度策略\npthread_attr_setscope(3)//设置线程的作用域\npthread_attr_setsigmask_np(3)//设置线程的信号掩码\npthread_attr_setstack(3)//设置线程的栈\npthread_attr_setstackaddr(3)//设置线程的栈地址\npthread_attr_setstacksize(3)//设置线程的栈大小示例程序：\nc#include &lt;err.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nstatic void display_pthread_attr(pthread_attr_t *attr, char *prefix) {\n  int s, i;\n  size_t v;\n  void *stkaddr;\n  struct sched_param sp;\n\n  s = pthread_attr_getdetachstate(attr, &amp;i);\n  printf(\"%sDetach state        = %s\\n\", prefix,\n         (i == PTHREAD_CREATE_DETACHED)   ? \"PTHREAD_CREATE_DETACHED\"\n         : (i == PTHREAD_CREATE_JOINABLE) ? \"PTHREAD_CREATE_JOINABLE\"\n                                          : \"???\");\n\n  s = pthread_attr_getscope(attr, &amp;i);\n\n  printf(\"%sScope               = %s\\n\", prefix,\n         (i == PTHREAD_SCOPE_SYSTEM)    ? \"PTHREAD_SCOPE_SYSTEM\"\n         : (i == PTHREAD_SCOPE_PROCESS) ? \"PTHREAD_SCOPE_PROCESS\"\n                                        : \"???\");\n\n  s = pthread_attr_getinheritsched(attr, &amp;i);\n  printf(\"%sInherit scheduler   = %s\\n\", prefix,\n         (i == PTHREAD_INHERIT_SCHED)    ? \"PTHREAD_INHERIT_SCHED\"\n         : (i == PTHREAD_EXPLICIT_SCHED) ? \"PTHREAD_EXPLICIT_SCHED\"\n                                         : \"???\");\n\n  s = pthread_attr_getschedpolicy(attr, &amp;i);\n\n  printf(\"%sScheduling policy   = %s\\n\", prefix,\n         (i == SCHED_OTHER)  ? \"SCHED_OTHER\"\n         : (i == SCHED_FIFO) ? \"SCHED_FIFO\"\n         : (i == SCHED_RR)   ? \"SCHED_RR\"\n                             : \"???\");\n\n  s = pthread_attr_getschedparam(attr, &amp;sp);\n\n  printf(\"%sScheduling priority = %d\\n\", prefix, sp.sched_priority);\n\n  s = pthread_attr_getguardsize(attr, &amp;v);\n\n  printf(\"%sGuard size          = %zu bytes\\n\", prefix, v);\n\n  s = pthread_attr_getstack(attr, &amp;stkaddr, &amp;v);\n\n  printf(\"%sStack address       = %p\\n\", prefix, stkaddr);\n  printf(\"%sStack size          = %#zx bytes\\n\", prefix, v);\n}\n\nstatic void *thread_start(void *arg) {\n  int s;\n  pthread_attr_t gattr;\n\n  /* pthread_getattr_np() is a non-standard GNU extension that\n     retrieves the attributes of the thread specified in its\n     first argument. */\n\n  s = pthread_getattr_np(pthread_self(), &amp;gattr);\n\n  printf(\"Thread attributes:\\n\");\n  display_pthread_attr(&amp;gattr, \"\\t\");\n\n  exit(EXIT_SUCCESS); /* Terminate all threads */\n}\n\nint main(int argc, char *argv[]) {\n  pthread_t thr;\n  pthread_attr_t attr;\n  pthread_attr_t *attrp; /* NULL or &amp;attr */\n  int s;\n\n  attrp = NULL;\n\n  /* If a command-line argument was supplied, use it to set the\n     stack-size attribute and set a few other thread attributes,\n     and set attrp pointing to thread attributes object. */\n\n  if (argc &gt; 1) {\n    size_t stack_size;\n    void *sp;\n\n    attrp = &amp;attr;\n\n    s = pthread_attr_init(&amp;attr);\n\n    s = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);\n\n    s = pthread_attr_setinheritsched(&amp;attr, PTHREAD_EXPLICIT_SCHED);\n\n    stack_size = strtoul(argv[1], NULL, 0);\n\n    s = posix_memalign(&amp;sp, sysconf(_SC_PAGESIZE), stack_size);\n\n    printf(\"posix_memalign() allocated at %p\\n\", sp);\n\n    s = pthread_attr_setstack(&amp;attr, sp, stack_size);\n  }\n\n  s = pthread_create(&amp;thr, attrp, &amp;thread_start, NULL);\n\n  if (attrp != NULL) {\n    s = pthread_attr_destroy(attrp);\n  }\n\n  pause(); /* Terminates when other thread calls exit() */\n}pthread_mutex_init函数c#include &lt;pthread.h&gt;\n\nint pthread_mutex_destroy(pthread_mutex_t *mutex);\nint pthread_mutex_init(pthread_mutex_t *restrict mutex,\n    const pthread_mutexattr_t *restrict attr);\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;pthread_mutex_destroy() 函数应销毁 mutex 引用的互斥锁对象；实际上，该互斥锁对象将变为未初始化状态。实现可能导致 pthread_mutex_destroy() 将 mutex 引用的对象设置为无效值。\n可以使用 pthread_mutex_init() 重新初始化已销毁的互斥锁对象；在销毁后以其他方式引用该对象的结果是未定义的。\n销毁已初始化且已解锁的互斥锁应该是安全的。尝试销毁已锁定的互斥锁，或其他线程正在尝试锁定的互斥锁，或其他线程正在 pthread_cond_timedwait() 或 pthread_cond_wait() 调用中使用的互斥锁，将导致未定义行为。\npthread_mutex_init() 函数应使用 attr 指定的属性初始化 mutex 引用的互斥锁。如果 attr 为 NULL，则使用默认的互斥锁属性；其效果应与传递默认互斥锁属性对象的地址相同。成功初始化后，互斥锁的状态将变为已初始化和已解锁。\n尝试初始化已初始化的互斥锁将导致未定义行为。\n如果默认互斥锁属性适用，则可以使用宏 PTHREAD_MUTEX_INITIALIZER 来初始化互斥锁。其效果应等效于通过调用 pthread_mutex_init() 并将参数 attr 指定为 NULL 进行动态初始化，但不会执行错误检查。\n如果成功，pthread_mutex_destroy() 和 pthread_mutex_init() 函数应返回零；否则，将返回一个错误号以指示错误。\npthread_mutex_lock函数c#include &lt;pthread.h&gt;\n\nint pthread_mutex_lock(pthread_mutex_t *mutex);\nint pthread_mutex_trylock(pthread_mutex_t *mutex);\nint pthread_mutex_unlock(pthread_mutex_t *mutex);调用 pthread_mutex_lock() 函数并返回零或 EOWNERDEAD 时，应锁定 mutex 引用的互斥锁对象。如果该互斥锁已被其他线程锁定，则调用线程应阻塞，直到该互斥锁可用。此操作应在互斥锁对象处于锁定状态且调用线程作为其所有者时返回，该互斥锁对象由 mutex 引用。如果某个线程尝试重新锁定其已锁定的互斥锁，则 pthread_mutex_lock() 的行为应如以下表格的“重新锁定”列中所述。如果某个线程尝试解锁 不是这个线程锁定的互斥锁 或 已解锁的互斥锁 ，则 pthread_mutex_unlock() 的行为应如以下表格的“非所有者解锁”列中所述。\n\n\n\n互斥锁类型\n稳健性\n重新锁定\n非所有者解锁\n\n\n\nNORMAL\n非稳健\n死锁\n未定义行为\n\n\nNORMAL\n稳健\n死锁\n返回错误\n\n\nERRORCHECK\n非稳健或稳健\n返回错误\n返回错误\n\n\nRECURSIVE\n非稳健或稳健\n递归（见下文）\n返回错误\n\n\nDEFAULT\n非稳健\n未定义行为†\n未定义行为†\n\n\nDEFAULT\n稳健\n未定义行为†\n返回错误\n\n\n† 如果互斥锁类型为 PTHREAD_MUTEX_DEFAULT，则 pthread_mutex_lock() 的行为可能与上表中所述的三种其他标准互斥锁类型之一相对应。如果它与这三种类型都不相对应，则对于标记为 † 的情况，其行为未定义。\n如果表格显示递归行为，则互斥锁应维护锁计数的概念。当线程首次成功获取互斥锁时，锁计数应设置为 1。每次线程重新锁定此互斥锁时，锁计数应递增 1。每次线程解锁互斥锁时，锁计数应递减 1。当锁计数达到零时，该互斥锁应可供其他线程获取。\npthread_mutex_trylock() 函数应等效于 pthread_mutex_lock()，不同之处在于，如果 mutex 引用的互斥锁对象当前已锁定（由任何线程锁定，包括当前线程），则调用应立即返回。如果互斥锁类型为 PTHREAD_MUTEX_RECURSIVE 且互斥锁当前由调用线程拥有，则互斥锁计数应递增 1，并且 pthread_mutex_trylock() 函数应立即返回成功。\npthread_mutex_unlock() 函数应释放 mutex 引用的互斥锁对象。互斥锁的释放方式取决于互斥锁的类型属性。如果在调用 pthread_mutex_unlock() 时有线程阻塞在 mutex 引用的互斥锁对象上，导致该互斥锁变为可用，则调度策略应决定哪个线程应获取该互斥锁。\n（对于 PTHREAD_MUTEX_RECURSIVE 互斥锁，当计数达到零且调用线程不再拥有此互斥锁上的任何锁时，该互斥锁应变为可用。）\n如果向等待互斥锁的线程发送信号，则从信号处理程序返回后，该线程应继续等待该互斥锁，如同未被中断一样。\n如果 mutex 是稳健的互斥锁，并且包含拥有线程的进程在持有互斥锁时终止，则对 pthread_mutex_lock() 的调用应返回错误值 EOWNERDEAD。如果 mutex 是稳健的互斥锁，并且拥有线程在持有互斥锁时终止，则即使拥有线程所在的进程尚未终止，对 pthread_mutex_lock() 的调用也可能返回错误值 EOWNERDEAD。在这些情况下，互斥锁由线程锁定，但其保护的状态被标记为不一致。应用程序应确保该状态一致以供重用，并在完成后调用 pthread_mutex_consistent()。如果应用程序无法恢复状态，则应在不事先调用 pthread_mutex_consistent() 的情况下解锁互斥锁，之后该互斥锁将被标记为永久不可用。\n如果 mutex 未引用已初始化的互斥锁对象，则 pthread_mutex_lock()、pthread_mutex_trylock() 和 pthread_mutex_unlock() 的行为未定义。\n如果成功，pthread_mutex_lock()、pthread_mutex_trylock() 和 pthread_mutex_unlock() 函数应返回0；否则，将返回一个错误号以指示错误。\n示例程序：\nc#include &lt;pthread.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid *thread_function(void *arg) {\n    pthread_mutex_t *mutex = (pthread_mutex_t *)arg;\n    pthread_mutex_lock(mutex);\n    printf(\"Thread acquired lock once.\\n\");\n    pthread_mutex_lock(mutex);\n    printf(\"Thread acquired lock twice.\\n\");\n    pthread_mutex_unlock(mutex);\n    printf(\"Thread released lock once.\\n\");\n    pthread_mutex_unlock(mutex);\n    printf(\"Thread released lock twice.\\n\");\n    return NULL;\n}\n\nint main() {\n    pthread_mutexattr_t attr;\n    pthread_mutex_t mutex;\n    pthread_t thread;\n    pthread_mutexattr_init(&amp;attr);// Initialize mutex attribute\n    pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);// Set mutex type to recursive\n    pthread_mutex_init(&amp;mutex, &amp;attr);// Initialize mutex with attribute\n    pthread_create(&amp;thread, NULL, thread_function, (void *)&amp;mutex);// Create a thread\n    pthread_join(thread, NULL);// Wait for thread to finish\n    // Destroy mutex and attribute\n    pthread_mutex_destroy(&amp;mutex);\n    pthread_mutexattr_destroy(&amp;attr);\n    return 0;\n}pthread_rwlock_init函数c#include &lt;pthread.h&gt;\n\nint pthread_rwlock_destroy(pthread_rwlock_t *rwlock);\nint pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,\n    const pthread_rwlockattr_t *restrict attr);\npthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;pthread_rwlock_destroy() 函数应销毁 rwlock 引用的读写锁对象，并释放该锁使用的任何资源。在通过再次调用 pthread_rwlock_init() 重新初始化该锁之前，后续使用该锁的效果是未定义的。实现可能导致 pthread_rwlock_destroy() 将 rwlock 引用的对象设置为无效值。如果在任何线程持有 rwlock 时调用 pthread_rwlock_destroy()，则结果未定义。尝试销毁未初始化的读写锁将导致未定义行为。\npthread_rwlock_init() 函数应分配使用 rwlock 引用的读写锁所需的任何资源，并将该锁初始化为具有 attr 引用的属性的解锁状态。如果 attr 为 NULL，则应使用默认的读写锁属性；其效果与传递默认读写锁属性对象的地址相同。初始化后，该锁可以使用任意次数，而无需重新初始化。如果在指定已初始化的读写锁时调用 pthread_rwlock_init()，则结果未定义。如果在未先初始化读写锁的情况下使用它，则结果未定义。\n如果 pthread_rwlock_init() 函数失败，则 rwlock 不应初始化，并且 rwlock 的内容未定义。\n如果默认读写锁属性适用，则可以使用宏 PTHREAD_RWLOCK_INITIALIZER 来初始化读写锁。其效果应等效于通过调用 pthread_rwlock_init() 并将 attr 参数指定为 NULL 进行动态初始化，但不会执行错误检查。\n如果传递给 pthread_rwlock_init() 的 attr 参数指定的值未引用已初始化的读写锁属性对象，则行为未定义。\n如果成功，pthread_rwlock_destroy() 和 pthread_rwlock_init() 函数应返回0；否则，将返回一个错误号以指示错误。\npthread_rwlock_rdlock函数c#include &lt;pthread.h&gt;\n\nint pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);\nint pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);\nint pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);\nint pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);\nint pthread_rwlock_unlock(pthread_rwlock_t *rwlock);如果成功，函数应返回0；否则，将返回一个错误号以指示错误。\npthread_cond_init函数c#include &lt;pthread.h&gt;\n\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\n\nint pthread_cond_init(pthread_cond_t *cond,\n                      pthread_condattr_t *cond_attr);\nint pthread_cond_signal(pthread_cond_t *cond);\nint pthread_cond_broadcast(pthread_cond_t *cond);\nint pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);\nint pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,\n                      const struct timespec *abstime);\nint pthread_cond_destroy(pthread_cond_t *cond);条件（“条件变量”的缩写）是一种同步机制，允许线程挂起执行并放弃处理器，直到满足共享数据上的某个谓词为止。条件的基本操作是：发出条件信号（当谓词变为真时）和等待条件，挂起线程执行，直到另一个线程发出条件信号。\n条件变量必须始终与互斥锁相关联，以避免出现竞争条件，即一个线程准备等待条件变量，而另一个线程恰好在第一个线程实际等待之前发出条件信号。\npthread_cond_init() 使用 cond_attr 中指定的条件属性初始化条件变量 cond，如果 cond_attr 为 NULL，则使用默认属性。LinuxThreads 实现不支持条件的属性，因此实际上会忽略 cond_attr 参数。\npthread_cond_t 类型的变量也可以使用常量 PTHREAD_COND_INITIALIZER 进行静态初始化。\npthread_cond_signal() 重新启动正在等待条件变量 cond 的其中一个线程。如果没有线程在 cond 上等待，则不会发生任何事情。如果有几个线程在 cond 上等待，则只有一个线程会重新启动，但没有指定是哪个线程。\npthread_cond_broadcast() 重新启动所有正在等待条件变量 cond 的线程。如果没有线程在 cond 上等待，则不会发生任何事情。\npthread_cond_wait() 原子地解锁互斥锁（根据 pthread_unlock_mutex()）并等待条件变量 cond 被发出信号。线程执行被挂起，并且在条件变量被发出信号之前不会消耗任何 CPU 时间。在进入 pthread_cond_wait() 时，调用线程必须锁定互斥锁。在返回到调用线程之前，pthread_cond_wait() 会重新获取互斥锁（根据 pthread_lock_mutex()）。\n解锁互斥锁和在条件变量上挂起是原子地完成的。因此，如果所有线程总是在发出条件信号之前获取互斥锁，则可以保证在某个线程锁定互斥锁的时间与它等待条件变量的时间之间不会发出条件信号（从而被忽略）。\npthread_cond_timedwait() 原子地解锁互斥锁并在 cond 上等待，就像 pthread_cond_wait() 一样，但它也限制了等待的持续时间。如果在 abstime 指定的时间量内没有发出 cond 信号，则会重新获取互斥锁 mutex，并且 pthread_cond_timedwait() 返回错误 ETIMEDOUT。abstime 参数指定一个绝对时间，其起点与 time(2) 和 gettimeofday(2) 相同：abstime 为 0 对应于 1970 年 1 月 1 日 GMT 时间 00:00:00。\npthread_cond_destroy() 销毁一个条件变量，释放它可能持有的资源。在进入 pthread_cond_destroy() 时，任何线程都不得在条件变量上等待。在 LinuxThreads 实现中，没有与条件变量关联的资源，因此 pthread_cond_destroy() 实际上除了检查条件是否没有等待线程之外什么也不做。\nc#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;unistd.h&gt;\n\n#define NUM_THREADS 3\n\npthread_mutex_t mutex;\npthread_cond_t cond;\nint count = 0;\n\n// 线程函数，等待条件变量\nvoid *thread_function(void *arg) {\n  int thread_id = *(int *)arg;\n  printf(\"线程 %d 启动，即将进入临界区...\\n\", thread_id);\n\n  pthread_mutex_lock(&amp;mutex);\n  printf(\"线程 %d 进入临界区，等待条件变量的同时解除互斥锁\\n\", thread_id);\n  // 等待条件变量，同时释放互斥锁\n  pthread_cond_wait(&amp;cond, &amp;mutex);\n  \n  // 条件满足后，重新获取互斥锁\n\n  printf(\"线程 %d 被唤醒，count = %d\\n\", thread_id, count);\n  pthread_mutex_unlock(&amp;mutex);\n\n  pthread_exit(NULL);\n}\n\nint main() {\n  pthread_t threads[NUM_THREADS];\n  int thread_args[NUM_THREADS];\n\n  // 初始化互斥锁和条件变量\n  pthread_mutex_init(&amp;mutex, NULL);\n  pthread_cond_init(&amp;cond, NULL);\n\n  // 创建线程\n  for (int i = 0; i &lt; NUM_THREADS; i++) {\n    thread_args[i] = i;\n    pthread_create(&amp;threads[i], NULL, thread_function, &amp;thread_args[i]);\n  }\n\n  // 等待一段时间，确保线程已经进入等待状态\n  sleep(2);\n\n  // 修改条件并发送信号\n  pthread_mutex_lock(&amp;mutex);\n  count = 10;\n  printf(\"主线程修改条件，发送信号...\\n\");\n\n  // 选择使用 pthread_cond_signal 或 pthread_cond_broadcast\n  //pthread_cond_signal(&amp;cond); // 只唤醒一个线程\n  pthread_cond_broadcast(&amp;cond); // 唤醒所有线程\n\n  pthread_mutex_unlock(&amp;mutex);\n\n  // 等待线程结束\n  for (int i = 0; i &lt; NUM_THREADS; i++) {\n    pthread_join(threads[i], NULL);\n  }\n\n  // 销毁互斥锁和条件变量\n  pthread_mutex_destroy(&amp;mutex);\n  pthread_cond_destroy(&amp;cond);\n\n  return 0;\n}sem_init函数c#include &lt;semaphore.h&gt;\n\nint sem_init(sem_t *sem, int pshared, unsigned int value);\nint sem_destroy(sem_t *sem);sem_init() 函数用于初始化位于 sem 指向地址的未命名信号量。value 参数指定信号量的初始值。\npshared 参数指示该信号量是在进程的线程之间共享，还是在进程之间共享。\n\n如果 pshared 的值为 0，则该信号量在进程的线程之间共享，并且应该位于所有线程都可以看到的某个地址（例如，全局变量或在堆上动态分配的变量）。\n\n如果 pshared 不为零，则该信号量在进程之间共享，并且应该位于共享内存区域中（请参阅 shm_open(3)、mmap(2) 和 shmget(2)）。（由于 fork(2) 创建的子进程会继承其父进程的内存映射，因此它也可以访问该信号量。）任何可以访问该共享内存区域的进程都可以使用 sem_post(3)、sem_wait(3) 等操作该信号量。\n\n\n初始化已经初始化过的信号量将导致未定义行为。\nsem_destroy() 函数销毁由 sem 指向的未命名信号量。\n\n只有使用 sem_init(3) 初始化的信号量才能使用 sem_destroy() 销毁。\n销毁其他进程或线程当前阻塞（在 sem_wait(3) 中）的信号量会导致未定义行为。\n使用已被销毁的信号量会产生未定义的结果，直到使用 sem_init(3) 重新初始化该信号量。\n\n这两个函数成功返回0，失败返回-1，并设置 errno 以指示错误。\nsem_wait函数c#include &lt;semaphore.h&gt;\n\nint sem_wait(sem_t *sem);\nint sem_trywait(sem_t *sem);\nint sem_timedwait(sem_t *restrict sem,\n                  const struct timespec *restrict abs_timeout);sem_wait() 函数对由 sem 指向的信号量进行减1操作（加锁）。如果信号量的值大于零，则进行减1操作，函数立即返回。如果信号量的值当前为零，则调用将阻塞，直到可以执行减1操作（即信号量值大于零）或信号处理程序中断调用为止。\nsem_trywait() 函数与 sem_wait() 函数相同，区别在于如果无法立即执行减1操作，则调用将返回错误（errno 设置为 EAGAIN），而不是阻塞。\nsem_timedwait() 函数与 sem_wait() 函数相同，区别在于 abs_timeout 指定了如果无法立即执行减1操作，则调用应阻塞的最长时间。abs_timeout 参数指向一个 timespec(3) 结构体，该结构体指定了自 Epoch（1970-01-01 00:00:00 +0000 (UTC)）以来的秒数和纳秒数的绝对超时时间。\n如果在调用时超时已过期，并且无法立即锁定信号量，则 sem_timedwait() 函数失败并返回超时错误（errno 设置为 ETIMEDOUT）。\n如果可以立即执行操作，则无论 abs_timeout 的值如何，sem_timedwait() 函数都不会返回超时错误。此外，在这种情况下，不会检查 abs_timeout 的有效性。\n这些函数在成功时都返回 0；如果出错，则信号量的值保持不变，返回 -1，并设置 errno 以指示错误。\nsem_post函数c#include &lt;semaphore.h&gt;\n\nint sem_post(sem_t *sem);sem_post() 函数对由 sem 指向的信号量进行加1操作（解锁）。如果信号量的值因此变得大于零，则在 sem_wait(3) 调用中阻塞的另一个进程或线程将被唤醒并继续锁定该信号量。\nsem_post() 函数在成功时返回 0；如果出错，则信号量的值保持不变，返回 -1，并设置 errno 以指示错误。\n","slug":"Linux系统编程（信号与多线程）","date":"2024-07-05T07:09:36.000Z","categories_index":"Linux","tags_index":"Linux,C++","author_index":"Ac-Accelerator"},{"id":"68c10486ec2cc89517f4c1626fec120f","title":"Linux系统编程（进程）","content":"PCB进程控制块cstruct task_struct {\n  unsigned int __state; /* 进程状态：运行、等待、停止等 */\n  pid_t pid;            /* 进程标识符 */\n  pid_t tgid;           /* 父进程的标识符 */\n  int prio;             /* 进程的动态优先级 */\n  int static_prio;      /* 静态优先级 */\n  int normal_prio;      /*正常优先级*/\n  unsigned int policy; /* 进程的策略：如SCHED_FIFO, SCHED_RR, SCHED_NORMAL等 */\n  struct mm_struct *mm;             /* 进程的地址空间描述符 */\n  void *stack;                      /* 内核态堆栈的指针 */\n  u64 start_time;                   /* Monotonic time in nsecs: */\n  u64 utime;                        /* 进程的累计用户态时间 */\n  u64 stime;                        /* 进程的累计内核态时间 */\n  struct signal_struct *signal;     /* Signal handlers: */\n  struct task_struct __rcu *parent; /* Recipient of SIGCHLD, wait4() reports: */\n  struct list_head sibling;         /* 兄弟进程链表指针 */\n  struct list_head children;        /* 子进程链表 */\n  struct files_struct *files;       /* Open file information: */\n  struct fs_struct *fs;             /* Filesystem information: include umask*/\n  sigset_t blocked;                 /* 信号屏蔽位图 */\n  struct task_struct *group_leader; /* 进程所在线程组的领导进程指针 */\n  int nr_cpus_allowed;              /* CPU亲和性 */\n  struct sched_entity se;           /* 调度实体 */\n  struct sched_rt_entity rt;        /* 实时调度实体 */\n  struct prev_cputime prev_cputime; /* snapshot of system and user cputime */\n  const struct sched_class *sched_class; /* 进程的调度类 */\n  struct nsproxy *nsproxy;               /* Namespaces: */\n  struct thread_struct thread;      /* CPU-specific state of this task: 进程切换后寄存器值保存在这里*/\n\n#ifdef CONFIG_CGROUPS\n  struct css_set __rcu\n      *cgroups; /* Control Group info protected by css_set_lock: */\n  struct list_head\n      cg_list; /* cg_list protected by css_set_lock and tsk-&gt;alloc_lock: */\n#endif\n};fork函数c#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\n\npid_t fork(void);fork() 函数通过复制调用进程创建一个新进程。新进程被称为子进程，调用进程被称为父进程。 fork()函数是用于创建新进程的标准方式\n子进程和父进程在独立的内存空间中运行。在 fork() 调用时，两个内存空间拥有相同的内容。一个进程执行的内存写入、文件映射 (mmap(2)) 和解除映射 (munmap(2)) 操作不会影响另一个进程。\n子进程是父进程的精确副本，但以下几点除外：\n\n子进程拥有其唯一的进程 ID (PID)，该 PID 与任何现有进程组（setpgid(2)）或会话的 ID 不匹配。\n子进程的父进程 ID (PPID)与父进程的进程 ID 相同。\n子进程不继承其父进程的内存锁(mlock(2), mlockall(2))。\n子进程的进程资源利用率(getrusage(2)) 和 CPU 时间计数器(times(2)) 被重置为零。\n子进程的待处理信号集最初为空 (sigpending(2))。\n子进程不继承其父进程的信号量调整(semop(2))。\n子进程不继承其父进程的进程关联记录锁(fcntl(2))。（另一方面，它继承了父进程的 fcntl(2) \n开文件描述符锁和 flock(2) 锁。）\n子进程不继承其父进程的定时器(setitimer(2), alarm(2), timer_create(2))。\n子进程不继承其父进程的未完成异步 I/O 操作(aio_read(3), aio_write(3))，也不继承其父进程的任何异步 I/O 上下文(参见 io_setup(2))。\n\n成功调用时，父进程返回子进程的 PID，子进程返回 0。失败时，父进程返回 -1，不创建子进程，并设置相应的 errno。\n\n\n\n\n\n\n提示\n当 fork 被调用时，操作系统会创建一个子进程，并为子进程分配一个与父进程相同的地址空间。但是，实际的物理内存不会立即被复制。父进程和子进程共享相同的物理内存页面。只有在父进程或子进程尝试修改某个页面时，操作系统才会将该页面复制一份，并分别分配给两个进程。这种技术被称为“写时复制”。\n由于 fork 调用之后，子进程是父进程的精确拷贝，意味着下次执行的位置也是一样的，因此会各自从 fork 之后的代码开始执行，所以子进程不会执行 fork 之前的代码。\n\n\ngetpid函数c#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\n\npid_t getpid(void);\npid_t getppid(void);getpid() 返回调用进程的进程 ID (PID)。（这通常由生成唯一临时文件名的例程使用。）\ngetppid() 返回调用进程的父进程的进程 ID。这将是使用 fork() 创建此进程的进程的 ID，或者，如果该进程已经终止，则将是此进程已被重新设置父进程的进程的 ID（可以是 init(1) 或者通过 prctl(2) PR_SET_CHILD_SUBREAPER 操作定义的 “subreaper” 进程）（我这里是systemd）。\n这两个函数绝对不会运行失败。\nexec函数族c#include &lt;unistd.h&gt;\n\nextern char **environ;\n\nint execl(const char *pathname, const char *arg, ...\n                /* (char  *) NULL */);\nint execlp(const char *file, const char *arg, ...\n                /* (char  *) NULL */);\nint execle(const char *pathname, const char *arg, ...\n                /*, (char *) NULL, char *const envp[] */);\nint execv(const char *pathname, char *const argv[]);\nint execvp(const char *file, char *const argv[]);\nint execvpe(const char *file, char *const argv[],\n                char *const envp[]);exec() 函数族用新的进程映像替换当前进程映像。本手册页中描述的函数位于 execve(2) 之上。\n这些函数的第一个参数是要执行的文件的名称。\n这些函数可以根据 “exec” 前缀后面的字母进行分组：\n\nl - execl()，execlp()，execle()\nconst char *arg 和后面的省略号可以认为是 arg0, arg1, …, argn。它们共同描述了一个或多个指向以空值终止的字符串的指针列表，这些字符串表示可执行程序可用的参数列表。按照惯例，第一个参数应该指向与被执行文件关联的文件名。参数列表必须由一个空指针终止，并且由于这些是可变参数函数，因此必须将此指针强制转换为 (char *) NULL。\n与 ‘l’ 函数相比，’v’ 函数（如下）将被执行程序的命令行参数指定为一个向量。\n\n\nv - execv()，execvp()，execvpe()\nchar *const argv[] 参数是一个指向以空值终止的字符串的指针数组，这些字符串表示新程序可用的参数列表。按照惯例，第一个参数应该指向与被执行文件关联的文件名。指针数组必须由一个空指针终止。\n\n\ne - execle()，execvpe()\n调用者的环境通过参数 envp 指定。envp 参数是一个指向以空值终止的字符串的指针数组，并且必须由一个空指针终止。\n所有其他 exec() 函数（后缀中不包含 ‘e’）从调用进程中的外部变量 environ 获取新进程映像的环境。\n\n\np - execlp()，execvp()，execvpe()\n如果指定的文件名不包含斜杠 (/) 字符，则这些函数会像 shell 一样搜索可执行文件。将在 PATH 环境变量中指定的以冒号分隔的目录路径名列表中搜索该文件。如果未定义此变量，则路径列表默认为包含  confstr(_CS_PATH)  返回的目录（通常返回  “/bin:/usr/bin”）以及可能的当前工作目录的列表；有关更多详细信息，请参见“注意”。\n如果指定的文件名包含斜杠字符，则将忽略 PATH，并执行指定路径名处的文件。\n此外，某些错误会被特殊处理。\n如果某个文件的权限被拒绝（尝试的  execve(2)  因错误  EACCES  而失败），则这些函数将继续搜索搜索路径的其余部分。但是，如果没有找到其他文件，它们将返回并将  errno  设置为  EACCES。\n如果无法识别文件的标头（尝试的  execve(2)  因错误  ENOEXEC  而失败），则这些函数将执行 shell (/bin/sh)，并将文件的路径作为其第一个参数。（如果此尝试失败，则不会进行进一步搜索。）\n所有其他  exec()  函数（后缀中不包含  ‘p’）将其第一个参数作为标识要执行程序的（相对或绝对）路径名。\n\n\n\n在 execve() 期间，所有进程属性都将保留，但以下各项除外：\n\n任何被捕获信号的处置都将重置为默认值 (signal(7))。\n任何备用信号堆栈都不会保留 (sigaltstack(2))。\n内存映射不会保留 (mmap(2))。\n附加的 System V 共享内存段将被分离 (shmat(2))。\nPOSIX 共享内存区域将被取消映射 (shm_open(3))。\n打开的 POSIX 消息队列描述符将被关闭 (mq_overview(7))。\n任何打开的 POSIX 命名信号量都将被关闭 (sem_overview(7))。\nPOSIX 定时器不会保留 (timer_create(2))。\n任何打开的目录流都将被关闭 (opendir(3))。\n内存锁不会保留 (mlock(2), mlockall(2))。\n退出处理程序不会保留 (atexit(3), on_exit(3))。\n浮点环境将重置为默认值（请参阅 fenv(3)）。\n\n仅当发生错误时，exec() 函数才会返回（如果没有发生错误exec函数后的代码将不会被执行）。 返回值为 -1，并设置  errno  以指示错误。 所以通常我们直接在exec函数调用后直接调用perror()，和exit()，无需if判断。\n孤儿进程和僵尸进程在 Linux 中，当一个父进程退出而它的一个或多个子进程仍在运行时，这些子进程就会变成孤儿进程。Linux 系统会通过 init 进程 (进程 ID 为 1) 来处理孤儿进程，具体步骤如下:\n\n检测: 当一个进程退出时，内核会检查它是否有子进程。\n标识: 如果发现有子进程，并且这些子进程的父进程 ID 仍然是原先的父进程 ID（而不是 init 进程的 ID），那么这些子进程就会被标记为孤儿进程。\n过继:  init 进程会定期检查系统中是否存在孤儿进程，并将所有检测到的孤儿进程“过继”为自己的子进程。这意味着这些孤儿进程的父进程 ID 会被更改为 1 (init 进程的 ID)。\n资源回收:  init 进程会监控它所有子进程（包括过继来的孤儿进程）的状态。当一个子进程结束后，init 进程会负责回收该子进程占用的系统资源，例如内存、文件描述符等。\n\n为什么要这样做？\n\n防止资源泄漏: 如果没有 init 进程的接管，孤儿进程会一直存在于系统中，即使它们已经完成了任务。这会导致系统资源（例如内存、文件描述符）无法被释放，最终可能导致系统崩溃。\n提供正常终止环境:  init 进程会等待孤儿进程结束后再进行资源回收，这使得孤儿进程有机会完成清理工作并正常退出，而不是被强制终止。\n\n如果一个死循环程序成为了孤儿进程，请使用 kill -9 PID 来杀死它。\n僵尸进程\n僵尸进程是指一个子进程已经终止，但是其退出状态信息还没有被其父进程读取。由于父进程还没有处理这个子进程的终止状态，子进程的进程控制块（PCB）依然存在，因而被称为“僵尸”。\n处理僵尸进程的方法\n\n等待父进程: 最理想的情况是父进程使用 wait() 或 waitpid() 系统调用来等待子进程结束并读取其退出状态。这将清理僵尸进程。\n\n发送 SIGCHLD 信号:  如果父进程没有等待子进程，可以向父进程发送 SIGCHLD 信号。这会提醒父进程去处理子进程的退出状态。\n\n终止父进程: 如果父进程没有响应 SIGCHLD 信号，使子进程成为孤儿进程，然后由 init 进程接管。init 进程会负责清理僵尸进程。\n\n\n\n\n\n\n\n\n提示\n为什么父进程要读取子的退出状态后，子进程才消失？\n进程控制块（PCB）的保留：当子进程终止时，内核需要保留其进程控制块（PCB）以便父进程能够读取子进程的退出状态。如果立即删除子进程的PCB，父进程将无法获得子进程的退出信息。\n进程同步：父进程可能需要知道子进程是如何终止的（正常退出或被信号终止），以及它的退出码。通过保留子进程的PCB，父进程可以在适当的时间通过wait或waitpid获取这些信息，从而实现进程间的同步和资源管理。\n\n\nwait函数c#include &lt;sys/types.h&gt;\n#include &lt;sys/wait.h&gt;\n\npid_t wait(int *wstatus);\npid_t waitpid(pid_t pid, int *wstatus, int options);所有这些系统调用都用于等待调用进程的子进程状态发生变化，并获取状态发生变化的子进程的信息。状态变化被认为是：子进程终止；子进程被信号停止；或者子进程被信号恢复。对于终止的子进程，执行等待操作允许系统释放与子进程相关的资源；如果没有执行等待，则终止的子进程将保持“僵尸”状态（请参阅下面的注释）。\n如果子进程已经改变状态，则这些调用将立即返回。否则，它们将阻塞，直到某个子进程状态发生变化或信号处理程序中断调用（假设没有使用 sigaction(2) 的 SA_RESTART 标志自动重启系统调用）。在本页的其余部分，状态已更改但尚未被这些系统调用之一等待的子进程被称为可等待 的。\nwait() 系统调用会暂停调用线程的执行，直到它的一个子进程终止。调用 wait(&amp;wstatus) 等效于：\ncwaitpid(-1, &amp;wstatus, 0);waitpid() 系统调用会暂停调用线程的执行，直到由 pid 参数指定的子进程状态发生变化。默认情况下，waitpid() 只等待终止的子进程，但是可以通过 options 参数修改此行为，如下所述：\npid 的值可以是：\n\n&lt; -1:  表示等待进程组 ID 等于 pid 绝对值的任何子进程。\n-1:   表示等待任何子进程。\n0:    表示等待进程组 ID 等于调用 waitpid() 时调用进程的进程组 ID 的任何子进程。\n&gt; 0:  表示等待进程 ID 等于 pid 值的子进程。\n\nwait(): 成功时，返回终止子进程的进程 ID；出错时，返回 -1。设置错误码 errno。\nwaitpid(): 成功时，返回状态发生变化的子进程的进程 ID；如果指定了 options=WNOHANG 并且存在由 pid 指定的一个或多个子进程，但其状态尚未更改，则返回 0。出错时，返回 -1。设置错误码 errno。\n没有相符合的子进程的时候，错误码为 ECHILD。\n\n\n\n\n\n\n提示\n一次wait()或waitpid()只能等待一个子进程，如果有多个子进程需要等待，可以使用循环调用。\n\n\n这是一个使用wait函数的例子：\nc#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/wait.h&gt;\n\nint main() {\n    pid_t pid = fork();  // 创建一个子进程\n    if (pid &lt; 0) {\n        // fork失败\n        perror(\"fork failed\");\n        exit(1);\n    } else if (pid == 0) {\n        // 这是子进程\n        printf(\"Child process (PID: %d) is running\\n\", getpid());\n        sleep(2);  // 子进程睡眠2秒\n        printf(\"Child process (PID: %d) is exiting\\n\", getpid());\n        exit(0);  // 子进程正常退出\n    } else {\n        // 这是父进程\n        printf(\"Parent process (PID: %d) is waiting for child to exit\\n\", getpid());\n        int status;\n        pid_t child_pid = wait(&amp;status);  // 等待子进程退出\n        if (child_pid &gt; 0) {\n            if (WIFEXITED(status)) {\n                // 子进程正常退出\n                printf(\"Child process (PID: %d) exited with status %d\\n\", child_pid, WEXITSTATUS(status));\n            } else {\n                // 子进程异常退出\n                printf(\"Child process (PID: %d) did not exit normally\\n\", child_pid);\n            }\n        } else {\n            // wait失败\n            perror(\"wait failed\");\n            exit(1);\n        }\n    }\n    return 0;\n}管道c#include &lt;unistd.h&gt;\n\nint pipe(int pipefd[2]);\n\n#include &lt;fcntl.h&gt;              /* Obtain O_* constant definitions */\n#include &lt;unistd.h&gt;\n\nint pipe2(int pipefd[2], int flags);pipe() 函数创建一个管道，它是一个可以用于进程间通信的单向数据通道。数组 pipefd 用于返回两个文件描述符，分别指向管道的两端。pipefd[0] 指向管道的读取端。 pipefd[1] 指向管道的写入端。写入管道写入端的数据会被内核缓冲，直到从管道的读取端读取为止。更多详细信息，请参阅 pipe(7)。\n成功时返回 0。出错时返回 -1，并设置相应的 errno，且 pipefd 保持不变。\n如果 flags 为 0，则 pipe2() 的行为与 pipe() 相同。以下值可以使用按位或运算符 (ORed) 在 flags 中组合，以获得不同的行为：\npipe2 函数的 flags 参数可以用于设置不同的标志，以改变管道的行为。以下是可能的取值及其对应的功能：\n\n\n\nFlag\nDescription\n\n\n\nO_CLOEXEC\n在执行 exec 系列函数时关闭文件描述符。\n\n\nO_NONBLOCK\n设置管道为非阻塞模式。读取或写入操作不会阻塞进程。使用此标志可以省去额外的 fcntl(2) 调用以达到相同的结果。\n\n\nO_DIRECT\n尝试最小化内核缓存效果，使I/O直接从用户空间缓冲区和硬件之间传输，通常用于提升性能。（有注意事项，请参考手册！）\n\n\n下面是一个使用pipe的例子，请看注释：\nc#include &lt;stdio.h&gt;\n#include &lt;sys/wait.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    int pipe_fd[2];// 用于保存管道文件描述符\n    pid_t pid;\n    const char *msg = \"Hello from parent to child!\";\n    char buffer[128];\n    // 创建管道\n    if (pipe(pipe_fd) == -1) {//在这个地方，会将管道的读写文件描述符保存到pipe_fd数组中\n        perror(\"pipe\");\n        exit(EXIT_FAILURE);\n    }\n    // 创建子进程\n    pid = fork();\n    if (pid == -1) {\n        perror(\"fork\");\n        exit(EXIT_FAILURE);\n    }\n    if (pid == 0) { // 子进程\n        close(pipe_fd[1]); // 关闭写端\n        read(pipe_fd[0], buffer, sizeof(buffer)); // 从管道读取数据\n        printf(\"Child process received: %s\\n\", buffer);\n        close(pipe_fd[0]); // 关闭读端\n    } else { // 父进程\n        close(pipe_fd[0]); // 关闭读端\n        write(pipe_fd[1], msg, strlen(msg) + 1); // 向管道写入数据\n        close(pipe_fd[1]); // 关闭写端\n        wait(NULL); // 等待子进程结束\n    }\n\n    return 0;\n}\n\n\n\n\n\n提示\n当管道的写端关闭，且管道中的所有数据都被读取完毕时，读取管道那方的 read 函数会返回 0。这是一个指示“数据流结束”的标志。\n\n\n管道实现ls -l | wc -l父进程写，子进程读\nc#include &lt;dirent.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;sys/wait.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char **argv) {\n  int pipe_fd[2];\n  if (pipe(pipe_fd)) {\n    perror(\"open pipe faild\");\n    exit(-1);\n  }\n  pid_t pid = fork();\n  if (!pid) { // 子进程\n    close(pipe_fd[1]);\n    dup2(pipe_fd[0],STDIN_FILENO);\n    char * args[]={\"wc\",\"-l\",NULL};\n    execvp(\"wc\",args);\n  } else { // 父进程\n    close(pipe_fd[0]);\n    dup2(pipe_fd[1],STDOUT_FILENO);\n    execlp(\"ls\",\"ls\",\"-l\",argv[1],NULL);\n  }\n}两个子进程通信，父进程等待两个子进程结束并回收资源。\nc#include &lt;dirent.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;sys/wait.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char **argv) {\n  int pipe_fd[2];\n  if (pipe(pipe_fd)) {\n    perror(\"open pipe faild\");\n    exit(-1);\n  }\n  pid_t pid = fork();\n  if (!pid) { // 子进程1\n    close(pipe_fd[1]);\n    dup2(pipe_fd[0], STDIN_FILENO);\n    char *args[] = {\"wc\", \"-l\", NULL};\n    execvp(\"wc\", args);\n  }\n  // 父进程\n  pid = fork();\n  if (!pid) { // 子进程2\n    close(pipe_fd[0]);\n    dup2(pipe_fd[1], STDOUT_FILENO);\n    execlp(\"ls\", \"ls\", \"-l\", argv[1], NULL);\n  }\n  close(pipe_fd[0]);\n  close(pipe_fd[1]);\n  wait(NULL);\n  wait(NULL);\n}多个写者，一个读者c#include &lt;dirent.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;sys/wait.h&gt;\n#include &lt;unistd.h&gt;\nint main(void) {\n  pid_t pid;\n  int fd[2], i, n;\n  char buf[1024];\n  int ret = pipe(fd);\n  if (ret == -1) {\n    perror(\"pipe error\");\n    exit(1);\n  }\n\n  for (i = 0; i &lt; 2; i++) {\n    if ((pid = fork()) == 0)\n      break;\n    else if (pid == -1) {\n      perror(\"fork error\");\n      exit(1);\n    }\n  }\n\n  if (i == 0) {\n    close(fd[0]);\n    write(fd[1], \"1.hello\\n\", strlen(\"1.hello\\n\"));\n  } else if (i == 1) {\n    close(fd[0]);\n    write(fd[1], \"2.world\\n\", strlen(\"2.world\\n\"));\n  } else {\n    close(fd[1]); // 父进程关闭写端,留读端读取数据\n    // sleep(1);\n    while ((n = read(fd[0], buf, 1024))) { // 从管道中读数据\n      write(STDOUT_FILENO, buf, n);\n    }\n    for (i = 0; i &lt; 2; i++) // 两个儿子wait两次\n      wait(NULL);\n  }\n  return 0;\n}mkfifo函数虽然管道相比信号，套接字实现进程通信，简单很多，但是只能单向通信，双向通信需建立两个管道，且只能用于有血缘关系的进程间通信。于是引入了命名管道（FIFO）。\nc#include &lt;sys/types.h&gt;\n#include &lt;sys/stat.h&gt;\n\nint mkfifo(const char *pathname, mode_t mode);mkfifo() 创建一个名为 pathname 的 FIFO 特殊文件。mode 参数指定 FIFO 的权限。它会像通常一样被进程的 umask 修改：创建的文件的权限为 (mode &amp; ~umask)。\nFIFO 特殊文件类似于管道，只是创建方式不同。FIFO 特殊文件不是匿名的通信通道，而是通过调用 mkfifo() 函数将其输入到文件系统中。\n通过这种方式创建 FIFO 特殊文件后，任何进程都可以像打开普通文件一样打开它进行读取或写入。但是，在继续对其执行任何输入或输出操作之前，必须同时打开它的两端。打开 FIFO 进行读取通常会阻塞，直到其他进程打开同一个 FIFO 进行写入，反之亦然。有关 FIFO 特殊文件的非阻塞处理，请参阅 fifo(7)。\nmkfifo() 和 mkfifoat() 成功时返回 0。如果发生错误，则返回 -1 （此时会相应地设置 errno）。\nfifo进行进程间通信这是通信的写入端：\nc#include &lt;errno.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n  const char *fifoPath = \"./fifofile\";\n  int fd;\n  char *message = \"Hello from producer!\\n\";\nopen:\n  // 打开FIFO文件以写入\n  fd = open(fifoPath, O_WRONLY);\n  if (fd == -1) {\n    if (errno == ENOENT) {\n      if (mkfifo(fifoPath, 0644)) {\n        perror(\"mkfifo error\");\n        exit(-1);\n      }\n      printf(\"mkfifo success\");\n      goto open;\n    }\n    perror(\"open\");\n    exit(EXIT_FAILURE);\n  }\n\n  // 向FIFO写入数据\n  write(fd, message, strlen(message));\n  close(fd);\n\n  return 0;\n}这是通信的读取端：\nc#include &lt;fcntl.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n  const char *fifoPath = \"./fifofile\";\n  int fd;\n  char buffer[128];\nopen:\n  // 打开FIFO文件以读取\n  fd = open(fifoPath, O_RDONLY);\n  if (fd == -1) {\n    if (errno == ENOENT) {\n      if (mkfifo(fifoPath, 0644)) {\n        perror(\"mkfifo error\");\n        exit(-1);\n      }\n      goto open;\n    }\n    perror(\"open\");\n    exit(EXIT_FAILURE);\n  }\n  // 从FIFO读取数据\n  read(fd, buffer, sizeof(buffer));\n  printf(\"Received: %s\", buffer);\n  close(fd);\n\n  return 0;\n}文件用于进程间通信\n有血缘关系的进程（父子进程）：\n\n如果父进程在创建子进程之前已经打开了一个文件，并且在创建子进程时使用 fork() 系统调用，那么父进程和子进程将共享相同的文件描述符。也就是说，对于同一个文件，它们使用的是同一个文件描述符。\n父子进程共享文件描述符表的内容，但每个进程都有自己的文件描述符表，表中的条目指向相同的文件表项。因此，对文件的读写操作是同步的，反映在相同的文件偏移量上。\n\n\n没有血缘关系的进程：\n\n如果两个没有血缘关系的进程分别打开同一个文件，它们会获得不同的文件描述符。这些文件描述符在各自的文件描述符表中指向不同的文件表项，即使它们指向的是同一个文件系统中的文件。\n因此，这些进程对同一个文件的操作是独立的，文件偏移量和文件状态在各自的进程中是独立维护的。\n\n\n\nmmap函数c#include &lt;sys/mman.h&gt;\n\nvoid *mmap(void *addr, size_t length, int prot, int flags,\n          int fd, off_t offset);mmap() 系统调用在调用进程的虚拟地址空间中创建一个新的映射。新映射的起始地址由 addr 参数指定。length 参数指定映射的长度（必须大于 0）。\n如果 addr 为 NULL，则内核选择（页面对齐的）地址来创建映射；这是创建新映射最可移植的方法。如果 addr 不为 NULL，则内核将其作为放置映射位置的提示；在 Linux 上，内核将选择附近的页面边界（但始终高于或等于 /proc/sys/vm/mmap_min_addr 指定的值），并尝试在那里创建映射。如果该位置已存在其他映射，则内核会选择一个可能取决于或不取决于提示的新地址。新映射的地址作为调用结果返回。\n文件映射的内容（与匿名映射相反；参见下面的 MAP_ANONYMOUS）使用从文件描述符 fd 引用的文件（或其他对象）中偏移量为 offset 的 length 字节进行初始化。这个offset 必须是页面大小（由 sysconf(_SC_PAGE_SIZE) 返回）的倍数。\n在 mmap() 调用返回后，可以立即关闭文件描述符 fd，而不会使映射失效。\nprot 参数描述了映射所需的内存保护（并且不得与文件的打开模式冲突）。它可以是 PROT_NONE，也可以是一个或多个以下标志的按位或：\n\n\n\n宏\n描述\n\n\n\nPROT_EXEC\n页面可以被执行。\n\n\nPROT_READ\n页面可以被读取。\n\n\nPROT_WRITE\n页面可以被写入。\n\n\nPROT_NONE\n页面不可访问。\n\n\nflags 参数决定了对映射的更新是否对映射同一区域的其他进程可见，以及更新是否会传递到底层文件。  通过在 flags 中包含以下值中的恰好一个来确定此行为：\n\n\n\n宏\n描述\n\n\n\nMAP_SHARED\n共享此映射。对映射的更新对映射同一区域的其他进程可见，并且（在文件支持的映射的情况下）会传递到底层文件。（要精确控制何时将更新传递到底层文件，需要使用 msync(2)。）\n\n\nMAP_SHARED_VALIDATE （自 Linux 4.15 起）\n此标志提供与 MAP_SHARED 相同的行为，区别在于 MAP_SHARED 映射会忽略 flags 中的未知标志。相反，当使用 MAP_SHARED_VALIDATE 创建映射时，内核会验证传递的所有标志是否已知，并且如果存在未知标志，则映射将失败并返回错误 EOPNOTSUPP。此映射类型还需要能够使用某些映射标志（例如，MAP_SYNC）。\n\n\nMAP_PRIVATE\n创建一个私有的写时复制映射。对映射的更新对映射同一文件的其他进程不可见，并且不会传递到底层文件。未指定在 mmap() 调用之后对文件所做的更改是否在映射\n\n\n成功时，mmap() 返回指向映射区域的指针。出错时，返回 MAP_FAILED  (即 (void *) -1)，并将 errno 设置为指示错误的原因。\n以下是 mmap 系统调用常见的错误码及其原因：\n\n\n\n错误码\n描述\n\n\n\nEACCES\n文件描述符引用了非普通文件。  或者请求了文件映射，但 fd 未打开以供读取。  或者请求了 MAP_SHARED 并且设置了 PROT_WRITE，但 fd 未以读/写 (O_RDWR) 模式打开。  或者设置了 PROT_WRITE，但文件是只允许追加的。\n\n\nEAGAIN\n文件已锁定，或者已锁定太多内存（请参阅 setrlimit(2)）。\n\n\nEBADF\nfd 不是有效的文件描述符（并且未设置 MAP_ANONYMOUS）。\n\n\nEEXIST\n在 flags 中指定了 MAP_FIXED_NOREPLACE，并且 addr 和 length 覆盖的范围与现有映射冲突。\n\n\nEINVAL\n我们不喜欢 addr、length 或 offset（例如，它们太大，或者未在页面边界上对齐）。  （自 Linux 2.6.12 起）length 为 0。  flags 不包含 MAP_PRIVATE、MAP_SHARED 或 MAP_SHARED_VALIDATE 中的任何一个。\n\n\nENFILE\n已达到系统范围内打开文件总数的限制。\n\n\nENODEV\n指定文件的底层文件系统不支持内存映射。\n\n\nENOMEM\n没有可用的内存。  进程的最大映射数将被超过。当在现有映射的中间解除映射区域时，munmap() 也可能发生此错误，因为这会导致在要解除映射的区域的两侧产生两个较小的映射。   （自 Linux 4.7 起）进程的 RLIMIT_DATA 限制（在 getrlimit(2) 中描述）将被超过。  我们不喜欢 addr，因为它超出了 CPU 的虚拟地址空间。\n\n\nEOVERFLOW\n在 32 位架构上以及大文件扩展（即，使用 64 位 off_t）：用于 length 的页数加上用于 offset 的页数将溢出 unsigned long（32 位）。\n\n\nEPERM\nprot 参数请求 PROT_EXEC，但映射的区域属于已挂载为 no-exec 的文件系统上的文件。   操作被文件密封阻止；请参阅 fcntl(2)。   指定了 MAP_HUGETLB 标志，但调用者没有权限（没有 CAP_IPC_LOCK 功能）并且不是 sysctl_hugetlb_shm_group 组的成员；请参阅 proc_sys(5) 中对 /proc/sys/vm/sysctl_hugetlb_shm_group 的描述。\n\n\nETXTBSY\n设置了 MAP_DENYWRITE，但 fd 指定的对象已打开以供写入。\n\n\n\n\n\n\n\n\n\n注意\n\n创建映射区的过程中，隐含着一次对映射文件的【读操作】\n当MAP_SHARED时，要求：映射区的权限应该&lt;=文件打开的权限（出于对映射区的保护）。而MAP_PRIVATE则无所谓，因为mmap中的权限是对内存的限制\n映射区的释放与文件关闭无关。只要映射建立成功，文件可以立即关闭\n特别注意，当映射文件大小为0时，不能创建映射区。所以：用于映射的文件必须要有实际大小！！mmap使用时常常会出现总线错误，通常是由于共享文件存储空间大小引起的。如，400字节大小的文件，在简历映射区时，offset4096字节，则会报出总线错误\nmunmap传入的地址一定是mmap返回的地址。\n文件偏移量必须为4K的整数倍\nmmap创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。\n\n\n\nmunmap函数c#include &lt;sys/mman.h&gt;\n\nint munmap(void addr[.length], size_t length);munmap() 系统调用删除指定地址范围的映射，并导致对该范围内地址的进一步引用生成无效的内存引用。当进程终止时，该区域也会自动解除映射。另一方面，关闭文件描述符并不会解除映射区域。\n地址 addr 必须是页面大小的倍数（但长度不必是）。包含指定范围内一部分的所有页面都将解除映射，并且随后对这些页面的引用将生成 SIGSEGV 信号。如果指定的范围不包含任何映射的页面，则不会出错。\n成功时，munmap() 返回 0。失败时，返回 -1，并将 errno 设置为指示错误的原因（通常为 EINVAL）。\n\n\n\n\n\n\n提示\n在MAP_SHARED映射的情况下，munmap()调用会将修改写回文件系统。munmap()会自动触发文件的更新，将映射的内存区域中的所有更改写回到文件中。\n\n\n","slug":"Linux系统编程（进程）","date":"2024-07-04T01:36:23.000Z","categories_index":"Linux","tags_index":"Linux,C++","author_index":"Ac-Accelerator"},{"id":"e27fddc9922de42aba7a0e5c52964723","title":"Linux系统编程（文件操作）","content":"getopt函数c#include &lt;unistd.h&gt;\n\nint getopt(int argc, char * const argv[],\n          const char *optstring);\n\nextern char *optarg;\nextern int optind, opterr, optopt;getopt() 函数用于解析命令行参数。它的参数 argc 和 argv 分别是在程序调用时传递给 main() 函数的参数计数和参数数组。\nargv 中以 ‘-‘ 开头的元素（且不完全是 “-“ 或 “–”）是选项元素。除了初始的 ‘-‘ 之外，该元素的字符是选项字符。如果重复调用 getopt()，它会从每个选项元素中依次返回每个选项字符。\n变量 optind 是 argv 中要处理的下一个元素的索引。系统将此值初始化为 1。调用方可以将其重置为 1 以重新开始扫描相同的 argv，或者在扫描新的参数向量时重置。\n如果 getopt() 找到了另一个选项字符，它会返回该字符，并更新外部变量 optind 和静态变量 nextchar，以便下一次调用 getopt() 可以从下一个选项字符或 argv 元素继续扫描。如果没有更多的选项字符，getopt() 将返回 -1。此时，optind 是 argv 中第一个非选项元素的索引。\noptstring 是一个包含合法选项字符的字符串。如果这样的字符后面跟着一个冒号，则该选项需要一个参数，因此 getopt() 会将一个指向同一 argv 元素中后续文本的指针，或指向下一个 argv 元素中文本的指针，放在 optarg 中。两个冒号表示选项接受一个可选参数；如果当前 argv 元素中有文本（例如，在与选项名称相同的单词中，例如 “-oarg”），则将其返回到 optarg 中，否则将 optarg 设置为零。这是 GNU 扩展。如果 optstring 包含一个后跟分号的 W，则将 -W foo 视为长选项 –foo。（POSIX.2 保留 -W 选项用于实现扩展。）此行为是 GNU 扩展，在 glibc 2 之前的库中不可用。\n默认情况下，getopt() 在扫描时会对 argv 的内容进行排列，以便最终所有非选项都位于末尾。还实现了另外两种扫描模式。如果 optstring 的第一个字符是 ‘+’ 或设置了环境变量 POSIXLY_CORRECT，则选项处理会在遇到非选项参数时立即停止。如果 optstring 的第一个字符是 ‘-‘，则每个非选项 argv 元素都将被视为字符代码为 1 的选项的参数。（这被那些被编写为期望选项和其他 argv 元素以任何顺序排列，并且关心两者顺序的程序所使用。）特殊参数 “–” 强制结束选项扫描，而不管扫描模式如何。\n在处理选项列表时，getopt() 可以检测到两种错误：（1）optstring 中未指定的选项字符，以及（2）缺少选项参数（即，命令行末尾的选项没有预期的参数）。此类错误将按如下方式处理和报告：\n\n默认情况下，getopt() 会在标准错误输出上打印错误消息，将错误的选项字符放入 optopt 中，并返回 ‘?’ 作为函数结果。\n如果调用方已将全局变量 opterr 设置为零，则 getopt() 不会打印错误消息。调用方可以通过测试函数返回值是否为 ‘?’ 来确定是否发生了错误。（默认情况下，opterr 的值为非零值。）\n如果 optstring 的第一个字符（在上述任何可选的 ‘+’ 或 ‘-‘ 之后）是冒号（’:’），则 getopt() 同样不会打印错误消息。此外，它会返回 ‘:’ 而不是 ‘?’ 来指示缺少选项参数。这允许调用方区分这两种不同类型的错误。\n\nc#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char *argv[]) {\n  int opt;\n  char *optstring = \"bc::a:\";\n\n  while ((opt = getopt(argc, argv, optstring)) != -1) {\n    switch (opt) {\n    case 'a'://-a[arg]\n      printf(\"Option -a with argument: %s\\n\", optarg);\n      break;\n    case 'b'://-b\n      printf(\"Option -b\\n\");\n      break;\n    case 'c'://-c[arg]\n      printf(\"Option -c with argument: %s\\n\", optarg ? optarg : \"none\");\n      break;\n    case '?'://-s -a\n      printf(\"Unknown option: -%c\\n\", optopt);\n      break;\n    case ':'://*optstring = \":bc::a:\" -a\n      printf(\"Option -%c requires an argument\\n\", optopt);\n      break;\n    default:\n      printf(\"Unknown error\\n\");\n      break;\n    }\n  }\n\n  return 0;\n}\nopen函数c#include &lt;sys/types.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;fcntl.h&gt;\n\nint open(const char *pathname, int flags);\nint open(const char *pathname, int flags, mode_t mode);open() 系统调用打开由 pathname 指定的文件。如果指定的文件不存在，则可以选择由 open() 创建（如果在 flags 中指定了 O_CREAT）。\nopen() 的返回值是一个文件描述符，它是一个小的非负整数，用于后续的系统调用（read(2)、write(2)、lseek(2)、fcntl(2) 等）来引用打开的文件。成功调用返回的文件描述符将是该进程当前未打开的最小编号文件描述符。\n默认情况下，新文件描述符设置为在 execve(2) 后保持打开状态（即，fcntl(2) 中描述的 FD_CLOEXEC 文件描述符标志最初是被禁用的）；可以使用下面描述的 O_CLOEXEC 标志来更改此默认值。文件偏移量设置为文件的开头（请参阅 lseek(2)）。\n调用 open() 会创建一个新的打开文件描述，它是系统范围内打开文件表中的一个条目。打开文件描述记录了文件偏移量和文件状态标志（见下文）。文件描述符是对打开文件描述的引用；如果随后删除或修改 pathname 以引用不同的文件，则此引用不受影响。有关打开文件描述的更多详细信息，请参阅注释。\n参数 flags 必须包含以下访问模式之一：O_RDONLY、O_WRONLY 或 O_RDWR。这些请求分别以只读、只写或读/写方式打开文件。\n此外，可以在 flags 中对零个或多个文件创建标志和文件状态标志进行按位或运算。文件创建标志是 O_CLOEXEC、O_CREAT、O_DIRECTORY、O_EXCL、O_NOCTTY、O_NOFOLLOW、O_TMPFILE 和 O_TRUNC。文件状态标志是下面列出的所有剩余标志。这两组标志之间的区别在于，文件创建标志会影响打开操作本身的语义，而文件状态标志会影响后续 I/O 操作的语义。可以检索和（在某些情况下）修改文件状态标志；有关详细信息，请参阅 fcntl(2)。\n以下是 open 函数中各个标志的含义：\n\n\n\n标志\n含义\n\n\n\nO_CLOEXEC\n在执行exec()时，自动关闭文件描述符。\n\n\nO_CREAT\n如果文件不存在，则创建它，此时要传入mode参数描述创建文件的用户访问权限\n\n\nO_DIRECTORY\n如果路径名不是一个目录，打开失败。\n\n\nO_EXCL\n和 O_CREAT 一起使用，如果文件已经存在，打开失败。\n\n\nO_NOCTTY\n如果路径名指向终端设备，不要将此设备分配为控制终端。\n\n\nO_NOFOLLOW\n如果路径名是一个符号链接，打开失败。\n\n\nO_TMPFILE\n创建一个匿名临时文件，文件将在关闭时删除。必须与 O_RDWR 或 O_WRONLY 一起使用，并且必须包含在 O_CREAT 中。\n\n\nO_TRUNC\n如果文件存在并且以写入模式打开，将其截断为长度 0。\n\n\nopen()， openat() 和 creat() 函数在成功时返回新的文件描述符（一个非负整数），如果发生错误则返回 -1（此时，errno 会被设置为相应的错误码）。\n\n\n\n\n\n\n提示\n每次调用 open 系统调用时，内核都会创建一个新的文件描述符，即使两次调用的文件路径相同。每个文件描述符都有自己独立的文件指针和文件状态标志。\n\n\nclose函数c#include &lt;unistd.h&gt;\n\nint close(int fd);close() 函数用于关闭一个文件描述符，使其不再指向任何文件，并可以被重用。该进程持有的，与文件描述符关联的任何记录锁 (参见 fcntl(2))，都会被移除 (无论使用哪个文件描述符获取的锁)。如果 fd 是指向底层打开文件描述符的最后一个文件描述符 (参见 open(2))，则与该打开文件描述符关联的资源将被释放；如果该文件描述符是对已使用 unlink(2) 移除的文件的最后一个引用，则该文件将被删除。\nclose() 函数调用成功时返回0。发生错误时返回-1，并将 errno 设置为相应的错误码。\nstrerror函数c#include &lt;string.h&gt;\n\nchar *strerror(int errnum);strerror() 函数返回一个指向字符串的指针，该字符串描述传递给参数 errnum 的错误码，可能会使用当前语言环境的 LC_MESSAGES 部分来选择适当的语言。（例如，如果 errnum 为 EINVAL ，则返回的描述将是“无效参数”。）应用程序不得修改此字符串，但可以通过后续调用 strerror() 或 strerror_l() 进行修改。 包括 perror(3) 在内的任何其他库函数都不会修改此字符串。\nc#include &lt;errno.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n  FILE *file = fopen(\"nonexistentfile.txt\", \"r\");//如果打开失败，errno会被设置\n  if (file == NULL) {\n    // 打开文件失败，输出错误信息\n    printf(\"Error opening file: %s\\n\", strerror(errno));//将错误码转换为错误信息，直观方便\n  } else {\n    // 打开文件成功，关闭文件\n    fclose(file);\n  }\n  return 0;\n}perror函数c#include &lt;stdio.h&gt;\n\nvoid perror(const char *s);\n\n#include &lt;errno.h&gt;\n\nconst char * const sys_errlist[];\nint sys_nerr;\nint errno;       /* Not really declared this way; see errno(3) */perror() 函数在标准错误输出上生成一条消息，描述在调用系统或库函数期间遇到的最后一个错误。\n首先（如果 s 不为 NULL 且 *s 不为空字节 (‘\\0’)），则打印参数字符串 s，后跟冒号和空格。 然后是与当前 errno 值对应的错误消息和换行符。\n为了最大程度地发挥作用，参数字符串应包含发生错误的函数的名称。\n全局错误列表 sys_errlist[] 可以通过 errno 索引，可用于获取不带换行符的错误消息。 表中提供的最大消息编号为 sys_nerr-1。 直接访问此列表时要小心，因为新错误值可能尚未添加到 sys_errlist[] 中。 现在不推荐使用 sys_errlist[]； 请改用 strerror(3)。\n当系统调用失败时，它通常返回 -1 并将变量 errno 设置为描述错误的值。\n许多库函数也是如此。 perror() 函数用于将此错误代码转换为人类可读的形式。 请注意，在系统调用或库函数调用成功后， errno 的值是未定义的：即使调用成功，此调用也可能会更改此变量，例如，因为它在内部使用了其他一些失败的库函数。 因此，如果在失败的调用之后没有立即调用 perror()，则应保存 errno 的值。\nread函数c#include &lt;unistd.h&gt;\n\nssize_t read(int fd, void *buf, size_t count);read() 函数尝试从文件描述符 fd 读取最多 count 字节的数据到以 buf 开始的缓冲区中。对于支持文件定位操作的文件，读取操作从文件偏移量处开始，读取的字节数将累加到文件偏移量中。如果文件偏移量已经到达或超过文件末尾，则不会读取任何字节，并且 read() 返回 0。\n如果 count 为零，read() 可能会检测到下述错误。如果没有错误，或者 read() 没有检查错误，那么 count 为 0 的 read() 调用将返回 0，并且不会产生其他影响。\n根据 POSIX.1 标准，如果 count 大于 SSIZE_MAX，则结果取决于具体实现；有关 Linux 的上限，请参阅注释部分。\n成功时，返回读取的字节数（0 表示文件结束），并且文件位置会向前移动相应的字节数。如果返回的字节数小于请求的字节数，则不视为错误；发生这种情况的原因可能是当前实际可用的字节数较少（例如，因为文件已接近末尾，或者正在从管道或终端读取数据），或者因为 read() 被信号中断。 另请参阅注释部分。\n发生错误时，返回 -1，并将 errno 设置为相应的错误码。 在这种情况下，文件位置（如果有）是否发生变化是未指定的。\nwrite函数c#include &lt;unistd.h&gt;\n\nssize_t write(int fd, const void *buf, size_t count);write() 函数将以 buf 开始的缓冲区中最多 count 字节的数据写入文件描述符 fd 所指向的文件。\n写入的字节数可能会少于 count，例如，底层物理介质上空间不足，或者遇到 RLIMIT_FSIZE 资源限制（请参阅 setrlimit(2)），或者在写入少于 count 字节后，调用被信号处理程序中断。（另请参阅 pipe(7)）。\n对于可定位文件（例如，可以应用 lseek(2) 的文件，如常规文件），写入操作在文件偏移量处进行，并且文件偏移量会增加实际写入的字节数。如果文件是用 O_APPEND 标志打开的（参见 open(2)），则在写入之前，文件偏移量会先被设置为文件末尾。文件偏移量的调整和写入操作是以原子操作的形式执行的。\nPOSIX 标准要求，在一个可证明发生在 write() 返回之后的 read(2) 操作中，将会返回新的数据。请注意，并非所有文件系统都符合 POSIX 标准。\n根据 POSIX.1 标准，如果 count 大于 SSIZE_MAX，则结果取决于具体实现；有关 Linux 的上限，请参阅注释部分。\n成功时，返回写入的字节数。发生错误时，返回 -1，并设置 errno 以指示错误原因。\n需要注意的是，即使 write() 调用成功，也可能只传输了少于 count 字节的数据。 这种部分写入可能由多种原因造成； 例如，磁盘设备上的空间不足以写入所有请求的字节，或者对套接字、管道或类似设备的阻塞 write() 操作在传输了部分数据后被信号处理程序中断。 如果发生部分写入，调用者可以再次调用 write() 以传输剩余的字节。 后续调用将传输更多字节，也可能导致错误（例如，如果磁盘已满）。\n如果 count 为零且 fd 引用的是常规文件，那么如果检测到以下错误之一，write() 可能会返回失败状态。 如果未检测到错误或未执行错误检测，则将返回 0 且不会产生任何其他影响。 如果 count 为零且 fd 引用的是常规文件以外的文件，则结果未指定。\n文件描述符对于一个进程来说，系统维护一个文件描述符表，用于记录进程打开的文件。文件描述符是一个非负整数，用于标识一个文件，对应文件描述符表中的一个表项（下标）。默认情况下，进程最开始运行时会打开3个文件，分别是：\n\n0:STDIN\n1:STDOUT\n2:STDERR\n\n于是，如果第一次使用 open() 函数打开一个文件，那么返回的文件描述符就是3。\n根据这个知识，我们可以自己使用系统调用完成scanf函数和printf函数的功能。\nc#include &lt;unistd.h&gt;\n\nint main(int argc, char *argv[]) {\n  char buf[100]={};\n  int n = read(STDIN_FILENO,buf,100);//scanf\n  //注意，此时从标准输入读取的字符串是不会自动加上'\\0'的\n  write(STDOUT_FILENO, buf, n);//printf\n}fcntl函数c#include &lt;unistd.h&gt;\n#include &lt;fcntl.h&gt;\n\nint fcntl(int fd, int cmd, ... /* arg */ );fcntl() 函数对打开的文件描述符 fd 执行以下操作之一。 具体操作由 cmd 参数决定。\nfcntl() 可以接受一个可选的第三个参数。 是否需要此参数取决于 cmd。 每个 cmd 名称后面的括号中指明了所需的参数类型（在大多数情况下，所需的类型是 int，我们使用名称 arg 来标识参数），如果不需要参数，则指定为 void。\n以下某些操作仅在特定 Linux 内核版本之后才受支持。 检查主机内核是否支持特定操作的首选方法是使用所需的 cmd 值调用 fcntl()，然后测试调用是否失败并返回 EINVAL 错误，这表明内核无法识别此值。\n\n\n\ncmd 参数\n解释\n用法\n\n\n\nF_GETFD\n获取文件描述符的标志位\nint flags = fcntl(fd, F_GETFD);\n\n\nF_SETFD\n设置文件描述符的标志位\nfcntl(fd, F_SETFD, flags);\n\n\nF_GETFL\n获取文件状态标志\nint flags = fcntl(fd, F_GETFL);\n\n\nF_SETFL\n设置文件状态标志\nfcntl(fd, F_SETFL, flags);\n\n\nF_GETLK\n获取文件锁信息\nstruct flock lock; fcntl(fd, F_GETLK, &amp;lock);\n\n\nF_SETLK\n设置文件锁信息，非阻塞模式\nfcntl(fd, F_SETLK, &amp;lock);\n\n\nF_SETLKW\n设置文件锁信息，阻塞模式\nfcntl(fd, F_SETLKW, &amp;lock);\n\n\nF_DUPFD\n复制文件描述符\nint new_fd = fcntl(fd, F_DUPFD, 0);\n\n\nF_DUPFD_CLOEXEC\n复制文件描述符，并设置 FD_CLOEXEC 标志\nint new_fd = fcntl(fd, F_DUPFD_CLOEXEC, 0);\n\n\nF_GETOWN\n获取信号所有者 PID 或进程组 ID\nint owner = fcntl(fd, F_GETOWN);\n\n\nF_SETOWN\n设置信号所有者 PID 或进程组 ID\nfcntl(fd, F_SETOWN, owner);\n\n\nF_GETSIG\n获取异步 I/O 信号\nint sig = fcntl(fd, F_GETSIG);\n\n\nF_SETSIG\n设置异步 I/O 信号\nfcntl(fd, F_SETSIG, sig);\n\n\nF_SETPIPE_SZ\n设置管道的缓冲区大小\nfcntl(fd, F_SETPIPE_SZ, size);\n\n\nF_GETPIPE_SZ\n获取管道的缓冲区大小\nint size = fcntl(fd, F_GETPIPE_SZ);\n\n\nF_OFD_GETLK\n获取文件描述符锁信息（文件描述符级别的锁）\nstruct ofd_lock lock; fcntl(fd, F_OFD_GETLK, &amp;lock);\n\n\nF_OFD_SETLK\n设置文件描述符锁信息（文件描述符级别的锁），非阻塞模式\nfcntl(fd, F_OFD_SETLK, &amp;lock);\n\n\nF_OFD_SETLKW\n设置文件描述符锁信息（文件描述符级别的锁），阻塞模式\nfcntl(fd, F_OFD_SETLKW, &amp;lock);\n\n\n函数返回值取决于cmd参数，发生错误时，返回值为 -1，并设置 errno 以指示错误原因。\n阻塞和非阻塞对文件进行读写操作时，根据打开文件的类型，读写操作可能会阻塞。例如，对于程序默认打开的终端STDIN，如果没有输入，那么读操作会一直阻塞，直到有输入为止。\n对一个文件的读写操作是否会阻塞，取决于其文件状态标志，使用open函数时传入了O_NONBLOCK参数，则在打开时可以设置该标志，那么就不会被阻塞。\n值得注意的是：对于普通文件，读取操作通常不会阻塞，即使文件描述符是阻塞的，因为文件的大小是固定的，读取操作要么成功读取数据，要么返回EOF。对于终端设备、管道、套接字等，读取操作在没有可用数据时可能会阻塞，直到有数据可读或发生错误。\n如果想让终端设备、管道、套接字等读写操作不阻塞，则要设置其文件状态标志。这样在读取的时候不会发生阻塞，但是会立即返回一个错误码，错误码为EAGAIN或EWOULDBLOCK。这个时候可以通过轮询的方式来读取数据，直到读取到数据为止。\nc#include &lt;errno.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;unistd.h&gt;\n\n#define MSG_TRY \"try again\\n\"\n\nint main(void) {\n  char buf[10];\n  int flags, n;\n\n  flags = fcntl(STDIN_FILENO, F_GETFL); // 获取stdin属性信息\n  if (flags == -1) {\n    perror(\"fcntl error\");\n    exit(1);\n  }\n  flags |= O_NONBLOCK;\n  int ret = fcntl(STDIN_FILENO, F_SETFL, flags);\n  if (ret == -1) {\n    perror(\"fcntl error\");\n    exit(1);\n  }\n\ntryagain:\n  n = read(STDIN_FILENO, buf, 10);\n  if (n &lt; 0) {\n    if (errno != EAGAIN) {\n      perror(\"read /dev/tty\");\n      exit(1);\n    }\n    sleep(3);\n    write(STDOUT_FILENO, MSG_TRY, strlen(MSG_TRY));\n    goto tryagain;\n  }\n  write(STDOUT_FILENO, buf, n);\n  return 0;\n}lseek函数c#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\n\noff_t lseek(int fd, off_t offset, int whence);文件的读指针和写指针是同一个指针。lseek 修改的是文件描述符的当前位置，无论你进行读取还是写入操作，都是从这个位置开始的。因此，lseek 同时影响读取和写入的起始位置。\nlseek() 函数根据指令 whence 的值，将与文件描述符 fd 关联的打开文件描述符的文件偏移量重新定位到参数 offset 指定的位置，具体如下：\n\nSEEK_SET：文件偏移量被设置为 offset 字节。\nSEEK_CUR：文件偏移量被设置为当前位置加上 offset 字节。\nSEEK_END：文件偏移量被设置为文件大小加上 offset 字节。\nSEEK_DATA：文件偏移量被设置为下一个数据区的开始，如果offset本来就在数据区中，则不改变。\nSEEK_HOLE：文件偏移量被设置为下一个空洞的开始，如果offset本来就在空洞区中，则不改变，如果没有空洞区，则指向文件末尾。\n\nlseek() 允许将文件偏移量设置到文件末尾之后（但这不会改变文件的大小）。如果稍后在该点写入数据，则在实际写入数据到该间隙（“空洞”）之前，对该间隙中的数据的后续读取操作将返回空字节（’\\0’）。\n成功完成后，lseek() 返回从文件开头开始计算的偏移量（以字节为单位）。发生错误时，返回值为 (off_t) -1，并设置 errno 以指示错误原因。\ntruncate函数c#include &lt;unistd.h&gt;\n#include &lt;sys/types.h&gt;\n\nint truncate(const char *path, off_t length);\nint ftruncate(int fd, off_t length);truncate() 和 ftruncate() 函数将 path 指定的常规文件或 fd 引用的常规文件截断为 length 字节的大小。\n如果文件之前大于此大小，则多余的数据将丢失。如果文件之前较短，则会被扩展，扩展部分读取为空字节 (‘\\0’)。\n文件偏移量不会改变。\n如果文件大小发生变化，则文件的 st_ctime 和 st_mtime 字段（分别为最后一次状态更改时间和最后一次修改时间；参见 inode(7)）将被更新，并且 set-user-ID 和 set-group-ID 模式位可能会被清除。使用 ftruncate() 时，文件必须以写模式打开；使用 truncate() 时，文件必须是可写的。\nstat函数c#include &lt;sys/types.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;unistd.h&gt;\n\nint stat(const char *pathname, struct stat *statbuf);\nint fstat(int fd, struct stat *statbuf);\nint lstat(const char *pathname, struct stat *statbuf);\n\nstruct stat {\n  dev_t st_dev;         /* ID of device containing file */\n  ino_t st_ino;         /* Inode number */\n  mode_t st_mode;       /* File type and mode */\n  nlink_t st_nlink;     /* Number of hard links */\n  uid_t st_uid;         /* User ID of owner */\n  gid_t st_gid;         /* Group ID of owner */\n  dev_t st_rdev;        /* Device ID (if special file) */\n  off_t st_size;        /* Total size, in bytes */\n  blksize_t st_blksize; /* Block size for filesystem I/O */\n  blkcnt_t st_blocks;   /* Number of 512B blocks allocated */\n\n  /* Since Linux 2.6, the kernel supports nanosecond\n     precision for the following timestamp fields.\n     For the details before Linux 2.6, see NOTES. */\n\n  struct timespec st_atim; /* Time of last access */\n  struct timespec st_mtim; /* Time of last modification */\n  struct timespec st_ctim; /* Time of last status change */\n\n#define st_atime st_atim.tv_sec /* Backward compatibility */\n#define st_mtime st_mtim.tv_sec\n#define st_ctime st_ctim.tv_sec\n};\n这些函数返回文件信息，并将信息存储在 statbuf 指向的缓冲区中。 文件本身不需要任何权限，但对于 stat()、fstatat() 和 lstat()，需要对 pathname 中所有通向该文件的目录具有执行（搜索）权限。\nstat() 和 fstatat() 获取 pathname 指向的文件的信息；fstatat() 的区别将在下文介绍。\nlstat() 与 stat() 相同，区别在于如果 pathname 是符号链接，则 lstat() 返回有关链接本身的信息，而不是链接指向的文件的信息。\nfstat() 与 stat() 相同，区别在于要获取其信息的文件由文件描述符 fd 指定。\n若成功，返回 0。若出错，返回 -1，并将 errno 设置为相应的值。\nc#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;sys/sysmacros.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;time.h&gt;\n\nint main(int argc, char *argv[]) {\n  struct stat sb;\n\n  if (argc != 2) {\n    fprintf(stderr, \"Usage: %s &lt;pathname&gt;\\n\", argv[0]);\n    exit(EXIT_FAILURE);\n  }\n\n  if (lstat(argv[1], &amp;sb) == -1) {\n    perror(\"lstat\");\n    exit(EXIT_FAILURE);\n  }\n\n  printf(\"ID of containing device:  [%jx,%jx]\\n\", (uintmax_t)major(sb.st_dev),\n         (uintmax_t)minor(sb.st_dev));\n\n  printf(\"File type:                \");\n\n  switch (sb.st_mode &amp; S_IFMT) {\n  case S_IFBLK:\n    printf(\"block device\\n\");\n    break;\n  case S_IFCHR:\n    printf(\"character device\\n\");\n    break;\n  case S_IFDIR:\n    printf(\"directory\\n\");\n    break;\n  case S_IFIFO:\n    printf(\"FIFO/pipe\\n\");\n    break;\n  case S_IFLNK:\n    printf(\"symlink\\n\");\n    break;\n  case S_IFREG:\n    printf(\"regular file\\n\");\n    break;\n  case S_IFSOCK:\n    printf(\"socket\\n\");\n    break;\n  default:\n    printf(\"unknown?\\n\");\n    break;\n  }\n  printf(\"I-node number:            %ju\\n\", (uintmax_t)sb.st_ino);\n\n  printf(\"Mode:                     %jx (hex)\\n\", (uintmax_t)sb.st_mode);\n\n  printf(\"Link count:               %ju\\n\", (uintmax_t)sb.st_nlink);\n  printf(\"Ownership:                UID=%ju   GID=%ju\\n\", (uintmax_t)sb.st_uid,\n         (uintmax_t)sb.st_gid);\n\n  printf(\"Preferred I/O block size: %jd bytes\\n\", (intmax_t)sb.st_blksize);\n  printf(\"File size:                %jd bytes\\n\", (intmax_t)sb.st_size);\n  printf(\"Blocks allocated:         %jd\\n\", (intmax_t)sb.st_blocks);\n\n  printf(\"Last status change:       %s\", ctime(&amp;sb.st_ctime));\n  printf(\"Last file access:         %s\", ctime(&amp;sb.st_atime));\n  printf(\"Last file modification:   %s\", ctime(&amp;sb.st_mtime));\n\n  exit(EXIT_SUCCESS);\n}link函数c#include &lt;unistd.h&gt;\n\nint link(const char *oldpath, const char *newpath);link() 系统调用会为一个已有的文件创建一个新的链接（也称为硬链接）。\n如果 newpath 已经存在，它不会被覆盖，产生EEXIST错误码。\n这个新的文件名可以和旧文件名完全一样地用于任何操作；两个文件名都指向同一个文件（因此具有相同的权限和所有权），并且无法分辨哪个文件名是“原始”的。\n若调用成功，返回 0。若调用失败，返回 -1，并设置相应的错误码 errno。\nunlink函数c#include &lt;unistd.h&gt;\n\nint unlink(const char *pathname);unlink() 系统调用从文件系统中删除一个文件目录项。如果该文件目录项是文件的最后一个链接，并且没有任何进程打开了该文件，则该文件将被删除，其占用的空间将被释放以供重用。\n如果该文件名是文件的最后一个链接，但仍有进程打开了该文件，则该文件将继续存在，直到最后一个引用它的文件描述符被关闭。\n如果该文件名指向一个符号链接，则该链接将被删除。\n如果该文件名指向一个套接字、FIFO 或设备文件，则该文件名将被删除，但打开了该对象的进程可以继续使用它。\n若调用成功，返回 0。若调用失败，返回 -1，并设置相应的错误码 errno。\n\n\n\n\n\n\n提示\n如果文件仍有其他进程打开，文件的内容不会立即被删除。这是因为文件的实际内容和文件的目录项是分开的。文件的内容只有在所有打开该文件的进程关闭文件描述符后才会被真正删除。\n在大多数 UNIX 系统中，unlink 通常不会因为文件被其他进程打开而返回 EBUSY 错误。然而，有些系统和特定的文件系统可能会在这种情况下返回 EBUSY。一些特殊的文件系统或文件类型（如设备文件）可能会因为被某些内核模块或系统服务使用而导致 EBUSY 错误。\n以下是一些可能导致 unlink 返回 EBUSY 错误的具体场景：\n\n挂载点：\n\n如果你尝试删除一个目录或文件，但该目录或文件是一个挂载点（即文件系统被挂载到该目录上），则可能会遇到 EBUSY 错误。\n例如，尝试删除 /mnt 目录，而 /mnt 目录上挂载了一个文件系统。\n\n\n当前目录：\n\n如果当前工作目录是一个你试图删除的目录，unlink 将失败并返回 EBUSY。\n你不能删除当前工作目录。\n\n\n文件被其他进程打开：\n\n在大多数 UNIX 系统中，unlink 通常不会因为文件被其他进程打开而返回 EBUSY 错误。然而，有些系统和特定的文件系统可能会在这种情况下返回 EBUSY。\n一些特殊的文件系统或文件类型（如设备文件）可能会因为被某些内核模块或系统服务使用而导致 EBUSY 错误。\n\n\n挂载文件系统：\n\n如果你尝试删除挂载点，而该点下的文件系统正在被使用，unlink 将失败并返回 EBUSY 错误。\n例如，尝试删除 /dev 目录的文件，而该目录被用于设备文件挂载。\n\n\n\n\n\n这是一个使用link和unlink函数实现mv命令的例子：\nc#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nvoid move_file(const char *src, const char *dst) {\n  // 创建硬链接\n  if (link(src, dst) != 0) {\n    perror(\"Error creating hard link\");\n    exit(EXIT_FAILURE);\n  }\n\n  // 删除原始文件\n  if (unlink(src) != 0) {\n    perror(\"Error deleting original file\");\n    // 这里我们希望在失败时撤销之前的操作\n    // 如果 unlink 失败，删除刚才创建的硬链接\n    if (unlink(dst) != 0) {\n      perror(\"Error deleting the newly created file\");\n    }\n    exit(EXIT_FAILURE);\n  }\n}\n\nint main(int argc, char *argv[]) {\n  if (argc != 3) {\n    fprintf(stderr, \"Usage: %s &lt;source&gt; &lt;destination&gt;\\n\", argv[0]);\n    return EXIT_FAILURE;\n  }\n\n  move_file(argv[1], argv[2]);\n  return EXIT_SUCCESS;\n}opendir函数c#include &lt;sys/types.h&gt;\n#include &lt;dirent.h&gt;\n\nDIR *opendir(const char *name);\nDIR *fdopendir(int fd);opendir() 函数打开一个与目录名相对应的目录流，并返回指向该目录流的指针。该流定位在目录的第一个条目。\nfdopendir() 函数类似于 opendir()，但它返回的是由已打开文件描述符 fd 所指向的目录的目录流。成功调用 fdopendir() 后，fd 将被内部使用，应用程序不应再使用该文件描述符。\nopendir() 和 fdopendir() 函数返回指向目录流的指针。如果发生错误，则返回 NULL ，并设置相应的错误码 errno。\n\n\n\n\n\n\n提示\n成功调用 fdopendir() 后，传递给它的文件描述符 fd 将被内部使用，意味着该文件描述符会被 DIR 结构体内部使用，管理打开的目录流。应用程序不应再使用该文件描述符的原因有以下几个方面：\n\n资源管理交由系统：fdopendir() 函数将文件描述符 fd 转换成一个 DIR* 类型的指针，该指针代表一个打开的目录流。这个目录流由系统管理，应用程序如果继续直接使用 fd，可能会破坏系统对目录流的管理。\n\n避免竞态条件：如果应用程序在 fdopendir() 后继续使用 fd，可能会引发竞态条件。例如，应用程序可能会在不适当的时机关闭或修改该文件描述符，从而影响到 DIR* 结构体的正常工作，导致未定义的行为。\n\n资源释放问题：fdopendir() 接管了 fd 的管理职责，这意味着当通过 DIR* 进行的目录操作完成后，应用程序应该使用 closedir() 来关闭目录流。直接使用 fd 进行关闭或其他操作可能会导致资源泄漏或双重释放问题。\n\n\n\n\nreaddir函数c#include &lt;dirent.h&gt;\n\nstruct dirent *readdir(DIR *dirp);\n\nstruct dirent {\n    ino_t          d_ino;       /* inode 编号 */\n    off_t          d_off;       /* 不是偏移量；见下文 */\n    unsigned short d_reclen;    /* 此记录的长度 */\n    unsigned char  d_type;      /* 文件类型；并非所有文件系统类型都支持 */\n    char           d_name[256]; /* 以空字符结尾的文件名 */\n};\nreaddir() 函数返回一个指向 dirent 结构体的指针，该结构体表示由 dirp 指向的目录流中的下一个目录项。当到达目录流的末尾或发生错误时，它返回 NULL。\n调用成功时，readdir() 函数返回一个指向 dirent 结构体的指针。（该结构体可能被静态分配；不要尝试使用 free(3) 释放它。）\n如果到达目录流的末尾，则返回 NULL，且 errno 不变。如果发生错误，则返回 NULL，并设置相应的 errno。为了区分到达目录流末尾和发生错误，需要在调用 readdir() 之前将 errno 设置为 0，然后在返回 NULL 时检查 errno 的值。\n\n\n\n\n\n\n提示\nreaddir() 返回的 dirent 结构体指针指向的内存区域通常是静态分配的。这意味着：\n共享单一缓冲区：在许多实现中，readdir() 使用一个静态分配的缓冲区来存放 dirent 结构体的内容。每次调用 readdir()，都会复用同一个缓冲区来存储新的目录项信息。这是为了减少内存分配和释放的开销，提高性能。\n不可释放：由于这个缓冲区是静态分配的，由系统的 C 库管理，而不是动态分配在堆上，因此不能使用 free() 来释放它。试图使用 free() 释放它将导致未定义的行为，可能会引发程序崩溃或者其他不可预见的问题。\n\n\nclosedir函数c#include &lt;sys/types.h&gt;\n#include &lt;dirent.h&gt;\n\nint closedir(DIR *dirp);closedir() 函数关闭与 dirp 关联的目录流。成功调用 closedir() 也会关闭与 dirp 关联的底层文件描述符。在此调用之后，目录流描述符 dirp 将不再可用。\nclosedir() 函数成功时返回 0。如果发生错误，则返回 -1，并设置相应的错误码 errno。\n下面是使用 opendir()、readdir() 和 closedir() 函数列出目录中所有文件的示例：\nc#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;dirent.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;pwd.h&gt;\n#include &lt;grp.h&gt;\n#include &lt;time.h&gt;\n\nvoid print_file_info(const char *path, const struct dirent *entry) {\n    struct stat file_stat;\n    char full_path[PATH_MAX];\n    snprintf(full_path, PATH_MAX, \"%s/%s\", path, entry-&gt;d_name);\n\n    if (stat(full_path, &amp;file_stat) == -1) {\n        perror(\"stat\");\n        return;\n    }\n\n    printf((S_ISDIR(file_stat.st_mode)) ? \"d\" : \"-\");\n    printf((file_stat.st_mode &amp; S_IRUSR) ? \"r\" : \"-\");\n    printf((file_stat.st_mode &amp; S_IWUSR) ? \"w\" : \"-\");\n    printf((file_stat.st_mode &amp; S_IXUSR) ? \"x\" : \"-\");\n    printf((file_stat.st_mode &amp; S_IRGRP) ? \"r\" : \"-\");\n    printf((file_stat.st_mode &amp; S_IWGRP) ? \"w\" : \"-\");\n    printf((file_stat.st_mode &amp; S_IXGRP) ? \"x\" : \"-\");\n    printf((file_stat.st_mode &amp; S_IROTH) ? \"r\" : \"-\");\n    printf((file_stat.st_mode &amp; S_IWOTH) ? \"w\" : \"-\");\n    printf((file_stat.st_mode &amp; S_IXOTH) ? \"x\" : \"-\");\n\n    printf(\" %lu\", file_stat.st_nlink);\n\n    struct passwd *pw = getpwuid(file_stat.st_uid);\n    struct group *gr = getgrgid(file_stat.st_gid);\n    printf(\" %s %s\", pw-&gt;pw_name, gr-&gt;gr_name);\n\n    printf(\" %5ld\", file_stat.st_size);\n\n    char time_str[20];\n    strftime(time_str, sizeof(time_str), \"%b %d %H:%M\", localtime(&amp;file_stat.st_mtime));\n    printf(\" %s\", time_str);\n\n    printf(\" %s\\n\", entry-&gt;d_name);\n}\n\nvoid list_long(const char *path) {\n    DIR *dir = opendir(path);\n    if (dir == NULL) {\n        perror(\"opendir\");\n        exit(EXIT_FAILURE);\n    }\n\n    struct dirent *entry;\n    while ((entry = readdir(dir)) != NULL) {\n        print_file_info(path, entry);\n    }\n\n    if (closedir(dir) == -1) {\n        perror(\"closedir\");\n        exit(EXIT_FAILURE);\n    }\n}\n\nint main(int argc, char *argv[]) {\n    const char *path = argc &gt; 1 ? argv[1] : \".\";\n    list_long(path);\n    return 0;\n}下面是一个递归遍历目录的c程序示例：\nc#include &lt;dirent.h&gt;\n#include &lt;grp.h&gt;\n#include &lt;pwd.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;time.h&gt;\nvoid list(const char *path);\n\nvoid list(const char *path) {\n  struct stat sb;\n  int s = stat(path, &amp;sb);\n  if (s != 0) {\n    perror(\"list read stat:\");\n    exit(-1);\n  }\n  printf(\"%s\\n\", path);\n  if (S_ISDIR(sb.st_mode)) {\n    DIR *dirp = opendir(path);\n    if (dirp == NULL) {\n      perror(\"list opendir\");\n      exit(-1);\n    }\n    dirent *dir_element;\n    while ((dir_element = readdir(dirp))) {\n      if (strcmp(dir_element-&gt;d_name, \".\") &amp;&amp;\n          strcmp(dir_element-&gt;d_name, \"..\")) {\n        char name[PATH_MAX];\n        snprintf(name, PATH_MAX, \"%s/%s\", path, dir_element-&gt;d_name);\n        list(name);\n      }\n    }\n    closedir(dirp);\n  }\n}\nint main(int argc, char *argv[]) {\n  const char *path = argc &gt; 1 ? argv[1] : \".\";\n  list(argv[1]);\n  return 0;\n}dup函数c#include &lt;unistd.h&gt;\n\nint dup(int oldfd);\nint dup2(int oldfd, int newfd);dup() 系统调用使用未使用的最小文件描述符编号为新描述符创建一个 oldfd 文件描述符的副本。\n成功返回后，新旧文件描述符可以互换使用。它们指向同一个已打开的文件描述（参见 open(2)），因此共享文件偏移量和文件状态标志；例如，如果使用 lseek(2) 修改其中一个文件描述符的文件偏移量，则另一个文件描述符的偏移量也会更改。\n这两个文件描述符不共享文件描述符标志（“执行时关闭”标志）。复制描述符的“执行时关闭”标志（FD_CLOEXEC；参见 fcntl(2)）处于关闭状态。\ndup2() 系统调用执行与 dup() 相同的任务，但它不会使用未使用的最小文件描述符编号，而是使用 newfd 中指定的文件描述符编号。如果文件描述符 newfd 之前已打开，则会在重用之前将其静默关闭。\n关闭和重用文件描述符 newfd 的步骤是原子执行的。这一点很重要，因为尝试使用 close(2) 和 dup() 实现相同的功能可能会导致竞争条件，即 newfd 可能会在这两个步骤之间被重用。这种重用可能发生的原因是主程序被分配文件描述符的信号处理程序中断，或者并行线程分配了文件描述符。\n当调用成功时，这些系统调用返回新的文件描述符。如果发生错误，则返回 -1，并设置相应的错误码 errno。\n","slug":"Linux系统编程（文件操作）","date":"2024-07-03T01:58:46.000Z","categories_index":"Linux","tags_index":"Linux,C++","author_index":"Ac-Accelerator"},{"id":"45eea3793f995e9782f39b2b3ca183ab","title":"《Effective C++》笔记","content":"读完《Effective C++》后，确实感到收益匪浅。但因为目前是学生，平时实践并不多，恐怕很多知识点会忘记。所以，我打算写一篇读后总结，以便日后复习，用电子版的方式也方便进行检索。\n一、让自己习惯C++1 视C++为一个语言联邦C++是一个多重范型的语言，虽然功能强大且灵活，但是却导致其不存在一个通用的程序设计守则和通例。为了能够获得简单直观的程序设计守则和通例，需要对C++语言的不同特性进行划分，总的来说可以C++划分为4个子语言，分别是C、Object-Oriented C++、Template C++和STL。不同的子语言有不同的程序设计守则和通例。因此，C++程序员最好视C++为一个语言联邦，而不是一个单一的语言。\n2 尽量以const、enum、inline替换#define总而言之是：能让编译器做的别让预处理器做。\n对于单纯的常量，最好使用const对象或者enum，而不是#define\n原因如下：\ncpp#define ASPECT_RATIO 1.653 // 不会进入符号表\n\nconst double AspectRatio = 1.653; // 会进入符号表当编译报错的时候，前者只会显示1.653（不直观），而后者会显示AspectRatio（直观）。且使用#define可能会导致代码膨胀。\n\n\n\n\n\n\n\n注意\n用const替换#define时，要注意的是如果对象是指针的话，要将指针本身也声明为const。\n对于类的专属常量，例如下面的NumTurns作为数组的大小在编译的时候要被使用，如何避免使用#define ：\ncppclass GamePlayer {//放在头文件中\nprivate:\n    static const int NumTurns = 5; \n    int scores[NumTurns];\n...\n};\n\nconst int GamePlayer::NumTurns;//放在实现文件中，如果编译器不要求提供定义，则可以忽略。上述做法可能不起作用，因为老旧的编译器可能不允许static成员在声明时获得初始值，所以可以使用enum hack：\ncppclass GamePlayer {\nprivate:\n    enum { NumTurns = 5 };\n    int scores[NumTurns];\n}\n\n对于形似函数的宏，最好使用inline函数替换\n原因如下：\ncpp#define CALL_WITH_MAX(a, b) func((a)&gt;(b)?(a):(b))\n\nint a = 5, b = 0;\nCALL_WITH_MAX(++a, b); // a被累加两次！\nCALL_WITH_MAX(++a, b+10); // a被累加一次！假设有这样一个宏，则会发生离谱的事情！这时候就需要使用inline函数：\ncpptemplate&lt;typename T&gt;\ninline void callWithMax(const T&amp; a, const T&amp; b) {\n    func(a&gt;b?a:b);\n}因此，预处理器扮演编译控制即可，其他的事情交给编译器。\n3 尽量使用const让编译器来进行语义约束！\n将某些东西声明为const可以帮助编译器侦测出错误用法。const可以被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。\n原因如下，这是一个用const避免错误用法的一个例子：\ncppclass Rational { ... };\nconst Rational operator*(const Rational&amp;lhs, const Rational&amp; rhs);\n\nRational a, b, c;\n(a * b) = c;//编译器可检查出这种错误编译器强制实施bitwise constness，但是程序员必须实施conceptual constness。\n原因如下，bitwise constness指的是const成员函数不能更改任何成员变量，这对编译器来说容易检测。然而通过bitwise并不代表该函数具有常量性质，例如：\ncppclass TextBlock {\npublic:\n    ...\n    //const char&amp; operator[](std::size_t position) const //正确举例！！\n    char&amp; operator[](std::size_t position) const//错误举例，未能保证conceptual constness\n    {\n        ...\n        return text[position];\n    }\nprivate:\n    char *text;\n};\n\nconst TextBlock tb(\"Hello\");\ntb[0] = 'x';//编译器不会报错,但是tb已经被修改了，失去了常量的意义\n与bitwise constness相对的conceptual constness指的是一个函数在逻辑上是const的，但是在bitwise上却不必然如此。但是编译器却是强制实施bitwise constness的，这时候可以使用mutable来修饰，跳过bitwise检测，例如：\ncppclass TextBlock {\npublic:\n    ...\n    std::size_t length() const\n    {\n        if (!lengthIsValid) {\n            lengthIsValid = true;\n            textLength = std::strlen(text);\n        }\n        return textLength;\n    }\nprivate:\n    char *text;\n    mutable std::size_t textLength; //使用mutable来修饰，跳过bitwise检测\n    mutable bool lengthIsValid; //使用mutable来修饰，跳过bitwise检测\n};当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可以避免代码重复。\n单纯为了避免代码重复，提高代码的可维护性，做法如下：\ncppclass TextBlock {\npublic:\n    ...\n    const char&amp; operator[](std::size_t position) const\n    {\n        ...\n        return text[position];\n    }\n    char&amp; operator[](std::size_t position)\n    {   //进行类型转换，调用const版本\n        return const_cast&lt;char &amp;&gt;(static_cast&lt;const TextBlock&amp;&gt;(*this)[position]);\n    }\n\n};4 确保对象被使用前已被初始化将对象初始化的工作，C++在不同的环境下会有不同的表现。如果使用C part of C++ ,则不保证发生初始化，而如果使用non-C parts of C++，则规则会改变。因此，最好的做法是：手动初始化对象。\n因此：为内置型对象进行手工初始化，因为C++不保证初始化内置型对象。\n构造函数最好使用成员初值列，而不是在函数里面进行赋值操作。初值列列出的成员变量，其排列顺序应该和它们在class中的声明顺序相同。\n在构造函数中，成员变量的初始化发生在进入构造函数本体之前，在函数里面进行赋值操作就浪费了之前的初始化过程，降低了效率。尽管内置类型的初始化和赋值的成本相同，为了一致性，也最好使用成员初值列。如果某些成员变量在“成员初值列”中没有指定初值，那么编译器会对用户自定义的类型的成员变量调用默认构造函数，对内置类型的成员变量则不会进行初始化（危险），因此，最好在“成员初值列”中列出所有的成员变量，以免忘记初始化。\n此外，C++总是以成员声明的次序来进行成员初始化，和构造函数的成员初值列的顺序无关，因此最好将成员初值列的顺序和成员声明的顺序保持一致。\n为免除“跨编译单元之初始化次序问题”，请以local static对象替换non-local static对象。\n原因如下，假设有两个源码文件：\ncpp//源码文件1\nclass FileSystem { \npublic:\n    ...\n    std::size_t numDisks() const; \n    ...\n};\nextern FileSystem tfs;//non-local static对象cpp//源码文件2\nclass Directory { \npublic:\n    Directory(params);\n    ...\n};\nDirectory::Directory(params)\n{\n    ...\n    std::size_t disks = tfs.numDisks();\n    ...\n}\n\nDirectory tempDir(params);可以看到，源码文件2中的Directory构造函数依赖于源码文件1中的tfs对象，但是C++不保证tfs对象能在Directory构造函数之前被初始化，可能会导致问题。解决的方法是使用单例模式：\ncpp//源码文件1\nclass FileSystem {...};\nFileSystem&amp; tfs(){\n    static FileSystem fs;//local static对象\n    return fs;\n}cppclass Directory {...};\nDirectory::Directory(params)\n{\n    ...\n    std::size_t disks = tfs().numDisks();\n    ...\n}\n\n\n\n\n\n\n注意\n任何一种non-const static对象，不论是local还是non-local，在多线程系统中都可能引发问题，一种做法是在单线程启动阶段手工调用所有的reference-returning函数，以消除“竞速形式”\n\n\n二、构造/析构/赋值运算5 了解C++默默编写并调用的函数编译器可以暗自为class创建default构造函数、copy构造函数、copy assignment操作符和析构函数。\ncppclass Empty{};\n\nEmpty e1;       //只要构造了对象，则会创建default构造函数和析构函数\nEmpty e2(e1);   //只要执行这个操作，则会创建copy构造函数\ne2 = e1;        //只要用了赋值操作，则会创建copy assignment操作符只有当这些函数被需要的时候，编译器才会创建这些函数。\n编译器产生的析构函数是个non-virtual，除非它的base class中声明了一个virtual析构函数。\n编译器产生的copy构造函数会调用所有base classes以及成员变量的copy构造函数或拷贝操作进行拷贝。\n编译器产生的copy assignment操作符和copy构造函数的工作是一样的，但是如果成员变量有引用或者常量的话，亦或是其base class的copy assignment操作符是private的话，编译器就不会自行产生copy assignment操作符。\n6 若不想使用编译器自动生成的函数，就该明确拒绝为驳回编译器自动提供的机能，可将相应的成员函数声明为private并且不予实现。使用像Uncopyable这样的base class也是一种做法。\n为了防止编译器自动生成的函数被客户调用，产生不可预期的行为，因此应该明确提示编译器不要生成这些函数。声明为private是一种方法，还有一种方法是使用Uncopyable这样的base class：\ncppclass Uncopyable {\nprotected: \n    Uncopyable() {} \n    ~Uncopyable() {} \nprivate:\n    Uncopyable(const Uncopyable&amp;);\n    Uncopyable&amp; operator=(const Uncopyable&amp;);\n};\n\nclass Money: private Uncopyable {\n    ...\n};\nC++11后，可以使用delete关键字来阻止编译器自动生成的函数：\ncppclass Money: private Uncopyable {\n    ...\n    Money(const Money&amp;) = delete;\n};7 为多态基类声明virtual析构函数polyrmophic base classes应该声明一个virtual析构函数。如果class带有任何virtual函数（代表会有多态性），它就应该拥有一个virtual析构函数。\n原因如下：\ncppclass TimeKeeper {\npublic:\n    TimeKeeper();\n    ...\n    ~TimeKeeper();//non-virtual析构函数\n    //virtual ~TimeKeeper();//正确做法\n};\nclass AtomicClock: public TimeKeeper {...};\nclass WaterClock: public TimeKeeper {...};\n\nTimeKeeper* getTimeKeeper(){\n    return new AtomicClock(...);\n}\n\nTimeKeeper* ptk = getTimeKeeper();\n\ndelete ptk;//只会调用TimeKeeper的析构函数，不会调用AtomicClock的析构函数这会产生一个局部销毁的对象，带来巨大的风险！\nClass的设计目的如果不是作为base class使用，或不是为了具备多态性，就不应该声明virtual析构函数。\n原因如下：如果某个类有virtual函数，内存中则会有一个vptr指针指向虚函数表，这不仅会增加内存开销，还使得和该类不再和其他语言内的相同声明有一样的结构，失去移植性。\n不声明virtual析构函数也通常意味着不希望该类被继承（并不绝对），因此在继承的时候需要小心的判断。\n\n\n\n\n\n\n\n注意\n即使class中完全没有virtual函数，也会出现这种情况，仅注意：\ncppclass StringClass: public std::string {...};\n\nStringClass* psc = new StringClass(\"hello world\");\nstd::string* ps = psc;\n...\ndelete ps;std::string类不含virtual函数，这样的类被继承后，如果delete基类指针，会产生问题。同理所有的STL容器都是如此。\n\n\n“给base class声明一个virtual析构函数”这个规则只适用于带多态的base class上。\n8 别让异常逃离析构函数析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。\n析构是内存操作，在析构发生异常后离开析构函数，可能会导致内存泄漏问题，或者产生不明确的行为，因此应该尽量避免异常离开析构函数。\n该怎么做：\ncppclass DBConnection {\npublic:\n    ...\n    static DBConnection create();//返回DBConnection对象\n    void close();//关闭链接,可能产生异常\n};\n\nclass DBConn {\npublic:\n    ...\n    ~DBConn()//析构函数\n    {\n        try {\n            db.close();\n        }\n        catch (...) {\n            //记录异常，不传播\n            ...\n            // std::abort();//如果需要，则停止程序\n        }\n    }\nprivate:\n    DBConnection db;\n};\n\n{//用户程序\n    DBConn dbc(DBConnection::create());//获得数据库连接\n    //没有手动销毁\n}//离开区块调用析构函数这种方法虽然可以避免异常离开析构函数，使得对象内存正常销毁，但是无法对产生的异常做出反应。因此另一种解决方法是将close的责任交给用户：\n如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。\ncppclass DBConn {\npublic:\n    ...\n    void close()//给用户关闭的机会\n    {\n        db.close();\n        closed = true;\n    }\n\n    ~DBConn()//析构函数\n    {\n        if (!closed) {\n            try {\n                db.close();\n            }\n            catch (...) {\n                //记录异常，不传播\n                ...\n                // std::abort();//如果需要，则停止程序\n            }\n        }\n    }\nprivate:\n    DBConnection db;\n    bool closed;\n};转移责任，让用户自己处理异常，析构函数的close仅用作双保险。\n9 绝不在构造和析构过程中调用virtual函数在构造和析构期间不要调用virtual函数，因为这类调用从不下降至derived class。\n在base class构造期间，virtual函数不是virtual函数！为什么C++有这个特性呢？由于base class的构造函数早于derived class的构造函数执行，如果此时调用virtual函数下降到derived class，那么derived class的构造函数还没有执行，这样就会导致不明确的行为，因此C++不会将virtual函数调用下降到derived class，而是保持在base class的版本。\n同理析构函数。\n例子如下：\ncppclass Transaction {\npublic:\n    Transaction(){ init(); }//编译器和连接器都不会报错，运行时系统终止\n    virtual void logTransaction() const = 0;//纯虚函数\n    ...\nprivate:\n    void init() { logTransaction(); }//调用纯虚函数\n};在这个例子中，在构造函数中间接调用纯虚函数，连接器则不会报错，但是运行时系统会终止。如果直接调用了纯虚函数，那么连接器则会报错。如果直接调用了非纯虚函数，那么连接器则不会报错，但是会调用base class的版本。\n\n\n\n\n\n\n\n注意\n注意是“在构造和析构期间”，因此需要递归地检查所有的构造函数和析构函数，以及它们调用的函数，确保不违反这一准则。\n\n\n那如何达到原本的目的呢？可以使用non-virtual interface（NVI）,既然无法使用virtual函数从base class下降到derived class，那就在构造期间令derived class将必要的构造信息传递给base class。\ncppclass Transaction {\npublic:\n    explicit Transaction(const std::string&amp; logInfo);\n    void logTransaction(const std::string&amp; logInfo) const;\n    ...\n};\n\nTransaction::Transaction(const std::string&amp; logInfo)\n{\n    ...\n    logTransaction(logInfo);\n}\n\nclass BuyTransaction: public Transaction {\npublic:\n    BuyTransaction(...): Transaction(createLogString(...)) {...}\n    ...\nprivate:\n    static std::string createLogString(...);\n};10 令operator=返回一个reference to *this*令operator=返回一个reference to this。\n这是为了支持连锁赋值，例如：\ncppint x, y, z;\nx = y = z = 15;这个准则不仅适用于标准的赋值形式，也适用于+=、-=、*=、/=等运算符。\n但是这个守则并无强制性，不遵守也不会产生什么问题，仅仅是不方便。\n11 在operator=中处理“自我赋值”确保当对象自我赋值时operator=有良好的行为。其中技术包括比较来源对象和目标对象的地址、精心周到的语句顺序、以及copy-and-swap。\n自我赋值是指将一个对象赋值给自己。\n例如：\ncppclass Bitmap {...};\nBitmap b;\n...\nb = b;//明显的自我赋值\n\nint a[10],x=1,y=1;\na[x] = a[y];//不明显的自我赋值\n\nint * px = a+3, * py = a+3;\n*px = *py;//不明显的自我赋值这里重点记录copy-and-swap技术：\ncppclass Widget {\npublic:\n    ...\n    Widget&amp; operator=(const Widget&amp; rhs)\n    {\n        Widget temp(rhs);//调用拷贝构造函数\n        swap(temp,*this);//调用swap函数\n        return *this;\n    }\n    ...\n};\n\nclass Object {\npublic:\n    ...\n    Object&amp; operator=(Object rhs)//传值调用，调用拷贝构造函数\n    {\n        swap(rhs,*this);//调用swap函数\n        return *this;\n    }\n    ...\n};\n确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。\n12 复制对象时勿忘其每一个成分Copying函数应该确保复制“对象内的所有成员变量”及“所有base class成分”。\n当编写Copying函数的时候，检查以下两点：\n\n复制所有的local成员变量\n调用所有的base class的Copying函数（容易忽视）\n\ncppclass B extends A {\npublic:\n    ...\n    B&amp; operator=(const B&amp; rhs)\n    {\n        A::operator=(rhs);//调用base class的Copying函数\n        ...\n        return *this;\n    }\n    B(const B&amp; rhs):A(rhs)//调用base class的Copying函数\n    {\n        ...\n    }\n    ...\n};不要尝试以某个copy函数实现另一个copy函数。应该将共同机能放进第三个函数，然后由两个copy函数共同调用它。\n三、资源管理一旦用了资源，在将来必须还给系统。\n13 以对象管理资源为了防止资源泄漏，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。\n通过谨慎地编写代码，确保资源在任何情况下都会被释放。这不但要消耗精力，而且还要软件开始接受维护被修改时常常会使得这种保证失效。因此需要通过把资源放到对象中，然后依赖C++的析构函数来确保资源被释放。\n以对象管理资源的两个关键想法：\n\n获得资源后立刻放进管理对象内。\n管理对象运用析构函数确保资源被释放。（请确保遵守条款8）\n\n两个常见的RAII class分别是std::shared_ptr和std::unique_ptr,前者通常是较佳选择，因为其copy行为比较直观。若选择std::unique_ptr，则需要使用std::move来进行转移。\n14 在资源管理类中小心copying行为并非所有的资源都是heap-based，对于那种资源来说，智能指针可能不是最佳选择。在某些时候，需要创建资源管理类。\n复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。\n当一个RAII对象被复制时，有哪些做法？\n\n禁止复制（不应该被复制）\n施行引用计数（保有资源直到最后一个引用者被销毁）\n复制底部资源（不再需要资源时进行释放）\n转移底部资源的拥有权（只希望有一个对象指向对应的资源）\n\n普遍而常见的RAII class copying行为是：抑制copying、施行引用计数、转移底部资源的ownership。\n15 在资源管理类中提供对原始资源的访问APIs往往要求访问原始资源，所以每一个RAII class都应该提供一个“取得其所管理之资源”的方法。\n对原始资源的访问可能经由显式转换或隐式转换。一般而言，显式转换比较安全，但是隐式转换对客户比较方便。\n提供显式转换还是隐式转换，主要取决于RAII class被设计执行的特定工作，以及它被使用的情况。提供对原始资源的访问，看似破坏了封装性，但其实RAII class的目的并不是为了封装，而是为了使资源释放一定会发生，因此提供对原始资源的访问是合理的。\n16 成对使用new和delete时要采取相同形式如果你在new后面使用[]，就要在delete后面使用[]；如果你在new后面不使用[]，就不要在delete后面使用[]。\n编译器需要知道，即将被删除的那个指针，指向的是一个对象，还是一个对象数组。单一对象的内存布局和数组对象的内存布局是不同的，数组一般有一个“数组大小记录”，因此需要告诉编译器，如何理解这段内存。\n\n\n\n\n\n\n\n注意\n尽量不要对数组形式做typedefs动作，因为这样会使得确定delete形式变得困难且易出错。\n\n\n17 以独立语句将newed对象置入智能指针以独立语句将newed对象置入智能指针。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄漏。\n原因如下：\ncppint priority();\nvoid processWidget(std::shared_ptr&lt;Widget&gt; pw, int priority);\n\n//调用processWidget\nprocessWidget(std::shared_ptr&lt;Widget&gt;(new Widget), priority());//可能会导致资源泄漏！！！调用processWidget的时候，编译器要做3件事：\n\n调用new Widget\n调用std::shared_ptr的构造函数\n调用priority\n\n可以确定new Widget的过程一定发生在std::shared_ptr构造函数之前。但是priority的调用时间在C++中并没有明确的规定。假设以这样的顺序调用：\n\n调用new Widget\n调用priority\n调用std::shared_ptr的构造函数\n\n万一priority抛出异常，那么new Widget产生的对象就会泄漏！！！因此，最好的做法是,将这个操作独立出来：\ncppstd::shared_ptr&lt;Widget&gt; pw(new Widget);\nprocessWidget(pw, priority());四、设计与声明18 让接口容易被正确使用，不易被误用理想上，如果客户调用了你的接口而没有获得预期的结果，那么这个代码就不该通过编译。如果代码通过了编译，它的作为就是客户想要的。\n好的接口容易被正确使用，不易被误用。你应该在你的所有接口中努力达成这些性质。\n“促进正确使用”的帮法包括接口的一致性，以及与内置类型的行为兼容。\n“阻止误用”的手法包括建立新类型、限制类型上的操作、束缚对象值以及消除客户的资源管理责任。\nstd::shared_ptr支持定制型删除器。这可防范DLL问题，可被用来自动解除互斥锁。\n19 设计class犹如设计typeclass的设计就是type的设计。在定义一个新type之前，请确定你已经考虑过本条款覆盖的所有讨论主题\n\n新type的对象应该如何被创建和销毁\n对象的初始化和对象的赋值应该有什么样的差别\n新type的对象如果被passed by value，意味着什么（拷贝构造函数的实现）\n什么是新type的“合法值”\n你的新type需要配合某个继承体系吗\n你的新type需要什么样的转换\n什么样的操作符和函数对你的新type是合理的\n什么样的标准函数应该被驳回\n谁该取用新type的成员\n什么是新type的“未声明接口”\n你的新type有多么一般化？（class或class template）\n你真的需要一个新type吗？\n\n20 宁以pass-by-reference-to-const替换pass-by-value尽量以pass-by-reference-to-const替换pass-by-value。前者通常比较高效，而且可以避免切割问题。\n原因如下，pass-by-value会导致对象的拷贝，会增加在函数中会招致额外的构造和析构成本。相比之下，pass-by-reference-to-const仅仅传递指针。同时，by-reference方式传递参数，可以避免切割问题：当一个derived class对象以by-value方式传递给一个base class对象时，base class的构造函数被调用，导致derived class对象被切割，损失其多态特性！！！\n其次，某些编译器的实现对待“内置类型”和“用户自定义类型”的态度截然不同（只把指针和内置类型放到寄存器内），保险起见，更应该使用pass-by-reference来传递对象来获得更好的性能。\n以上规则不适用于内置类型和STL迭代器和函数对象。对他们而言，pass-by-value往往比较合适。\n对于内置类型而言，pass-by-value比pass-by-reference效率高。STL也是如此，因为它们都被设计为pass-by-value。\n21 必须返回对象时，不要妄想返回reference绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象，或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。条款4已经为“在单线程环境中合理返回reference指向一个local static对象”提供了一个实例。\n如果返回一个指向local stack对象，那么该对象在函数退出时就已经被销毁。如果返回一个指向heap-allocated对象，那么谁来保证能释放这个对象？如果返回一个指向local static对象，不仅会导致线程安全问题，更加深层的问题是这个：\ncppconst Rational&amp; operator*(const Rational&amp; lhs, const Rational&amp; rhs)\n{\n    static Rational result;//local static对象\n    result = lhs.value() * rhs.value();\n    return result;\n}\n\nRational a, b, c, d;\n...\nif ((a * b) == (c * d)) {...}//该表达式永远为true！如果返回reference只是为了逃避必要的构造和析构的开销，那么其带来的后果比起这些开销要严重得多！况且在编译器的优化下，返回值的构造和析构的开销都有可能被消除，你的工作只有编写出行为正确的代码，返回值开销问题请交给编译器。\n22 将成员变量声明为private切记将成员变量声明为private。这可赋予客户访问数据的一致性，可细微划分访问控制，许诺约束条件获得保证，并提供class作者以充分的实现弹性。\n为什么不采用public成员变量呢？\n\n语法一致性：如果成员变量不是public，那么唯一能访问对象的就是成员函数。这样遵循了条款18。\n比起public成员变量，使用成员函数可以更精确的控制成员变量的处理，进行访问控制。\n保持了封装性，为“所有可能的实现”提供了弹性，维护了class的约束条件，修改实现时不会影响客户。\n\nprotected并不比public更具封装性。\n23 宁以non-member、non-friend替换member函数宁可拿non-member、non-friend函数替换member函数。这样做可以增加封装性、包裹弹性和机能扩充性。\n原因如下：\ncppclass WebBrowser {\npublic:\n    ...\n    void clearCache();\n    void clearHistory();\n    void removeCookies();\n    ...\n    void clearEverything();//member函数实现，调用上述三个函数\n};\n\nvoid clearBrowser(WebBrowser&amp; wb)//non-member函数实现\n{\n    wb.clearCache();\n    wb.clearHistory();\n    wb.removeCookies();\n}都是清理浏览器的操作，member实现和non-member,non-friend实现到底哪个好呢？面向对象的规则要求我们将数据和操作放在一起，使得一些人误以为member实现更加符合面向对象的规则，其实不然。在封装性上，non-member,non-friend实现能比member实现有更好的封装性！\n越少的代码可以访问数据，封装性就越好。那么如何测量“可以访问数据的代码”这一指标呢？作为一个粗糙的测量：越多的函数可以访问它，数据的封装性越低。因此，在提供相同功能的member和non-member,non-friend函数中做选择，导致较大封装性的一定是non-member,non-friend函数。\n此外，提供non-member函数可允许对WebBrowser相关的机能有较大的包裹弹性，导致较低的编译相依度，增加了WebBrowser的机能扩充性。\n对于上述例子，C++比较自然的做法是让clearBrowser这样的便利函数成为一个non-member,non-friend函数并位于WebBrowser的同一个namespace中。\n24 若所有参数皆需类型转换，请为此采用non-member函数如果你需要为某个函数的所有参数（包括被this指针所指的那个隐喻对象）进行类型转换，那么这个函数必须是个non-member函数。\n这在操作符重载中尤为重要。只有参数被位于参数列内，这个参数才是隐式转换的合格参与者，而this对象则不会被隐式转换！！！\n\n\n\n\n\n\n\n注意\n太多C++程序员假设，如果一个“与某class相关”的函数不是member函数，就该是个friend函数。但是其实没有必要一定是friend函数：\ncppclass Rational {...};\nconst Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs){\n    return Rational(lhs.numerator()*rhs.numerator(),lhs.denominator()*rhs.denominator());\n}不论何时，如果你可以避免friend函数，就该避免。虽然有时候friend函数是有需要的，但不能只因函数不该成为member，就自动将它变成friend。\n\n\n25 考虑写出一个不抛异常的swap函数当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常\nstd::swap函数是一个模板函数，调用的过程会导致一次拷贝构造和两次赋值操作。对于某些对象而言，这样的操作是不必要的，因此可以自己提供一个swap成员函数，以提高效率。由于swap的一个最好的应用是帮助class（和class templates）提供强烈的异常安全性保障，因此swap函数绝对不应该抛出异常，该约束只施行于成员版，不施行于非成员版，因为swap的缺省版是以copy构造函数和copy assignment操作符来实现的，这两者都允许抛出异常。\n如果你提供一个member swap，也该提供一个non-member swap用来调用前者。对于classes（而非templates），也特化一个std::swap。\n为了让他人调用swap的时候总是能取得我们提供的较高效的特定版本，这种做法不仅可以通过编译，还与STL容器具有一致性。因为STL容器也都提供有public swap成员函数和std::swap的特化版本（用以调用前者）。\ncppclass Widget {\npublic:\n    ...\n    void swap(Widget&amp; other){\n        using std::swap;\n        swap(impl,other.impl);\n    }\nprivate:\n    WidgetImpl* impl;\n};\n\nvoid swap(Widget&amp; a, Widget&amp; b)\n{\n    a.swap(b);\n}\n\n//因为Widget是一个class不是一个class template，所以需要特化std::swap。\n//如果是个class template，那就不必考虑特化std::swap的事了（编译不可能通过）\n//因为C++不能对function template进行偏特化，std::swap也不建议被重载，因为其行为是不确定的。\nnamespace std {\n    template&lt;&gt;\n    void swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)\n    {\n        a.swap(b);\n    }\n}调用swap的时候，应该针对std::swap使用using声明式，然后调用swap并且不带任何命名空间修饰。\n站在用户的角度，假设正在写一个templete函数，那么调用swap的时候，如何确保能够在T的专属版本存在的情况下调用T的专属版本，在T的专属版本不存在的情况下调用std::swap的一般化版本呢？\ncpptemplate&lt;typename T&gt;\nvoid doSomething(T&amp; lhs, T&amp; rhs)\n{\n    using std::swap;\n    ...\n    swap(lhs,rhs);//自动调用合适的版本\n    ...\n}在这种情况下，如果T有专属版本的swap，那么C++能够查到global作用域或T所在命名空间内的任何T专属swap版本。如果没有，那么C++会调用std::swap。即使如此，std::swap的T专属特化版的优先级也比std::swap的一般化版本高。\n为“用户定义类型”进行std templates全特化是好的，但是千万不要尝试在std命名空间内增加对std而言全新的东西（如重载std::swap）。\n五、实现写出定义和声明是花费心思最多的事，实现通常不会太花心思，然而：太快定义变量可能造成效率上的拖延，过度使用转型可能导致代码又慢又难以维护，返回对象handle可能会破坏封装并留给客户虚吊的号码牌。未考虑异常带来的冲击则可能导致资源泄漏和数据败坏，而过度使用inline可能导致代码膨胀，过度耦合可能导致冗长的编译时间。\n26 尽可能延后变量定义式的出现时间尽可能延后变量定义式的出现时间。这样做可增加程序清晰度并提高效率。\n一个变量被定义，通常意味着增加了构造和析构的成本。如果程序在 一个变量定义之后，使用之前 的过程中抛出了异常，那么这个变量就没有被使用，致使白白增加了构造和析构的成本。因此，尽可能延后变量定义式的出现时间，直到非得使用变量的前一刻为止，甚至延后到能给这份定义一个初值的时候（使用构造函数传递）。\n循环怎么办？下列两种写法：\ncppWidget w;\nfor(int i = 0; i &lt; n; ++i){\n    w = 取决于i的某个值；\n    ...\n}\n\nfor(int i = 0; i &lt; n; ++i){\n    Widget w(取决于i的某个值)；\n    ...\n}从成本上看，第一种做法的成本是：1个构造函数+1个析构函数+n个赋值操作；第二种做法的成本是n个构造函数+n个析构函数。在这种情况下要精心计算成本来进行选择。但是第一种做法会使得w的作用域变大，从而降低可理解性和易维护性。因此除非你知道赋值成本小于“构造+析构”成本，或是处理效率高度敏感的部分，否则应该使用第二种做法。\n27 尽量少做转型动作如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_cast。如果有个设计需要转型动作，试着发展出一个不需要转型的设计。\n原因如下，我们有可能写出下面这个看似正确的代码（在其他语言中还真有可能是对的），SpecialWindow的onResize要先调用Window的onResize，以此修改该对象的base class部分：\ncppclass Window {\npublic:\n    virtual void onResize() {...}\n    ...\n};\n\nclass SpecialWindow: public Window {\npublic:\n    virtual void onResize() {\n        static_cast&lt;Window&gt;(*this).onResize();//调用了*this的bass class成分的副本的onResize！！！错误的做法\n        //Window::onResize();//正确的做法\n        ...\n    }\n    ...\n};Window::onResize的功能修改了一些成员变量，但其实其改动的只是一个副本！！！\n再说dynamic_cast，它的许多实现效率非常低下（对class名字进行字符串比较）（因为要支持动态链接嘛）。而之所以dynamic_cast被需要，是因为想在你认定为derived class的对象上执行derived class的操作，但是手头上只有base class的指针。这种情况下，如何避免使用dynamic_cast呢？\n\n消除“通过base class接口处理对象”的需要。使用容器并在其中存放指向derived class对象的指针（通常是智能指针）。\n提供virtual函数来处理你想对各个派生类做的事。\n\n宁可以用C++-style转型，不要使用旧式转型，前者很容易被识别出来，而且也比较有着分门别类的职掌。\n转型动作分为3种：C风格的转型、函数风格的转型、C++风格的转型。前两者形式基本上除了括号的位置，没有什么区别，称为旧式转型。C++提供了4种新式转型：\n\nconst_cast，用来移除const性\ndynamic_cast，用来进行安全的向下转型\nreinterpret_cast，用来进行低级转型（不可移植）\nstatic_cast，用来进行隐式转型\n\n新的转型由于有固定的关键字因此易被找到，而且转型动作的目标更窄化，编译器也可以介入检查。\n\n\n\n\n\n\n\n注意\n“转型其实什么都没做，只是告诉编译器把某种类型视为另一种类型”是一个错误的观念！！！任何一个类型转换往往真的令编译器编译出运行期间执行的代码。如将int转换成double的操作，又如下面这种操作：\ncppclass Window { ... };\nclass SpecialWindow: public Window { ... };\nSpecialWindow ps;\nWindow* pw = &amp;ps;//隐喻地将SpecialWindow*转换成Window*注意，这里在C++中存在ps的值和pw的值不一致的情况！！！有一个偏移量被施加在了ps的值上用于得到pw的值。单一对象可能拥有多个地址，一旦使用多重继承，这件事几乎一直发生着（单一继承也有可能会）。因此也不应该以知道“对象在C++中如何布局”为前提，执行任何转型动作。\n\n\n如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需要自己执行转型。\n28 避免返回handles指向对象内部成分避免返回handles（包括references、指针、迭代器）指向对象内部。遵守这个条款可以增加封装性，帮助const成员函数的行为像个const，并将发生“虚吊号码牌”问题的机会减至最低。\n原因如下，返回handles指向对象内部，可能导致成员变量的封装性降低，因为成员变量的封装性最多等于“返回其reference的函数的封装性”。也可能导致“虽然调用const成员函数却造成对象状态被更改”。最后的关键在于，有一个handle被传出去了，是的代码暴露在“handle比其所指对象的寿命更长”的风险之下。\n29 为“异常安全”而努力是值得的异常安全函数即使发生异常也不会泄露资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型。\n\n基本型，如果异常被抛出，程序内的任何事物仍然保持在有效状态（但是对程序现实状态没有要求）。\n强烈型，如果异常被抛出，程序状态不会改变（让人联想到“事务”）\n不抛异常型，一定能完成它的工作，不会抛出异常。（作用在内置类型身上的所有操作都能提供该保证）\n\n可能的话，最好提供“不抛异常型”的保证，但是大部分函数而言，往往只能在“基本型”和“强烈型”中选择。\n“强烈保证”往往能够以copy-and-swap实现出来，但“强烈保证”并非对所有函数都可实现或具备现实意义。\ncopy一个副本并在副本上进行修改，然后swap副本和源对象。但是总有一些函数是无法实现“强烈保证”，除去copy-and-swap过程带来的效率问题，还有下面这种“连带影响”的问题导致的困难：\ncppvoid doSomething()\n{\n    ...\n    changeDataBase(...);//修改外部的数据库\n    changeLocal(...);//修改本地数据\n    ...\n}如果在changeDataBase的动作送出之后（即修改了非局部数据），一旦changeLocal抛出异常，没有什么办法恢复数据库的旧观（因为可能其他客户已经拿到这一笔新数据）。因此，这种情况下，只能提供“基本型”保证。\n函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。\n就像上述代码，假设changeDataBase不提供任何异常安全保证，那么doSomething也不可能提供任何异常安全保证。\n30 透彻了解inlining的里里外外将大多数inlining限制于小型、经常调用的函数上。这可使日后的调试过程和二进制升级更加容易，也能使潜在的代码膨胀问题的影响减至最低，使程序速度提升机会最大化。\n如果inline函数的本体很小，编译器针对函数本体所产生的代码可能比函数调用产生的代码还要小。因此，inline确实可能导致较小的目标码，和较高的指令cache命中率。但是inline只是对编译器的一个申请，并不是强制命令。\n另外，如果有一个inline函数在日后被修改，那么所有调用这个函数的地方都需要重新编译。而非inline函数只需要重新链接。\n\n\n\n\n\n\n提示\n虽然有时候编译器有意愿inline一个函数，但可能还是会给这个函数生成一个函数本体。\ncppinline void func(){...}\nvoid (*pf)() = f;\n\nf();//将被inline\npf();//或许不被inline，而是转移到函数本体执行此外，构造和析构函数不适合inline。构造函数有可能调用别的构造函数，且所做的工作偏多，一旦构造函数被inline，可能会导致代码膨胀。\n\n\n不要只因为function template被定义在头文件中，就为它们声明为inline。\nTemplate的具象化和inline无关。除非你认为所有根据此template生成的函数都应该被inline，否则不要为它们声明为inline（否则遭致不必要的成本）。\n\n\n\n\n\n\n提示\n总而言之，一开始先不要将任何函数声明为inline，慎重使用inline是对日后使用调试器带来帮助。作为开发者，需要找出可以有效增进程序整体效率的代码然后inline。\n\n\n31 将文件间的编译依存关系降至最低支持“编译依存关系最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是Handle class和Interface class。\n如果修改了一个class的定义式，那么所有依赖于这个class的文件都需要重新编译，为升级和维护带来巨大的影响。因此，我们需要将文件间的编译依存关系降至最低。\nHandle class的构想是“将对象的实现细目隐藏于一个指针背后”，对于一个样例Person而言，需要两个类来实现，一个用来提供接口，一个用来实现该接口。这样的话，就算PersonImpl的定义式发生了变化，使用了Person类的源文件也不需要重新编译：\ncpp//Person.h\n#include &lt;memory&gt;\n#include &lt;string&gt;\nclass PersonImpl;   //前置声明\nclass Person {      //handle class\npublic:\n  Person(const std::string&amp; name, int age);\n  ~Person();\n  std::string name() const;\n  int age() const;\n  int id() const;\nprivate:\n    std::unique_ptr&lt;PersonImpl&gt; pImpl;//指向PersonImpl的指针\n};\n\n//PersonImpl.h\n#include &lt;string&gt;\nclass PersonImpl {\npublic:\n  PersonImpl(const std::string &amp;name, int age);\n  ~PersonImpl();\n  std::string name() const;\n  int age() const;\n  int id() const;\nprivate:\n  std::string name_;\n  int age_;\n  int id_;\n};\n\n//Person.cpp\n#include \"Person.h\"\n#include \"PersonImpl.h\"\nPerson::Person(const std::string &amp;name, int age) : pImpl(new PersonImpl(name, age)) {}\nPerson::~Person() = default;\nstd::string Person::name() const { return pImpl-&gt;name(); }\nint Person::age() const { return pImpl-&gt;age(); }\nint Person::id() const { return pImpl-&gt;id(); }\n\n//PersonImpl.cpp\n#include \"PersonImpl.h\"\nstd::string PersonImpl::name() const { return name_; }\nint PersonImpl::age() const { return age_; }\nint PersonImpl::id() const { return id_; }\nPersonImpl::PersonImpl(const std::string &amp;name, int age) : name_(name), age_(age) {}\nPersonImpl::~PersonImpl() = default;\n\n//main.cpp\n#include &lt;iostream&gt;\n#include &lt;Person.h&gt;\nint main(){\n  Person p(\"Scott\", 25);\n  std::cout &lt;&lt; \"name: \" &lt;&lt; p.name() &lt;&lt; \" age: \" &lt;&lt; p.age() &lt;&lt; std::endl;\n  return 0;\n}\n\n\n\n\n\n提示\n编译依存性最小化的本质是：现实中让头文件尽可能自我满足，万一做不到，则让它与其他文件内的声明式（非定义式）相依。其他每一件事都源自于这个简单的策略：\n\n如果使用object reference或object pointer可以完成任务，那么就不要使用object。\n如果能够，尽量以class声明式替换class定义式。\n为声明式和定义式提供不同的文件。（标准库中只含声明式的那个头文件名称以fwd结尾）\n\n\n\n简而言之，假设你想定义一个Person类，Handle class的用法是：\n\n将Person的定义式放在Person.h中（class PersonImpl;）\n将PersonImpl的定义式放在PersonImpl.h中\n将Person成员函数的实现放在Person.cpp中（#include “PersonImpl.h”,#include “Person.h”）\n将PersonImpl成员函数的实现放在PersonImpl.cpp中（#include “PersonImpl.h”）\n客户使用Person功能的时候，只需要#include “Person.h”即可。\n\nInterface class的构想是实现想Java那样的Interfaces，Person的实现看起来像这样：\ncpp//Person.h\n#include &lt;memory&gt;\n#include &lt;string&gt;\nclass Person {      //Interface class\npublic:\n  virtual ~Person(){};\n  virtual std::string name() const = 0;\n  virtual int age() const = 0;\n  virtual int id() const = 0;\n  static std::unique_ptr&lt;Person&gt; create(const std::string &amp;name, int age);\n};\n\n//PersonImpl.h\n#include &lt;Person.h&gt;\n#include &lt;string&gt;\nclass PersonImpl : public Person {\npublic:\n  PersonImpl(const std::string &amp;name, int age);\n  ~PersonImpl();\n  std::string name() const;\n  int age() const;\n  int id() const;\nprivate:\n  std::string name_;\n  int age_;\n  int id_u;\n};\n\n//Person.cpp\n#include &lt;PersonImpl.h&gt;\nstd::unique_ptr&lt;Person&gt; Person::create(const std::string &amp;name, int age) {//工厂函数\n  return std::unique_ptr&lt;Person&gt;(new PersonImpl(name, age));\n}\n\n//PersonImpl.cpp\n#include \"PersonImpl.h\"\nstd::string PersonImpl::name() const { return name_; }\nint PersonImpl::age() const { return age_; }\nint PersonImpl::id() const { return id_u; }\nPersonImpl::PersonImpl(const std::string &amp;name, int age) : name_(name), age_(age) {}\nPersonImpl::~PersonImpl() {}\n\n//main.cpp\n#include &lt;Person.h&gt;\n#include &lt;iostream&gt;\nint main(){\n  std::unique_ptr&lt;Person&gt; p(Person::create(\"Scott\", 25));\n  std::cout &lt;&lt; \"name: \" &lt;&lt; p-&gt;name() &lt;&lt; \" age: \" &lt;&lt; p-&gt;age() &lt;&lt; std::endl;\n  return 0;\n}简而言之，假设你想定义一个Person类，Interface class的用法是：\n\n将Person的定义式放在Person.h中\nPersonImpl public继承Person，定义式放在PersonImpl.h中（#include “Person.h”）\n将Person的工厂函数放在Person.cpp中（#include “PersonImpl.h”）\n将PersonImpl成员函数的实现放在PersonImpl.cpp中（#include “PersonImpl.h”）\n客户使用Person功能的时候，只需要#include “Person.h”即可。\n\n程序库头文件应该以“完全且仅有声明式”的形式存在。这种做法不论是否涉及template都适用。\n例如C++标准库文件中的&lt;iosfwd&gt;，它只包含了iostream各组件的声明式，其对应的定义式则在&lt;iostream&gt;中。当你在某些 只需要 这些类声明，而不需要定义的地方（例如：自定义的头文件中），就可以简单的include这个头文件！我们写的库也应该提供这个文件。\n\n\n\n\n\n\n提示\n关于缺点：\n在Handle class中，每个函数调用都需要间接调用带来了效率问题，每个对象消耗的内存也会多一个指针的大小，还有动态内存分配以及释放的开销，以及遭遇bad_alloc的风险。\n在Interface class中，每次函数调用将多一个间接跳跃的成本，vptr也可能会增加对象的大小（如果除了Interface class之外有其他的virtual函数来源）。\nHandle classes或Interface classes，都不能充分利用inline函数。\n这些缺点看似是的本条款是个bad idea，但是实际上，在程序发展的时候使用Handle classes或Interface classes来降低实现码有所变化时对客户码的影响。当它们真正导致难以调和的速度或大小的问题时，再以具象类替换之。\n\n\n六、继承与面向对象设计32 确定你的public继承塑模出is-a关系“public继承”意味着is-a。适用于base class对象的地方必然适用于derived class对象，因为derived class对象就是base class对象。\nC++对于“public”继承严格奉行上述见解。如果你令“penguin”public继承“bird”，或是令“square”public继承“rectangle”，如果你发现你的代码中有“penguin”对象无法适用于“bird”对象的地方，例如“penguin”不会飞，而“bird”又有fly函数，那么它们之间就不适用于public关系。在这种情况下，即使编译器不报错，可能也会带来不正确的程序行为。\n33 避免遮掩继承而来的名称derived class内的名称会遮掩base class内的名称。在public继承下从来没有人希望如此。\nderived class的作用域包裹在base class内，所以只要是derived class内与base class同名的就会覆盖掉。假设你要覆写的成员函数在基类有重载，则在覆写的时候会一并失去那些重载！如果使用public继承而又不继承那些重载函数，那就违反了“public继承意味着is-a”的原则。\n为了让遮掩的名称再次见诸世面，可以使用using声明式或转交函数。\ncppclass Base {\npublic:\n    void mf1() const;\n    void mf1(int)const;\n    void mf2(int);\n};\nclass Derived : public Base {\npublic:\n    using Base::mf1;    //如果没有这一行，Derived将没有mf1(int)函数\n    void mf1() const;\n    void mf2(int);\n    void mf3() const;\n};在public继承下，你必须继承所有的base class函数。然而在private继承下，你可以选择性的继承base class的函数，这种情况下，using声明式并不适用。这时应该使用转交函数：\ncppclass Derived : private Base {\npublic:\n    void mf1(int x) { Base::mf1(x); }//转交函数\n    ...\n};\n\n\n\n\n\n\n注意\n当继承结合templates，又会面对“继承名称被遮掩的”新问题，关于“角括号定界”的所有问题见条款43。\n\n\n34 区分接口继承和实现继承接口继承和实现继承不同，在public继承之下，derived class总是继承base class的接口。\npure virtual函数只具体指定接口继承。\n简朴的（非纯）impure virtual函数具体指定接口继承及缺省实现继承。\n上述是一般的缺省情况，有的时候我们希望为子类提供一个通用的接口函数但是不希望它是缺省的实现。并且在子类忘记定义该函数的时候使编译器提出警告。这就需要切断“virtual 函数接口”和其“缺省实现”之间的连接，下面是一种做法：\ncppclass Airplane{\npublic:\n    virtual void fly(const Airport &amp; destination) = 0 ;\n    ...\nprotected:\n    void defaultFly(const Airport &amp; destination);\n}\n\nvoid Airplane::defaultFly(const Airport &amp; destination){//通用的接口\n    ...\n}non-virtual函数具体指定接口继承及强制实现继承。\n任何derived class的non-virtual函数都不应该尝试改变bass class的行为。\n\n\n\n\n\n\n\n注意\nclass设计者的两个认知错误：\n\n将可能作为base class的所有函数声明为non-virtual，使得derived class难以进行特化\n将所有成员函数声明为virtual（有时候是对的），可能某些函数就是不该在derived class中被重新定义。\n\n\n\n35 考虑virtual函数以外的选择当你为解决问题而寻找某个设计方法时，不妨考虑virtual函数的替代方案。\n\n使用NVI手法，以public non-virtual成员函数包裹较低访问性（protected或private）的virtual函数。\n将virtual函数替换为函数指针。\n将virtual函数替换为tr1::function对象。\n将继承体系内的virtual函数替换为另一个继承体系内的virtual函数。\n\n它们各有各的优点，在设计的时候，请将它们和虚函数的方案一同考虑。\n36 绝不重新定义继承而来的non-virtual函数non-virtual函数是静态绑定，而virtual函数是动态绑定。如果你重新定义了一个non-virtual函数，那么就会导致“继承体系内的函数行为不一致”。\n37 绝不重新定义继承而来的缺省参数值继承而来的缺省参数值在编译期间就已经确定了，而virtual函数的调用却是在运行期间决定的。\n你只能继承virtual函数和non-virtual函数，而条款36已经说了不要重新定义non-virtual函数。因此，讨论的问题是如何继承一个带有缺省参数值的virtual函数。\n编译器为了效率，函数的缺省值会在编译期决定。有可能造成这样的结果，调用一个定义在derived class中的函数，却使用了base class中的缺省值！\n\n\n\n\n\n\n\n注意\n如果你的设计需要定义一个带有缺省参数值的virtual函数，那么你的设计可能有问题。\ncppclass Shape {\npublic:\n    enum ShapeColor {Red, Green, Blue};\n    virtual void draw(ShapeColor color = Red) const = 0;\n    ...\n};\n\nclass Rectangle : public Shape {\npublic:\n    virtual void draw(ShapeColor color = Red) const;\n    ...\n};这个设计似乎遵守了本条款，但是它的问题在于，代码冗余且耦合性高。何不尝试下面的NVI设计：\ncppclass Shape {\npublic:\n    enum ShapeColor {Red, Green, Blue};\n    void draw(ShapeColor color = Red) const { doDraw(color); }\n    ...\nprivate:\n    virtual void doDraw(ShapeColor color) const = 0;\n};\n\nclass Rectangle : public Shape {\nprivate:\n    virtual void doDraw(ShapeColor color) const;\n    ...\n};\n\n\n38 通过复合塑模出has-a或“根据某物实现出”复合的意义和public继承的意义是完全不同的。\n复合是类型之间的一种关系，表现为某种类型的对象内含另一种类型的对象。\n在应用域，复合意味has-a。在实现域，复合意味“根据某物实现出”。\n比如说一个person类，有一个string类的名字，这就是has-a的关系；假设你在使用list来实现set，你不能用public继承来塑模他们，因为这样的话你会继承list的所有接口，你应该将list作为set的一个成员来复合，这就是“根据某物实现出”。\n39 明智而审慎地使用private继承private继承意味着is-implemented-in-terms-of。它通常比复合的级别低。但是当derived class需要访问protected base class的成员，或需要重新定义继承而来的virtual函数时，private继承是合适的。\n如果class之间的继承关系是private，编译器不会自动将一个derived class对象转换为base class对象。并且由private继承而来的成员在derived class中的访问级别是private的。\n因此，private继承意味着“is-implemented-in-terms-of”，意思是derived class对象的实现依赖于base class对象的实现。private继承在软件的“设计”层面没有意义，它只有在软件的“实现”层面才有意义。\n既然private继承和复合的意义相似（is-implemented-in-terms-of），如何在这两者之间取舍呢？答案是：尽可能使用复合，必要时使用private继承。何时必要呢：当derived class需要访问protected base class的成员，或需要重新定义继承而来的virtual函数时！\n和复合不同，private继承可以造成empty base class最优化。这对致力于“对象尺寸最小化”的程序库开发者来说是个重要的考量。\n面对一个大小为0的独立（非附属）对象，C++官方默认安插一个char到空对象内，以确保每个对象在内存中的地址都是独一无二的。这样的话无疑对内存敏感的程序库开发者来说是个问题。使用private继承来实现，可以避免这个问题，也就是所谓的EBO。\n40 明智而审慎地使用多重继承多重继承比单一继承更复杂。它可能导致新的歧义性，以及对virtual继承的需要。\n歧义自不必说，virtual继承是怎么回事呢？假设你有一个class D，它public继承了两个class B和C，而B和C又public继承了A。那么D中就会有两个A的副本，这就是所谓的“菱形继承”。为了解决这个问题，C++提供了virtual继承，这样的话，D中就只有一个A的副本了。这样的关系在标准库的basic_ios、basic_istream、basic_ostream、basic_iostream之间就有体现。\nvirtual继承会增加大小、速度、初始化复杂度。如果virtual base class不带任何数据，将是最具实用价值的情况。\n然而为了避免继承得来的成员变量重复，编译器会做出幕后工作。这种virtual继承同时也伴随着内存和速度的损失，且初始化也非常不直观。因此，不必要的时候不要使用virtual base。平常请使用non-virtual继承，如果必须使用virtual base class，请确保它不带任何数据。\n多重继承的常见用途有：为“public继承”塑模出“接口继承”和private继承某个协助实现的class的两相组合。\ncppclass Iperson {\npublic:\n    virtual ~Iperson() ;\n    virtual std::string name() const = 0;\n    virtual std::string birthDate() const = 0;\n    ...\n};\n\nclass DatabaseID {...};\n\nclass PersonInfo {\npublic:\n    explicit PersonInfo(DatabaseID pid) : pid_(pid) {}\n    virtual ~PersonInfo();\n    virtual const char * theName() const ;\n    virtual const char * theBirthDate() const ;\n    virtual const char * valueDelimOpen() const ;\n    virtual const char * valueDelimClose() const ;\n    ...\n};\n\nclass Cperson : public Iperson, private PersonInfo {\npublic:\n    explicit Cperson(DatabaseID pid) : PersonInfo(pid) {};\n    virtual std::string name() const{return PersonInfo::name();}//实现必要的Iperson成员函数\n    virtual std::string birthDate() const{return PersonInfo::birthDate();}//实现必要的Iperson成员函数\nprivate:\n    const char * valueDelimOpen() const {return \"&lt;\";}//重新定义继承而来的virtual“界限函数”\n    const char * valueDelimClose() const {return \"&gt;\";}\n};七、模板与泛型编程41 了解隐式接口和编译期多态classes和templates都支持接口和多态。\nclass的接口在源码中可见，可谓显式接口。而templates的接口则是隐式的。class的多态发生在运行期（运行期多态），而templates的多态发生在编译期（编译期多态）。\n对classes而言，接口是显式的，以函数签名为中心。多态则是通过virtual函数发生在运行期。\n显式接口由函数签名式（函数名称、参数类型、返回类型）构成。\n对template参数而言，接口是隐式的，奠基于有效表达式。多态则是通过template具现化和函数重载解析发生在编译期。\n隐式接口基于有效表达式，这些有效表达式需要在template中找到并确保其有效性。\n42 了解typename的双重意义声明template参数时，class和typename没有区别\n请使用关键字typename标识嵌套从属类型名称；但不得在base class list或member initialization list内以它作为base class修饰符。\n43 学习处理模板化基类内的名称可在derived class template中通过“this-&gt;”指涉base class template内的成员名称。或籍由一个明白的base class名称指涉该名称。\n面对“指涉base class member”之无效references，编译器的诊断时间可能发生在早期（当解析derived class template的定义式时），也可能发生在晚期（当那些templates被特定之template实参具现化时）。C++的政策宁愿是早诊断，因此当“base class从template中被具现化时”，它假设它对那些base class的内容毫无所悉。\n44 将与参数无关的代码移出templatestemplate生成多个classes和多个函数，所以在任何template代码都不该于某个造成膨胀的template参数产生相依关系。\n看如下代码：\ncpptemplate&lt;typename T , std::size_t n&gt;\nclass SquareMatrix {\npublic:\n    void invert();\n    ...\n};这个类的invert函数的实现可能会依赖于n的值，这样就会导致代码膨胀。因此，我们应该将invert函数的实现移出template。\n因非类型模板参数而产生的代码膨胀，往往可以被消除，做法是以函数参数或class成员变量替换template参数。\n因类型参数而产生的代码膨胀，往往可以被降低，做法是让带有完全相同二进制表述的具现类型共享一个实现码。\n45 运用成员函数模板接受所有兼容类型请使用member function templates生成“可接受所有兼容类型”的函数。\n如果你声明member templates 用于“泛化copy构造”或“泛化assignment操作”，你还是需要声明一个正常的copy构造函数和copy assignment操作符。\n46 需要类型转换时请为模板定义非成员函数当我们编写一个class template，而它所提供之“与此template相关的”函数支持“所有参数之隐式类型转换”时，请将那些函数定义为“class template内部的friend函数”。\n47 请使用traits classes表现类型信息traits class 使得“类型相关信息”在编译期可用。它们以templates和“templates特化”完成实现。\n整合重载技术（overloading）后，traits class有可能在编译期对类型执行if…else测试。\n48 认识template 元编程template metaprogramming可以将工作由运行期移往编译期，因而得以实现早期错误侦测和更高的性能。\nTMP可被用来生成“基于政策选择组合”的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码\n八、定制new和delete49 了解new-handler的行为set_new_handler允许客户指定一个函数,在内存分配无法获得满足时被调用。\ncppvoid outOfMem(){\n    std::cerr &lt;&lt; \"Unable to satisfy request for memory\\n\";\n    std::abort();\n}\n\nint main(){\n    std::set_new_handler(outOfMem);\n    ...\n    int *pBigDataArray = new int[100000000L];\n}c++中，new-handler是一个错误处理函数，默认值是null，即不做任何处理并抛出异常。通过set_new_handler可以设置一个新的new-handler，当内存分配失败时，会反复调用这个函数直到申请成功。一个设计良好的new-handler必须做到以下几点：\n\n让更多内存可用（一个做法是：程序开始执行的时候就分配一大块内存，调用new-handler时，释放这部分内存）\n安装另一个new-handler（本new-handler无法处理时，可能的话，交给另一个new-handler）\n卸除new-handler（如果new-handler处理不了，则卸除。这将在new无法分配内存时抛出异常）\n抛出bad_alloc异常（这样的异常不会被new捕获，会被传播到内存索取处）\n不返回（abort或者exit）\n\n有的时候我们希望不同的类在内存分配失败的时候调用特定的new-handler，这该如何实现呢？\ncppclass NewHandlerHolder {//基于RAII的new-handler管理类\npublic:\n    explicit NewHandlerHolder(std::new_handler nh) : handler(nh) {}\n    ~NewHandlerHolder() { std::set_new_handler(handler); }\nprivate:\n    std::new_handler handler;\n    NewHandlerHolder(const NewHandlerHolder&amp;);\n    NewHandlerHolder&amp; operator=(const NewHandlerHolder&amp;);\n};\n\nclass Widget {//要特化new-handler的类\npublic:\n    ...\n    static std::new_handler set_new_handler(std::new_handler p) throw();\n    static void * operator new(std::size_t size) throw(std::bad_alloc);\nprivate:\n    static std::new_handler currentHandler;//用于保存当前new-handler，静态成员将在class外定义\n};\n\nstd::new_handler Widget::currentHandler = 0;//静态成员将在class外定义\n\nstd::new_handler Widget::set_new_handler(std::new_handler p) throw() {//用于设置class专属的new-handler\n    std::new_handler oldHandler = currentHandler;\n    currentHandler = p;\n    return oldHandler;\n}\n\nvoid * Widget::operator new(std::size_t size) throw(std::bad_alloc) {//运算符new重载\n    NewHandlerHolder h(std::set_new_handler(currentHandler));\n    return ::operator new(size);\n}上述方法是一种。然而我们还可以设计一个“mixin”风格的基类，让所有继承该基类的类都能够有上述的功能（特化自己的new-handler）。被称为“怪异的循环模板模式”。\ncpptemplate &lt;typename T&gt;\nclass NewHandlerSupport {\npublic:\n    static std::new_handler set_new_handler(std::new_handler p) throw();\n    static void * operator new(std::size_t size) throw(std::bad_alloc);\nprivate:\n    static std::new_handler currentHandler;\n};\n\ntemplate &lt;typename T&gt;\nstd::new_handler NewHandlerSupport&lt;T&gt;::set_new_handler(std::new_handler p) throw() {\n    std::new_handler oldHandler = currentHandler;\n    currentHandler = p;\n    return oldHandler;\n}\n\ntemplate &lt;typename T&gt;\nvoid * NewHandlerSupport&lt;T&gt;::operator new(std::size_t size) throw(std::bad_alloc) {\n    NewHandlerHolder h(std::set_new_handler(currentHandler));\n    return ::operator new(size);\n}\n\ntemplate &lt;typename T&gt;\nstd::new_handler NewHandlerSupport&lt;T&gt;::currentHandler = 0;\n\nclass Widget : public NewHandlerSupport&lt;Widget&gt; {//令Widget继承NewHandlerSupport，即可获得特化new-handler的能力\n    ...\n};上述代码可能有一个疑问，NewHandlerSupport中并没有用到类型T，那么为什么要用模板呢？这是因为我们希望每个继承自NewHandlerSupport的类都有互异的NewHandlerSupport附件，而不是共享一个。template机制会为每一个参数T生成一份currentHandler！！！\nNothrow new是一个颇为局限的工具，因为它只适用于内存分配；后继的构造函数调用却可能抛出异常。所以没有运用Nothrow new的需要\n50 了解new和delete的合理替换时机为什么要写个自定的new和delete呢？\n有多个理由需要写个自定的new和delete，包括改善效能、对heap的错误使用进行调试、收集heap使用统计资料等等\n理由如下：\n\n检测运用上的错误\n收集动态分配内存之使用统计信息\n增加分配和归还的速度\n降低缺省内存管理器带来的空间额外开销\n弥补缺省分配器中的非最佳对齐位\n将相关对象成簇集中\n获得非传统行为\n\n51 编写new和delete时需固守常规如果要写自定的new和delete，那么应该遵循什么规则呢？\noperator new应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足需求，就该调用new-handler。它也应该有能力处理0 byte的请求，Class专属版本则还应该处理“比正确大小更大的（错误）申请”。\n一个示例的operator new：\ncppclass Base {\npublic:\n    static void * operator new(std::size_t size) throw(std::bad_alloc);\n    ...\n};\n\nvoid * Base::operator new(std::size_t size) throw(std::bad_alloc) {\n    using namespace std;\n    if (size != sizeof(Base))//判断是否被用来初始化derived class对象（顺便判断是否0-byte请求）\n        return ::operator new(size);//使用std的operator new\n    while (true) {\n        /*尝试分配内存*/\n        if (/*分配成功*/) return mem;\n        \n        //分配失败，调用new-handler\n        new_handler globalHandler = set_new_handler(0);\n        set_new_handler(globalHandler);//多线程条件下，视情况加锁\n        if (globalHandler) (*globalHandler)();\n        else throw bad_alloc();\n    }\n}如果要写一个operator new[],那么要做的仅仅是分配一块未加工的内存。还要考虑包含额外的空间用来存放数组的长度。\noperator delete应该在收到null指针时不做任何事。Class的专属版本则还应该处理“比正确大小更大的（错误）申请”。\n一个示例的operator delete：\ncppvoid Base::operator delete(void *rawMemory) throw() {\n    if (rawMemory == 0) return;//空指针不做任何事\n    if (size != sizeof(Base))//判断是否被用来初始化derived class对象\n    {\n        ::operator delete(rawMemory);\n        return;\n    }\n    /*释放内存*/\n    return;\n}\n\n\n\n\n\n\n注意\n如果即将被删除的对象派生自某个base class，而后者缺乏一个virtual析构函数，那么C++传给operator delete函数的参数的值就不对，可能会导致程序行为不正常。务必遵守条款7！！！\n\n\n52 写了placement new也要写placement delete当你写一个placement operator new时，请确定也写出了对应的placement operator delete。如果没有这样做，你的程序可能会发生隐微而时断时续的内存泄漏。\n看看这个语句：\ncppWidget *pw = new Widget;首先调用了operator new，然后调用了Widget的构造函数。如果Widget的构造函数抛出异常，那么C++的运行期系统会自动调用参数个数和类型都与operator new相同的operator delete来释放内存，如果没有找到合适的operator delete，则什么都不做，这就会导致内存泄漏。因此，务必写出对应的placement operator delete。\n\n\n\n\n\n\n\n注意\n注意下面这种写法可能被忽视：\ncppWidget *pw = new(std::cout) Widget;//调用了placement operator new\ndelete pw;//没有调用placement operator delete，可能导致内存泄漏\n\n当你声明placement new和placement delete时，请确定不要无意识（非故意）地遮掩了它们的正常版本。\n参考条款33\n九、杂项53 不要轻易忽视编译器的警告严肃对待编译器发出的警告信息，努力在你的编译器的最高警告级别下争取“无任何警告”的荣誉。\n不要过度依赖编译器的警告信息，因为不同编译器对待事情的态度不同，一旦移植到另一个编译器上，可能就没警告了。\n54 让自己熟悉包括TR1在内的标准程序库C++标准组件库的主要机能由STL、iostreams、locales组成。并包含C99标准查询库。\nTR1增加了许多新的组件，包括智能指针、一般化函数指针、hash-base容器、正则表达式以及另外10个组件。\nTR1自身只是一个规范。为获得TR1提供的好处，你需要一个份实物，如Boost。\n55 让自己熟悉Boost","slug":"《Effective-C-》读后总结","date":"2024-02-03T08:12:24.000Z","categories_index":"C++","tags_index":"C++进阶","author_index":"Ac-Accelerator"},{"id":"cee75310a6ad538e1f2e1c9426d13379","title":"Spring Boot","content":"Spring BootSpring Boot是什么上文关于Spring的介绍中提过，Spring是一个开发的生态圈，它提供了若干个项目，每个项目可以完成独立的功能。其中一个就是Spring Boot，它是一个快速构建项目的框架，让开发者可以在简化开发的基础上更进一步加速开发。在原有的基础上使开发更加简单，写更少的代码。\nSpring Boot创建这个页面是Spring Boot的官方创建页面，可以在非常方便的创建一个Spring Boot项目。在这个页面中，按照自己的需求填写相关信息，然后点击Generate，就可以下载一个Spring Boot项目的压缩包。\n除了在官方页面中创建，也可以在IDEA或Vscode中创建。其实IDE也是调用了官方的创建页面。因此，创建Spring Boot项目是需要联网的。（虽然也可以不联网手写，但是这已经失去了Spring Boot为开发者带来便利的初衷了。）\n从官方页面中下载的压缩包解压后，可以看到如下的目录结构：\ntxtdemo\n├── HELP.md\n├── mvnw\n├── mvnw.cmd\n├── pom.xml\n└── src\n    ├── main\n    │   ├── java\n    │   │   └── com\n    │   │       └── example\n    │   │           └── demo\n    │   │               └── DemoApplication.java\n    │   └── resources\n    │       ├── application.properties\n    │       ├── static\n    │       └── templates\n    └── test\n        └── java\n            └── com\n                └── example\n                    └── demo\n                        └── DemoApplicationTests.java\n\n14 directories, 7 filesSpring Boot Web开发Spring Boot的方便之处就在于，在简单创建Spring Boot项目后，不用更改其他设置，只需要简单的编写类，就可以实现一个简单的Web应用。\n在新建Spring Boot项目（要选择 Spring Web）后，接着新建一个类com.example.controller.UserController,写入如下代码（Spring MVC开发）：\njava@RestController\n@RequestMapping(\"/user\")\npublic class UserController {\n    @GetMapping(\"/{id}\")\n    public String getUserById(@PathVariable String id) {\n        return \"user + \" + id;\n    }\n}点击运行即可跑起一个简单的Web应用。在浏览器中输入localhost:8080/user/1，即可看到返回的结果。\n上述例子可以看到，Spring Boot简化了Spring Mvc的开发，并不需要像Spring Mvc那样需要编写配置类、手动添加依赖，配置Tomcat。框架的好处不就在于能自动完成这些繁琐的工作吗？就算不去配置也能达到大部分人想要的效果。\nSpring Boot原理Spring Boot能够简化开发，那么它是如何做到的呢？\n在项目的创建过程中，Spring Boot以图形化的界面让开发者选择需要的功能，然后根据开发者的选择，自动添加依赖。这些依赖项就在pom.xml文件中，如下：\nxml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;3.1.5&lt;/version&gt;\n        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n    &lt;/parent&gt;\n    &lt;groupId&gt;com.example&lt;/groupId&gt;\n    &lt;artifactId&gt;demo&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;name&gt;demo&lt;/name&gt;\n    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n    &lt;properties&gt;\n        &lt;java.version&gt;17&lt;/java.version&gt;\n    &lt;/properties&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n首先看到 &lt;parent&gt;标签,表明该配置文件从spring-boot-starter-parent继承了一系列的属性和配置。\n可以查看spring-boot-starter-parent-x.x.x.pom,里面基本上都是一些maven插件的配置，该pom文件的&lt;parent&gt;标签表明它从spring-boot-dependencies继承了一系列的依赖项。\n查看spring-boot-dependencies-x.x.x.pom，可以看到这个pom文件提供了依赖管理的功能，它定义了常用的第三方库的版本号，保证这些库在版本方面互相兼容（所以导入常用的第三方库时可以不用写版本号）。\n回到pom.xml文件，接着看到&lt;dependencies&gt;标签，这里面就是项目的依赖项，可以看到spring-boot-starter-web，这个依赖项包含了Spring Boot Web开发所需要的依赖项，而spring-boot-starter-test则是测试所需要的依赖项。\n在插件的部分可以看到spring-boot-maven-plugin，这个插件的功能有：把项目打包成可执行的jar或war文件、运行Spring Boot应用程序、生成构建信息并在运行集成测试之前启动Spring Boot应用程序，该插件默认包含在Spring Boot项目的pom.xml文件中。\n由此可见，Spring Boot工程的pom.xml文件：\n\n通过继承spring-boot-starter-parent，定义了常用的第三方库的版本号，使我们不用关系版本依赖问题；定义了一些maven插件，简化了开发者的工作。\n通过导入spring-boot-starter-xxx依赖项，批量导入了实现对应功能所需要的常用依赖项。\n通过导入spring-boot-maven-plugin插件，实现了打包成可执行的jar或war文件、运行、测试等功能。\n\n现在来回答为什么在Spring Boot中不用配置Tomcat就能运行Web应用的问题。在spring-boot-starter-web依赖项中，有一个spring-boot-starter-tomcat依赖项，这个依赖项中包含了内嵌的Tomcat。因此，Spring Boot中不需要配置Tomcat，就可以运行Web应用。这是Spring Boot为开发者提供的辅助功能。\n而且，在Spring Boot中，不仅仅是Tomcat，还可以内嵌Jetty、Undertow等容器。拿Jetty来说，需要对pom.xml文件进行如下配置：\nxml        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n            &lt;exclusions&gt;\n            &lt;!-- 排除掉默认的tomcat起步依赖 --&gt;\n                &lt;exclusion&gt;\n                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;\n                &lt;/exclusion&gt;\n            &lt;/exclusions&gt;\n        &lt;/dependency&gt;\n        &lt;!-- 添加jetty的起步依赖 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- 虽然jetty的起步依赖包含了jakarta.servlet-api，但是由于版本版本匹配问题，需要覆盖掉默认的依赖 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;jakarta.servlet&lt;/groupId&gt;\n            &lt;artifactId&gt;jakarta.servlet-api&lt;/artifactId&gt;\n            &lt;version&gt;5.0.0&lt;/version&gt;\n            &lt;scope&gt;compile&lt;/scope&gt;\n        &lt;/dependency&gt;这样，在点击启动的时候就可以使用jetty容器了。由此可见Spring Boot项目在换技术栈的时候，也是非常方便的。\n\n\n\n\n\n\n提示\n如果要更改起步依赖所包含的依赖项的版本（如jakarta.servlet-api的版本），除了可以向上面那样直接覆盖，还可以在pom.xml文件的 &lt;properties&gt;属性中添加：\nxml    &lt;properties&gt;\n        &lt;jakarta-servlet.version&gt;5.0.0&lt;/jakarta-servlet.version&gt;\n    &lt;/properties&gt;这两者可以达到同样的效果。\n\n\nSpring Boot配置在Spring Boot中，可以通过修改配置文件来对项目的属性进行配置。Spring Boot提供了三种格式的配置文件：application.properties、application.yml、application.yaml。它们一般都存放在src/main/resources目录下，且文件名都为application。它们虽然拓展名不同，格式也不同，但是都能提供相同的功能。\nYAML是一种层级格式，它和.properties很容易互相转换，它的优点是去掉了大量重复的前缀，并且更加易读。\n但是，如果同时存不同格式的配置文件，优先级是application.properties &gt; application.yml &gt; application.yaml。而且并不会合并，只会使用优先级最高的那个。\n这是一个yaml配置文件的实例\nyaml# application.yaml\n\nserver:\n  port: 8081\n\nspring:\n  application:\n    name: test\n  datasource:\n    url: jdbc:hsqldb:file:testdb\n    username: root\n    password: 123456\n    driver-class-name: org.hsqldb.jdbc.JDBCDriver\nspring boot 编译的jar包是可以运行的，而可以通过传入运行时参数来修改配置。如，想把服务器的端口修改为8081端口。在运行时可以这样写：\ntxtjava -jar jar包文件名 --server.port=8081配置文件的内容还可以在Bean中读取，如：\njava@Component\n@ConfigurationProperties(prefix = \"spring.datasource\")\npublic class DataSourceProperties {\n    private String url;\n    private String username;\n    private String password;\n    private String driverClassName;\n    // getter and setter\n}这样配置文件中的内容就会被读取到Bean中。还有其他的用法，这里仅仅例举一种。\n","slug":"Spring-Boot","date":"2023-11-01T14:25:33.000Z","categories_index":"Java","tags_index":"Java,Web开发,Spring","author_index":"Ac-Accelerator"},{"id":"2131252b43aa75d3feeb9162c4eec1e2","title":"Java Spring","content":"什么是SpringSpring是一个开发的生态圈，它提供了若干个项目，每个项目可以完成独立的功能。开发者可以选择其中的一个或多个项目来使用其提供的功能，以完成开发任务。（即完全在Spring提供的解决方案下，把项目构建出来，并设计开发完成），因此Spring可以简化开发。并提供很高的灵活性和安全性。\n从这个页面可以看到Spring生态圈中的各个项目，其中Spring有3个十分重要的项目：Spring Framework、Spring Boot、Spring Cloud：\n\nSpring Framework，一个底层的，设计型的框架，其他的所有的项目都是依赖Spring Framework执行的。\nSpring Boot，它是一个快速构建项目的框架，让开发者可以在简化开发的基础上更进一步加速开发。在原有的基础上使开发更加简单，写更少的代码。\nSpring Cloud，它是一个分布式开发的框架。\n\nSpring Framework\n\nTest：单元测试与集成测试\nCore Container：核心容器\nAOP：面向切面编程\nAspects：AOP思想实现\nWeb：Web开发\nData Access/Integration：数据访问与集成\n\n知道Spring Framework是一个项目，想要使用它，就需要引入它的库。将对应的坐标添加到pom.xml中即可，该坐标可在maven中央仓库中复制（带有RELEASE的是稳定版）：\nxml    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n      &lt;version&gt;5.2.25.RELEASE&lt;/version&gt;\n    &lt;/dependency&gt;Core ContainerCore Container是做什么的呢？在回答这个问题之前需要先了解一个概念：IoC。\n试想这样一个场景：\njavapublic class Service {\n    final static String url = \"jdbc:mysql://localhost:3306/permission?useSSL=true&amp;serverTimezone=UTC\";\n    final static String username = \"root\";\n    final static String password = \"123456\";\n    ...\n}\n\npublic class MyServlet1 extends HttpServlet {\n    private Service service = new Service();\n\n    public void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        long id = getFromCookie(req);\n        String password = service.searchPassword(req);\n    }\n}\n\npublic class MyServlet2 extends HttpServlet {\n    private Service service = new Service();\n\n    public void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String password = service.searchUsername(req);\n    }\n}上述代码中，两个MyServlet类都使用了new来初始化一个Service对象来使用其方法，这样会导致代码的耦合性变高，因为如果该Service类的构造函数被修改了，那么这两个MyServlet类也需要进行修改。而且这两个MyServlet类明明可以使用同一个Service对象啊，每次都new一个系统效率低，但如果一个Service对象被多个组件共享，销毁释放资源又是一个难题。随着更多的组件被引入，组件的依赖关系会越来越复杂，系统效率会不断降低。\n\n\n\n\n\n\n提示\n如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。\n如何解决呢？\n不要使用new产生对象，转而由外部容器产生对象并注入到需要使用的组件中。以此完成解耦！\n\n\nIoC：控制反转，把对象的创建交给外部，由外部来创建并管理对象。\nSpring对IoC进行了实现。其Core Container就是一个IoC容器，也就是IoC思想中的外部。被Spring管理的对象称为Bean。在Bean和Bean之间建立依赖关系的行为称为依赖注入。最终使得在使用对象的时候，不仅可以直接从IoC容器中获取，而且获取到的对象已经自动绑定了所有的依赖。\n\n\n\n\n\n\n哪些Bean适合交给Spring管理？哪些不适合？\n适合适合交给Spring管理：\n\n表现层对象\n业务层对象\n数据层对象\n工具对象\n\n不适合交给Spring管理：\n\n封装实体的域对象\n\n\n\n了解了上述概念之后，接下来的问题是，在编写了一个类后，如何让Spring来管理它呢？\n\n在类上添加注解@Component，表示该类是一个Bean，需要被Spring管理。（常用）\n使用xml配置文件，将类的全限定名添加到xml文件中，表示该类是一个Bean，需要被Spring管理。（最原始最底层）\n\n本文介绍的是第一种方式，即使用注解的方式。\n这是案例的项目结构：\ntxt├── pom.xml\n└── src\n    └── main\n        ├── java\n        │   └── org\n        │       └── example\n        │           ├── App.java\n        │           ├── config\n        │           │   └── AppConfiguration.java\n        │           ├── dao\n        │           │   ├── impl\n        │           │   │   └── UserDaoImpl.java\n        │           │   └── UserDao.java\n        │           └── service\n        │               ├── impl\n        │               │   └── UserServiceImpl.java\n        │               └── UserService.java\n        └── resources其中：\njava//AppConfiguration.java\n\n@Configuration\n@ComponentScan({\"org.example\"})\n//@Import({JdbcConfig.class})\n//@PropertySource({\"classpath:db.properties\"})\npublic class AppConfiguration {\n\n    @Bean(name = {\"UserDao1\"})\n    public UserDao createUserDao1() {\n        return new UserDaoImpl();\n    }\n\n    @Bean\n    public UserDao createUserDao2() {\n        return new UserDaoImpl();\n    }\n\n    @Bean(name = \"UserDao3\")\n    public UserDao createUserDao3(UserService userService) {\n        System.out.println(userService);\n        return new UserDaoImpl();\n    }\n}java//UserDao.java\n\npublic interface UserDao {\n    public void save();\n}java//UserDaoImpl.java\n\n@Repository(\"UserDao\")\npublic class UserDaoImpl implements UserDao {\n    //    @Value(\"${name}\")\n    @Value(\"AC_ACCELERATOR\")\n    String name;\n\n    @Value(\"18\")\n    int age;\n\n    public void save() {\n        System.out.println(\"save running...UserDao:\" + name + age);\n    }\n}java//UserService.java\n\npublic interface UserService {\n    public void save();\n}java//UserServiceImpl.java\n\n@Service\n@Scope(\"singleton\")\npublic class UserServiceImpl implements UserService {\n\n    @Autowired\n    @Qualifier(\"UserDao1\")\n    private UserDao userDao;\n    public void save() {\n        userDao.save();\n        System.out.println(\"save running...UserService\");\n    }\n    @PostConstruct\n    public void init() {\n        System.out.println(\"init UserService\");\n    }\n\n    @PreDestroy\n    public void delete() {\n        System.out.println(\"delete UserService\");\n    }\n}java//App.java\n\npublic class App {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfiguration.class);\n        context.registerShutdownHook();\n        UserService us1 = context.getBean(UserService.class);\n        UserService us2 = context.getBean(UserService.class);\n        System.out.println(us1 == us2);\n\n        UserDao ud1 = context.getBean(\"UserDao1\", UserDao.class);\n        UserDao ud2 = context.getBean(\"createUserDao2\", UserDao.class);\n        UserDao ud3 = context.getBean(\"UserDao3\", UserDao.class);\n        System.out.println(ud1 == ud2);\n        us1.save();\n    }\n}运行结果：\ntxtinit UserService\norg.example.service.impl.UserServiceImpl@145f66e3\ntrue\nfalse\ntrue\nsave running...UserDao:AC_ACCELERATOR18\nsave running...UserService\ndelete UserService如何解读这一份代码呢？\n首先先看AppConfiguration.java文件，其中使用了@Configuration注解（这个注解有点复杂最好看这篇文章），表示这是一个全配置类，这个类与其他类的区别是：在该类中，@Bean注解的工厂方法返回的对象，在IoC容器中仅存在一个，即如果重复调用该工厂方法，则只有第一次会新建对象，后面只会返回第一次生成的那个对象。@ComponentScan({\"org.example\"})表示扫描org.example包下的所有类，如果类上有@Component注解，那么就会被Spring管理（由此，在该包下的所有类就可以通过编写注解来标识自己为bean，让spring管理哦。而且可以看到：”org.example”只是列表中的一项哦，还可以添加很多包哦），如果类上有@Configuration，则会引入该配置类。@Bean注解表示这是一个Bean（手动指定并添加的bean都用这种形式哦，和用@Component标识被自动扫描并添加的bean相对应），Spring会根据这个方法的返回值来生成一个Bean（可以看到在这个例子中，同一个类产生了3个不同的bean哦。其他的第三方库的bean也要通过这种方式加载哦，毕竟大部分第三方库可没有@Component注解给Spring扫描哦），其中name属性表示Bean的id，如果不写，那么默认为方法名（可以看到传入的是一个列表哦，因此一个bean是可以有多个名字的）。@Import注解表示导入其他的类作为配置（可以不被@Configuration注解）（把不同功能的配置分开成一个个文件有利于管理捏），@PropertySource注解表示导入属性文件（之后会介绍具体用途）。\n\n\n\n\n\n\n在配置类中定义的bean要依赖其他的bean怎么办？\nUserDao3中，可以看到要依赖一个UserService的bean，因此在参数中写上UserService userService，Spring会自动从IoC容器中，通过类型找到UserService的bean并注入到这个参数中。这种在定义第三方库的bean的时候经常会用到。\n\n\nUserDao.java文件，这个文件是一个接口，其中没有任何注解，表示这个接口不是一个Bean，不需要被Spring管理。实际上任何接口都不需要被Spring管理，只有实现类才需要被Spring管理。同理UserService.java也是一个接口，也不需要任何注解。\nUserDaoImpl.java文件，这个文件是UserDao接口的实现类，其中使用了@Repository(\"UserDao\")注解，表示这是一个Bean，且指定了bean的id为UserDao。@Repository注解和@Component注解是完全一样的，只是换了个写法，能够让人对目前所标识的类的作用有更好的理解。\n\n\n\n\n\n\n提示\n@Component注解是一个通用的注解，表示这是一个Bean，但是不能够让人对目前所标识的类的作用有更好的理解。因此Spring提供了和@Component注解功能完全一样的注解，但是名字不同。这些注解分别是：\n\n@Repository：表示这是一个数据访问层的Bean\n@Service：表示这是一个业务层的Bean\n@Controller：表示这是一个表现层的Bean\n\n\n\n@Value注解表示给属性注入简单类型的值，其中可以写一个字符串表示要注入的值（不论要注入的是数字还是字符串，注解里面都是字符串形式哦）。不过为什么要通过这种方式赋值呢？为什么不直接用=赋值呢？这就要提到配置类中的@PropertySource注解了，有的时候，需要在属性文件中写一些配置信息，然后在代码中读取这些配置信息（包括读取一些第三方jar包内部的属性文件的配置信息），这个时候就可以在配置类中使用@PropertySource注解来导入属性文件，然后在bean中使用@Value注解来读取配置文件中的信息并注入（如被注释掉的那行@Value(\"${name}\") 可以读取配置文件中名称为name的那一项）。这样做的好处是，如果配置文件中的信息需要修改，那么只需要修改配置文件，而不需要修改代码，这样就提高了代码的灵活性。\nUserServiceImpl.java文件，这个文件是UserService接口的实现类，其中使用了@Service注解，表示这是一个Bean，没有指定bean的id，则默认为userServiceImpl（注意第一个字母小写）。@Scope(\"singleton\")注解表示这个Bean是单例的，即在IoC容器中只有一个实例（如果换成\"prototype\"则是多例的，从IoC容器中每获得一次该bean都会是不同的实例，这些实例的生命周期也不归IoC容器管。目前不推荐这样使用），不写该注解默认为单例。@Autowired注解表示自动装配（和@Value相对应，不过那个是用来装配常量值的，这个是用来装配引用的），即自动将依赖的Bean注入到当前Bean中，默认通过属性类型自动装配，但如果一个属性类型有多个bean可以采用（如一个接口有多个实现类，亦或是一个类有多个bean），则要加@Qualifier进行指定。由于本例中有多个UserDao的bean可以采用，因此@Qualifier(\"UserDao1\")注解表示 指定Bean的id进行注入。接下来是两个与生命周期有关的两个注解，@PostConstruct注解表示在Bean初始化之后执行的方法，@PreDestroy注解表示在Bean销毁之前执行的方法。\n\n\n\n\n\n\n提示\n不论是@Value还是@Autowired，都可以用在属性上，也可以用在setter方法上。而且他们的原理都是通过反射来实现的，因此即使是private也能够注入成功的。\n@Autowired不但可以直接写在属性上，还可以写在setter方法上、写在构造方法中\n前两者是setter注入，最后一个是构造器注入。\n\n\n使用setter注入时：spring构造bean的时候使用反射来调用其无参构造函数（不论是public还是private都能调用），如果没有无参构造函数，则会报错。\n\n\n\n\n\n\n\n依赖注入的方式选择\n\n必须要有的依赖使用构造器注入，因为setter注入有可能会导致null对象出现。\n可选依赖使用setter注入，灵活性强\nspring框架倡导使用构造器注入（更严谨），第三方框架大部分采用构造器注入。\n构造器注入和setter注入可以混合使用。\n如果没有提供setter方法只能使用构造器注入\n自己开发的模块使用setter注入。\n\n\n\n最后，来看App.java文件，这是这个应用程序的主函数入口。在其中：\njava//App.java\n\npublic class App {\n    public static void main(String[] args) {\n        //传入配置类，并根据配置类创建IoC容器\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfiguration.class);\n\n        //注册一个钩子，当程序退出时，自动关闭IoC容器，如果没有这一行`@PreDestroy`注解标识的方法则不会执行，可以不写\n        context.registerShutdownHook();\n\n        //从IoC容器中获取Bean，参数是Bean的类型（通过类型获得bean，但如果一个属性类型有多个bean可以采用，则不能使用这种方法）\n        UserService us1 = context.getBean(UserService.class);\n        UserService us2 = context.getBean(UserService.class);\n        //由于UserService是单例的bean，因此us1和us2是同一个对象\n        System.out.println(us1 == us2);//true\n\n        //从IoC容器中获取Bean，参数是Bean的id（通过id获得bean）\n        UserDao ud1 = context.getBean(\"UserDao1\", UserDao.class);\n        UserDao ud2 = context.getBean(\"createUserDao2\", UserDao.class);\n        UserDao ud3 = context.getBean(\"UserDao3\", UserDao.class);\n        UserDao ud4 = context.getBean(\"UserDao1\", UserDao.class);\n        //由于UserDao1和UserDao2不是同一个bean，因此ud1和ud2不是同一个对象，但是ud1和ud4是同一个对象，因为UserDao1是单例的bean。\n        System.out.println(ud1 == ud2);//false\n        System.out.println(ud1 == ud4);//true\n        us1.save();\n    }\n}\n\n\n\n\n\nspring的报错信息如何看？\n从最后一个Caused by开始看，一般最后一个Caused by是最重要的错误信息。如果最后一个不能明确指明问题，才往前看。\n\n\n如何和JUNIT整合？\n首先在pom.xml中添加依赖，例如：\nxml    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-test&lt;/artifactId&gt;\n      &lt;version&gt;5.2.25.RELEASE&lt;/version&gt;\n      &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;junit&lt;/groupId&gt;\n        &lt;artifactId&gt;junit&lt;/artifactId&gt;\n        &lt;version&gt;RELEASE&lt;/version&gt;\n        &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;    然后在测试类中添加注解：\njava@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(classes = AppConfiguration.class)\npublic class AppTest {\n    @Autowired\n    private UserService userService;\n\n    @Test\n    public void test() {\n        userService.save();\n    }\n}其中，@RunWith(SpringJUnit4ClassRunner.class)表示使用Spring的单元测试框架，@ContextConfiguration(classes = AppConfiguration.class)表示使用AppConfiguration类作为配置类（特别注意参数使用的是classes）。将要测试的组件通过@Autowired注入到测试类中，然后进行测试。\nAOPAOP（Aspect Oriented Programming）即面向切面编程。什么是面向切面编程？Spring又是如何实现的呢？\n什么是面向切面编程一般来说，编写的代码有两个原则，基于这些原则能让程序结构更加清晰（和AOP无关，只是一种编程建议）：\n\n职责清晰：一个类只负责一件事；\n易于测试：一次只测一个功能。\n\n开发者都应该遵循这两个原则来编写代码，使其项目结构清晰更好维护。因此，每一个类都应该被设计为专注完成自己核心的业务逻辑。\n但是整个系统还可能还会要求关注安全检查、日志、事务等功能，比如说在执行业务逻辑前进行安全检查，在业务逻辑执行出现异常的时候进行记录。这样就不得不在每一个业务逻辑片段中都加上几乎重复的代码，还打破了上述的原则：一个类做了不属于自己核心逻辑的事。\njavapublic class UserService {\n\n    public void createUser(User user) {\n        SecurityCheck();//安全检查\n        UserManager usermanager = GetUserManager();\n        try {\n            usermanager.create(user);//核心业务逻辑\n        } catch (RuntimeException e) {\n            usermanager.rollback();//异常处理\n            throw e;\n        }\n        log(\"created user success: \" + user);//日志\n    }\n\n    public void deleteUser(User user) {\n        SecurityCheck();//安全检查\n        UserManager usermanager = GetUserManager();\n        try {\n            usermanager.delete(user);//核心业务逻辑\n        } catch (RuntimeException e) {\n            usermanager.rollback();//异常处理\n            throw e;\n        }\n        log(\"deleted user success: \" + user);//日志\n    }\n}如何解决？\n把程序中的共性功能抽取出来：如安全检查、日志等，写成通知类，在通知类中，将前面提到的共性功能定义为方法，这些方法称为通知。程序中所有的执行方法都被称为连接点（能与通知进行连接的入口），但是程序中并不是所有的方法都要执行通知，因此需要定义哪些连接点需要执行通知，即定义切入点。切面则定义了在哪个切入点执行哪个通知。这就是面向切面编程的思想。\n重新梳理一下概念：\n\n连接点：程序执行过程中的任意位置，在SpringAOP中，连接点是方法执行的位置。\n切入点：匹配连接点的式子（一个切入点可匹配任意个数的连接点）\n通知：在切入点执行的操作（共性功能）\n通知类：定义了通知的类\n切面：描述通知与切入点的对应关系\n\nSpring的AOP要实现AOP，则要解决以下问题：如果获得了UserService的引用，当调用UserService.create()时，如何对调用方法进行拦截，并在拦截前后进行安全检查、日志、事务等处理？\nSpring的AOP实现是基于JVM的动态代理。由于JVM的动态代理要求必须实现接口，如果一个普通类没有业务接口，就需要通过CGLIB或者Javassist这些第三方库实现。\nSpring对AOP的实现如下：\n\n启动IoC容器\n扫描所有的bean（并检查这个bean是不是切面）\n如果是切面，则解析切面，获得切面的通知和切入点\n如果不是切面，则跳过\n\n\n初始化所有bean，检查bean对应的类中是否有方法匹配到任意切入点。\n如果没有，则创建对象\n如果有，则创建原始对象的代理对象（com.sun.proxy类型）。\n\n\n\n这是一个简单的代理模式的案例：\njavapublic class AProxy implements A {\n    private A a;\n    public AProxy(A a) {\n        this.a = a;\n    }\n    public void a() {\n        //放置前置通知\n        this.a.a();//这里并不是递归哦，而是调用的原始对象的方法。\n        //后置通知\n    }\n}可以看到，通过代理模式，可以在原始对象的方法执行前后进行一些操作，甚至进行异常处理，这就是Spring AOP的原理。同时也可以说，Spring AOP是实现代理模式的一种方式。\n那如何在Spring中进行AOP开发呢？\n除了之前引入的spring-context（已经包含spring-aop）外，还要引入下面这个spring-aspects。\nxml    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;\n        &lt;version&gt;5.2.25.RELEASE&lt;/version&gt;\n    &lt;/dependency&gt;由于spring是个IOC框架，因此也要通过bean来表示AOP的概念，这是一个简单的bean：\njava@Component\n@Aspect\npublic class ExampleAOP {\n\n   @Pointcut(\"execution(* org.example.service.UserService.save())\")\n   public void pointcut1() {\n   }\n\n    @Before(\"pointcut1()\")\n    public void before() {\n        System.out.println(\"before\");\n    }\n}\n除了@Component注解表示这是一个bean外，还有一个@Aspect注解表示这是一个切面。但要注意，要使spring能够识别@Aspect注解，还需要给配置类添加@EnableAspectJAutoProxy注解，表示启用AOP。当spring检查到一个bean有@Aspect注解的时候，就会去检查这个类里面的，与AOP有关的注解。\n在此例中，与AOP有关的注解是@Pointcut，@Before。@Pointcut注解表示定义一个切入点，其中的参数是一个切点表达式，表示匹配哪些连接点，被修饰的方法没有限制，感觉仅仅是个形式，所以随便写了一个空方法，而且就算这个方法里有代码，也不会被执行。\n@Before注解的参数也是切点表达式，用于指定在切入点执行前执行的通知，在这个例子中，我希望它能在切入点执行前，打印一些东西。\n执行一下，可以发现在执行us1.save()的时候，会先打印出before，然后再执行save()方法里的内容。\n\n\n\n\n\n\n\n\n\n尽管上述例子中，采用了@Pointcut注解来实现切入点的概念，但是别忘了@Before注解的参数也是切点表达式，因此可以直接使用@Before注解为连接点或切入点绑定通知。但在有的时候，使用@Pointcut注解来定义切入点可以使得代码的耦合性降低。\n切点表达式可以匹配连接点，功能强大且复杂，这里详细介绍了切点表达式\n\n\n\n\n\n\n关于切点表达式该写什么\n\n一般匹配接口不匹配实现类（降耦合）\n接口大多是public，和切点表达式默认值相同，因此可以省略访问控制修饰符描述\n返回值类型对于增删改类使用精准类型加速匹配，对于查询类则使用*通配快速描述\n包名不要使用..进行匹配，效率太低，可使用*通配符来描述\n接口名/类名书写，与模块相关的采用*匹配，如UserService写成*Service\n方法名书写，以动词进行精确匹配，名词采用*匹配\n不使用异常作为匹配规则\n\n\n\nAOP通知类型\n\n前置通知：在切入点执行前执行@Before\n后置通知：在切入点执行后执行（无论是否抛出异常）@After\n环绕通知：在切入点执行前后执行@Around\n异常通知：在切入点抛出异常时执行@AfterThrowing\n返回后通知：在切入点正常返回后执行（抛异常不执行）@AfterReturning\n\n前置通知和后置通知用法相似，前面已经描述过前置通知，后置通知同理，只不过是在切入点执行后执行。\n返回后通知和后置通知的不同的地方在于，返回后通知只在切入点正常返回后执行，抛异常不执行，而后置通知无论切入点是否抛异常都会执行。\n异常通知的作用是字面意思：在切入点抛出异常时执行。不抛异常不执行。\n重点是环绕通知，这是功能最强大的通知类型。前置通知和后置通知都可以用环绕通知来实现。\n对于这样一个通知类：\njava@Component\n@Aspect\npublic class ExampleAOP {\n\n    @Pointcut(\"execution(void org.example.service.UserService.save())\")\n    public void pointcut() {\n    }\n\n    @Around(\"pointcut()\")\n    public void around(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(\"before\");\n        joinPoint.proceed();\n        System.out.println(\"after\");\n    }\n}可以看到，被@Around注解的函数的参数是ProceedingJoinPoint类型，这是一个接口，表示连接点。ProceedingJoinPoint接口有一个proceed()方法，表示执行连接点的方法。由于AOP不负责异常处理，因此需要在方法上声明throws Throwable。\n连接点执行是在proceed()方法执行的时候，在proceed()方法之前的代码是前置通知的代码，在proceed()方法之后的代码是后置通知的代码。\n但是，这是在连接点没有返回值的情况下，如果连接点有返回值，比如这里返回一个int：\njava@Component\n@Aspect\npublic class ExampleAOP {\n\n    @Pointcut(\"execution(int org.example.service.UserService.count())\")\n    public void pointcut() {\n    }\n\n    @Around(\"pointcut()\")\n    public void around(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(\"before\");\n        joinPoint.proceed();\n        System.out.println(\"after\");\n    }\n}则抛出异常：\ntxtException in thread \"main\" org.springframework.aop.AopInvocationException: Null return value from advice does not match primitive return type for: public abstract int org.example.service.UserService.count()根据异常信息，可以看到，通知方法的返回值类型和连接点的返回值类型不匹配，抛出异常。因为在Spring AOP中，连接点的返回值应该被通知获取，由通知代为返回。因此，如果连接点有返回值，那么通知方法的返回值类型必须和连接点的返回值类型一致。在这个例子中，通知方法的返回值类型应该是int或者Integer或者Object。返回值类型和连接点匹配之后，便不会抛异常了。不仅如此，通知需要获取连接点的返回值，将连接点的返回值返回出去（在通知中可以对返回值进行修改哦），修改后的代码如下：\njava    @Around(\"pointcut()\")\n    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(\"before\");\n        Object ret = joinPoint.proceed();\n        //在这里可以对返回值ret进行处理哦！！！\n        System.out.println(\"after\");\n        return ret;\n    }\n\n\n\n\n\n提示\n在这个例子中，尽管通知的返回值类型是Object类型，但是实际在代理对象中，count()方法的返回类型依然是int没变。\n由于proceed()返回对象的只能是Object类型，而对于大多数应用场景来说，一般都将连接点返回值直接返回，因此通知方法的返回值类型一般都选择Object类型比较好。\n即使连接点返回值是void，通知方法的返回值也可以设置成Object类型。\n\n\n在上个例子中，在通知中获得了连接点的返回值。在这个例子中，还可以获取连接点的参数(并进行处理,第一个参数改为100)，也可以获得异常：\njava    @Around(\"pointcut()\")\n    public Object around(ProceedingJoinPoint joinPoint){\n        System.out.println(\"before\");\n        Object[] args = joinPoint.getArgs();\n        args[0] = 100;\n        Object ret = null;\n        try {\n            ret = joinPoint.proceed(args);\n        } catch (Throwable e) {\n            throw new RuntimeException(e);\n        }\n        System.out.println(\"after\");\n        return ret;\n    }这里看到，由于在通知中对异常进行了处理，因此通知方法的返回值类型可以不用声明throws Throwable了。注意，如果修改了连接点的参数，则使用proceed(Object[] args)方法，用以传入修改后的参数；如果不修改连接点参数，则直接使用proceed()方法即可。\n关于获取连接点的参数和返回值或者异常，其他通知类型各有不同：\njava    @Before(\"pointcut()\")//能获得：参数\n    //通知参数是JoinPoint类型！是ProceedingJoinPoint的父接口\n    public void before(JoinPoint joinPoint) {\n        //通过getArgs()方法获取连接点的参数，但是不能修改后再传入连接点\n        System.out.println(\"get args at before \"+joinPoint.getArgs()[0].toString());\n    }\n    \n    @After(\"pointcut()\")//能获得：参数\n    //通知参数是JoinPoint类型！是ProceedingJoinPoint的父接口\n    public void after(JoinPoint joinPoint) {\n        //通过getArgs()方法获取连接点的参数，但是不能修改后再传入连接点\n        System.out.println(\"get args at after \"+joinPoint.getArgs()[0].toString());\n    }\n    \n    @AfterReturning(value = \"pointcut()\", returning = \"ret\")//能获得：参数、返回值\n    //通过Object类型的参数获取连接点的返回值，注意注解中的参数名要和方法参数名一致，这里都是ret。如果要获取连接点的参数，则要使用JoinPoint类型的参数，且必须是第一个参数。\n    public void afterReturning(JoinPoint joinPoint, Object ret) {\n        System.out.println(\"get args at afterReturning \"+joinPoint.getArgs()[0].toString());\n        System.out.println(\"get ret at afterReturning \"+ret.toString());\n    }\n    \n    @AfterThrowing(value = \"pointcut()\", throwing = \"e\")//能获得：参数、异常\n    //通过Exception类型的参数获取连接点的异常，注意注解中的参数名要和方法参数名一致，这里都是e。如果要获取连接点的参数，则要使用JoinPoint类型的参数，且必须是第一个参数。\n    public void afterThrowing(JoinPoint joinPoint, Exception e) {\n        System.out.println(\"get args at afterThrowing \"+joinPoint.getArgs()[0].toString());\n        System.out.println(\"get exception at afterThrowing \"+e.toString());\n    }\n\n\n\n\n\n\n在AOP编程中要遵循的原则\n有以下两点非常重要，必须遵守，否则会出现问题：\n\n访问被注入的Bean时，必须调用方法而不是直接访问字段；\n编写Bean时，如果可能会被代理，就不要编写public final方法。\n\n关于第一点，原因如下：Spring通过CGLIB创建的代理类，不会初始化代理类自身继承的任何成员变量，包括final类型的成员变量！（因为是毕竟代理类嘛），因此如果直接访问字段，会出现空指针异常。因此，如果要访问被注入的Bean的成员变量，必须调用返回该成员变量的方法，而不是直接访问字段。\n关于第二点：虽然CGLIB创建的代理类不会初始化代理类自身继承的任何成员变量，但是会覆写代理类自身继承的所有方法。如果一个方法被声明为final，那么CGLIB就无法覆写并绑定该方法。因此，如果该方法又直接访问了成员变量，就会导致：其他Bean如果调用此方法，将访问到代理类的成员变量，发生空指针异常。\n\n\nTransaction什么是事务最经典的例子莫过于银行转账了，假设A账户有1000元，B账户有2000元，A账户向B账户转账100元，那么这个过程中，A账户的钱减少100元，B账户的钱增加100元，这两个操作必须同时成功或者同时失败，如果其中一个操作失败了，那么另一个操作也必须回滚。银行转账的操作就是一个事务（同时成功，同时失败）。\nSpring的事务事务的底层原理依然是由AOP实现的。对于开启事务的类/接口/方法，Spring会创建其对应的代理对象，该代理对象会有一个PlatformTransactionManager成员，作为事务管理员管理事务。\n在Spring中，会有事务协调类TransactionInterceptor来拦截执行方法体，判断是否开启事务，然后执行事务方法体，方法体中catch住异常，接着判断是否需要回滚，如果需要回滚就委托真正的TransactionManager进行处理。\n要在Spring上使用声明式事务，首先给配置类加上@EnableTransactionManagement注解，表示开启与事务有关的AOP，并开启和事务管理有关的注解：@Transactional（可为方法注解，也可为类/接口注解。为类/接口注解即对该类/接口下所有的方法开启事务管理）。\n还记得代理对象有个的PlatformTransactionManager成员吗？这个成员从那来呢？这个成员是要在配置类中进行手动配置的，这里使用了JDBC的一个事务管理器，它为JDBC的操作提供事务管理：\njava    @Bean\n    PlatformTransactionManager PTM(DataSource dataSource) {\n        return new DataSourceTransactionManager(dataSource);\n    }接着给对应的，有数据库操作的方法加上@Transactional注解，即可声明该方法为事务。在一个事务方法中，如果程序判断需要回滚事务，只需抛出RuntimeException。\n相关的，事务还有传播级别的概念，但是大部分情况下，默认的REQUIRED就够用了，其他的自搜。REQUIRED的意思是：在执行到事务方法时，如果当前没有事务，就创建一个新事务，如果当前有事务，就加入到当前事务中执行。比如说，A方法调用B方法，A方法是事务，B方法也是事务。执行B方法时，已经看到有A方法的事务了，那么B方法的事务会合并到A方法的事务中去。\n\n\n\n\n\n\n\n事务如何传播\n事务能正确传播的前提是，方法调用是在一个线程内才行。因为Spring会把和事务有关的信息保存在线程中，如果不在一个线程内，则事务信息不同步，依照上文所述原则：如果当前没有事务，就创建一个新事务，如果当前有事务，就加入到当前事务中执行。因此，新的线程在REQUIRED级别中，总是会创建一个新事务，而不会合并，失去了传播功能。\n\n\nSpring MVC什么是MVCMVC是三个单词的首字母缩写，它们是Model（模型）、View（视图）和Controller（控制）。MVC是一种设计模式，常用于开发WEB应用。\n一个以MVC设计模式开发的WEB应用，具体工作流程如下：\n\n首先，用户通过浏览器发送HTTP请求，请求到达服务器的Controller；\nController根据用户请求，执行业务层逻辑，其处理结果作为Model传递给View；\nView根据Model渲染出HTML，通过HTTP响应返回给浏览器。\n\n这里的View指代JSP之类的，但是Web开发通常使用其他的前端框架，如Vue、React等，这些框架都是前后端分离的。\nSpring MVC在Spring中，要使用MVC需要包含以下依赖，一个是spring-webmvc，这个则包含了spring-context在内的包（可以不用导入spring-context了）。另外，既然是Web应用，那就少不了servlet容器的使用了，因此要加上servlet-api依赖。另外，也可以加上jackson-databind依赖，这是一个JSON序列化/反序列化的库，用于将Java对象转换为JSON字符串，或者将JSON字符串转换为Java对象，这在Web开发中非常有用。（非必须）\nxml        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;\n            &lt;version&gt;5.2.25.RELEASE&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;\n            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;\n            &lt;version&gt;4.0.1&lt;/version&gt;\n            &lt;scope&gt;provided&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n            &lt;version&gt;2.14.3&lt;/version&gt;\n        &lt;/dependency&gt;关于打包的格式在pom.xml中配置为war（这对servlet很重要）：\nxml    &lt;packaging&gt;war&lt;/packaging&gt;关于Servlet容器，这里选择Tomcat。可以选择在IDEA中配置Tomcat，也可以选择在pom.xml中配置Tomcat。这里选择在pom.xml中添加Tomcat插件，这样可以在其他IDE中也能运行。\nxml            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;\n                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;\n                &lt;version&gt;2.2&lt;/version&gt;\n            &lt;/plugin&gt;至此，前置条件已经完成，接下来开始编写Java代码。\n在前面的所有例子中，通过在主函数中创建IoC容器，然后从IoC容器中获取Bean，然后调用Bean的方法，但这样的方式是不适合Web应用的，因为Web应用是由Servlet容器来管理的，那IoC容器如何与Servlet容器进行配合协作呢？\n解决方法是：需要将IoC容器交给Servlet容器来管理。\n这就要介绍一下ServletContainerInitializer接口了：ServletContainerInitializer是 Servlet 3.0 新增的一个接口，主要用于在容器启动阶段通过编程风格注册Filter, Servlet以及Listener，以取代通过web.xml配置注册。这样就利于开发内聚的web应用框架，为第三方组件的初始化提供了简单的方法。ServletContainerInitializer接口的实现类通过Java SPI声明自己是ServletContainerInitializer的provider，容器启动阶段依据Java SPI获取到所有ServletContainerInitializer的实现类，然后执行其onStartup方法，完成初始化工作。\n在包spring-webmvc中的一个类：org.springframework.web.SpringServletContainerInitializer实现了这个接口，Servlet容器启动时会调用这个类的onStartup()方法。这是这个方法的定义：\njava    @Override\n    public void onStartup(@Nullable Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)\n            throws ServletException {\n\n        List&lt;WebApplicationInitializer&gt; initializers = new LinkedList&lt;&gt;();\n\n        if (webAppInitializerClasses != null) {\n            for (Class&lt;?&gt; waiClass : webAppInitializerClasses) {\n                //这里，Spring扫描所有的WebApplicationInitializer的实现类，然后将其实例化，放入initializers中\n                if (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;\n                        WebApplicationInitializer.class.isAssignableFrom(waiClass)) {\n                    try {\n                        initializers.add((WebApplicationInitializer)\n                                ReflectionUtils.accessibleConstructor(waiClass).newInstance());\n                    }\n                    catch (Throwable ex) {\n                        throw new ServletException(\"Failed to instantiate WebApplicationInitializer class\", ex);\n                    }\n                }\n            }\n        }\n\n        if (initializers.isEmpty()) {\n            servletContext.log(\"No Spring WebApplicationInitializer types detected on classpath\");\n            return;\n        }\n\n        servletContext.log(initializers.size() + \" Spring WebApplicationInitializers detected on classpath\");\n        AnnotationAwareOrderComparator.sort(initializers);\n        for (WebApplicationInitializer initializer : initializers) {\n            //这里，Spring调用所有的WebApplicationInitializer的实现类的onStartup方法，并将ServletContext传入\n            initializer.onStartup(servletContext);\n        }\n    }上述代码意思是，Spring扫描会所有的WebApplicationInitializer的实现类，然后将其实例化，并调用所有的WebApplicationInitializer的实现类的onStartup方法，并将ServletContext传入。因此，我们只需要实现WebApplicationInitializer接口，然后在onStartup方法中创建IoC容器，将IoC容器交给Servlet容器管理即可。\n听起来很麻烦，但是由于Spring的封装，提供了一个简便的方法：继承抽象类AbstractDispatcherServletInitializer，并实现其抽象方法即可。原因是：这个抽象类实现了WebApplicationInitializer接口，并且在onStartup方法中调用registerDispatcherServlet方法，registerDispatcherServlet方法又会调用createServletApplicationContext抽象方法，创建IoC容器，并将其交给Servlet容器管理。\n其抽象方法有3个：\n\ncreateServletApplicationContext\ngetServletMappings\ncreateRootApplicationContext\n\n下面是一个例子：\njava//ServletContainerInit.java\n\n//也可以继承AbstractAnnotationConfigDispatcherServletInitializer更加简洁\npublic class ServletContainerInit extends AbstractDispatcherServletInitializer {\n    //加载spring-mvc配置\n    @Override\n    protected WebApplicationContext createServletApplicationContext() {//这个函数被registerDispatcherServlet方法调用\n        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();\n        context.register(SpringMVCConfiguration.class);\n        return context;\n    }\n\n    //哪些请求路径交给SpringMVC处理\n    @Override\n    protected String[] getServletMappings() {\n        return new String[]{\"/\"};\n    }\n\n    //加载Spring容器配置\n    @Override\n    protected WebApplicationContext createRootApplicationContext() {\n        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();\n        context.register(SpringConfiguration.class);\n        return context;\n    }\n\n    @Override\n    protected Filter[] getServletFilters() {//Tomcat7以下版本则需要配置，仅解决post请求乱码,高版本不会有中文乱码问题（可选）\n        CharacterEncodingFilter filter = new CharacterEncodingFilter();\n        filter.setEncoding(\"UTF-8\");\n        return new Filter[]{filter};\n    }\n}\njava//SpringMVCConfiguration.java\n\n@ComponentScan({\"org.example.controller\"})\n@EnableWebMvc// 这个注解会打开许许多多方便的功能\npublic class SpringMVCConfiguration {\n\n}java//SpringConfiguration.java\n\n@Configuration\n@ComponentScan(value = {\"org.example\"}, excludeFilters = {\n        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = {Controller.class})\n})\npublic class SpringConfiguration {\n}java//Hello.java\n\n@Controller //只被SpringMVCConfiguration扫描到（后面会解释）\n@RequestMapping(\"/hello\")//路径映射\npublic class Hello {\n\n    @RequestMapping(\"/save\")//路径映射\n    @ResponseBody//返回内容作为响应体，不会被视图解析器解析\n    public String save(@RequestParam(\"int\") int i,String s) {//@RequestParam的简单使用例子\n        System.out.println(s);\n        return \"received\"+i+\"+\"+s;\n    }\n\n    @RequestMapping(\"/hi\")\n    @ResponseBody\n    public String hi() {//不接受请求参数\n        return \"hi\";\n    }\n}在上述例子中，createServletApplicationContext方法通过加载SpringMVCConfiguration类来创建上下文，用于指定哪些类与Servlet有关（通常是表现层的类），在SpringConfiguration.java看到，该类会扫描包org.example.controller下的所有被@Component注解的类，创建为bean。\ngetServletMappings也会被抽象类调用，用于指定哪些请求路径交给SpringMVC处理。\ncreateRootApplicationContext方法通过加载SpringConfiguration类来创建上下文，用于指定与Servlet无关的类（通常放业务和功能），在SpringConfiguration.java可以看到，该类会扫描包org.example下的所有被@Component注解的类，创建为bean，但是排除@Controller注解的类。\n\n\n\n\n\n\n\n避免重复扫描\n为什么要过滤@Controller注解的类呢？因为@Controller注解的类会被createServletApplicationContext方法加载的SpringMVCConfiguration类扫描到，因此不需要再在createRootApplicationContext方法加载的SpringConfiguration类中扫描了。\n过滤的条件也不仅仅只有一种，还有其他的过滤条件，比如按照类名过滤，按照注解过滤等等。\n如果SpringMVCConfiguration.java放在包org.example下，为了正确实现过滤功能，注意这个时候不能将其用@Configuration修饰。因为@Controller也是属于@Component的一种，如果被SpringConfiguration扫描到，则会引入SpringMVCConfiguration的@ComponentScan，这样的话，好不容易排除的@Controller注解的类又被扫描进来了！\n除了设置过滤避免重复加载，还有一个方法：究其原因，就是因为org.example所包含的范围太大了，所以最简单的解决方法就是更加细致的指定扫描范围。\n\n\n再看到Hello.java文件，这个文件就是一个Controller，它位于org.example.controller包下，且被@Controller修饰，因此会被SpringMVCConfiguration扫描到，但是不会被SpringConfiguration扫描到。类注解@RequestMapping(\"/hello\")表明，该类下的所有方法都会被映射到/hello路径下。方法save被@RequestMapping(\"/save\")修饰，表明该方法会被映射到/hello/save路径下。@ResponseBody则表明，返回内容将作为响应体，不会被视图解析器解析。形参@RequestParam(\"int\") int i表示，请求参数中的int参数会被映射到形参i上，@RequestParam用于绑定请求参数与形参之间的关系，如果不指定value或者不进行注解，则形参名必须和请求参数名一致（如这里的形参s就会接收名为s的请求参数，而形参i会接收名为int的请求参数），形参列表为空则说明该方法不接收请求参数。\n\n\n\n\n\n\n提示\n域名大小写不敏感，路径和请求参数大小写敏感。\n\n\n以上是两个简单的例子，仅仅是简单的传参，其实还有更多的方式，来看下面这个例子：\njavapublic class User {\n    int age;\n    String name;\n\n    //getters and setters and toString\n}javapublic class Zone {\n    String url;\n    int id;\n    User user;\n\n    //getters and setters and toString\n}java    @RequestMapping(\"/pojo\")\n    @ResponseBody\n    public String pojo(User user) {//接受请求参数，自动封装成对象\n        System.out.println(user);\n        return \"received \" + user;\n    }\n\n    @RequestMapping(\"/pojo2\")\n    @ResponseBody\n    public String pojo2(Zone zone) {//接受请求参数，自动封装成对象\n        System.out.println(zone);\n        return \"received \" +  zone;\n    }首先有两个实体类，User和Zone，User的成员变量是基础类型，而Zone的成员变量则有引用类型。\n对于第一个方法，如果用get方法传参：/hello/pojo?name=ABC&amp;age=19，请求参数中的age和name会被自动封装成User对象。\n对于第二个方法，如果用get方法传参：/hello/pojo2?id=1&amp;url=example.com&amp;user.name=ac&amp;user.age=11，请求参数中的id和url会被自动封装成Zone对象，而user.name和user.age会被自动封装成User对象，然后将User对象赋值给Zone对象的user成员变量。非常的方便（尽管很少用就是了）\n另外对于列表数据则可以采用以下形式：\njava    @RequestMapping(\"/array\")\n    @ResponseBody\n    public String array(String[] s) {\n            System.out.println(Arrays.toString(s));\n        return \"received \" + Arrays.toString(s);\n    }\n\n    @RequestMapping(\"stringlist\")\n    @ResponseBody\n    public String ListString(@RequestParam List&lt;String&gt; s) {\n        System.out.println(s.toString());\n        return \"received \" + s;\n    }对于第一个方法，如果用get方法传参：/hello/array?s=hello&amp;s=i&amp;s=am&amp;s=spring-mvc，请求参数中的s会被自动封装成String数组。\n对于第二个方法，如果用get方法传参：/hello/stringlist?s=hello&amp;s=world，请求参数中的s会被自动封装成List。\n\n\n\n\n\n\n提示\n第二个方法如果形参不用@RequestParam修饰，则会报错。因为Spring会当作pojo传参处理，而不是列表传参。\n\n\n这两种传参形参只能是基础类型如String，不能是自定义类型如User。如果为User，虽然不报错，但是显然请求参数无法正确描述User的数据结构。为此，介绍下面的json传参形式，在使用这种形式之前，需要在SpringMVCConfiguration中配置@EnableWebMvc，开启相关的功能。另外在maven中引入jackson-databind包。\njava    @RequestMapping(\"jsonlist\")\n    @ResponseBody\n    public String jsonlist(@RequestBody List&lt;String&gt; s) {\n        System.out.println(s.toString());\n        return \"received \" + s;\n    }//[\"hello\",\"world\",\"!!\"]\n\n    @RequestMapping(\"jsonpojo\")\n    @ResponseBody\n    public String jsonpojo(@RequestBody Zone zone) {\n        System.out.println(zone);\n        return \"received \" + zone;\n    }//{ \"url\": \"example.org\", \"id\": \"789\", \"user\": { \"name\": \"ac\", \"age\": \"12\" } }\n\n    @RequestMapping(\"jsonpojolist\")\n    @ResponseBody\n    public String jsonpojolist(@RequestBody List&lt;Zone&gt; zone) {\n        System.out.println(zone);\n        return \"received \" + zone;\n    }//[ { \"url\": \"example.com\", \"id\": \"12\", \"user\": { \"name\": \"ac\", \"age\": \"4\" } }, { \"url\": \"example.cn\", \"id\": \"34\", \"user\": { \"name\": \"xw\", \"age\": \"8\" } }]\n\n    @RequestMapping(\"getzone\")\n    @ResponseBody\n    public Zone getzone() {\n        Zone zone = new Zone();\n        zone.setId(1);\n        zone.setUrl(\"zone1\");\n        User user = new User();\n        user.setAge(18);\n        user.setName(\"user1\");\n        zone.setUser(user);\n        return zone;\n    }//{\"url\":\"zone1\",\"id\":1,\"user\":{\"age\":18,\"name\":\"user1\"}}\n\n    @RequestMapping(\"getzonelist\")\n    @ResponseBody\n    public List&lt;Zone&gt; getzonelist() {\n        Zone zone = new Zone();\n        zone.setId(1);\n        zone.setUrl(\"zone1\");\n        User user = new User();\n        user.setAge(18);\n        user.setName(\"user1\");\n        zone.setUser(user);\n        Zone zone2 = new Zone();\n        zone2.setId(2);\n        zone2.setUrl(\"zone2\");\n        User user2 = new User();\n        user2.setAge(19);\n        user2.setName(\"user2\");\n        zone2.setUser(user2);\n        return Arrays.asList(zone, zone2);\n    }//[{\"url\":\"zone1\",\"id\":1,\"user\":{\"age\":18,\"name\":\"user1\"}},{\"url\":\"zone2\",\"id\":2,\"user\":{\"age\":19,\"name\":\"user2\"}}]其中，对于前3个方法，@RequestBody注解表示请求参数在请求体里面，jackjson会自动将请求体中的json字符串转换为对应的对象。对于后2个方法，@ResponseBody注解会使jackjson会自动将对象转换为json字符串。这里留心一下参数的类型以及函数的返回类型。\nRESTRESTful风格是一种基于HTTP协议设计Web API的软件架构风格，它强调使用HTTP动词来表示对资源的操作（GET、POST、PUT、PATCH、DELETE等），并通过URI表示资源的唯一标识符。RESTful风格的Web API设计简单、易于扩展，因此被广泛应用于互联网公司的API设计。\n\n\n\n路径\n行为\n请求方式\n\n\n\nlocalhost/users\n查询全部用户信息\nGET\n\n\nlocalhost/users/1\n查询id为1的用户信息\nGET\n\n\nlocalhost/users\n添加用户信息\nPOST\n\n\nlocalhost/users/\n修改用户信息\nPUT\n\n\nlocalhost/users/1\n删除id为1的用户信息\nDELETE\n\n\n这是一个简单的案例：\njava@Controller\n@ResponseBody//写在类上，表示该类下的所有方法都被@ResponseBody修饰\n@RequestMapping(\"/rest\")\npublic class Rest {\n\n    @RequestMapping(value = \"/users\", method = RequestMethod.GET)\n    public String get() {\n        return \"get success\";\n    }\n\n    @RequestMapping(value = \"/users/{id}\", method = RequestMethod.GET)\n    public String get(@PathVariable String id){\n        return \"get success \"+id;\n    }\n\n    @RequestMapping(value = \"/users\", method = RequestMethod.POST)\n    public String post(@RequestBody User user) {\n\n        return \"post success \"+user;\n    }\n\n    @RequestMapping(value = \"/users\", method = RequestMethod.PUT)\n    public String put(@RequestBody User user) {\n        return \"put success \"+user;\n    }\n\n    @RequestMapping(value = \"/users/{number}\", method = RequestMethod.DELETE)\n    public String delete(@PathVariable(\"number\") String id) {\n        return \"delete success \" + id;\n    }\n}上述写法中，对于@RequestMapping注解添加了method限定参数，这样就可以根据请求方式来调用不同的方法。同时，由于这里@RequestMapping传入了两个参数，因此缺省的参数名value必须要写明。要使用路径变量的话，路径变量用大括号括起来（如{id}）。@PathVariable注解使路径变量自动映射到形参中（变量名必须相同，或者像最后一个方法那样进行指定）。\n像上面那样写，虽然能实现RESTful风格，但是代码量太大了。Spring提供了更加简单的写法：\njava@RestController\n@RequestMapping(\"/rest/users\")\npublic class Rest {\n\n    @GetMapping\n    public String get() {\n        return \"get success\";\n    }\n\n    @GetMapping(value = \"/{id}\")\n    public String get(@PathVariable String id){\n        return \"get success \"+id;\n    }\n\n    @PostMapping\n    public String post(@RequestBody User user) {\n\n        return \"post success \"+user;\n    }\n\n    @PutMapping\n    public String put(@RequestBody User user) {\n        return \"put success \"+user;\n    }\n\n    @DeleteMapping(value = \"/{number}\")\n    public String delete(@PathVariable(\"number\") String id) {\n        return \"delete success \" + id;\n    }\n}其中，@RestController注解相当于@Controller和@ResponseBody的组合。@GetMapping、@PostMapping、@PutMapping、@DeleteMapping也都同理。\n至此，Spring Framework的基础内容已经结束。\n","slug":"Java-Spring","date":"2023-10-05T08:13:00.000Z","categories_index":"Java","tags_index":"Java,Web开发,Spring","author_index":"Ac-Accelerator"},{"id":"00373d310aa46142930357ce33d9554f","title":"Servlet详解","content":"在Browser-Server架构的Web应用中，浏览器根据URL请求服务器的资源，浏览器则返回对应的资源给浏览器。这些资源可包括HTML文本，二进制文件等等。而其所用的传输协议即是HTTP协议。\n在网页请求的过程中，浏览器要做的是：\n\n与服务器建立TCP连接；\n发送HTTP请求；\n收取HTTP响应，然后把网页在浏览器中显示出来。\n\n服务器要做的是：\n\n与浏览器建立TCP连接\n等待接收HTTP请求\n返回HTTP响应\n\nHTTP是一个非常简单的协议。它的请求由4部分组成：\n\n请求行：指定了请求的方法，路径和协议版本；\n请求头：由key-value形式的字符串组成，表示对请求的补充说明；服务器可以根据这些信息做出不同的响应；\n空行\n请求体：GET请求没有请求体，POST请求有请求体,包含浏览器上传给服务器的数据。\n\n这是一个HTTP GET请求的例子：\ntxtGET /api/users/1 HTTP/1.1\nAccept: application/json, text/plain, */*\nAccept-Encoding: gzip, deflate, br, zsdch\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\nConnection: keep-alive\nHost: localhost:9443\nReferer: https://localhost:9443/\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36 Edg/112.0.1722.48\n第一行是请求行，有三个用单个空格分隔的部分：\n\n请求方法：GET表示一个读取请求；\n请求路径：/api/users/1表示请求的路径；对应服务器的一个资源路径\nHTTP协议版本：HTTP/1.1表示使用的是HTTP协议版本1.1。\n\n第二行开始是请求头，每个请求头都是一个key: value形式的字符串，表示对请求的额外描述，请求头的个数是不限的。常见的请求头有：\n\nAccept：浏览器支持的数据类型；\nAccept-Encoding：浏览器支持的压缩格式；\nAccept-Language：浏览器当前设置的语言；\nConnection：浏览器与服务器之间连接的类型；\nHost：请求的域名；\nReferer：请求的来源页面；\nUser-Agent：浏览器的用户代理字符串。\n\n由于是GET请求，规定上GET请求没有请求体，但是，仍然有一行空行，表示请求结束。\n下面来一个POST请求的例子：\ntxtPOST /login.action HTTP/1.1\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\nConnection: keep-alive\nContent-Length: 27\nContent-Type: application/x-www-form-urlencoded\nHost: localhost:8080\nOrigin: http://localhost:8080\nReferer: http://localhost:8080/\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36 Edg/112.0.1722.48\n\nusername=admin&amp;password=abc第一行仍然是请求行，可见请求方法为POST。\n这个例子可以看到其他的一些请求头：\n\nContent-Type：请求的数据类型；\nContent-Length：请求的数据长度；在这种情况下，正好等于请求体的长度\n\n正常情况下请求体的格式和Content-Type指定的格式要保持一致，因为服务器根据Content-Type来决定如何解读请求体。上例中Content-Type的值是application/x-www-form-urlencoded，表示请求体是key-value的形式发送的，如果有多个key-value对则用&amp;连接。其他的格式有application/json，表示请求体是JSON格式，application/octet-stream表示请求体是一个字节流，可以用来上传文件。等等。\n除了GET和POST外，常用的HTTP请求还有PUT，DELETE，HEAD，OPTIONS等，但是基本不常用，用法自搜。\nHTTP响应也由4部分组成：\n\n状态行：指定了协议版本，状态码和状态描述；\n响应头：由key-value形式的字符串组成，表示对响应的补充说明；浏览器可以根据这些信息做出不同的处理；\n空行\n响应正文：服务器返回给浏览器的数据。\n\n这是一个HTTP响应的例子：\ntxtHTTP/1.1 200 OK\nServer: Apache-Coyote/1.1\nContent-Type: text/html;charset=ISO-8859-1\nContent-Length: 154\nDate: Fri, 29 Sep 2023 10:39:00 GMT\n\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJwYXNzd29yZCI6ImFiYyIsImV4cCI6MTY5NjE2Mzk0MCwidXNlcm5hbWUiOiJhZG1pbiJ9.i1QiBVjO_nPXDudpPWJmiMWsQROekYCmozQAzreOcrE这里值得注意的是状态代码，其中2xx表示成功，3xx表示重定向，4xx表示客户端引发的错误，5xx表示服务器端引发的错误。\n\n\n\n\n\n\n关于GET和POST的参数传递\n这两个方法都能够传递请求参数，一般来说POST请求的参数是在请求体中传递的，而GET请求的参数是在URL中传递的，例如在bing上搜索github：https://www.bing.com/search?q=github&amp;form=ANNNB1这个即是一个GET请求，其请求行为：\ntxtGET /search?q=github&amp;form=ANNNB1 HTTP/1.1其中，/search是请求路径，？是分隔符，q=github&amp;form=ANNNB1是请求参数，多个参数用&amp;连接。其传参格式仅能是application/x-www-form-urlencoded。如果传入参数有中文，需要进行URL编码。所以我们在搜索引擎搜索中文时会看到URL中有一些奇怪的字符。这是因为浏览器会对URL进行编码，由ASCII字符转义中文字符，再发送给服务器。\n\n\n虽然HTTP协议非常简单，但是要手动编写一个完善的HTTP服务器依然十分复杂，要考虑的东西很多。所以，我们需要一个能够帮助我们处理HTTP协议的框架！\nServletServlet的全称是Server Applet，即服务器端小程序。它是JavaEE规范中定义的一种用来处理HTTP请求的规范。在Java实现中作为一个接口（interface）类存在。\nServlet类（实现Servlet接口的类）运行在Servlet容器中（如Tomcat），Servlet容器负责与客户端建立连接，解析HTTP请求，调用Servlet接口的方法，将HTTP响应返回给客户端。一个Web App就是由一个或多个Servlet组成的。\n我们编写的Servlet类需要实现Servlet接口，然后将其打包成一个war包，放入Servlet容器中，Servlet容器在接收到对应请求时会调用Servlet接口的方法，进而完成 我们编写的Servlet类 的功能。\n在使用Servlet时，我们需要在maven中引入相关的包，示例版本是8.0.1，注意加上&lt;scope&gt;provided&lt;/scope&gt;，表示在部署打包的时候不应该引入这个类（因为运行这个类的Servlet容器已经包含了这个类了，再引入就会发生错误）：\nxml&lt;dependency&gt;\n    &lt;groupId&gt;javax&lt;/groupId&gt;\n    &lt;artifactId&gt;javaee-web-api&lt;/artifactId&gt;\n    &lt;version&gt;8.0.1&lt;/version&gt;\n    &lt;scope&gt;provided&lt;/scope&gt;\n&lt;/dependency&gt;关于打包的格式在pom.xml中配置为war（这对servlet很重要）：\nxml    &lt;packaging&gt;war&lt;/packaging&gt;Servlet接口Servlet接口定义了5个方法，分别是：\njavapublic interface Servlet {\n    void init(ServletConfig var1) throws ServletException;\n\n    ServletConfig getServletConfig();\n\n    void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;\n\n    String getServletInfo();\n\n    void destroy();\n}其中，init方法是在Servlet服务器首次将Servlet类加载到内存时调用的，由于Servlet类是单例模式（因此如果Servlet中定义了字段，要注意多线程并发访问的问题），所以init方法也只会被调用一次。Servlet容器会将一个ServletConfig对象传入init方法，这个对象包含了Servlet的配置信息，例如Servlet的名称，Servlet的初始化参数等等。\n配置 Servlet 的初始化参数有 2 种方式：\n\n使用web.xml配置初始化参数；（deprecated）\n使用@WebServlet注解配置初始化参数。\n\ngetServletConfig方法用于获取Servlet的配置信息。在很多实现中，返回值和init方法的参数是同一个对象。而一般来说，我们也不会用到这个方法，因此覆写为空也行。\nservice方法是在接收到请求时调用的，Servlet容器收到请求后，根据请求创建ServletRequest和ServletResponse对象，然后调用service方法，将这两个对象传入，由service方法处理请求。因此service函数是用于处理请求的核心函数，通过实现该方法即可处理请求。\ngetServletInfo方法用于获取Servlet的信息，很多实现也直接返回空字符串。一般来说，我们也不会用到这个方法，因此覆写为空也行。\ndestroy方法是在Servlet容器关闭时调用的，用于释放资源。\n这里定义了一个Servlet类作为参考：\njavapackage com.neuq.demo;\n\nimport javax.servlet.*;\nimport java.io.IOException;\n\n@WebServlet(\"/ServletClass\")\npublic class ServletClass implements  Servlet {\n\n    String str = null;\n\n    @Override\n    public void init(ServletConfig servletConfig) throws ServletException {\n        str = \"Hello, world!\";\n    }\n\n    @Override\n    public ServletConfig getServletConfig() {\n        return null;\n    }\n\n    @Override\n    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {\n        System.out.println(str);\n    }\n\n    @Override\n    public String getServletInfo() {\n        return null;\n    }\n\n    @Override\n    public void destroy() {\n\n    }\n}可见实现该类的重点在于实现service方法。\n注意到给类添加了一个注解@WebServlet(\"/ServletClass\")，即使用了@WebServlet注解的方式配置初始化参数。\n\n\n\n\n\n\n关于注解\n注解可以理解为：可以在任何代码中加入的程序可读的注释，这个注释可以用也可以不用，用的时候就拿出来看看这个注释里定义了什么东西可以用。\n更加深入的来说，在这个例子中，我们在这个Servlet类上使用了javax.servlet.annotation包中定义的一个注解（注解在编译之后会被编译器实现为一个接口类），Servlet容器在使用该Servlet类时，会通过反射机制读取这个注解，进而获取到Servlet的配置信息，然后进行初始化。\n\n\n这是这个注解的定义：\njava@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface WebServlet {\n    String name() default \"\";\n\n    String[] value() default {};\n\n    String[] urlPatterns() default {};\n\n    int loadOnStartup() default -1;\n\n    WebInitParam[] initParams() default {};\n\n    boolean asyncSupported() default false;\n\n    String smallIcon() default \"\";\n\n    String largeIcon() default \"\";\n\n    String description() default \"\";\n\n    String displayName() default \"\";\n}@Target注解表示该注解可以用在哪些地方，这里的ElementType.TYPE表示可以用在类上。\n@Retention注解表示该注解的生命周期，这里的RetentionPolicy.RUNTIME表示该注解会被保留到运行时，即可以通过反射机制读取该注解。\n关于这里注解的具体内容，可以看到有很多属性，这些属性就是Servlet的配置信息。例如name属性表示Servlet的名称，urlPatterns属性表示Servlet的URL路径。\n那上面的例子中，@WebServlet(\"/ServletClass\")又该如何解读呢？\n@WebServlet(\"/ServletClass\")其实是@WebServlet(value = \"/ServletClass\")的简写，因为value属性是@WebServlet注解的默认属性，所以可以省略不写value =。而对于一个@WebServlet注解来说，value属性就是urlPatterns属性，即@WebServlet(value = \"/ServletClass\")等价于@WebServlet(urlPatterns = \"/ServletClass\")。因此上述写法的含义就是：将Servlet的URL路径设置为/ServletClass。\n其他的属性也可以通过这种方式设置。如@WebServlet(urlPatterns = {\"/ServletClass\", \"/ServletClass2\"},loadOnStartup = 1)。则表示将Servlet的URL路径设置为/ServletClass和/ServletClass2，并且设置Servlet在部署的时候启动，而不是默认的在第一次请求时启动。urlPatterns也支持类似/*的通配符。\n抽象类HttpServlet在javax.servlet包中，实现了一个Servlet抽象类GenericServlet，它将Servlet接口中的其他方法都做了空实现，只保留了service方法作为抽象方法。因此，定义Servlet类时，我们可以继承GenericServlet类，只需要实现service方法即可。\n而在javax.servlet.http包中，又从抽象类GenericServlet中继承了一个抽象类HttpServlet，对HTTP协议进行了进一步的封装，使得我们可以更加方便的处理HTTP请求。\nHttpServlet类定义了多个处理HTTP请求的方法，其中最常用的是doGet和doPost方法，如果我们需要实现自己的业务请求，可以继承HttpServlet类，然后覆写对应的方法即可。\n这是一个继承了抽象类HttpServlet的类的定义：\njavaimport javax.servlet.http.*;\nimport javax.servlet.annotation.*;\n\n@WebServlet(\"/HandleRequest\")\npublic class HandleRequest extends HttpServlet {\n\n    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) {\n        // 处理POST请求\n    }\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) {\n        // 处理GET请求\n    }\n}\n\n\n\n\n\n具体生效的原理\nServlet容器收到请求后，根据请求创建ServletRequest和ServletResponse对象，并调用了类中的public void service(ServletRequest req, ServletResponse res)方法，这个方法会将ServletRequest和ServletResponse对象转换为HttpServletRequest和HttpServletResponse对象，这个方法之后会调用protected void service(HttpServletRequest req, HttpServletResponse resp)方法，这个方法会根据请求的方法调用对应的doXXX方法，例如GET请求会调用doGet方法，POST请求会调用doPost方法。\n\n\n注意到HttpServletRequest对象是用来获取请求信息的，而HttpServletResponse对象是用来设置响应信息的。\nServletRequest这个类用来获取请求信息。如：\n\n获取请求行信息\n获取请求方法：getMethod()方法\n获取虚拟路径：getContextPath()方法\n获取Servlet路径：getServletPath()方法\n获取请求参数：getQueryString()方法\n获取请求URI：getRequestURI()方法和getRequestURL()方法（URL是带有http://前缀的那种）\n获取协议版本：getProtocol()方法\n获取客户端IP：getRemoteAddr()方法\n\n\n获取请求头信息\n根据请求头名称获取请求头：getHeader(String name)方法（大小写不敏感）\n获取所有请求头：getHeaderNames()方法\n返回请求携带的所有Cookie：getCookies()\n\n\n获取请求体信息\n获取请求体：getInputStream()方法\n获取请求体的字符流：getReader()方法\n\n\n\n也可以用于其他功能，例如：\n\n获取请求参数（post和get都能用！）\n根据参数名获取单个请求参数：getParameter(String name)方法\n获取所有请求参数：getParameterNames()方法\n根据参数名获取请求参数的值的数组：getParameterValues(String name)方法（因为存在abc=123&amp;abc=456这种情况啦）\n获取所有请求参数的Map：getParameterMap()方法\n\n\n请求转发（将请求转发给另一个Servlet类处理）\n根据要转发的路径获取一个RequestDispatcher对象用于请求转发getRequestDispatcher(String path)方法。\n转发请求：用RequestDispatcher对象的方法forward(ServletRequest request, ServletResponse response)转发请求。\n\n\n数据共享（在请求转发的时候可以通过这个功能让不同的Servlet类共享数据）\n通过setAttribute方法设置共享数据：setAttribute(String name, Object value)方法\n\n\n获取ServletContext对象\ngetServletContext()方法\n\n\n\nServletResponse这个类用来设置响应信息。由于HTTP响应必须先发送Header，再发送Body，所以，操作HttpServletResponse对象时，必须先调用设置Header的方法，最后调用发送Body的方法。\n\n设置响应头信息\n设置响应头：setHeader(String name, String value)方法\n设置响应状态码：setStatus(int sc)方法\n设置响应体的字符编码：setCharacterEncoding(String charset)方法\n设置响应体的内容类型：setContentType(String type)方法\n设置响应体的内容长度：setContentLength(int len)方法（底层会自动设置，最好不要手动指定。如果写入的数据量很小，实际上会先写入缓冲区，如果写入的数据量很大，服务器会自动采用Chunked编码让浏览器能识别数据结束符而不需要设置Content-Length头。）\n添加Cookie：addCookie(Cookie cookie)方法\n添加Header：addHeader(String name, String value)方法\n设置Cookie过期时间：setMaxAge(int expiry)方法\n\n\n设置响应体信息\n获取输出流：getOutputStream()方法(只能二选一)\n获取输出字符流：getWriter()方法(只能二选一)\n\n\n刷新\nflush()方法\n\n\n\n\n\n\n\n\n\n\n特别注意\n大部分Web服务器都基于HTTP/1.1协议，会复用TCP连接。如果没有调用flush()，将导致缓冲区的内容无法及时发送到客户端。此外，写入完毕后千万不要调用close()，原因同样是因为会复用TCP连接，如果关闭写入流，将关闭TCP连接，使得Web服务器无法复用此TCP连接。\n\n\nSession在HTTP中，每个请求都是无状态的，即服务器无法区分两个请求是否来自同一个浏览器。而很多WEB应用需要区分用户。这就需要在HTTP通信中携带一些信息，因此诞生了Cookie和Session。\nCookie是保存在浏览器端的一小段文本，在每次请求时，浏览器都会将Cookie放在请求头中发送给服务器，作为标识用户的信息。而Session是保存在服务器端的一小段数据，在Java Web中是存储在WEB服务器端的java对象，用来保存用户的信息。\nCooket和Session是这样配合的：当客户端第一次访问服务器的时候，此时客户端的请求中不携带任何标识给服务器，此时服务器无法找到与之对应的session，就会新建session对象（每个Session对象有个唯一标识符），并在响应的时候，将该唯一标识符放到响应头的Set-Cookie中，以key-value的形式返回给客户端（意思是在Cookie中加上这段键值对）形式如：JSESSIONID=XXXXXXXXXXXXXXXXXX；其中JSESSIONID是key，而后面的value值是给该用户新创建的session的唯一标识符，之后浏览器再次进行服务器访问的时候，客户端会将此key-value放到cookie中一并请求服务器，服务器就会从Cookie中查找JSESSIONID，并根据此唯一标识符寻找对应的session对象，通过对session对象获得用户的信息。\njava    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // 根据Cookie获取session对象，如果没有则会创建\n        HttpSession session = request.getSession();\n        // 设置session的最大存活时间\n        session.setMaxInactiveInterval(60 * 60);\n        // 设置session的属性，保存用户信息，注意这里的value是Object类型\n        session.setAttribute(\"username\", \"admin\");\n        // 获取session的属性，注意返回值是Object类型\n        // String username = (String) session.getAttribute(\"username\");\n        // 删除session的属性\n        // session.removeAttribute(\"username\");\n        // 销毁session\n        // session.invalidate();\n    }关于Cookie的使用\njava    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // 获取Cookie\n        Cookie[] cookies = request.getCookies();\n        // 遍历Cookie\n        for (Cookie cookie : cookies) {\n            // 获取Cookie的名称\n            String name = cookie.getName();\n            // 获取Cookie的值\n            String value = cookie.getValue();\n        }\n        // 创建Cookie\n        Cookie cookie = new Cookie(\"username\", \"admin\");\n        // 设置Cookie的最大存活时间\n        cookie.setMaxAge(60 * 60);\n        // 设置Cookie生效的路径，浏览器只有在这个路径下才能发送这个Cookie\n        cookie.setPath(\"/\");\n        // 设置Cookie的域名，浏览器只有在这个域名下才能发送这个Cookie\n        cookie.setDomain(\"localhost\");\n        // 设置Cookie的安全属性，为true时，浏览器只有在HTTPS协议下才能发送这个Cookie\n        cookie.setSecure(true);\n        // 设置Cookie的HttpOnly属性\n        cookie.setHttpOnly(true);\n        // 添加Cookie\n        response.addCookie(cookie);\n\n        // 删除Cookie\n        // cookie.setMaxAge(0);\n        // response.addCookie(cookie);\n    }\n\n\n\n\n\n\nCookie的名称\n由于Cookie是以key-value的形式存储的，因此Cookie的名称不能重复，否则会覆盖。因此，像JSESSIONID这种被Session使用的Cookie的名称不应该被手动管理。\n\n\n","slug":"Servlet详解","date":"2023-09-29T09:42:00.000Z","categories_index":"Java","tags_index":"Java,Web开发,Servlet,Tomcat,HTTP","author_index":"Ac-Accelerator"},{"id":"3255a3c7fdb01a732e78ce23940a0d52","title":"STM32入门（八）：定时器","content":"有时会在单片机中需要等待一段时间再执行的命令。我们有两种方式实现，一种是让CPU空转，另一种是使用定时器。空转的方式会浪费CPU资源，且时间准确度很低（由于ARM使用流水线的原因），而定时器则不会。本文主要介绍定时器的使用。\n定时器的基本原理基本上就是一个带有自动重装载的16位累加计数器，计数器的时钟通过一个预分频器得到。当计数器的值达到设定值时，就会加载重装载值到计数器，并触发相应操作。\n定时器的分类一共有三个大类：常规定时器、专用定时器和内核定时器。\n\n常规定时器\n基本定时器\n通用定时器\n高级定时器\n\n\n专用定时器\n窗口看门狗\n独立看门狗\n实时时钟（RTC）\n低功耗定时器\n\n\n内核定时器\n系统定时器（SysTick）\n\n\n\n本文介绍常规定时器。\n定时器计数模式向上计数模式在向上计数模式中，计数器从0计数到自动加载值(TIMx_ARR计数器的内容)，然后重新从0开始计数并且产生一个计数器溢出事件。每次计数器溢出时可以产生更新事件（也可以不产生哦）。\n向下计数模式在向下模式中，计数器从自动装入的值(TIMx_ARR计数器的值)开始向下计数到0，然后从自动装入的值重新开始并且产生一个计数器向下溢出事件。每次计数器溢出时可以产生更新事件（也可以不产生哦）。\n中央对齐模式（向上/向下计数模式）\n\n\n\n\n\n\n\n\n在这个模式，不能写入TIMx_CR1中的DIR方向位。它由硬件更新并指示当前的计数方向。\n在中央对齐模式，计数器从0开始计数到自动加载的值(TIMx_ARR寄存器)−1，产生一个计数器溢出事件，然后向下计数到1并且产生一个计数器下溢事件；然后再从0开始重新计数。可以在每次计数上溢和每次计数下溢时产生更新事件（也可以不产生哦）；\n\n\n\n\n\n\n\n\n\n关于更新事件： 当发生一次更新事件时，所有寄存器会被更新：\n\n传送预装载值(TIMx_PSC寄存器的内容)至预分频器的缓冲区\n自动重装载影子寄存器被更新为预装载值(TIMx_ARR)。\n\n(通过软件或使用从模式控制器)设置TIMx_EGR寄存器的UG位也可以产生更新事件。设置TIMx_CR1中的UDIS位可以禁止产生更新事件。\n关于中断/DMA请求：配置中断使能寄存器(TIMx_DIER)UDE位后，每次更新事件会产生一个DMA请求。配置UIE位后，每次更新事件会产生一个更新中断。另外，如果设置了TIMx_CR1寄存器中的URS(选择更新请求)（用来决定UG位产生的更新事件对中断/DMA请求有没有用的），设置UG位可以产生一次更新事件UEV，但不设置UIF标志(即没有中断或DMA请求)，此时上溢下溢仍然会设置UIF标志哦。\n常规定时器不同的芯片的定时器个数等等都不一样，但是基本原理都是一样的。这里以STM32F103为例。\n常规定时器的共同点包括：\n\n都支持16位的计数器位数\n都支持向上计数\n分频系数都是1~65535\n\n溢出时间计算\n\n其中  是TIMxCLK的时钟间隔，单位为ms。\n基本定时器TIM6、TIM7\n用途：没有输入输出通道，常用做定时功能。\n主要特性\n是一个16位的递增计数器\n16位的预分频器\n可用于触发DAC（数字模拟转换器）的转换\n在更新事件时产生中断/DMA请求\n挂载在APB1总线上\n\n\n\n寄存器：\n\nTIMx_CNT：计数器寄存器\nTIMx_PSC：预分频器寄存器\nTIMx_ARR：自动重装载寄存器\nTIMx_CR1：控制寄存器1(包含计数器使能位CEN、自动重装载预加载使能位ARPE、更新请求源位URS、禁止更新位UDIS)\nTIMx_CR2：控制寄存器2(MMS主模式选择)\nTIMx_DIER：DMA/中断使能寄存器\nTIMx_SR：状态寄存器(UIF中断状态)\nTIMx_EGR：事件生成寄存器(UG位用于产生更新事件)\n\n计数模式仅仅支持向上计数模式。\n自动重装载寄存器是预加载的，每次读写自动重装载寄存器时，实际上是通过读写预加载寄存器实现。根据TIMx_CR1寄存器中的自动重装载预加载使能位(ARPE)（用来指示预加载寄存器内容是否立刻生效的啦），写入预加载寄存器的内容能够立即或在每次更新事件时，传送到它的影子寄存器。计数器由预分频输出CK_CNT驱动，设置TIMx_CR1寄存器中的计数器使能位(CEN)使能计数器计数。\n预分频可以以系数介于1至65536之间的任意数值对计数器时钟分频。它是通过一个16位寄存器(TIMx_PSC)的计数实现分频。因为TIMx_PSC控制寄存器具有缓冲，可以在运行过程中改变它的数值，新的预分频数值将在下一个更新事件时起作用。\nTIMxCLK频率：由于其挂载在APB1总线上，所以其时钟（TIMxCLK）频率与APB1总线的时钟频率相关。具体频率需要查看时钟树的相关设置HAL_StatusTypeDef Stm32_Clock_Init(); 。\n基本定时器配置步骤\n配置定时器基础工作参数：HAL_TIM_Base_Init()\n定时器基础MSP初始化：HAL_TIM_Base_MspInit()，配置NVIC和时钟\n使能更新中断并启动计数器：HAL_TIM_Base_Start_IT()\n设置优先级使能中断：HAL_NVIC_SetPriority()和HAL_NVIC_EnableIRQ()\n编写中断服务函数：TIMx_IRQHandler()→HAL_TIM_IRQHandler()\n编写定时器更新中断服务函数：HAL_TIM_PeriodElapsedCallback()\n\n基本定时器的应用:延时HAL_StatusTypeDef Stm32_Clock_Init();void LED_Init();\ncpp#include &lt;stm32f1xx_hal.h&gt;\n\nHAL_StatusTypeDef Stm32_Clock_Init();\nvoid LED_Init();\n\nvoid BaseTim_Init(uint32_t arr, uint32_t psc);//基本定时器初始化函数\nstatic TIM_HandleTypeDef g_timx_handle;//定时器句柄\n\nint main()\n{\n    HAL_Init();                     // 初始化HAL库\n    Stm32_Clock_Init(RCC_PLL_MUL9); // 初始化时钟\n    LED_Init();                     // 初始化LED外设\n    BaseTim_Init(7199, 4999);       // 初始化基本定时器，定时时间为500ms\n    while (1)\n    {\n        LED1_OFF();\n    }\n}\n\n\nvoid BaseTim_Init(uint32_t arr, uint32_t psc)\n{\n    g_timx_handle.Instance = TIM6;      // 指定定时器为TIM6\n    g_timx_handle.Init.Prescaler = psc; // 设置预分频系数\n    // g_timx_handle.Init.CounterMode = TIM_COUNTERMODE_UP;//该项在基本定时器中无用，如果设置最好设置为TIM_COUNTERMODE_UP\n    g_timx_handle.Init.Period = arr;       // 设置自动重装载寄存器周期的值\n    HAL_TIM_Base_Init(&amp;g_timx_handle);     // 初始化定时器\n    HAL_TIM_Base_Start_IT(&amp;g_timx_handle); // 开启定时器中断并且启动定时器\n}\n\nvoid HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim) // 定时器硬件初始化：配置NVIC和时钟\n{\n    if (htim-&gt;Instance == TIM6) /// 定时器判断，如果有多个定时器，这个判断很有必要\n    {\n        __HAL_RCC_TIM6_CLK_ENABLE();           // 使能TIM6时钟\n        HAL_NVIC_SetPriority(TIM6_IRQn, 4, 0); // 设置TIM6中断优先级\n        HAL_NVIC_EnableIRQ(TIM6_IRQn);         // 开启TIM6中断\n    }\n}\n\nvoid TIM6_IRQHandler(void) // 定时器中断服务函数\n{\n    HAL_TIM_IRQHandler(&amp;g_timx_handle); // 调用HAL库中断处理公用函数\n}\n\nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) // 被HAL_TIM_IRQHandler()调用\n{\n    if (htim-&gt;Instance == TIM6) // 定时器判断，如果有多个定时器，这个判断很有必要\n    {\n        LED0_TOGGLE(); // 一些功能\n    }\n}通用定时器TIM2、TIM3、TIM4、TIM5\n用途：有输入输出通道，可用于输入捕获、输出比较。也可用作定时。\n主要特性\n是一个16位的递增、递减、中心对齐计数器\n16位的预分频器\n有4个独立的通道，可用于输入捕获、输出比较、PWM输出、单脉冲模式输出\n可用于触发ADC（模数转换器）/DAC（数字模拟转换器）的转换\n在更新事件、触发事件、捕获/比较事件时产生中断/DMA请求\n使用外部信号定时器且可实现多个定时器互联的同步电路（级联）\n支持编码器和霍尔传感器电路\n挂载在APB1总线上\n\n\n\n寄存器：\n\nTIMx_CNT：计数器寄存器\nTIMx_PSC：预分频器寄存器\nTIMx_ARR：自动重装载寄存器\nTIMx_CR1：控制寄存器1(包含计数器使能位CEN、自动重装载预加载使能位ARPE、更新请求源位URS、禁止更新位UDIS、方向位DIR、中央对齐模式选择位CMS、单脉冲模式选择位OPM)\nTIMx_CR2：控制寄存器2(MMS主模式选择)\nTIMx_SMCR：从模式控制寄存器\nTIMx_DIER：DMA/中断使能寄存器\nTIMx_SR：状态寄存器(UIF中断状态)\nTIMx_EGR：事件生成寄存器(UG位用于产生更新事件)\nTIMx_CCMRx：捕获/比较模式寄存器\nTIMx_CCER：捕获/比较使能寄存器\nTIMx_CCRx：捕获/比较寄存器\nTIMx_DCR：DMA控制寄存器\nTIMx_DMAR：连续模式的DMA地址\n\n计数模式支持向上计数模式、向下计数模式、中央对齐模式。\n自动重装载寄存器是预加载的，每次读写自动重装载寄存器时，实际上是通过读写预加载寄存器实现。根据TIMx_CR1寄存器中的自动重装载预加载使能位(ARPE)（用来指示预加载寄存器内容是否立刻生效的啦），写入预加载寄存器的内容能够立即或在每次更新事件时，传送到它的影子寄存器。计数器由预分频输出CK_CNT驱动，设置TIMx_CR1寄存器中的计数器使能位(CEN)使能计数器计数。\n预分频可以以系数介于1至65536之间的任意数值对计数器时钟分频。它是通过一个16位寄存器(TIMx_PSC)的计数实现分频。因为TIMx_PSC控制寄存器具有缓冲，可以在运行过程中改变它的数值，新的预分频数值将在下一个更新事件时起作用。\nTIMxCLK频率：由于其挂载在APB1总线上，所以其时钟（TIMxCLK）频率与APB1总线的时钟频率相关。具体频率需要查看时钟树的相关设置HAL_StatusTypeDef Stm32_Clock_Init(); 。\n时钟选择计数器时钟可由下列时钟源提供：\n\n内部时钟(CK_INT)\n外部时钟模式1：外部输入脚(TIx)\n外部时钟模式2：外部触发输入(ETR)\n内部触发输入(ITRx)：使用一个定时器作为另一个定时器的预分频器，如可以配置一个定时器Timer1而作为另一个定时器Timer2的预分频器。\n\n内部时钟：预分频器的时钟就由内部时钟CK_INT提供。(TIMx_SMCR寄存器的SMS=000,ECE=0)\n外部时钟模式1：计数器可以在选定输入端的每个上升沿或下降沿计数。(TIMx_SMCR寄存器的SMS=111)\n\n\n外部时钟模式2：计数器能够在外部触发ETR的每一个上升沿或下降沿计数。(TIMx_SMCR寄存器中的ECE=1)\n\n\n内部触发输入：\n\n\n\n输入捕获模式在输入捕获模式下，当检测到ICx信号上相应的边沿后，计数器的当前值被锁存到捕获/比较寄存器(TIMx_CCRx)中。当捕获事件发生时，相应的CCxIF标志(TIMx_SR寄存器)被置’1’，如果使能了中断或者DMA操作，则将产生中断或者DMA操作。如果捕获事件发生时CCxIF标志已经为高，那么重复捕获标志CCxOF(TIMx_SR寄存器)被置’1’。写CCxIF=0可清除CCxIF，或读取存储在TIMx_CCRx寄存器中的捕获数据也可清除CCxIF。写CCxOF=0可清除CCxOF。\n\n\n\n以下例子说明如何在TI1输入的上升沿时捕获计数器的值到TIMx_CCR1寄存器中，步骤如下：\n\n选择有效输入端：TIMx_CCR1必须连接到TI1输入，所以写入TIMx_CCR1寄存器中的CC1S=01，只要CC1S不为’00’，通道被配置为输入，并且TM1_CCR1寄存器变为只读。\n根据输入信号的特点，配置输入滤波器为所需的带宽(即输入为TIx时，输入滤波器控制位是TIMx_CCMRx寄存器中的ICxF位)。假设输入信号在最多5个内部时钟周期的时间内抖动，我们须配置滤波器的带宽长于5个时钟周期。因此我们可以(以fDTS频率)连续采样8次，以确认在TI1上一次真实的边沿变换，即在TIMx_CCMR1寄存器中写入IC1F=0011。\n选择TI1通道的有效转换边沿，在TIMx_CCER寄存器中写入CC1P=0(上升沿)。\n配置输入预分频器。在本例中，我们希望捕获发生在每一个有效的电平转换时刻，因此预分频器被禁止(写TIMx_CCMR1寄存器的IC1PS=00)。\n设置TIMx_CCER寄存器的CC1E=1，允许捕获计数器的值到捕获寄存器中。\n如果需要，通过设置TIMx_DIER寄存器中的CC1IE位允许相关中断请求，通过设置TIMx_DIER寄存器中的CC1DE位允许DMA请求。\n\n当发生一个输入捕获时：\n\n产生有效的电平转换时，计数器的值被传送到TIMx_CCR1寄存器。\nCC1IF标志被设置(中断标志)。当发生至少2个连续的捕获时，而CC1IF未曾被清除，CC1OF也被置’1’。\n如设置了CC1IE位，则会产生一个中断。\n如设置了CC1DE位，则还会产生一个DMA请求。\n\n为了处理捕获溢出，建议在读出捕获溢出标志之前读取数据，这是为了避免丢失在读出捕获溢出标志之后和读取数据之前可能产生的捕获溢出信息。\n输入捕获模式配置步骤：\n\n配置定时器基础工作参数：HAL_TIM_IC_Init()\n定时器输入捕获MSP初始化：HAL_TIM_IC_MspInit()，配置NVIC和时钟、GPIO\n配置输入通道映射、捕获边沿等：HAL_TIM_IC_ConfigChannel()\n设置优先级使能中断：HAL_NVIC_SetPriority()和HAL_NVIC_EnableIRQ()\n使能定时器更新中断：__HAL_TIM_ENABLE_IT()\n使能捕获、捕获中断以及计数器：HAL_TIM_IC_START_IT()\n编写中断服务函数：TIMx_IRQHandler()→HAL_TIM_IRQHandler()\n编写更新中断和捕获回调函数：HAL_TIM_PeriodElapsedCallback()和HAL_TIM_IC_CaptureCallback()\n\n测量脉冲宽度：\nHAL_StatusTypeDef Stm32_Clock_Init();void LED_Init();void LED0_TOGGLE();void UART_Init(uint32_t bound);void print(char *str);void printn(char *str, uint32_t n);\ncpp#include &lt;stm32f1xx_hal.h&gt;\n\nHAL_StatusTypeDef Stm32_Clock_Init();\nvoid UART_Init(uint32_t bound);\nvoid LED_Init();\nvoid print(char *str);\nvoid printn(char *str, uint32_t n);\nvoid LED0_TOGGLE();\n\n\nextern TIM_HandleTypeDef htimx;\nextern uint16_t capture;\nextern uint32_t status ;\nvoid GeneralTim_Init(uint32_t arr, uint32_t psc);//通用定时器初始化函数\n\nint main()\n{\n    HAL_Init();                     // 初始化HAL库\n    Stm32_Clock_Init(RCC_PLL_MUL9); // 初始化时钟\n    LED_Init();                     // 初始化LED\n    UART_Init(115200);              // 初始化串口波特率为115200\n    GeneralTim_Init(0XFFFF, 71);    // 初始化定时器5，自动重装值为0XFFFF，预分频系数为71\n    uint32_t time = 0;\n    while (1)\n    {\n        if (status &amp; (1U &lt;&lt; 31U))\n        {\n            print(\"capture:\");\n            uint32_t temp = (status &amp; 0X3FFFFFFF) * 0XFFFF + capture;\n            char str[16];\n            uint8_t i = 0;\n            while (temp)\n            {\n                str[i] = temp % 10 + '0';\n                ++i;\n                temp /= 10;\n            }\n            while (i)\n            {\n                --i;\n                printn(&amp;str[i], 1);\n            }\n            print(\"\\r\\n\");\n            status = 0;\n        }\n        time++;\n        if (time % 20 == 0)\n        {\n            LED0_TOGGLE();\n        }\n        if (time % 500 == 0)\n        {\n            print(\"Hello World!\\r\\n\");\n        }\n        HAL_Delay(10);\n    }\n}\n\n\nTIM_HandleTypeDef htimx;//定时器句柄\n\nuint16_t capture = 0; // 捕获值\nuint32_t status = 0;  // 捕获状态,bit31:捕获完成标志，bit30:捕获到高电平标志\n\nvoid GeneralTim_Init(uint32_t arr, uint32_t psc) // arr为自动重装值，psc为预分频值\n{\n    htimx.Instance = TIM5;                       // 定时器5\n    htimx.Init.Prescaler = psc;                  // 预分频值\n    htimx.Init.Period = arr;                     // 自动重装值\n    htimx.Init.CounterMode = TIM_COUNTERMODE_UP; // 向上计数\n    HAL_TIM_IC_Init(&amp;htimx);                     // 初始化输入捕获\n\n    TIM_IC_InitTypeDef sConfigIC = {0};                          // 定义输入捕获初始化结构体\n    sConfigIC.ICPolarity = TIM_ICPOLARITY_RISING;                // 上升沿捕获\n    sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;            // 映射到TI1上\n    sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;                      // 不分频\n    sConfigIC.ICFilter = 0;                                      // 不滤波\n    HAL_TIM_IC_ConfigChannel(&amp;htimx, &amp;sConfigIC, TIM_CHANNEL_1); // 配置通道1\n\n    __HAL_TIM_ENABLE_IT(&amp;htimx, TIM_IT_UPDATE); // 使能更新中断\n    HAL_TIM_IC_Start_IT(&amp;htimx, TIM_CHANNEL_1); // 开启输入捕获中断\n}\n\nvoid HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)\n{\n    if (htim-&gt;Instance == TIM5) // TIM5\n    {\n        GPIO_InitTypeDef GPIO_InitStruct = {0};       // 定义GPIO初始化结构体\n        GPIO_InitStruct.Pin = GPIO_PIN_0;             // PA0\n        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;       // 复用推挽输出\n        GPIO_InitStruct.Pull = GPIO_PULLDOWN;         // 下拉\n        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; // 速度可以不设置\n        __HAL_RCC_GPIOA_CLK_ENABLE();                 // 使能GPIOA时钟\n        __HAL_RCC_TIM5_CLK_ENABLE();                  // 使能TIM5时钟\n        HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);       // 初始化GPIOA0\n        HAL_NVIC_SetPriority(TIM5_IRQn, 4, 0);        // 设置TIM5中断优先级，注意要比SysTick_IRQn的优先级高\n        HAL_NVIC_EnableIRQ(TIM5_IRQn);                // 开启TIM5中断\n    }\n}\n\nvoid TIM5_IRQHandler(void)\n{\n    HAL_TIM_IRQHandler(&amp;htimx); // 调用HAL库TIM中断处理公用函数\n}\n\nvoid HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)\n{\n\n    if (htim-&gt;Instance == TIM5) // TIM5\n    {\n        if (htim-&gt;Channel == HAL_TIM_ACTIVE_CHANNEL_1) // 通道1\n        {\n            if (status &amp; (1U &lt;&lt; 31U))\n            {\n            }\n            else\n            {\n                if (status &amp; (1U &lt;&lt; 30U)) // 捕获过上升沿，捕获到了下降沿\n                {\n                    status |= (1U &lt;&lt; 31U);                                               // 标记成功捕获到下降沿\n                    capture = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);            // 读取捕获值\n                    TIM_RESET_CAPTUREPOLARITY(htim, TIM_CHANNEL_1);                      // 重置捕获极性\n                    TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_1, TIM_ICPOLARITY_RISING); // 设置为上升沿捕获\n                }\n                else // 首次捕获上升沿\n                {\n                    status = (1U &lt;&lt; 30U);\n                    capture = 0;\n                    __HAL_TIM_DISABLE(htim);                                              // 关闭定时器\n                    __HAL_TIM_SET_COUNTER(htim, 0);                                       // 计数器清零\n                    TIM_RESET_CAPTUREPOLARITY(htim, TIM_CHANNEL_1);                       // 重置捕获极性\n                    TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_1, TIM_ICPOLARITY_FALLING); // 设置为下降沿捕获\n                    __HAL_TIM_ENABLE(htim);                                               // 使能定时器\n                    //其实这样写有一个问题，从捕获到上升沿到重新启动定时器，这段时间内的脉宽会被忽略，可以采用更好的方式解决，在这里就不做更改了。\n                }\n            }\n        }\n    }\n}\n\nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)\n{\n    if (htim-&gt;Instance == TIM5) // TIM5\n    {\n        if (status &amp; (1U &lt;&lt; 31U))\n            ;\n        else\n        {\n            status++;\n        }\n    }\n}输出比较模式此项功能是用来控制一个输出波形，或者指示一段给定的的时间已经到时。\n\n\n当计数器与捕获/比较寄存器的内容相同时，输出比较功能做如下操作：\n\n将输出比较模式(TIMx_CCMRx寄存器中的OCxM位)和输出极性(TIMx_CCER寄存器中的CCxP位)定义的值输出到对应的引脚上。在比较匹配时，输出引脚可以保持它的电平(OCxM=000)、被设置成有效电平(OCxM=001)、被设置成无效电平(OCxM=010)或进行翻转(OCxM=011)。\n设置中断状态寄存器中的标志位(TIMx_SR寄存器中的CCxIF位)。\n若设置了相应的中断屏蔽(TIMx_DIER寄存器中的CCxIE位)，则产生一个中断。\n若设置了相应的使能位(TIMx_DIER寄存器中的CCxDE位，TIMx_CR2寄存器中的CCDS位选择DMA请求功能)，则产生一个DMA请求。\n\nTIMx_CCMRx中的OCxPE位选择TIMx_CCRx寄存器是否需要使用预装载寄存器。在输出比较模式下，更新事件UEV对OCxREF和OCx输出没有影响。同步的精度可以达到计数器的一个计数周期。输出比较模式(在单脉冲模式下)也能用来输出一个单脉冲。\n输出比较模式的配置步骤：\n\n选择计数器时钟(内部，外部，预分频器)\n将相应的数据写入TIMx_ARR和TIMx_CCRx寄存器中\n如果要产生一个中断请求和/或一个DMA请求，设置CCxIE位和/或CCxDE位。\n选择输出模式，例如当计数器CNT与CCRx匹配时翻转OCx的输出引脚，CCRx预装载未用，开启OCx输出且高电平有效，则必须设置OCxM=’011’、OCxPE=’0’、CCxP=’0’和CCxE=’1’。\n设置TIMx_CR1寄存器的CEN位启动计数器TIMx_CCRx寄存器能够在任何时候通过软件进行更新以控制输出波形，条件是未使用预装载寄存器(OCxPE=’0’，否则TIMx_CCRx影子寄存器只能在发生下一次更新事件时被更新)。\n\nPWM输出模式在TIMx_CCMRx寄存器中的OCxM位写入’110’(PWM模式1)或’111’(PWM模式2)，能够独立地设置每个OCx输出通道产生一路PWM。必须设置TIMx_CCMRx寄存器OCxPE位以使能相应的预装载寄存器，最后还要设置TIMx_CR1寄存器的ARPE位，(在向上计数或中心对称模式中)使能自动重装载的预装载寄存器。\nOCx的极性可以通过软件在TIMx_CCER寄存器中的CCxP位设置，它可以设置为高电平有效或低电平有效。TIMx_CCER寄存器中的CCxE位控制OCx输出使能。详见TIMx_CCERx寄存器的描述。\nPWM输出模式配置步骤：\n\n配置定时器基础工作参数：HAL_TIM_PWM_Init()\n定时器基础MSP初始化：HAL_TIM_PWM_MspInit()，配置NVIC和时钟、GPIO\n配置PWM模式/比较值：HAL_TIM_PWM_ConfigChannel()\n使能更新中断并启动计数器：HAL_TIM_PWM_Start()\n配置修改占空比（可选）： __HAL_TIM_SET_COMPARE()\n使能通道预装载（可选）：__HAL_TIM_ENABLE_OCx_PRELOAD()\n\n呼吸灯\nHAL_StatusTypeDef Stm32_Clock_Init();\ncpp#include &lt;stm32f1xx_hal.h&gt;\nHAL_StatusTypeDef Stm32_Clock_Init();\n\nextern TIM_HandleTypeDef htimx;//通用定时器句柄\nvoid GeneralTim_Init(uint32_t arr, uint32_t psc);//通用定时器初始化函数\n\nint main()\n{\n    HAL_Init();                     // 初始化HAL库\n    Stm32_Clock_Init(RCC_PLL_MUL9); // 初始化时钟\n    GeneralTim_Init(499, 71);       // 初始化通用定时器，周期为0.5ms\n    _Bool flag = 1;\n    unsigned int pwmval = 0;\n    while (1)\n    {\n        HAL_Delay(10);\n        if (flag)\n            pwmval++;\n        else\n            pwmval--;\n        if (pwmval == 0)\n            flag = 1;\n        else if (pwmval == 300)\n            flag = 0;\n        __HAL_TIM_SET_COMPARE(&amp;htimx, TIM_CHANNEL_2, pwmval);\n    }\n}\n\nTIM_HandleTypeDef htimx;\n\nvoid GeneralTim_Init(uint32_t arr, uint32_t psc) // arr为自动重装值，psc为预分频值\n{\n    TIM_OC_InitTypeDef sConfigOC = {0};                           // 定义输出比较结构体\n    htimx.Instance = TIM3;                                        // 定时器3\n    htimx.Init.Prescaler = psc;                                   // 预分频值\n    htimx.Init.Period = arr;                                      // 自动重装值\n    htimx.Init.CounterMode = TIM_COUNTERMODE_UP;                  // 向上计数\n    HAL_TIM_PWM_Init(&amp;htimx);                                     // 初始化PWM，调用HAL_TIM_PWM_MspInit()\n    sConfigOC.OCMode = TIM_OCMODE_PWM1;                           // PWM模式1，即向上计数时TIMx_CNT&lt;TIMx_CCRx时输出有效电平\n    sConfigOC.Pulse = arr / 2;                                    // 占空比为50%，之后可用__HAL_TIM_SET_COMPARE()修改\n    sConfigOC.OCPolarity = TIM_OCPOLARITY_LOW;                    // 配置CC1P为1，即有效电平为低电平\n    HAL_TIM_PWM_ConfigChannel(&amp;htimx, &amp;sConfigOC, TIM_CHANNEL_2); // 配置PWM通道\n    HAL_TIM_PWM_Start(&amp;htimx, TIM_CHANNEL_2);                     // 开启PWM\n}\n\nvoid HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)//通用定时器硬件初始化：配置NVIC和时钟、GPIO\n{\n    if (htim-&gt;Instance == TIM3) // TIM3\n    {\n        // 因为TIM3_CH2可通过重映射连接到LED所在的PB5，所以配置GPIOB5重映射为TIM3_CH2\n        GPIO_InitTypeDef GPIO_InitStruct = {0};       // 定义GPIO初始化结构体\n        GPIO_InitStruct.Pin = GPIO_PIN_5;             // PB5\n        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;       // 推挽复用功能\n        GPIO_InitStruct.Pull = GPIO_PULLUP;           // 上拉\n        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; // 高速\n        __HAL_RCC_GPIOB_CLK_ENABLE();                 // 使能GPIOB时钟\n        __HAL_RCC_TIM3_CLK_ENABLE();                  // 使能TIM3时钟\n        HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);       // 初始化GPIOB5\n        __HAL_RCC_AFIO_CLK_ENABLE();                  // 使能AFIO时钟\n        __HAL_AFIO_REMAP_TIM3_PARTIAL();              // 重映射TIM3_CH2到PB5\n    }\n}计时基本定时功能：和基本定时器的配置步骤类似，可以参考基本定时器的配置步骤。不同在于通用定时器的句柄（依然是 TIM_HandleType）可配置性更强，可配置的参数（可实现的功能）更多。\n由于通用定时器的时钟源可以来自内部也可以来自外部，因此比基本定时器的功能稍多，如果要使用外部时钟，还需要配置外部时钟源。如果不使用外部时钟，那么通用定时器的配置步骤和基本定时器的配置步骤是一样的（仅仅是名称里的数字如TIM2、TIM6这样的差别）。\n如果使用的是外部时钟模式：\n\n配置定时器基础工作参数：HAL_TIM_IC_Init()\n定时器输入捕获MSP初始化：HAL_TIM_IC_MspInit()，配置NVIC和时钟、GPIO\n配置定时器从模式：HAL_TIM_SlaveConfigSynchro()\n使能输入捕获并启动计数器：HAL_TIM_IC_Start()\n获取计数器值：__HAL_TIM_GET_COUNTER()\n设置计数器值：__HAL_TIM_SET_COUNTER()\n\ncppvoid GeneralTim_Init(uint32_t arr, uint32_t psc)\n{\n    htimx.Instance = TIM2;                       // 定时器2\n    htimx.Init.Prescaler = psc;                  // 预分频系数\n    htimx.Init.CounterMode = TIM_COUNTERMODE_UP; // 向上计数\n    htimx.Init.Period = arr;                     // 自动重装载值\n    HAL_TIM_IC_Init(&amp;htimx);                     // 初始化定时器\n\n    TIM_SlaveConfigTypeDef sSlaveConfig = {0};\n    sSlaveConfig.SlaveMode = TIM_SLAVEMODE_EXTERNAL1;          // 选择外部时钟模式\n    sSlaveConfig.InputTrigger = TIM_TS_TI1FP1;                 // 选择TI1FP1作为输入触发源\n    sSlaveConfig.TriggerPolarity = TIM_TRIGGERPOLARITY_RISING; // 选择上升沿触发\n    sSlaveConfig.TriggerFilter = 0;                            // 不滤波\n    HAL_TIM_SlaveConfigSynchronization(&amp;htimx, &amp;sSlaveConfig); // 配置定时器2为从模式\n\n    HAL_TIM_IC_Start(&amp;htimx, TIM_CHANNEL_1); // 开启通道1的输入捕获\n}\n\nvoid HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)\n{\n    if (htim-&gt;Instance == TIM2) // 如果是定时器2\n    {\n        __HAL_RCC_TIM2_CLK_ENABLE();  // 使能定时器2时钟\n        __HAL_RCC_GPIOA_CLK_ENABLE(); // 使能GPIOA时钟\n        GPIO_InitTypeDef GPIO_InitStruct = {0};\n        GPIO_InitStruct.Pin = GPIO_PIN_0;             // 指定要初始化的引脚\n        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;       // 指定引脚模式为复用推挽输出\n        GPIO_InitStruct.Pull = GPIO_PULLDOWN;         // 指定引脚上下拉为下拉\n        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; // 指定引脚速度为高速\n        HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);       // 初始化PA0引脚\n    }\n}\n高级定时器TIM1、TIM8\n用途：有输入输出通道，可用于输入捕获、输出比较。可用于带死区控制的互补信号输出、刹车输入。也可用于定时。（电机控制、数字电源控制）\n主要特性\n是一个16位的递增、递减、中心对齐计数器\n16位的预分频器\n有4个独立的通道，可用于输入捕获、输出比较、PWM输出、单脉冲模式输出\n可用于触发ADC（模数转换器）/DAC（数字模拟转换器）的转换\n在更新事件、触发事件、捕获/比较事件时产生中断/DMA请求\n使用外部信号定时器且可实现多个定时器互联的同步电路（级联）\n支持编码器和霍尔传感器电路\n挂载在APB2总线上\n带有重复计数器\n死区时间带可编程的互补输出\n断路输入，用于将定时器的输出信号置于用户可选的安全配置中。\n\n\n\n\n\n\n寄存器：\n\nTIMx_CNT：计数器寄存器\nTIMx_PSC：预分频器寄存器 \nTIMx_ARR：自动装载寄存器 \nTIMx_RCR：重复次数寄存器 \nTIMx_CR1：控制寄存器1\nTIMx_CR2：控制寄存器2\nTIMx_SMCR：从模式控制寄存器\nTIMx_DIER：DMA/中断使能寄存器\nTIMx_SR：状态寄存器\nTIMx_EGR：事件生成寄存器\nTIMx_CCMR1：通道1和通道2的捕获/比较模式寄存器\nTIMx_CCMR2：通道3和通道4的捕获/比较模式寄存器\nTIMx_CCER：捕获/比较使能寄存器\nTIMx_CCR1：捕获/比较寄存器1\nTIMx_CCR2：捕获/比较寄存器2\nTIMx_CCR3：捕获/比较寄存器3\nTIMx_CCR4：捕获/比较寄存器4\nTIMx_BDTR：断路器寄存器\nTIMx_DCR：DMA控制寄存器\nTIMx_DMAR：DMA地址寄存器\n\n计数模式支持向上计数模式、向下计数模式、中央对齐模式。\n自动重装载寄存器是预加载的，每次读写自动重装载寄存器时，实际上是通过读写预加载寄存器实现。根据TIMx_CR1寄存器中的自动重装载预加载使能位(ARPE)（用来指示预加载寄存器内容是否立刻生效的啦），写入预加载寄存器的内容能够立即或在每次更新事件时，传送到它的影子寄存器。计数器由预分频输出CK_CNT驱动，设置TIMx_CR1寄存器中的计数器使能位(CEN)使能计数器计数。\n预分频可以以系数介于1至65536之间的任意数值对计数器时钟分频。它是通过一个16位寄存器(TIMx_PSC)的计数实现分频。因为TIMx_PSC控制寄存器具有缓冲，可以在运行过程中改变它的数值，新的预分频数值将在下一个更新事件时起作用。\n在高级计数器中，计数器上溢/下溢时更新事件(UEV)只能在重复计数达到0的时候产生。重复计数器在下述任一条件成立时递减：\n\n向上计数模式下每次计数器溢出时 \n向下计数模式下每次计数器下溢时\n中央对齐模式下每次上溢和每次下溢时。虽然这样限制了PWM的最大循环周期为128，但它能够在每个PWM周期2次更新占空比。在中央对齐模式下，因为波形是对称的，如果每个PWM周期中仅刷新一次比较寄存器，则最大的分辨率为2xTck。\n\n重复计数器是自动加载的，重复速率是由TIMx_RCR寄存器的值定义。当更新事件由软件产生(通过设置TIMx_EGR 中的UG位)或者通过硬件的从模式控制器产生，则无论重复计数器的值是多少，立即发生更新事件，并且TIMx_RCR寄存器中的内容被重载入到重复计数器。\nTIMxCLK频率：由于其挂载在APB2总线上，所以其时钟（TIMxCLK）频率与APB1总线的时钟频率相关。具体频率需要查看时钟树的相关设置HAL_StatusTypeDef Stm32_Clock_Init();。\n高级定时器输出指定个数PWM波形的配置步骤：\n\n配置定时器基础工作参数：HAL_TIM_PWM_Init()\n定时器基础MSP初始化：HAL_TIM_PWM_MspInit()，配置NVIC和时钟、GPIO\n配置PWM模式/比较值：HAL_TIM_PWM_ConfigChannel()\n设置优先级使能中断：HAL_NVIC_SetPriority()和HAL_NVIC_EnableIRQ()\n使能定时器更新中断：__HAL_TIM_ENABLE_IT()\n使能输出、主输出和计数器：HAL_TIM_PWM_Start()\n编写中断服务函数：TIMx_IRQHandler()→HAL_TIM_IRQHandler()\n编写更新中断函数：HAL_TIM_PeriodElapsedCallback()\n\n\n\n\n\n\n\n\n\n\n高级定时器输出必须把MOE位设置为1，否则无法输出。\nHAL_StatusTypeDef Stm32_Clock_Init();void KEY_Init();\nc#include &lt;stm32f1xx_hal.h&gt;\n\nHAL_StatusTypeDef Stm32_Clock_Init();\nvoid KEY_Init();\nvoid AdvancedTim_Init(uint32_t arr, uint32_t psc);\nvoid update_pwm_num(uint8_t num);\n\nint main()\n{\n    HAL_Init();                   // 初始化HAL库\n    Stm32_Clock_Init();           // 初始化时钟\n    KEY_Init();                   // 初始化按键\n    AdvancedTim_Init(4999, 7199); // 初始化定时器8，自动重装值为4999，预分频系数为7199\n\n    // 配置PE5为输入引脚，避免冲突\n    GPIO_InitTypeDef GPIO_InitStruct = {0};\n    GPIO_InitStruct.Pin = GPIO_PIN_5;       // 指定要初始化的引脚\n    GPIO_InitStruct.Pull = GPIO_PULLUP;     // 上拉输入\n    GPIO_InitStruct.Mode = GPIO_MODE_INPUT; // 指定引脚模式为推挽输出\n    __HAL_RCC_GPIOE_CLK_ENABLE();           // 使能GPIOE时钟\n    HAL_GPIO_Init(GPIOE, &amp;GPIO_InitStruct); // 初始化PE5引脚\n\n    while (1)\n    {\n        HAL_Delay(10);\n    }\n}\n\nTIM_HandleTypeDef htimx;\n\nuint8_t num_pwm = 0;\n\nvoid AdvancedTim_Init(uint32_t arr, uint32_t psc)\n{\n    htimx.Instance = TIM8; // TIM8\n    htimx.Init.Prescaler = psc;//\n    htimx.Init.CounterMode = TIM_COUNTERMODE_UP;\n    htimx.Init.Period = arr;\n    htimx.Init.RepetitionCounter = 0;\n    HAL_TIM_PWM_Init(&amp;htimx);\n\n    TIM_OC_InitTypeDef TIM_OCInitStructure;\n    TIM_OCInitStructure.OCMode = TIM_OCMODE_PWM1;\n    TIM_OCInitStructure.Pulse = arr / 2;\n    TIM_OCInitStructure.OCPolarity = TIM_OCPOLARITY_HIGH;\n    HAL_TIM_PWM_ConfigChannel(&amp;htimx, &amp;TIM_OCInitStructure, TIM_CHANNEL_1);\n    __HAL_TIM_ENABLE_IT(&amp;htimx, TIM_IT_UPDATE);\n    HAL_TIM_PWM_Start(&amp;htimx, TIM_CHANNEL_1);\n}\n\nvoid HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)\n{\n    if (htim-&gt;Instance == TIM8)\n    {\n        GPIO_InitTypeDef GPIO_Initure;\n        __HAL_RCC_TIM8_CLK_ENABLE();  // 使能TIM8时钟\n        __HAL_RCC_GPIOC_CLK_ENABLE(); // 开启GPIOC时钟\n\n        GPIO_Initure.Pin = GPIO_PIN_6;        // PC6\n        GPIO_Initure.Mode = GPIO_MODE_AF_PP;  // 复用推挽输出\n        GPIO_Initure.Pull = GPIO_PULLUP;      // 上拉\n        GPIO_Initure.Speed = GPIO_SPEED_HIGH; // 高速\n        HAL_GPIO_Init(GPIOC, &amp;GPIO_Initure);\n\n        HAL_NVIC_SetPriority(TIM8_UP_IRQn, 4, 0); // 设置中断优先级，抢占优先级4，子优先级0\n        HAL_NVIC_EnableIRQ(TIM8_UP_IRQn);         // 开启TIM8_UP_IRQn中断\n    }\n}\n\nvoid update_pwm_num(uint8_t num)\n{\n    if (num == 0)\n        return;\n    num_pwm = num;\n    HAL_TIM_GenerateEvent(&amp;htimx, TIM_EVENTSOURCE_UPDATE);\n    __HAL_TIM_ENABLE(&amp;htimx);\n}\n\nvoid TIM8_UP_IRQHandler(void)\n{\n    HAL_TIM_IRQHandler(&amp;htimx);\n}\n\nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)\n{\n    if (htim-&gt;Instance == TIM8)\n    {\n        if (num_pwm)\n        {\n            TIM8-&gt;RCR = num_pwm - 1;\n            HAL_TIM_GenerateEvent(&amp;htimx, TIM_EVENTSOURCE_UPDATE);\n            __HAL_TIM_ENABLE(&amp;htimx);\n            num_pwm = 0;\n        }\n        else\n        {\n            // __HAL_TIM_DISABLE(&amp;htimx);\n            TIM8-&gt;CR1 &amp;= ~(TIM_CR1_CEN);\n        }\n    }\n}\n\n\n\n\n\n\n\n\n记一个奇怪的问题：我本来想使用串口通信来实现改变PWM波形个数，但是发现串口通信会导致定时器不能输出PWM。具体原因完全没有找到。以下是具体情况：\n\n上述代码在正常情况下：复位后仅仅输出一个PWM波形就会被关闭，按下按键后会开启并输出指定数量的PWM波形后关闭。不输出PWM的时候引脚为高电平。\n如果删除KEY_Init();，即不初始化按键，则复位后不会输出PWM波形，引脚为低电平❓。\n如果添加UART_Init(115200);，即初始化串口通信，则复位后不会输出PWM波形，引脚为低电平，按下按键也不会有任何反应❓。\n如果在删除KEY_Init();的情况下，添加UART_Init(115200);，则复位后不会输出PWM波形，引脚为低电平❓。\n在KEY_Init()函数中，如果仅仅初始化PE3一个引脚，设置对应中断，则复位后仅仅输出一个PWM波形就会被关闭，在按下与PE3相连的按键时会产生对应数量的PWM波形，不输出PWM的时候引脚为高电平。\n在KEY_Init()函数中，如果仅仅初始化PA0一个引脚，不设置任何中断，则复位后不会输出PWM波形，引脚为低电平❓。\n在KEY_Init()函数中，如果仅仅初始化PE3一个引脚，不设置任何中断，则复位后仅仅输出一个PWM波形就会被关闭，不输出PWM的时候引脚为高电平。\n\n目前仍未找到原因。\n死区控制死区时间是指在两个互补输出之间的时间间隔。死区时间的作用是防止两个互补输出同时处于有效状态，从而导致电流短路。死区时间的大小由TIMx_BDTR寄存器中的DTG[7:0]位和LOCK[1:0]位决定。死区时间的计算公式如下：\n\n其中，TIMxCLK是定时器的时钟频率，DeadTime是死区时间。死区时间的最大值为255个TIMxCLK周期。死区时间的最小值由LOCK[1:0]位决定.\n死区控制通常用于控制电机的驱动，防止电机的两个相同时刻都处于有效状态，导致电流短路。\n断路输入断路输入可以使得定时器的输出信号置于用户可选的安全配置中。断路输入的作用是在定时器输出信号的有效期间，当断路输入信号有效时，立即将定时器输出信号置为无效。断路输入信号可以是外部信号或者内部信号。外部信号可以是TIMx_ETR引脚上的信号或者TIMx_CHx引脚上的信号。内部信号可以是TIMx_TRGO引脚上的信号或者TIMx_ITRy引脚上的信号。\n","slug":"STM32入门（八）：定时器","date":"2023-09-17T09:22:52.000Z","categories_index":"嵌入式","tags_index":"STM32,单片机","author_index":"Ac-Accelerator"},{"id":"66ba1c7d8be31c9521741b1f3e971a8c","title":"STM32入门（七）：IWDG&WWDG","content":"单片机在运行过程中，由于受到外界干扰或者程序出现错误，导致程序陷入死循环，这时候就需要复位单片机，使其重新运行。单片机复位的方式有多种，比如手动复位、软件复位、看门狗复位等。本文主要介绍看门狗复位。\nIWDGIWDG（Independent Watchdog）独立看门狗，它是一个能产生复位信号的计数器，当计数器达到给定的超时值时，产生系统复位。独立看门狗(IWDG)由专用的低速时钟(LSI)驱动，即使主时钟发生故障它也仍然有效。IWDG最适合应用于那些需要看门狗作为一个在主程序之外，能够完全独立工作，并且对时间精度要求较低的场合。\n系统复位条件：\n\n外部复位NRST引脚低电平\n独立看门狗复位\n窗口看门狗复位\n软件复位\n低功耗管理复位\n\n目前介绍的是独立看门狗复位。\nIWDG特性\n自由运行的递减计数器\n时钟由独立的RC振荡器提供(可在停止和待机模式下工作)\n看门狗被激活后，则在计数器计数至0x000时产生复位\n\n因此，为了防止复位，必须在看门狗复位之前重载计数器。俗称喂狗。\n\n\n看门狗功能处于VDD供电区，即在停机和待机模式时仍能正常工作。\nIWDG溢出时间计算\n其中，为LSI的周期，为分频系数，为重装载值。\nIWDG寄存器配置步骤寄存器包括：\n\nIWDG_KR：键值寄存器\nIWDG_PR：预分频寄存器\nIWDG_RLR：重装载寄存器\nIWDG_SR：状态寄存器\n\n\n在IWDG_KR中写入0XCCCC，开启IWDG\n在IWDG_KR中写入0X5555，使能寄存器访问\n在IWDG_PR中写入分频系数\n对IWDG_RLR写入重装载值\n等待寄存器更新IWDG_SR=0X0000\n刷新计数器的值为IWDG_RLR的值（IWDG_KR=0XAAAA）\n\nIWDG配置步骤\nIWDG工作参数初始化:HAL_IWDG_Init()\n喂狗:HAL_IWDG_Refresh()\n\nHAL库应用HAL_StatusTypeDef Stm32_Clock_Init();void LED_Init();void UART_Init(uint32_t bound);void print(char *str);  \ncpp#include &lt;stm32f1xx_hal.h&gt;\n#include &lt;usart.h&gt; //STM32入门（六）：串口通信所需头文件\n\nHAL_StatusTypeDef Stm32_Clock_Init();\nvoid LED_Init();\nvoid UART_Init(uint32_t bound);\nvoid print(char *str);\n\nstatic IWDG_HandleTypeDef IWDG_Handler; // 独立看门狗句柄\nvoid IWDG_Init(uint32_t time_ms);\nvoid IWDG_Feed(void);\n\nint main()\n{\n    /*\n    HAL_Init()中，调用HAL_NVIC_SetPriorityGrouping设置中断优先级分组为NVIC_PRIORITYGROUP_4\n    即4位抢占优先级，0位响应优先级，并且用HAL_NVIC_SetPriority将SysTick_IRQn设置为15即最低优先级\n    */\n    HAL_Init();                     // 初始化HAL库\n    Stm32_Clock_Init(RCC_PLL_MUL9); // 初始化时钟\n    LED_Init();                     // 初始化LED外设\n    UART_Init(115200); // 初始化串口，波特率为115200\n    IWDG_Init(10000);  // 初始化独立看门狗，溢出时间为10000ms\n    HAL_Delay(1000);\n    HAL_GPIO_WritePin(GPIOE, GPIO_PIN_5, GPIO_PIN_SET);\n    while (1)\n    {\n        if (USART_RX_STA &amp; 0x8000) // 接收完成标志为1\n        {\n            IWDG_Feed(); // 喂狗\n            USART_RX_STA = 0;  // 接收完成标志清零\n        }\n        HAL_Delay(1000);\n        print(\"如果不发送数据，系统将重启\\r\\n\");\n    }\n}\n\nvoid IWDG_Init(uint32_t time_ms)\n{\n    uint32_t Prescaler = 4;// 分频系数\n    uint32_t Prescaler_Sta = 0;// 分频系数状态\n    for (; Prescaler_Sta &lt; 7; Prescaler_Sta++)//找到一个合适的分频系数和重装载值\n    {\n        if (time_ms * 40 / Prescaler &lt;= 0xFFF)\n            break;\n        Prescaler &lt;&lt;= 1;\n    }\n    IWDG_Handler.Instance = IWDG; // 独立看门狗\n    //设置分频系数和重装载值\n    if (Prescaler_Sta != 7)\n    {\n        IWDG_Handler.Init.Prescaler = Prescaler_Sta;\n        IWDG_Handler.Init.Reload = time_ms * 40 / Prescaler;\n    }\n    else{\n        IWDG_Handler.Init.Prescaler = IWDG_PRESCALER_256;\n        IWDG_Handler.Init.Reload = 0xFFF;\n    }\n    HAL_IWDG_Init(&amp;IWDG_Handler); // 初始化独立看门狗\n}\n\nvoid IWDG_Feed(void)// 喂狗\n{\n    HAL_IWDG_Refresh(&amp;IWDG_Handler); \n}\nWWDG窗口看门狗(Window Watchdog)通常被用来监测，由外部干扰或不可预见的逻辑条件造成的应用程序背离正常的运行序列而产生的软件故障。除非递减计数器的值在T6位变成0前被刷新，看门狗电路在达到预置的时间周期时，会产生一个MCU复位。在递减计数器达到窗口寄存器数值之前，如果7位的递减计数器数值(在控制寄存器中)被刷新， 那么也将产生一个MCU复位。这表明递减计数器需要在一个有限的时间窗口中被刷新。\n一般来说，硬件错误使用独立看门狗，软件错误使用窗口看门狗。\nWWDG特性\n可编程的自由运行递减计数器\n条件复位\n当递减计数器的值小于0x40，(若看门狗被启动)则产生复位。\n当递减计数器在窗口外被重新装载，(若看门狗被启动)则产生复位。\n\n\n如果启动了看门狗并且允许中断，当递减计数器等于0x40时产生早期唤醒中断(EWI)，它可以被用于重装载计数器以避免WWDG复位。\n\n当微控制器进入调试模式时(Cortex-M3核心停止)，根据调试模块中的DBG_WWDG_STOP 配置位的状态，WWDG的计数器能够继续工作或停止。\n\n\n\n\nWWDG溢出时间计算\n其中  是APB1以ms为单位的时钟间隔\nWWDG配置步骤\nWWDG工作参数初始化:HAL_WWDG_Init()\nWWDG MSP初始化:HAL_WWDG_MspInit(),配置NVIC和时钟\n设置优先级使能中断:HAL_NVIC_SetPriority()和HAL_NVIC_EnableIRQ()\n编写中断服务函数WWDG_IRQHandler()\n重定义提前唤醒中断服务函数HAL_WWDG_EarlyWakeupCallback()\n在窗口期内喂狗HAL_WWDG_Refresh()\n\nHAL_StatusTypeDef Stm32_Clock_Init();void LED_Init();void UART_Init(uint32_t bound);void print(char *str);  \ncpp#include &lt;stm32f1xx_hal.h&gt;\n\nHAL_StatusTypeDef Stm32_Clock_Init();\nvoid LED_Init();\nvoid UART_Init(uint32_t bound);\nvoid print(char *str);\n\nstatic WWDG_HandleTypeDef WWDG_Handler; // 窗口看门狗句柄\nvoid WWDG_Init(uint8_t tr, uint8_t wr, uint32_t fprer);\nvoid WWDG_Feed(void);\n\nint main()\n{\n    /*\n    HAL_Init()中，调用HAL_NVIC_SetPriorityGrouping设置中断优先级分组为NVIC_PRIORITYGROUP_4\n    即4位抢占优先级，0位响应优先级，并且用HAL_NVIC_SetPriority将SysTick_IRQn设置为15即最低优先级\n    */\n    HAL_Init();                     // 初始化HAL库\n    Stm32_Clock_Init(RCC_PLL_MUL9); // 初始化时钟\n    LED_Init();                     // 初始化LED外设\n    LED0_ON();                      // 点亮LED0\n    HAL_Delay(300);\n    WWDG_Init(0X7F,0X5F,WWDG_PRESCALER_8);  // 初始化窗口看门狗\n    while (1)\n    {\n        LED0_OFF(); // 关闭LED0\n    }\n}\n\nvoid WWDG_Init(uint8_t tr, uint8_t wr, uint32_t fprer)\n{\n    WWDG_Handler.Instance = WWDG;\n    WWDG_Handler.Init.Prescaler = fprer;         // 设置分频系数\n    WWDG_Handler.Init.Counter = tr;              // 设置计数器值\n    WWDG_Handler.Init.Window = wr;               // 设置窗口值\n    WWDG_Handler.Init.EWIMode = WWDG_EWI_ENABLE; // 使能早期唤醒中断\n    HAL_WWDG_Init(&amp;WWDG_Handler);                // 初始化窗口看门狗\n}\n\nvoid HAL_WWDG_MspInit(WWDG_HandleTypeDef *hwwdg)\n{\n    __HAL_RCC_WWDG_CLK_ENABLE();            // 使能窗口看门狗时钟\n    HAL_NVIC_SetPriority(WWDG_IRQn, 15, 0); // 设置窗口看门狗中断优先级\n    HAL_NVIC_EnableIRQ(WWDG_IRQn);          // 使能窗口看门狗中断，递减计数器等于0x40时产生早期唤醒中断\n}\n\n//递减计数器等于0x40时产生早期唤醒中断\nvoid WWDG_IRQHandler(void)\n{\n    HAL_WWDG_IRQHandler(&amp;WWDG_Handler); // 调用HAL库中断处理公用函数\n}\n\nvoid WWDG_Feed(void)\n{\n    HAL_WWDG_Refresh(&amp;WWDG_Handler); // 喂狗\n}\n\n//此函数会被HAL_WWDG_IRQHandler()调用\nvoid HAL_WWDG_EarlyWakeupCallback(WWDG_HandleTypeDef *hwwdg)//定义提前唤醒中断服务函数\n{\n    WWDG_Feed(); // 喂狗\n    LED1_TOGGLE(); // LED1翻转\n}\n特别注意，在中断内喂狗一定要快，否则当看门狗计数器值减到0X3F时将产生复位！\n","slug":"STM32入门（七）：IWDG&WWDG","date":"2023-07-20T10:24:54.000Z","categories_index":"嵌入式","tags_index":"STM32,单片机","author_index":"Ac-Accelerator"},{"id":"a08aadec6f6b3fd60392df174980aebb","title":"STM32入门（六）：串口通信","content":"通信基本概念串行/并行通信串行通信：数据逐位传输，一个单位时间只能发送一个bit。并行通信：数据同时通过多条线路传输，一次可以发送多个bit\n单工/半双工/全双工通信单工通信：数据只能单向传输，不能双向传输。半双工通信：数据可以双向传输，但是不能同时传输。全双工通信：数据可以双向传输，且可以同时传输。\n同步/异步通信同步通信：发送端和接收端的时钟信号是同步的，发送端和接收端的时钟信号是同一个时钟信号。异步通信：没有时钟信号，通过在数据的起始和终止位置添加特殊的标志位来实现同步。\n波特率/比特率比特率：单位时间内传输的bit数，单位为bit/s。波特率：单位时间内传送的码元个数，单位为Baud。码元与比特：信号在被编码调制后，一个码元可以代表多个比特。\n常见的串口通信协议\n\n\n通信协议\n接口引脚\n数据同步方式\n数据传输方向\n\n\n\nUART\nTXD、RXD、GND\n异步\n全双工\n\n\nSPI\nMOSI、MISO、SCLK、CS、GND\n同步\n全双工\n\n\nI2C\nSDA、SCL、GND\n同步\n半双工\n\n\n1-Wire\nDQ、GND\n异步\n半双工\n\n\n串口按位发送或接收的接口，如RS-232、RS-485、RS-422等。\nRS-232(USB)RS-232是一种串行通信接口标准，它是由美国电子工业协会联合贝尔系统公司、调制解调器厂家及计算机终端生产厂家于1970年共同制定，其全名是“数据终端设备和数据通信设备之间串行二进制数据交换接口技术标准”\n常用的RS-232串口使用方法：USB通过串口连接电脑等设备，USB信号通过USB转串口模块CH340，将USB电平转换为TTL/CMOS电平。\n和USART的关系USART是一种集成电路，它能够以同步或异步的方式进行数据传输。而RS-232是一种串行通信接口标准，它定义了电气特性、机械特性和功能特性等方面的规范。\nUSART可以通过RS-232接口与其他设备进行通信。在这种情况下，USART负责数据的发送和接收，而RS-232负责定义数据传输的电气特性和其他规范。因此，USART和RS-232可以协同工作，实现串行通信。\nUSART通用同步异步收发器(Universal Synchronous Asynchronous Receiver Transmitter)提供了一种灵活的方法与使用工业标准NRZ异步串行数据格式的外部设备之间进行全双工数据交换。USART利用分数波特率发生器提供宽范围的波特率选择。它支持同步单向通信和半双工单线通信，也支持LIN(局部互连网)，智能卡协议和IrDA(红外数据组织)SIR ENDEC规范，以及调制解调器(CTS/RTS)操作。它还允许多处理器通信。使用多缓冲器配置的DMA方式，可以实现高速数据通信。\nUART(Universal Asynchronous Receiver Transmitter)异步收发器是没有同步收发功能的USART\nUART和USART都可以使用RS-232串口作为物理层。\n通过STM32选型手册可以得知，STM32F103ZET6有3个USART，两个UART。因此有5个串口。\nUART：\n\n\n\n串口号\nTX\nRX\n\n\n\nUART4\nPC10\nPC11\n\n\nUART5\nPC12\nPD2\n\n\nUSART：\n\n\n\n串口号\nTX\nRX\nCTS\nRTS\nCK\n\n\n\nUSART1\nPA9\nPA10\nPA11\nPA12\nPA8\n\n\nUSART2\nPA2\nPA3\nPA0\nPA1\nPA4\n\n\nUSART3\nPB10\nPB11\nPB13\nPB14\nPB12\n\n\n\n\n\nSW_RX： 数据接收引脚，只用于单线和智能卡模式，属于内部引脚，没有具体外部引脚。\n\nRX：接收数据串行输。通过过采样技术来区别数据和噪音，从而恢复数据。\n\nTX：发送数据输出。当发送器被禁止时，输出引脚恢复到它的I/O端口配置。当发送器被激活，并且不发送数据时，TX引脚处于高电平。在单线和智能卡模式里，此I/O口被同时用于数据的发送和接收。\n\n\n\n\n\n\n\n\n\n\n\n\n总线在发送或接收前应处于空闲状态\n一个起始位\n一个数据字(8或9位)，最低有效位在前\n0.5，1.5，2个的停止位，由此表明数据帧的结束\n使用分数波特率发生器 —— 12位整数和4位小数的表示方法。\n一个状态寄存器(USART_SR)\n数据寄存器(USART_DR)\n一个波特率寄存器(USART_BRR)，12位的整数和4位小数\n一个智能卡模式下的保护时间寄存器(USART_GTPR)\n\n上面这两个USART引脚对应着RS-232串口的RXD和TXD。\n在同步模式中需要以下引脚：\n\nSCLK： 时钟信号，用于同步数据传输。\n\n在IrDA模式里需要下列引脚：\n\nIrDA_RDI: IrDA模式下的数据输入。\nIrDA_TDO: IrDA模式下的数据输出。\n\n在硬件流控模式中需要以下引脚：\n\nnCTS: 清除发送，若是高电平，在当前数据传输结束时阻断下一次的数据发送。\nnRTS: 发送请求，若是低电平，表明USART准备好接收数据。\n\nUSART寄存器介绍USART_SR：状态寄存器USART_DR：数据寄存器USART_BRR：波特率寄存器USART_CR1：控制寄存器1USART_CR2：控制寄存器2USART_CR3：控制寄存器3\n详细功能见参考手册。\n设置USART波特率依据USART的框图，可以得知波特率的计算公式：\n\n而USARTDIV由USART_BRR（波特比率寄存器）的低16位DIV_Mantissa和DIV_Fraction共同决定，其中DIV_Mantissa是整数部分，DIV_Fraction是小数部分。所以只需要设置这两个寄存器就可以设置USARTDIV，进而设置波特率。\nUSART分频的计算公式：\n\n通过以上两个公式，可以由USART_BRR的值推出波特率，也可以由波特率推出USART_BRR的值。\n\n\n\n\n\n\n\n\n\n要注意的是，USART1的时钟是PCLK2（因为挂载在APB2总线上），而其他的串口的时钟是PCLK1（因为挂载在APB1总线上）。详情参考芯片手册。\nHAL库回调机制外设初始化MSP回调机制：\nMSP的全称是MCU Support Package。它是为了方便ST不同芯片平台移植而产生的。\nHAL_PPP_Init()函数会调用HAL_PPP_MspInit()回调函数（PPP代表外设名字），其中HAL_PPP_MspInit()是个__weak类型函数，因此用户可以重写这个函数，实现外设的初始化。\n中断回调机制：\nHAL_PPP_IRQHandler()函数会调用HAL_PPP_xxx_Callback()回调函数（PPP代表外设名字，xxx代表中断类型），其中HAL_PPP_xxxCallback()是个__weak类型函数，因此用户可以重写这个函数，实现中断的处理。\n例子\nIO引脚复用功能通用： IO引脚由GPIO外设控制复用： IO引脚由非GPIO的其他外设控制\n参考芯片数据手册可以得知IO引脚分别支持哪些复用，如果遇到复用功能冲突，则可以使用重映射来实现。\nUSART/UART异步通信配置\n配置串口工作参数\n串口底层初始化，配置NVIC,GPIO,Clock等\n开启串口异步接收中断\n设置优先级，使能中断\n编写中断服务函数\n串口数据发送接收\n\nHAL库程序代码：接收什么发送什么HAL_StatusTypeDef Stm32_Clock_Init();void LED_Init();\ncpp#include &lt;stm32f1xx_hal.h&gt;\nHAL_StatusTypeDef Stm32_Clock_Init();\n\nvoid LED_Init();\nvoid UART_Init(uint32_t bound);\nvoid print(char *str);\nvoid printn(char *str, uint32_t n);\n\nuint8_t aRxBuffer[1];             // 数据缓冲区\nUART_HandleTypeDef UART1_Handler; // 句柄\nuint16_t USART_RX_STA=0;        // 串口接收到数据标志\nuint8_t USART_RX_BUF[256];        // 串口接收缓冲区\n\nint main()\n{\n    /*\n    HAL_Init()中，调用HAL_NVIC_SetPriorityGrouping设置中断优先级分组为NVIC_PRIORITYGROUP_4\n    即4位抢占优先级，0位响应优先级，并且用HAL_NVIC_SetPriority将SysTick_IRQn设置为15即最低优先级\n    */\n    HAL_Init();                     // 初始化HAL库\n    Stm32_Clock_Init(RCC_PLL_MUL9); // 初始化时钟\n    LED_Init();                     // 初始化LED外设\n    UART_Init(115200);              // 初始化串口，波特率为115200\n    HAL_GPIO_WritePin(GPIOE, GPIO_PIN_5, GPIO_PIN_SET);//灭灯，意义不大\n\n    int len = 0;\n    unsigned int times = 0;\n    while (1)\n    {\n        if (USART_RX_STA &amp; 0x8000) // 接收完成标志为1\n        {\n            len = USART_RX_STA &amp; 0x3fff; // 得到此次接收到的数据长度\n            print(\"\\r\\n您发送的消息为:\\r\\n\");\n\n            HAL_UART_Transmit(&amp;UART1_Handler, (uint8_t *)USART_RX_BUF, len, 1000); // 发送接收到的数据\n            while (__HAL_UART_GET_FLAG(&amp;UART1_Handler, UART_FLAG_TC) != SET)\n                ;              // 等待发送结束\n            print(\"\\r\\n\\r\\n\"); // 插入换行\n            USART_RX_STA = 0; // 接收完成标志清零\n        }\n        else\n        {\n            times++;\n            if (times % 1000 == 0)\n                print(\"请输入数据,以回车键结束\\r\\n\");\n            if (times % 300 == 0)\n                HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_5);\n            HAL_Delay(10);\n        }\n    }\n}\n\nvoid UART_Init(uint32_t bound)\n{\n    // UART 初始化设置\n    UART1_Handler.Instance = USART1;                              // 配置的目的串口是USART1\n    UART1_Handler.Init.BaudRate = bound;                          // 设置串口波特率\n    UART1_Handler.Init.WordLength = UART_WORDLENGTH_8B;           // 设置字长为8位数据格式\n    UART1_Handler.Init.StopBits = UART_STOPBITS_1;                // 设置停止位数为1\n    UART1_Handler.Init.Parity = UART_PARITY_NONE;                 // 奇偶校验位为无\n    UART1_Handler.Init.HwFlowCtl = UART_HWCONTROL_NONE;           // 硬件流控为无\n    UART1_Handler.Init.Mode = UART_MODE_TX_RX;                    // 串口模式为收发模式\n    HAL_UART_Init(&amp;UART1_Handler);                                // HAL_UART_Init()会调用HAL_UART_MspInit使能UART1\n    HAL_UART_Receive_IT(&amp;UART1_Handler, (uint8_t *)aRxBuffer, 1); // 该函数会开启接收中断：标志位UART_IT_RXNE，并且设置接收缓冲以及接收缓冲接收最大数据量\n}\n\nvoid HAL_UART_MspInit(UART_HandleTypeDef *huart) // 定义HAL_UART_MspInit\n{\n    GPIO_InitTypeDef GPIO_Initure; // GPIO端口配置结构体\n\n    if (huart-&gt;Instance == USART1) // 如果是串口1，进行串口1 MSP初始化\n    {\n        __HAL_RCC_USART1_CLK_ENABLE(); // 使能USART1时钟\n        __HAL_RCC_GPIOA_CLK_ENABLE();  // 因为USART1都在GPIOA的引脚上，所以使能GPIOA时钟\n        __HAL_RCC_AFIO_CLK_ENABLE();   // 使能AFIO时钟\n\n        GPIO_Initure.Pin = GPIO_PIN_9;             // PA9\n        GPIO_Initure.Mode = GPIO_MODE_AF_PP;       // TX引脚，因此选择复用推挽输出\n        GPIO_Initure.Speed = GPIO_SPEED_FREQ_HIGH; // 高速\n        HAL_GPIO_Init(GPIOA, &amp;GPIO_Initure);       // 初始化PA9\n\n        GPIO_Initure.Pin = GPIO_PIN_10;         // PA10\n        GPIO_Initure.Pull = GPIO_PULLUP;        // 空闲时高电平，因此选择上拉\n        GPIO_Initure.Mode = GPIO_MODE_AF_INPUT; // DX引脚，选择复用输入模式\n        HAL_GPIO_Init(GPIOA, &amp;GPIO_Initure);    // 初始化PA10\n\n        HAL_NVIC_EnableIRQ(USART1_IRQn);           // 使能USART1中断通道\n        HAL_NVIC_SetPriority(USART1_IRQn, 14, 0U); // 设置中断优先级\n    }\n}\n\nvoid USART1_IRQHandler(void)\n{\n    uint32_t timeout = 0;\n\n    HAL_UART_IRQHandler(&amp;UART1_Handler); // HAL库中断处理公共函数会调用HAL_UART_RxCpltCallback\n\n    timeout = 0;\n    while (HAL_UART_GetState(&amp;UART1_Handler) != HAL_UART_STATE_READY) // 等待就绪\n    {\n        timeout++; ////超时处理\n        if (timeout &gt; HAL_MAX_DELAY)\n            break;\n    }\n\n    timeout = 0;\n    while (HAL_UART_Receive_IT(&amp;UART1_Handler, (uint8_t *)aRxBuffer, 1) != HAL_OK) // 一次处理完成之后，重新开启中断并设置RxXferCount为1\n    {\n        timeout++; // 超时处理\n        if (timeout &gt; HAL_MAX_DELAY)\n            break;\n    }\n}\n\nvoid HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)\n{\n    if (huart-&gt;Instance == USART1) // 如果是串口1\n    {\n        if ((USART_RX_STA &amp; 0x8000) == 0) // 接收未完成\n        {\n            if (USART_RX_STA &amp; 0x4000) // 已经接收到了'/r'，但是还没接收到'/n'\n            {\n                if (aRxBuffer[0] != 0x0a) // 检查是不是'/n'\n                    USART_RX_STA = 0;     // 接收错误,清零\n                else\n                    USART_RX_STA |= 0x8000; // 接收完成标记\n            }\n            else // 还没收到'/r'\n            {\n                if (aRxBuffer[0] == 0x0d)   // 检查是不是'/r'\n                    USART_RX_STA |= 0x4000; // 标记接收到了'/r'\n                else                        // 记录在缓冲区\n                {\n                    USART_RX_BUF[USART_RX_STA &amp; 0X3FFF] = aRxBuffer[0];\n                    USART_RX_STA++;\n                    if (USART_RX_STA &gt; (256 - 1))\n                        USART_RX_STA = 0; // 接收数据错误,重新开始接收\n                }\n            }\n        }\n    }\n}\n\nvoid print(char *str)\n{\n    char *p = str;\n    while (*p != '\\0')\n    {\n        while (__HAL_UART_GET_FLAG(&amp;UART1_Handler, UART_FLAG_TC) != SET)\n            ; // 等待发送结束\n        HAL_UART_Transmit(&amp;UART1_Handler, (uint8_t *)p++, 1, 1000);\n    }\n}\n\nvoid printn(char *str, uint32_t n)\n{\n    char *p = str;\n    while (*p != '\\0' &amp;&amp; n--)\n    {\n        while (__HAL_UART_GET_FLAG(&amp;UART1_Handler, UART_FLAG_TC) != SET)\n            ; // 等待发送结束\n        HAL_UART_Transmit(&amp;UART1_Handler, (uint8_t *)p++, 1, 1000);\n    }\n}\n在platformio.ini中添加:\ninimonitor_speed = 115200使得其和上面的设置的波特率一致。\n","slug":"STM32入门（六）：串口通信","date":"2023-07-16T06:40:29.000Z","categories_index":"嵌入式","tags_index":"STM32,单片机","author_index":"Ac-Accelerator"},{"id":"216a2da9fe9c97a8ed131bdb8a83b703","title":"STM32入门（五）：中断","content":"中断概念中断是指计算机在正常处理程序的过程中，当发现某种异常事件或某种外部请求时，处理器会暂停执行当前程序转而执行异常事件处理或外部事件处理。在计算机科学中，中断是指处理器接收到来自硬件或软件的信号，提示发生了某个事件，应该被注意，这种情况就称为中断。通常，在接收到来自外围硬件（相对于中央处理器和内存）的异步信号，或来自软件的同步信号之后，处理器将会进行相应的硬件/软件处理。发出这样的信号称为进行中断请求（interrupt request，IRQ）。硬件中断导致处理器通过一个执行资讯切换（context switch）来保存执行状态（以程序计数器和程序状态字等寄存器信息为主）；软件中断则通常作为CPU指令集中的一个指令，以可编程的方式直接指示这种执行资讯切换，并将处理导向一段中断处理代码。\n在STM32中，一个中断的流程如下：\n\n\n中断优先级中断优先级是为了判断当多个中断同时发生时，哪个中断先执行而产生的概念。\n中断优先级分为：\n\n抢占优先级\n响应优先级\n自然优先级（中断向量表的优先级）\n\n抢占优先级高的会打断抢占优先级低的中断。当中断的抢占优先级相同时，响应优先级高的会先执行，但是不能互相打断。当中断的抢占优先级和响应优先级都相同时，自然优先级高的会先执行，但是不能互相打断。  \n中断优先级数值越小，优先级越高。\n在STM32中，有4个位来表示抢占优先级以及响应优先级，而中断优先级分组决定了这4个位中抢占优先级以及响应优先级位数的分配。\nNVIC嵌套向量中断控制器（Nested Vectored Interrupt Controller）\n\n68个可屏蔽中断通道(不包含16个Cortex™-M3的中断线)；\n16个可编程的优先等级(使用了4位中断优先级)；\n低延迟的异常和中断处理；\n电源管理控制；\n系统控制寄存器的实现；\n\n嵌套向量中断控制器(NVIC)和处理器核的接口紧密相连，可以实现低延迟的中断处理和高效地处理晚到的中断。\n\n\nISER(Interrupt Set-Enable Register):中断使能寄存器：此寄存器用于启用中断，并显示哪些中断已启用。ISCR(Interrupt Clear-Enable Register):中断失能寄存器：此寄存器用于禁用中断，并显示哪些中断已启用。AIRCR(Application Interrupt and Reset Control Register):应用程序中断和复位控制寄存器此寄存器提供了数据访问的端序状态和系统的复位控制。（和中断优先级分组有关）SHPR(System Handler Priority Registers):系统处理器优先级寄存器：这些寄存器设置异常处理程序的优先级级别。IPR(Interrupt Priority Registers):中断优先级寄存器：这些寄存器为每个中断提供一个4位优先级字段。  \nEXTI外部中断/事件控制器（External Interrupt）\n对于互联型产品，外部中断/事件控制器由20个产生事件/中断请求的边沿检测器组成，对于其它产品，则有19个能产生事件/中断请求的边沿检测器。每个输入线可以独立地配置输入类型(脉冲或挂起)和对应的触发事件(上升沿或下降沿或者双边沿都触发)。每个输入线都可以独立地被屏蔽。挂起寄存器保持着状态线的中断请求。\nEXTI控制器的主要特性如下：\n\n每个中断/事件都有独立的触发和屏蔽\n每个中断线都有专用的状态位\n支持多达20个软件的中断/事件请求\n检测脉冲宽度低于APB2时钟宽度的外部信号。\n\n\n\n\nIMR：Interrupt Mask Register，中断屏蔽寄存器。\nEMR：Event Mask Register，事件屏蔽寄存器。\nRTSR：Rising Trigger Selection Register，上升沿触发选择寄存器。\nFTSR：Falling Trigger Selection Register，下降沿触发选择寄存器。\nSWIER：Software Interrupt Event Register，软件中断事件寄存器。\nPR：Pending Register，挂起寄存器。\n\n要产生中断，必须先配置好并使能中断线。根据需要的边沿检测设置2个触发寄存器，同时在中断屏蔽寄存器的相应位写’1’允许中断请求。当外部中断线上发生了期待的边沿时，将产生一个中断请求，对应的挂起位也随之被置’1’。在挂起寄存器的对应位写’1’，将清除该中断请求。如果需要产生事件，必须先配置好并使能事件线。根据需要的边沿检测通过设置2个触发寄存器，同时在事件屏蔽寄存器的相应位写’1’允许事件请求。当事件线上发生了需要的边沿时，将产生一个事件请求脉冲，对应的挂起位不被置’1’。通过在软件中断/事件寄存器写’1’，也可以通过软件产生中断/事件请求。\nGPIO外部中断\n\n另外四个EXTI线的连接方式如下：\n\nEXTI线16连接到PVD输出\nEXTI线17连接到RTC闹钟事件\nEXTI线18连接到USB唤醒事件\nEXTI线19连接到以太网唤醒事件(只适用于互联型产品)\n\nGPIO外部中断配置方式\n使能GPIO时钟\n设置GPIO模式为输入\n使能AFIO/SYSCFG时钟\n设置EXTI和GPIO的映射关系\n设置EXTI触发方式\n设置NVIC\n定义中断服务函数\n\n\n\n依据上述回调机制，我们需要在自己定义的中断服务函数中调用HAL库中断处理公共函数，即HAL_GPIO_EXTI_IRQHandler，该函数会清除中断挂起寄存器PR，并调用回调函数HAL_GPIO_EXTI_Callback。HAL_GPIO_EXTI_Callback函数是个__weak类型的函数，可以重写该函数，这样就可以在中断服务函数里面实现具体的功能了。\nGPIO硬件中断代码例子制作一个会改变闪烁频率的LED灯\nHAL_StatusTypeDef Stm32_Clock_Init();void LED_Init();\ncpp#include &lt;stm32f1xx_hal.h&gt;\n\nHAL_StatusTypeDef Stm32_Clock_Init();\nvoid LED_Init();\nvoid KEY_Init();\nuint32_t time = 1000;\n\nint main()\n{\n    /*\n    HAL_Init()中，调用HAL_NVIC_SetPriorityGrouping设置中断优先级分组为NVIC_PRIORITYGROUP_4\n    即4位抢占优先级，0位响应优先级\n    并且用HAL_NVIC_SetPriority将SysTick_IRQn设置为15即最低优先级\n    */\n    HAL_Init();                     // 初始化HAL库\n    Stm32_Clock_Init(RCC_PLL_MUL9); // 初始化时钟\n    LED_Init();                     // 初始化LED外设\n    KEY_Init();                     // 初始化KEY外设\n    HAL_NVIC_SetPriority(SysTick_IRQn, 1, 0U);//由于我们要在中断里面使用HAL_Delay()函数消除抖动，所以要设置SysTick_IRQn的抢占优先级比EXTI3_IRQn和EXTI0_IRQn高。\n    while (1)                       // 交替闪烁\n    {\n        HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_RESET); // PB5输出低电平\n        HAL_GPIO_WritePin(GPIOE, GPIO_PIN_5, GPIO_PIN_SET);   // PE5输出高电平\n        HAL_Delay(time);\n\n        HAL_GPIO_WritePin(GPIOE, GPIO_PIN_5, GPIO_PIN_RESET); // PE5输出低电平\n        HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_SET);   // PB5输出高电平\n        HAL_Delay(time);\n    }\n}\n\nvoid KEY_Init()\n{\n    // 第1步，在使用GPIO之前，需要使能GPIO时钟\n    __HAL_RCC_GPIOA_CLK_ENABLE(); // 使能GPIOA时钟\n    __HAL_RCC_GPIOE_CLK_ENABLE(); // 使能GPIOE时钟\n\n    //第2步到第5步\n    GPIO_InitTypeDef GPIO_InitStruct = {0};\n\n    GPIO_InitStruct.Pin = GPIO_PIN_3;       // 指定要初始化的引脚\n    GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING; // 指定引脚模式为输入\n    GPIO_InitStruct.Pull = GPIO_PULLUP;     // 指定引脚上拉\n    HAL_GPIO_Init(GPIOE, &amp;GPIO_InitStruct);// 初始化PE3引脚\n\n    GPIO_InitStruct.Pin = GPIO_PIN_0; // 指定要初始化的引脚\n    GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;// 指定引脚模式为中断上升沿触发\n    GPIO_InitStruct.Pull = GPIO_PULLDOWN;// 指定引脚下拉\n    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);// 初始化PA0引脚\n\n    //第6步，设置NVIC\n    HAL_NVIC_SetPriority(EXTI0_IRQn, 15, 0);// 设置中断优先级15，抢占优先级0\n    HAL_NVIC_EnableIRQ(EXTI0_IRQn);// 使能中断线0\n\n    HAL_NVIC_SetPriority(EXTI3_IRQn, 15, 0);// 设置中断优先级15，抢占优先级0\n    HAL_NVIC_EnableIRQ(EXTI3_IRQn);// 使能中断线3\n}\n\nvoid EXTI0_IRQHandler()// 中断服务函数，当EXTI0发生中断时会自动调用该函数\n{   \n    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0);//调用HAL库中断处理公共函数\n}\n\nvoid EXTI3_IRQHandler()// 中断服务函数，当EXTI3发生中断时会自动调用该函数\n{   \n    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_3);//调用HAL库中断处理公共函数\n}\n\nvoid HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)// 重写回调函数，实现具体功能\n{\n    HAL_Delay(10);// 消除抖动\n    if (GPIO_Pin == GPIO_PIN_0)\n    {\n        if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_SET)\n        {\n            time /= (time==1?1:2);// 防止time为0\n        }\n    }\n    else if (GPIO_Pin == GPIO_PIN_3)\n    {\n        if (HAL_GPIO_ReadPin(GPIOE, GPIO_PIN_3) == GPIO_PIN_RESET)\n        {\n            time *= 2;\n        }\n    }\n}\n\nvoid SysTick_Handler()// SysTick中断服务函数\n{\n    HAL_IncTick();\n}","slug":"STM32入门（五）：中断","date":"2023-07-15T04:16:04.000Z","categories_index":"嵌入式","tags_index":"STM32,单片机","author_index":"Ac-Accelerator"},{"id":"68d21eb3a7189bac765001dce9d152b5","title":"STM32入门（四）：GPIO","content":"什么是GPIOGPIO（General-Purpose Input/Output，通用输入输出）是指集成电路或电子电路（例如MCU/MPU）板上的一个未提交的数字信号引脚，它可以用作输入或输出，或两者兼而有之，并且可以通过软件控制。GPIO没有预定义的目的，且默认情况下未使用。\nGPIO的用途非常广泛，它可以用来操作自定义电子设备。例如，您可以使用GPIO来构建自己的机器人臂或DIY气象站。GPIO接口可以让您自定义信号，以便正确操作您的设备。\n每个GPI/O端口有两个32位配置寄存器(GPIOx_CRL，GPIOx_CRH)，两个32位数据寄存器(GPIOx_IDR和GPIOx_ODR)，一个32位置位/复位寄存器(GPIOx_BSRR)，一个16位复位寄存器(GPIOx_BRR)和一个32位锁定寄存器(GPIOx_LCKR)。根据数据手册中列出的每个I/O端口的特定硬件特征， GPIO端口的每个位可以由软件分别配置成多种模式。\n\n输入浮空\n输入上拉\n输入下拉\n模拟输入\n开漏输出\n推挽式输出\n推挽式复用功能\n开漏复用功能\n\n每个I/O端口位可以自由编程，然而I/0端口寄存器必须按32位字被访问(不允许半字或字节访问)。GPIOx_BSRR和GPIOx_BRR寄存器允许对任何GPIO寄存器的读/更改的独立访问；这样，在读和更改访问之间产生IRQ时不会发生危险。\n\n\nGPIO模式输入浮空输入浮空模式是指逻辑器件与引脚既不接高电平，也不接低电平。由于逻辑器件的内部结构，当它输入引脚悬空时，相当于该引脚接了高电平。一般实际运用时，引脚不建议悬空，易受干扰。通俗讲就是浮空就是浮在空中，就相当于此端口在默认情况下什么都不接，呈高阻态，这种设置在数据传输时用的比较多。浮空最大的特点就是电压的不确定性，它可能是0V，页可能是VCC，还可能是介于两者之间的某个值（最有可能）\n输入上拉输入上拉模式是一种常用的输入模式，它可以用来检测外部信号，例如接地的按键等，在按键没有导通的时候端口状态为1。在输入上拉模式中，微控制器将开启引脚的内部上拉电阻，实现上拉输入功能。这种模式可以确保输入信号稳定，避免输入信号受到干扰。\n输入下拉输入下拉模式是一种常用的输入模式，它可以用来检测外部信号，例如接高电平的按键等，在按键没有导通的时候端口状态为0。在输入下拉模式中，微控制器将开启引脚的内部下拉电阻，实现下拉输入功能。这种模式可以确保输入信号稳定，避免输入信号受到干扰\n模拟输入模拟输入是指对连续变化的信号进行量化，将模拟信号通过模数转换器（ADC）转换成数字量，并将数据上传到计算机的功能。这种功能在数据采集卡中使用最为广泛。例如，当您需要测量温度、压力或电压等物理量时，可以使用模拟输入来读取传感器的输出信号，并将其转换为数字量以便计算机处理。\n开漏输出开漏输出（Open Drain Output）是一种常用的输出模式，它可以用来连接不同电平的器件，匹配电平。因为开漏引脚不连接外部的上拉电阻时，只能输出低电平，如果需要同时具备输出高电平的功能，则需要接上拉电阻。这样，通过改变上拉电源的电压，便可以改变传输电平。\n开漏输出还可以用于通信接口，例如I2C总线。在这种情况下，多个设备可以同时挂在同一条总线上。当内部信号输入高电平时，NMOS管导通，输出被拉低到低电平状态；当内部信号输入低电平时，NMOS管截至，输出高阻态。此时可以在外部接一个上拉电阻来实现输出高电平。\n推挽输出推挽输出（Push-Pull Output）是一种常用的输出模式，它可以用来直接控制数字电路。可以直接控制一些数字芯片，如ADC、DAC、触发器、锁存器、三极管控制引脚等等。推挽输出电路通常用于驱动负载电流较大的应用，例如音频放大器或电机驱动器等\n推挽复用功能推挽复用输出（Push-Pull Alternate Function Output），复用功能是指单片机的引脚既可以做普通GPIO使用，也可以作为内部外设控制器的引脚来使用。例如，STM32F103xx单片机的PA5引脚，它可以做为普通GPIO来使用；其次，如果作为外设的引脚，它可以作为SPI1的时钟（SPI1_SCK）、DAC的输出通道1（DAC_OUT1）或者ADC的输入通道5（ADC12_IN5）。\n开漏复用功能开漏式复用输出（Open Drain Alternate Function Output）是一种常用的输出模式，它可以用来连接片内外设功能，例如I2C的SCL和SDA。\nGPIO模式对应的状态输入\n输出缓冲器被禁止\n施密特触发输入被激活\n根据输入配置(上拉，下拉或浮动)的不同，弱上拉和下拉电阻被连接\n出现在I/O脚上的数据在每个APB2时钟被采样到输入数据寄存器\n对输入数据寄存器的读访问可得到I/O状态\n\n输出\n输出缓冲器被激活\n开漏模式：输出寄存器上的’0’激活N-MOS，而输出寄存器上的’1’将端口置于高阻状态(P-MOS从不被激活)。\n推挽模式：输出寄存器上的’0’激活N-MOS，而输出寄存器上的’1’将激活P-MOS。\n\n\n施密特触发输入被激活\n弱上拉和下拉电阻被禁止\n出现在I/O脚上的数据在每个APB2时钟被采样到输入数据寄存器\n在开漏模式时，对输入数据寄存器的读访问可得到I/O状态\n在推挽式模式时，对输出数据寄存器的读访问得到最后一次写的值。\n\n复用\n在开漏或推挽式配置中，输出缓冲器被打开\n内置外设的信号驱动输出缓冲器(复用功能输出)\n施密特触发输入被激活\n弱上拉和下拉电阻被禁止\n在每个APB2时钟周期，出现在I/O脚上的数据被采样到输入数据寄存器\n开漏模式时，读输入数据寄存器时可得到I/O口状态\n在推挽模式时，读输出数据寄存器时可得到最后一次写的值\n\n模拟\n输出缓冲器被禁止；\n禁止施密特触发输入，实现了每个模拟I/O引脚上的零消耗。施密特触发输出值被强置为’0’；\n弱上拉和下拉电阻被禁止；\n读取输入数据寄存器时数值为’0’。\n\nGPIO使用（控制LED闪烁）查看开发板电路图，看到两个LED的引脚分别是PB5和PE5，因此我们需要对这两个引脚进行初始化，使其成为输出引脚。\nGPIO初始化cpp#include &lt;stm32f1xx_hal.h&gt;\nvoid LED_Init()\n{\n    //在使用GPIO之前，需要使能GPIO时钟\n    __HAL_RCC_GPIOB_CLK_ENABLE();   // 使能GPIOB时钟\n    __HAL_RCC_GPIOE_CLK_ENABLE();   // 使能GPIOE时钟\n    GPIO_InitTypeDef GPIO_InitStruct = {0};\n    GPIO_InitStruct.Pin = GPIO_PIN_5;             // 指定要初始化的引脚\n    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; // 指定引脚模式为推挽输出\n    GPIO_InitStruct.Speed = GPIO_SPEED_LOW;    // 指定引脚速度为低速（在控制led的例子中这一项没那么重要）\n    // GPIO_InitStruct.Pull = GPIO_NOPULL;     // 输出模式上下拉没什么意义\n    HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);// 初始化PB5引脚\n    HAL_GPIO_Init(GPIOE, &amp;GPIO_InitStruct);// 初始化PE5引脚\n}\nGPIO使用HAL_StatusTypeDef Stm32_Clock_Init();\ncpp#include &lt;stm32f1xx_hal.h&gt;\nHAL_StatusTypeDef Stm32_Clock_Init();\nvoid LED_Init();\n\nvoid LED0_TOGGLE();\nvoid LED0_ON();\nvoid LED0_OFF();\n\nvoid LED1_TOGGLE();\nvoid LED1_ON();\nvoid LED1_OFF();\n\nint main()\n{\n    HAL_Init();                     // 初始化HAL库\n    Stm32_Clock_Init(RCC_PLL_MUL9); // 初始化时钟\n    LED_Init();                     // 初始化LED外设\n    while (1)//交替闪烁\n    {\n        HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_RESET);//PB5输出低电平\n        HAL_GPIO_WritePin(GPIOE, GPIO_PIN_5, GPIO_PIN_SET);//PE5输出高电平\n        HAL_Delay(500);\n\n        HAL_GPIO_WritePin(GPIOE, GPIO_PIN_5, GPIO_PIN_RESET);//PE5输出低电平\n        HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_SET);//PB5输出高电平\n        HAL_Delay(500);\n    }\n}\n\nvoid SysTick_Handler()//系统计时器中断处理程序（重要⚠️如果没定义则无法处理系统定时器的中断）\n{\n    HAL_IncTick();//系统嘀嗒计时器加1（如果不调用这个函数，无法使用HAL_Delay函数，需要自己实现其他方法）\n}\n\nvoid LED0_ON()\n{\n    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_RESET); // 点亮LED0\n}\n\nvoid LED0_OFF()\n{\n    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_SET); // 关闭LED0\n}\n\nvoid LED0_TOGGLE()\n{\n    HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_5); // 翻转LED0\n}\n\nvoid LED1_ON()\n{\n    HAL_GPIO_WritePin(GPIOE, GPIO_PIN_5, GPIO_PIN_RESET); // 点亮LED1\n}\n\nvoid LED1_OFF()\n{\n    HAL_GPIO_WritePin(GPIOE, GPIO_PIN_5, GPIO_PIN_SET); // 关闭LED1\n}\n\nvoid LED1_TOGGLE()\n{\n    HAL_GPIO_TogglePin(GPIOE, GPIO_PIN_5); // 翻转LED1\n}\n\n\n\n\n\n\n\n\n\n记得定义SysTick_Handler，否则时间延迟函数HAL_Delay()会进入死循环。\n其他的函数还有HAL_GPIO_ReadPin()、HAL_GPIO_TogglePin()等，可以自行查看。\n","slug":"STM32入门（四）：GPIO","date":"2023-07-14T14:36:30.000Z","categories_index":"嵌入式","tags_index":"STM32,单片机","author_index":"Ac-Accelerator"},{"id":"4ec857b23ce5e6dcd3e699fe4235ea27","title":"STM32入门（三）：时钟配置","content":"基本上所有的单片机功能都离不开时钟的帮助啦！所以时钟的配置是非常重要的。基本上是单片机开发的第一步呢！\n时钟系统初始化\n\ncpp#include &lt;stm32f1xx_hal.h&gt; //要使用hal库，必须使用这个头文件\nHAL_StatusTypeDef Stm32_Clock_Init();//时钟初始化函数\nint main()\n{\n    /*\n    首先初始化HAL库\n    这个函数首先会设置中断优先级分组\n    然后使用HSI作为默认时钟，设置1ms触发一个系统定时器的中断,中断优先级默认设置为15。\n    最后会初始化底层硬件\n    */\n    HAL_Init(); \n\n    Stm32_Clock_Init()；//时钟初始化\n}\nHAL_StatusTypeDef Stm32_Clock_Init()\n{\n    HAL_StatusTypeDef ret = HAL_OK;\n    RCC_OscInitTypeDef RCC_OscInitStructure;//晶震初始化结构体\n    RCC_ClkInitTypeDef RCC_ClkInitStructure;//时钟初始化结构体\n\n    RCC_OscInitStructure.OscillatorType = RCC_OSCILLATORTYPE_HSE; // 该结构体配置的目标是HSE\n    RCC_OscInitStructure.HSEState = RCC_HSE_ON;                   // 设置HSE的状态为打开\n    RCC_OscInitStructure.HSEPredivValue = RCC_HSE_PREDIV_DIV1;    // 时钟信号经过PLLXTPRE(PREDIV1)时不分频\n    RCC_OscInitStructure.PLL.PLLState = RCC_PLL_ON;               // 设置PLL状态为打开\n    RCC_OscInitStructure.PLL.PLLSource = RCC_PLLSOURCE_HSE;       // 选择HSE为PLL时钟源(PLLSRC)\n    RCC_OscInitStructure.PLL.PLLMUL = RCC_PLL_MUL9;               // 主PLL倍频因子(PLLMUL)，9倍频，得到72M\n    ret = HAL_RCC_OscConfig(&amp;RCC_OscInitStructure);               // 初始化\n\n    if (ret != HAL_OK)\n        return ret;\n\n    RCC_ClkInitStructure.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);// 选择配置SYSCLK、HCLK,PCLK1和PCLK2\n    RCC_ClkInitStructure.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;       // 设置SYSCLK为PLL\n    RCC_ClkInitStructure.AHBCLKDivider = RCC_SYSCLK_DIV1;              // AHB分频系数为1\n    RCC_ClkInitStructure.APB1CLKDivider = RCC_HCLK_DIV2;               // APB1分频系数为2\n    RCC_ClkInitStructure.APB2CLKDivider = RCC_HCLK_DIV1;               // APB2分频系数为1\n    /* 同时设置FLASH延时周期为2WS，也就是3个CPU周期。这是因为CPU比flash速度快，例如flash最快24MHz，如果CPU频率超过这个频率，就必须加入等待时间，比如一般用72MHz主频，那么flash等待周期必须设置为2*/\n    ret = HAL_RCC_ClockConfig(&amp;RCC_ClkInitStructure, FLASH_LATENCY_2); \n\n    if (ret != HAL_OK)\n        return ret;\n    return HAL_OK;\n}\n\nvoid SysTick_Handler()//系统计时器中断处理程序（重要⚠️如果没定义则无法处理系统定时器的中断）\n{\n    HAL_IncTick();//系统嘀嗒计时器加1（如果不调用这个函数，无法使用HAL_Delay函数，需要自己实现其他方法）\n}\n\n\n\n\n\n\n\n\n\nSysTick_Handler是系统定时器的中断处理程序。在HAL_Init中，设置系统定时器中断触发时间为1ms，因此这个函数1ms触发一次。在这个函数中，调用了HAL_IncTick()函数，这个函数的作用是将系统嘀嗒计时器的计数值加1。系统嘀嗒计时器的计数值是一个全局变量，它的值会在每次中断时加1，所以这个变量的值就是系统运行的时间，单位是ms。这个变量的值可以通过调用HAL_GetTick()函数获得。可以通过在该中断处理程序中完成一些周期性的工作。\n至此，系统时钟以及系统计时器配置完成。\nsystick配置cppHAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);将系统嘀嗒计时器的时钟源设置为HCLK，也就是72MHz。\n在HAL_Init函数中，默认是将系统嘀嗒计时器的时钟源设置为HCLK，所以这一步可以省略。\n时间延迟功能cppHAL_Delay(1000);上述函数的作用是延迟1000ms，也就是1s。\n如果要做到微秒级的延时控制，可以通过软件实现，但是精准度不高，所以一般使用硬件定时器（TIM）来实现。\n软件实现：\ncppvoid delay_us(u32 nus)  //软件控制微秒级延时\n{\n    u32 ticks;\n    u32 told, tnow, tcnt = 0;\n    u32 reload = SysTick-&gt;LOAD; // LOAD的值\n    ticks = nus * 72;       // 需要的节拍数\n    told = SysTick-&gt;VAL;        // 刚进入时的计数器值\n    while (1)\n    {\n        tnow = SysTick-&gt;VAL;\n        if (tnow != told)\n        {\n            if (tnow &lt; told)\n                tcnt += told - tnow; // SYSTICK是一个递减的计数器就可以了.\n            else\n                tcnt += reload - tnow + told;\n            told = tnow;\n            if (tcnt &gt;= ticks)\n                break; // 时间超过/等于要延迟的时间,则退出.\n        }\n    };\n}","slug":"STM32入门（三）：时钟配置","date":"2023-07-14T09:04:28.000Z","categories_index":"嵌入式","tags_index":"STM32,单片机","author_index":"Ac-Accelerator"},{"id":"38fc18eebdbdaec5f989594360c2293b","title":"STM32入门（二）：开发环境配置","content":"操作系统环境Ubuntu 22.04.2 LTS\n开发软件配置Visual Studio Code\n安装插件\nC/C++\nPlatformIO IDE\n\n新建PlatformIO工程配置PlatformIO在PlatformIO主页面中选择platform页面，安装一个嵌入式平台，选择ST STM32。\n在PlatformIO主页面中选择Project页面，点击New Project按钮，选择STM32F103ZE作为开发板，该芯片支持很多框架，这里选择STM32Cube，点击Finish按钮，即可新建一个PlatformIO工程。\n可以看到配置文件如下所示，由于我使用的是正点原子的F1精英开发板以及stlink下载器，所以添加最后两行用于指定上传和调试工具，避免其使用默认的工具导致出现错误。\nini[env:genericSTM32F103ZE]\nplatform = ststm32\nboard = genericSTM32F103ZE\nframework = stm32cube\n;添加如下两行\nupload_protocol = stlink ; 上传工具\ndebug_tool = stlink      ; 调试工具如果需要指定更多配置，可以参考官方文档。\n文件夹介绍可以看到PlatformIO自动为我们生成了一个简单的工程，其中有很多文件夹，各个文件夹的用途写在了对应的readme文件中。\nlib该目录适用于项目特定的（私有）库。PlatformIO 将它们编译为静态库并链接到可执行文件。\n每个库的源代码应该放在自己单独的目录中（“lib/your_library_name/[这里是源文件]”）。\n例如，以下两个库“Foo”和“Bar”的结构：\ntxt|--lib\n|  |\n|  |--Bar\n|  |  |--docs\n|  |  |--examples\n|  |  |--src\n|  |     |- Bar.c\n|  |     |- Bar.h\n|  |  |- library.json (optional, custom build options, etc) https://docs.platformio.org/page/librarymanager/config.html\n|  |\n|  |--Foo\n|  |  |- Foo.c\n|  |  |- Foo.h\n|\n|- platformio.ini\n|--src\n   |- main.c在源文件中，您可以使用以下方式包含库头文件：\ncpp#include &lt;Foo.h&gt;\n#include &lt;Bar.h&gt;\n\nint main (void)\n{\n  ...\n}src、include在src里面编写的源文件可以使用include目录下的头文件。\ntest单元测试文件夹,具体用法如下\n基础\n在嵌入式设备上运行\n持续集成和远程测试\nSTM32Cube库文件\n\n目录~/.platformio/packages/framework-stm32cubef1下的文件如上图所示。\n其中~/.platformio/packages/framework-stm32cubef1/Drivers/STM32F1xx_HAL_Driver 文件夹就是HAL库和LL库所在的位置。\n","slug":"STM32入门（二）：开发环境配置","date":"2023-07-14T06:13:00.000Z","categories_index":"嵌入式","tags_index":"STM32,单片机","author_index":"Ac-Accelerator"},{"id":"d680335def93df41c247e0c4f534ee20","title":"STM32入门（一）：认识STM32","content":"产品类型STM32分为小容量、中容量、大容量和互联型产品。\n\n小容量产品是指闪存存储器容量在16K至32K字节之间的STM32F101xx、STM32F102xx和STM32F103xx微控制器。  \n中容量产品是指闪存存储器容量在64K至128K字节之间的STM32F101xx、STM32F102xx和STM32F103xx微控制器。  \n大容量产品是指闪存存储器容量在256K至512K字节之间的STM32F101xx和STM32F103xx微控制器。  \n互联型产品是STM32F105xx和STM32F107xx微控制器。\n\n系统构架在小容量、中容量和 大容量产品中，主系统由4个驱动单元和4个被动单元组成。\n\n驱动单元：  \n\nDCode总线(D-bus)：一条基于AHB-Lite总线协议的32位总线，负责在0x0000_0000 – 0x1FFF_FFFF之间的数据访问操作。它的作用是对数据读写访问，只和数据有关。\n系统总线(S-bus)：一条基于AHB-Lite总线协议的32位总线，负责在0x2000_0000 – 0xDFFF_FFFF之间的数据访问操作1。它的作用是对数据读写访问，只和数据有关。\n通用DMA1：直接存储器访问（Direct Memory Access）控制器的第一个实例。它可以在不占用处理器资源的情况下，直接在内存和外设之间传输数据。在Cortex-M3内核中，DMA控制器通过与Cortex-M3内核共享系统总线来执行直接存储器传输。当CPU和DMA目标相同时（内存或外设），DMA请求可能会在一些总线周期内停止CPU对系统总线的访问\n通用DMA2：和DMA1一样，只是它是第二个实例。\n\n\n被动单元：  \n\n内部SRAM：静态随机存储器（Static Random Access Memory，简称SRAM）。它是一种内存类型，用于在芯片内部存储数据。与动态随机存储器（Dynamic Random Access Memory，简称DRAM）不同，SRAM不需要定期刷新来保持数据。这意味着它可以更快地访问数据，但也意味着它的成本更高，且集成度较低。\n内部闪存存储器：FLASH\nFSMC：灵活的静态存储器控制器（Flexible Static Memory Controller）是STM32中一个很有特色的外设，通过FSMC，STM32可以与SRAM、ROM、PSRAM、Nor Flash和NandFlash存储器的引脚相连，从而进行数据的交换。FSMC可以连接异步或同步存储器或16位PC存储卡，主要用途有：将AHB数据通信事务转换为适当的外部器件协议，满足外部器件的访问时序要求。\nAHB到APB的桥(AHB2APBx)，它连接所有的APB设备。\n\n\n\n\n\n\n\n\n\n\n\n\nCortex™-M3内核的DCode总线(D-bus)和系统总线(S-bus)都是基于AHB-Lite总线协议的32位总线，负责数据访问操作。它们的主要区别在于它们所负责的数据访问范围不同。DCode总线(D-bus)负责在0x0000_0000 – 0x1FFF_FFFF之间的数据访问操作，而系统总线(S-bus)负责在0x2000_0000 – 0xDFFF_FFFF之间的数据访问操作。尽管CM3支持非对齐访问，但你绝不会在该总线上看到任何非对齐的地址，这是因为处理器的总线接口会把非对齐的数据传送都转换成对齐的数据传送。因此，连接到D-Code总线上的任何设备都只需支持AHB-Lite的对齐访问，不需要支持非对齐访问\n\n\n\n\n\n\n\n\n\n高级高性能总线AHB（Advanced High-performance Bus）和高级外设总线APB（Advanced Peripheral Bus）都属于ARM公司的AMBA（Advanced Microcontroller Bus Architecture，高级微控制器总线架构）规范的一部分。它们之间的主要区别在于它们的速度和预期用途。AHB被设计用于需要快速数据传输速率和低延迟通信的高性能应用，而APB则被设计用于不需要高速数据传输的较慢外设。AHB使用全双工并行通信，而APB则使用大量的内存I/O访问。AHB通常用于芯片上不同组件之间的高速通信，而APB则用于处理器和其他外设之间的低速通信。AHB是一个同步协议，而APB是一个异步协议。\n\n\n\n指令总线(ICode bus)用于传输指令。该总线将Cortex™-M3内核的指令总线与闪存指令接口相连接。指令预取在此总线上完成。 \nSDIO是Secure Digital Input Output的缩写，它是一种安全数字卡接口，可以用作输入或输出设备的接口1。SDIO接口通常用于连接各种外设，如Wi-Fi、蓝牙、GPS等，以扩展设备的功能。  \nRCC是Reset and Clock Control（复位和时钟控制）的缩写。它是一个用于管理系统时钟和复位的模块。在Cortex-M3内核中，RCC模块负责管理系统时钟源，包括内部和外部时钟源，以及为外设提供时钟信号。此外，RCC模块还负责管理系统复位，包括软件复位、硬件复位和电源复位等。\nDMA总线将DMA的AHB主控接口与总线矩阵相联，总线矩阵协调着CPU的DCode和DMA到SRAM、闪存和外设的访问。\n总线矩阵协调内核系统总线和DMA主控总线之间的访问仲裁，仲裁利用轮换算法。\n\n启动配置在STM32F10xxx里，可以通过BOOT[1:0]引脚选择三种不同启动模式。\n\n\n\nBOOT0\nBOOT1\n启动模式\n\n\n\nX\n0\n主存储器启动模式\n\n\n0\n1\n系统存储器启动模式\n\n\n1\n1\nSRAM启动模式\n\n\n闪存存储器有主存储块和信息块组成。\n从主闪存存储器启动：主闪存存储器被映射到启动空间(0x0000 0000)，但仍然能够在它原有的地址(0x0800 0000)访问它，即闪存存储器的内容可以在两个地址区域访问，0x0000 0000或0x0800 0000。\n从系统存储器启动：系统存储器被映射到启动空间(0x0000 0000)，但仍然能够在它原有的地址(互联型产品原有地址为0x1FFF B000，其它产品原有地址为0x1FFF F000)访问它。\n从内置SRAM启动：只能在0x2000 0000开始的地址区访问SRAM。\n\n\n\n\n\n\n\n\n\n注意： 当从内置SRAM启动，在应用程序的初始化代码中，必须使用NVIC的异常表和偏移寄存器，从新映射向量表之SRAM中。\n复位STM32F10xxx支持三种复位形式，分别为系统复位、上电复位和备份区域复位。\n系统复位除了时钟控制器的RCC_CSR寄存器中的复位标志位和备份区域中的寄存器(见图4)以外，系统复位将复位所有寄存器至它们的复位状态。\n当发生以下任一事件时，产生一个系统复位：\n\nNRST引脚上的低电平(外部复位)\n窗口看门狗计数终止(WWDG复位)\n独立看门狗计数终止(IWDG复位)\n软件复位(SW复位)\n低功耗管理复位\n\n可通过查看RCC_CSR控制状态寄存器中的复位状态标志位识别复位事件来源。\n通过将Cortex™-M3中断应用和复位控制寄存器中的SYSRESETREQ位置’1’，可实现软件复位。\n在以下两种情况下可产生低功耗管理复位：\n\n在进入待机模式时产生低功耗管理复位：通过将用户选择字节中的nRST_STDBY位置’1’将使能该复位。这时，即使执行了进入待机模式的过程，系统将被复位而不是进入待机模式。\n在进入停止模式时产生低功耗管理复位：通过将用户选择字节中的nRST_STOP位置’1’将使能该复位。这时，即使执行了进入停机模式的过程，系统将被复位而不是进入停机模式。\n\n电源复位当以下事件中之一发生时，产生电源复位：\n\n上电/掉电复位(POR/PDR复位)\n从待机模式中返回\n\n电源复位将复位除了备份区域外的所有寄存器。\n\n\n图中复位源将最终作用于RESET引脚，并在复位过程中保持低电平。复位入口矢量被固定在地址0x0000 0004。芯片内部的复位信号会在NRST引脚上输出，脉冲发生器保证每一个(外部或内部)复位源都能有至少20μs的脉冲延时；当NRST引脚被拉低产生外部复位时，它将产生复位脉冲。\n备份区域复位拥有两个专门的复位，它们只影响备份区域。当以下事件中之一发生时，产生备份区域复位。\n\n软件复位，备份区域复位可由设置备份域控制寄存器(RCC_BDCR)中的BDRST位产生。\n在和两者掉电的前提下，或上电将引发备份区域复位。\n\n时钟概况三种不同的时钟源可被用来驱动系统时钟(SYSCLK)\n\nHSI振荡器时钟：高速内部振荡器（High-Speed Internal Oscillator）\nHSE振荡器时钟：高速外部振荡器（High-Speed External Oscillator）\nPLL时钟：锁相环（Phase-Locked Loop）用来倍频HSI RC的输出时钟或HSE晶体输出时钟。\n\n\n\n\n\n\n\n\n\n\nPLL的设置(选择HIS振荡器除2或HSE振荡器为PLL的输入时钟，和选择倍频因子)必须在其被激活前完成。一旦PLL被激活，这些参数就不能被改动。如果PLL中断在时钟中断寄存器里被允许，当PLL准备就绪时，可产生中断申请。如果需要在应用中使用USB接口，PLL必须被设置为输出48或72MHZ时钟，用于提供48MHz的USBCLK时钟。\n\n\n用户可通过多个预分频器配置AHB、高速APB(APB2)和低速APB(APB1)域的频率。AHB和APB2域的最大频率是72MHz。APB1域的最大允许频率是36MHz。SDIO接口的时钟频率固定为HCLK/2。\nRCC通过AHB时钟(HCLK)8分频后作为Cortex系统定时器(SysTick)的外部时钟。通过对SysTick控制与状态寄存器的设置，可选择上述时钟或Cortex(HCLK)时钟作为SysTick时钟。ADC时钟由高速APB2时钟经2、4、6或8分频后获得。\n定时器时钟频率分配由硬件按以下2种情况自动设置：\n\n如果相应的APB预分频系数是1，定时器的时钟频率与所在APB总线频率一致。\n否则，定时器的时钟频率被设为与其相连的APB总线频率的2倍。\n\nLSE晶体通过在备份域控制寄存器(RCC_BDCR)里的LSEON位启动和关闭。\nLSI RC可以通过控制/状态寄存器(RCC_CSR)里的LSION位来启动或关闭。\n时钟启动系统复位后，HSI振荡器被选为系统时钟。当时钟源被直接或通过PLL间接作为系统时钟时，它将不能被停止。\n只有当目标时钟源准备就绪了(经过启动稳定阶段的延迟或PLL稳定)，从一个时钟源到另一个时钟源的切换才会发生。在被选择时钟源没有就绪时，系统时钟的切换不会发生。直至目标时钟源就绪，才发生切换。\n时钟输出微控制器允许输出时钟信号到外部MCO引脚。\n相应的GPIO端口寄存器必须被配置为相应功能。以下四个时钟信号可被选作MCO时钟：\n\nSYSCLK\nHSI\nHSE\n除2的PLL时钟\n\n时钟的选择由时钟配置寄存器(RCC_CFGR)中的MCO[2:0]位控制。\n","slug":"STM32入门（一）：认识STM32","date":"2023-07-13T08:31:43.000Z","categories_index":"嵌入式","tags_index":"STM32,单片机","author_index":"Ac-Accelerator"},{"id":"59fff721b35c430dcc2003c20536d30b","title":"8086微机汇编语言","content":"在学校学习了汇编语言一课程，但是由于汇编指令繁多，而且在互联网上没有找到满足我要求的资料。同时书上的知识也比较分散，不好索引。所以我打算自己整理一份资料，方便自己以后查阅。同时也希望能帮助到其他人。\n寄存器分类通用寄存器\n\n\n寄存器符号\n全称\n\n用途\n\n\n\nAX\nAccumulator\n累加寄存器\n通用寄存器，主要作为累加器使用，是算数运算的主要寄存器\n\n\nBX\nBase\n基址寄存器\n通用寄存器，一般用于存放基址\n\n\nCX\nCount\n计数寄存器\n通用寄存器，一般用于存放循环次数的寄存器\n\n\nDX\nData\n数据寄存器\n通用寄存器，一般用于存储数据，在双精度算术运算中，和AX配合使用存放双字操作数，DX是高位寄存器，AX是低位寄存器\n\n\n地址寄存器\n\n\n寄存器符号\n全称\n\n用途\n\n\n\nSI\nSource Index\n源变址寄存器\n可作为源变址寄存器使用，是存放源变址的寄存器\n\n\nDI\nDestination Index\n目的变址寄存器\n可用于存放目的缓冲区的偏移地址\n\n\nSP\nStack Pointer\n堆栈指针寄存器\n用于指出堆栈顶端的偏移地址\n\n\nBP\nBase Pointer\n基址指针寄存器\n用于指出堆栈区某个单元的偏移地址\n\n\n段寄存器\n\n\n寄存器符号\n全称\n\n用途\n\n\n\nCS\nCode Segment\n代码段寄存器\n用于指出代码段的偏移地址\n\n\nDS\nData Segment\n数据段寄存器\n用于指出数据段的偏移地址\n\n\nSS\nStack Segment\n堆栈段寄存器\n用于指出堆栈段的偏移地址\n\n\nES\nExtra Segment\n附加段寄存器\n用于指出附加段的偏移地址\n\n\n控制寄存器\n\n\n寄存器符号\n全称\n\n用途\n\n\n\nIP\nInstruction Pointer\n指令指针寄存器\n用于指出下一条指令的偏移地址\n\n\nFLAGS\nFLAGS\n标志寄存器\n用于存放各种标志位\n\n\n\n\n\n标志码\n标志\n含义\n条件\n\n\n\nCF\nCarry Flag\n进位标志\n当指令的执行结果的最高位向前进位时，CF=1，否则CF=0\n\n\nSF\nSign Flag\n符号标志\n当指令的执行结果的最高位（符号位）为负数时，SF=1，否则SF=0\n\n\nZF\nZero Flag\n零标志\n当指令的执行结果为0时，ZF=1，否则ZF=0\n\n\nOF\nOverflow Flag\n溢出标志\n当指令的执行结果有溢出时（超出了表示的范围），OF=1，否则OF=0\n\n\nDF\nDirection Flag\n方向标志\n执行串操作时，若设置DF=1，储存单元地址自动减小，若设置DF=0时，储存单元地址自动增大\n\n\nIF\nInterrupt Flag\n中断标志\nIF=1时，允许CPU响应可屏蔽中断，IF=0时，禁止CPU响应中断请求\n\n\nPF\nParity Flag\n奇偶标志\n当指令的执行结果的二进制数中1的个数为偶数时，PF=1，否则PF=0\n\n\nTF\nTrap Flag\n陷阱标志\nDebug时，若设置TF=1，执行单步调试指令，进入陷阱，TF=0时，正常执行指令\n\n\nAF\nAuxiliary Carry Flag\n辅助进位标志\n当指令的执行结果的第三位（半字节）向前进位时，AF=1，否则AF=0\n\n\n8086标志位缩写形式\n\n\n\n标志名称\n标志\n值为1\n值为0\n\n\n\n进位标志\nCF\nCY\nNC\n\n\n符号标志\nSF\nNG\nPL\n\n\n零标志\nZF\nZR\nNZ\n\n\n溢出标志\nOF\nOV\nNV\n\n\n方向标志\nDF\nDN\nUP\n\n\n中断标志\nIF\nEI\nDI\n\n\n奇偶标志\nPF\nPE\nPO\n\n\n辅助进位标志\nAF\nAC\nNA\n\n\n指令分类DOS功能调用DOS功能调用采用中断指令INT 21H，功能号存放在AH寄存器，在其他的寄存器和存储单元中提供必须得参数和缓冲区地址，执行后系统在AL中放入返回参数。通常的DOS功能有5个：\n\n\n\n功能号\n功能\n说明\n示例\n\n\n\n1H\n键盘输入一个字符\n将键盘输入的字符放入AL中\nMOV AH,1HINT 21H\n\n\n8H\n键盘输入但不显示\n将键盘输入的字符放入AL中，不反映到在屏幕上\nMOV AH,8HINT 21H\n\n\n2H\n显示一个字符\n将DL中的字符显示在屏幕上，并且将AL的值改为DL的值\nMOV AH,2HINT 21H\n\n\n5H\n打印输出一个字符\n将DL中的字符发送到打印机，并且将AL的值改为DL的值\nMOV AH,5HINT 21H\n\n\n9H\n显示字符串\n将DS:DX中的字符串显示在屏幕上，AL的值被修改为24H\nMOV AH,9HLEA DX,STRINT 21H\n\n\n0AH\n键盘输入一个字符串\n将键盘输入的字符串放入DS:DX中\nMOV AH,0AHLEA DX,BUFFINT 21H\n\n\n4CH\n结束程序\n结束程序\nMOV AH,4CHINT 21H\n\n\n数据传送指令\n\n\n指令\n格式\n作用\n说明\n举例\n注意\n\n\n\n传输指令\nMOV DST,SRC\n(DST)←(SRC)\n将源操作数转移到目的操作数\nMOV AX, BX\n1.操作数类型要匹配2.目的操作数不能是立即数3.两个操作数不能同时是储存单元4.目的操作数属性要确定5.CS段寄存器不能作为目的操作数6.段寄存器不能用立即数赋值\n\n\n数据交换指令\nXCHG OPR1,OPR2\n(OPR1)↔(OPR2)\n将两个操作数互换\nXCHG AX, BX\n1.操作数类型要匹配2.两个操作数必须有一个是寄存器3.操作数不能是立即数\n\n\n进栈指令\nPUSH SRC\n((SP+1),(SP))←(SRC)\n先将堆栈指针减2，再将操作数SRC入栈\nPUSH AX\nSRC必须是字\n\n\n出栈指令\nPOP DST\n(DST)←((SP+1),(SP))\n将栈顶指针所指向的字单元的内容弹出到操作数DST中，再将SP加2\nPOP AX\n\n\n\n查表转换指令\nXLAT\nAL←(DS:BX+AL)\n将DS:BX+AL的内容送入AL,即把AL中位移量换成对应内容\nXLAT\n\n\n\n有效地址传送指令\nLEA 寄存器,储存单元\n寄存器←储存单元\n将储存单元的有效地址传送给寄存器\nLEA BX TABLE\n\n\n\n数据段地址传送指令\nLDS 寄存器,双字储存单元\nDS:寄存器←储存单元\n将双字单元的低字送入寄存器，高字传送给DS数据段寄存器\nLDS BX TABLE\n\n\n\n附加段地址传送指令\nLES 寄存器,双字储存单元\nES:寄存器←储存单元有效地址\n将双字单元的低字送入寄存器，高字传送给ES附加段寄存器\nLES BX TABLE\n\n\n\n字节拓展为字指令\nCBW\nAX←sign-extend(AL)\n将AL拓展到AX。如果AL的符号位为0，则AH为0，如果AL的符号位为1，则AH为FFH\nCBW\n\n\n\n字拓展为双字指令\nCWD\nDX:AX←sign-extend(AX)\n将AX拓展到DX。如果AX的符号位为0，则DX为0，如果AX的符号位为1，则DX为FFFFH\nCWD\n\n\n\n算术运算指令\n\n\n指令\n格式\n作用\n说明\n举例\n注意\n\n\n\n加法指令\nADD DST,SRC\n(DST)←(DST)+(SRC)\nSRC和DST相加，结果放入DST\nADD AX, BX\n\n\n\n带进位加法指令\nADC DST,SRC\n(DST)←(DST)+(SRC)+CF\n将SRC加到DST再加上进位标志CF，结果放入DST\nADC AX, BX\n一般用在双精度加法中，当低字相加后，两个高字相加时要考虑来自低字的进位\n\n\n加1指令\nINC OPR\n(OPR)←(OPR)+1\n将OPR加1，结果放入OPR\nINC AX\n\n\n\n减法指令\nSUB DST,SRC\n(DST)←(DST)-(SRC)\nSRC减去DST，结果放入DST\nSUB AX, BX\n\n\n\n带借位减法指令\nSBB DST,SRC\n(DST)←(DST)-(SRC)-CF\n将DST减去SRC再减去借位标志CF，结果放入DST\nSBB AX, BX\n一般用在双精度减法中，当低字相减后，两个高字相减时要考虑来自低字的借位\n\n\n减1指令\nDEC OPR\n(OPR)←(OPR)-1\n将OPR减1，结果放入OPR\nDEC AX\n\n\n\n求补指令\nNEG OPR\n(OPR)←0-(OPR)\n将OPR求补，结果放入OPR\nNEG AX\n\n\n\n比较指令\nCMP OPR1，OPR2\n(OPR1)-(OPR2)\n将OPR1减去OPR2，但不保存结果,改变标志位\nCMP AX, BX\n一般用于比较两个操作数的大小，不改变操作数的值\n\n\n无符号数乘法指令\nMUL SRC\nDX:AX←(AX) * (SRC)\n将AX乘以SRC（字），结果放入AX和DX\nMUL AX\n字节乘法是将AL乘以SRC（字节），结果放入AX\n\n\n带符号数乘法指令\nIMUL SRC\nDX:AX←(AX) * (SRC)\n将AX乘以SRC（字），结果放入AX和DX\nIMUL AX\n字节乘法是将AL乘以SRC（字节），结果放入AX\n\n\n无符号数除法指令\nDIV SRC\nAX←(DX:AX)/(SRC),DX←(DX:AX)%(SRC)\n将DX:AX除以SRC（字），结果放入AX，余数放入DX\nDIV AX\n字节除法是将AX除以SRC（字节），结果放入AL，余数放入AH\n\n\n带符号数除法指令\nIDIV SRC\nAX←(DX:AX)/(SRC),DX←(DX:AX)%(SRC)\n将DX:AX除以SRC（字），结果放入AX，余数放入DX\nIDIV AX\n字节除法是将AX除以SRC（字节），结果放入AL，余数放入AH\n\n\n压缩的BCD码加法调整\nDAA\n如果AL的低4位大于9，则将AL加6，并将AF置1，如果AL的高4位大于9（或等于9时AF为1），则将AL加60H，并将CF置1\n\nDAA\n\n\n\n压缩的BCD码减法调整\nDAS\n如果AF为1（AC），则将AL减6,AF置1。如果AL的高4位大于9，将AL减60H，并将CF置1\n\nDAS\n\n\n\n非压缩的BCD码加法调整\nAAA\n如果AL的低4位大于9，则将AL加6，AH加1，AL的高4位置0，CF和AF置1\n\nAAA\n\n\n\n非压缩的BCD码减法调整\nAAS\n如果AF为1（AC），则将AL减6，AH减1，AL高4位置0，CF置1\n\nAAS\n\n\n\n非压缩的BCD码乘法调整\nAAM\nAL除以0AH，得到的商送往AH，余数送往AL\n将乘积调整为两个非压缩的BCD码。\nAAM\n\n\n\n非压缩的BCD码除法调整\nAAD\nAL+AH×0AH，结果送往AL，AH清零\n在做除法之前，将被除数AX中的两个非压缩的BCD码调整为二进制数\nAAD\n\n\n\n算数左移\nSAL OPR,CNT\n(OPR)←(OPR)×2^(CNT)\n将OPR左移CNT位，结果放入OPR\nSAL AX, 1\n超过1位必须用CL寄存器指出位移位数\n\n\n算数右移\nSAR OPR,CNT\n(OPR)←(OPR)/2^(CNT)\n将OPR右移CNT位，结果放入OPR\nSAR AX, 1\n超过1位必须用CL寄存器指出位移位数\n\n\n循环左移\nROL OPR,CNT\n\nOPR左移，最高位进CF同时进最低位\nROL AX, 1\n超过1位必须用CL寄存器指出位移位数\n\n\n循环右移\nROR OPR,CNT\n\nOPR右移，最低位进CF同时进最高位\nROR AX, 1\n超过1位必须用CL寄存器指出位移位数\n\n\n带进位循环左移\nRCL OPR,CNT\n\nOPR左移，CF移入最低位，最高位进CF\nRCL AX, 1\n超过1位必须用CL寄存器指出位移位数\n\n\n带进位循环右移\nRCR OPR,CNT\n\nOPR右移，CF移入最高位，最低位进CF\nRCR AX, 1\n超过1位必须用CL寄存器指出位移位数\n\n\n逻辑运算指令\n\n\n指令\n格式\n作用\n说明\n举例\n注意\n\n\n\n逻辑与\nAND DST,SRC\n(DST)←(DST) AND (SRC)\nSRC和DST进行逻辑与，结果放入DST\nAND AX, BX\n自身相与结果不变但是改变标志位\n\n\n逻辑或\nOR DST,SRC\n(DST)←(DST) OR (SRC)\nSRC和DST进行逻辑或，结果放入DST\nOR AX, BX\n\n\n\n逻辑非\nNOT OPR\n(OPR)←NOT (OPR)\n将OPR求逻辑非，结果放入OPR\nNOT AX\n\n\n\n逻辑异或\nXOR DST,SRC\n(DST)←(DST) XOR (SRC)\nSRC和DST进行逻辑异或，结果放入DST\nXOR AX, BX\n\n\n\n测试指令\nTEST DST,SRC\n(DST) AND (SRC)\nSRC和DST进行逻辑与，结果不放入DST，只改变标志位\nTEST AX, BX\n\n\n\n逻辑左移\nSHL OPR,CNT\n(OPR)←(OPR)×2^(CNT)\n将OPR左移CNT位，结果放入OPR\nSHL AX, 1\n超过1位必须用CL寄存器指出位移位数\n\n\n逻辑右移\nSHR OPR,CNT\n(OPR)←(OPR)/2^(CNT)\n将OPR右移CNT位，结果放入OPR\nSHR AX, 1\n超过1位必须用CL寄存器指出位移位数\n\n\n串操作指令\n\n\n串处理指令\n格式\n作用\n说明\n举例\n\n\n\n串传送\nMOVS/MOVSB/MOVSW DST,SRC\nREP连用，以字或字节的形式重复传送，直到CX=0为止,源串偏移地址由SI指出，目的串的偏移地址由DI指出，传送次数由CX指出\n第一种格式的双操作数要显式地指出源和目的操作数的地址属性；后两种格式隐式地指出源和目的串的地址和属性，即指令中没有操作数只有操作码\nREP MOVS BYTE PTR ES:[SI],DS:[DI]REP MOVSB\n\n\n串比较\nCMPS/CMPSB/CMPSW DST,SRC\n和REPZ等指令连用，以字或字节的形式重复比较，直到CX=0为止，并改变标志位,源串偏移地址由SI指出，目的串的偏移地址由DI指出，比较次数由CX指出\n第一种格式的双操作数要显式地指出源和目的操作数的地址属性；后两种格式隐式地指出源和目的串的地址和属性，即指令中没有操作数只有操作码\nREPNE CMPSW\n\n\n串扫描\nSCAS/SCASB/SCASW DST\n和REPZ等指令连用，在目的串中查找与AL或AX相等的字或字节，直到CX=0为止，并改变标志位,目的串在附加段中，偏移地址由DI指出，扫描次数由CX指出\n第一种格式的单操作数要显式地指出目的操作数的地址和属性；后两种格式隐式地指出目的串的地址和属性，即指令中没有操作数只有操作码\nREPNZ SCASB\n\n\n串获取\nLODS/LODSB/LODSW SRC\n从源串中取出一个字或字节放入AL或AX中,源串在数据段定义，源串偏移地址由SI指出。如果与REP连用则直到CX=0为止，取出次数由CX指出\n第一种格式的单操作数要显式地指出源操作数的地址和属性；后两种格式隐式地指出源串的地址和属性，即指令中没有操作数只有操作码\nREP LODSW\n\n\n串存入\nSTOS/STOSB/STOSW DST\n将AL或AX中的字或字节存入目的串中,目的串在附加段定义，目的串偏移地址由DI指出。如果与REP连用则直到CX=0为止，存入次数由CX指出\n第一种格式的单操作数要显式地指出目的操作数的地址和属性；后两种格式隐式地指出目的串的地址和属性，即指令中没有操作数只有操作码\nREP STOSB\n\n\n控制与转移指令\n\n\n无条件转移指令\n用法\n说明\n举例\n\n\n\n段内直接短转移\nJMP SHORT OPR\n(IP)←(IP)+8位位移量OPR\nJMP SHORT HELLO\n\n\n段内直接近转移\nJMP NEAR OPR\n(IP)←(IP)+16位偏移量OPR\nJMP NEAR HELLO\n\n\n段内间接转移\nJMP WORD PTR OPR\n(IP)←(EA)\nJMP WORD PTR [BX+SI]\n\n\n段间直接转移\nJMP FAR OPR\n(CS):(IP)←(OPR)\nJMP FAR PTR HELLO\n\n\n段间间接转移\nJMP DWORD PTR OPR\n(IP)←(EA),(CS)←(EA+2)\nJMP DWORD PTR [BX]\n\n\n\n\n\n条件标志转移指令\n转移条件\n说明\n\n\n\nJZ/JE\nZF=1\n结果为0则转移\n\n\nJNZ/JNE\nZF=0\n结果不为0则转移\n\n\nJC\nCF=1\n进位标志为1则转移\n\n\nJNC\nCF=0\n进位标志为0则转移\n\n\nJS\nSF=1\n符号标志为1则转移\n\n\nJNS\nSF=0\n符号标志为0则转移\n\n\nJO\nOF=1\n溢出标志为1则转移\n\n\nJNO\nOF=0\n溢出标志为0则转移\n\n\nJP\nPF=1\n奇偶标志为1则转移\n\n\nJNP\nPF=0\n奇偶标志为0则转移\n\n\n\n\n\n无符号数比较转移指令\n转移条件\n说明\n\n\n\nJB/JNAE\nCF=1 AND ZF=0\n小于则转移\n\n\nJBE/JNA\nCF=1 OR ZF=1\n小于等于则转移\n\n\nJA/JNBE\nCF=0 AND ZF=0\n大于则转移\n\n\nJAE/JNB\nCF=0 OR ZF=1\n大于等于则转移\n\n\n\n\n\n带符号数比较转移指令\n转移条件\n说明\n\n\n\nJL/JNGE\nSF≠OF AND ZF=0\n小于则转移\n\n\nJLE/JNG\nZF=1 OR SF≠OF\n小于等于则转移\n\n\nJG/JNLE\nZF=0 AND SF=OF\n大于则转移\n\n\nJGE/JNL\nSF=OF OR ZF=1\n大于等于则转移\n\n\n\n\n\nCX转移\n转移条件\n说明\n\n\n\nJCSZ\nCX=0\nCX为0则转移\n\n\n\n\n\n循环指令\n格式\n作用\n举例\n\n\n\n循环\nLOOP OPR\n(CX)←(CX)-1,若CX≠0，跳转到标号OPR处循环执行，若CX=0，退出循环并执行LOOP的下一条指令\nLOOP SS1\n\n\n循环\nLOOPZ/LOOPE OPR\n(CX)←(CX)-1,若CX≠0且ZF=1，跳转到标号OPR处循环执行，若CX=0或ZF=0，则执行LOOPZ的下一条指令\nLOOPZ SS1\n\n\n循环\nLOOPNZ/LOOPNE OPR\n(CX)←(CX)-1,若CX≠0且ZF=0，跳转到标号OPR处循环执行，若CX=0或ZF=1，则执行LOOPNZ的下一条指令\nLOOPNZ SS1\n\n\n处理机控制指令\n\n\n指令\n作用\n说明\n\n\n\nCLC\nCF=0\n清除进位标志\n\n\nSTC\nCF=1\n设置进位标志\n\n\nCMC\nCF=NOT CF\n进位标志取反\n\n\nCLD\nDF=0\n清除方向标志\n\n\nSTD\nDF=1\n设置方向标志\n\n\nCLI\nIF=0\n清除中断标志\n\n\nSTI\nIF=1\n设置中断标志\n\n\nHLT\n停机\n停机\n\n\nNOP\n无操作\n占3个时钟周期\n\n\n","slug":"8086微机汇编语言","date":"2023-04-16T10:25:35.000Z","categories_index":"汇编","tags_index":"汇编","author_index":"Ac-Accelerator"},{"id":"77e095561161043d7bcb5f0fd932479f","title":"数据库系统原理（二）","content":"数据的定义与操作SQL概述关系数据库的标准语言是 Structured Query Language，全称的翻译成中文就是结构化查询语言，简称SQL。虽然SQL字面含义是“查询语言”，但是其功能却包括了数据定义、数据查询、数据修改和保护等许多内容。伴随着数据库技术的发展和应用，国际标准化组织先后发布了SQL语言的多个版本的标准。实际中，各种不同数据库管理系统 在SQL语言的实现上存在一些小的差异。\nSQL语言的核心是SELECT语句，基本Select语句的一般形式中，第一个子句是SELECT，SELECT后面是ALL或者DISTINCT，或ALL和DISTINCT两个都不出现的默认的声明，再后面是一个或多个&lt;目标列表达式&gt;，每个&lt; 目标列表达式 &gt;还可以起个[ 别名 ]跟在后面；第二个子句是FROM FROM后面可以是一个&lt; 表名 &gt;或者是一个[&lt; 连接表达式 &gt;]；第三个子句是WHERE，WHERE后面是一个&lt; 条件表达式 &gt;；第四个子句是GROUP BY，GROUP BY后面是一个或多个 &lt; 列名 &gt; ；第五个子句是HAVING，HAVING后面是一个&lt; 条件表达式 &gt;；第六个子句是ORDER BY，ORDER BY后面是一个或多个 &lt; 列名 &gt; 以及相应的ASC或DESC，或两者都不出现的默认声明。ASC表示按升序排列，DESC表示按降序排列。如果指定了多个排序列，那么仅在前面的表达式排序相等的情况下，才使用后面的表达式做进一步排序；第七个子句是LIMIT，后面是一个表示输出行数的数值，再后面是offset 后面跟一个表示偏移量的数值，这就是基本Select语句的一般形式。\nsqlSELECT [ALL|DISTINCT]\n    &lt;目标列表达式&gt; [别名][,&lt;目标列表达式&gt; [别名]]...\n[FROM &lt;表名&gt;[别名] [&lt;连接表达式&gt;]...]\n[WHERE &lt;条件表达式&gt;]\n[GROUP BY &lt;列名&gt; [&lt;列名&gt;]\n[HAVING &lt;条件表达式&gt;]]\n[ORDER BY &lt;列名&gt; [ASC|DESC] [&lt;列名&gt; [ASC|DESC]]\n[LIMIT &lt;行数&gt; [&lt;OFFSET偏移量&gt;]]];整个语句的执行过程:（在实际执行时数据库管理系统会为了尽可能快地获得等价查询结果而采取完全不同的执行步骤）\n\n如果仅有SELECT子句，按SELECT子句中给出的列名或列表达式求值，否则继续执行(2) ;\nFROM: 从FROM子句获得表;\n取满足WHERE子句所给出条件表达式的行;\n按GROUP BY子句中指定列的值分组;\n提取满足HAVING子句中组条件表达式的那些组;\n按SELECT子句中给出的列名或列表达式求值;\nORDER BY子句对输出的目标表进行排序，ASC:升序，DESC:降序;\n按照LIMIT子句的偏移量和行数确定输出元组;\n\nWHERE与HAVING的区别：WHERE子句是作用于FROM子句中关系的属性上的谓词，从FROM子句结果关系中选择满足条件的行，WHERE子句必须跟在FROM子句后面，没FROM子句就不能有WHERE子句;HAVING子句作用于GROUP BY子句的结果组，从中选择满足条件的组，HAVING子句必须跟在GROUP BY子句后面，没有GROUP BY子句就不能有HAVING子句。\nSQL语言是大小写不敏感的，PG建议SQL的保留字用大写 表名，字段名等所有数据库对象名全部使用小写，除非从定义到使用始终都加双引号，否则系统把所有对象名自动转化为小写，PG用单引号做字符串常量的标识，只有引号里面的字符才区分大小写。\n数据的定义以及修改表的定义包括表模式的创建、修改和删除\n数据修改包括给表里添加数据、更新数据以及删除数据\n创建表：\nsqlCREATE TABLE&lt;表名&gt;\n  (&lt;列名&gt;&lt;数据类型&gt;,\n  &lt;列名&gt;&lt;数据类型&gt;,\n  ...\n  );可以看到表的每个列都要指定数据类型，具体数据类型查看此表\n更改表的名字：\nsqlALTER TABLE &lt;表名&gt; RENAME TO &lt;新表名&gt;;删除表：\nsqlDROP TABLE &lt;表名&gt;修改表：\nsqlALTER TABLE&lt;表名&gt;\n[ADD COLUMN &lt;新列名&gt; &lt;数据类型&gt;]\n[ADD [完整性约束(&lt;列名&gt;)] ]\n[RENAME COLUMN &lt;旧列名&gt; TO &lt;新列名&gt;]\n[ALTER COLUMN &lt;列名&gt; TYPE &lt;数据类型&gt;]\n[DROP COLUMN &lt;列名&gt;];插入元组：插入元组的分量个数必须是正确的，插入元组的属性值必须在属性域中，元组值对应的属性排列顺序必须与定义时的顺序一致，否则必须在INSERT语句中明确指明属性顺序。在插入的常量元组中非主键属性可以使用空值null。\nsqlINSERT INTO &lt;表名&gt; [(&lt;属性1&gt;[,&lt;属性2&gt;,...])]VALUES (&lt;常量1&gt;[,&lt;常量2&gt;]... )插入查询结果：\nsqlINSERT INTO &lt;表名&gt; [(&lt;列名序列&gt;)]\n&lt;SELECT查询语句&gt;插入表：\nsqlINSERT INTO &lt;表名1&gt; [(&lt;列名序列&gt;)]\nTABLE &lt;表名2&gt;删除元组：如果没有任何条件限制，将删除所有元组\nsqlDELETE FROM &lt;表名&gt; [WHERE &lt;条件表达式&gt;]更新表中元组的某些列值：如果没有任何条件限制，将更新所有元组\nsqlUPDATE &lt;表名&gt;\nSET &lt;列名&gt;=&lt;表达式&gt;[,&lt;列名&gt;=&lt;表达式&gt;]...\n[WHERE &lt;条件&gt;]简单查询单表查询：包括投影、选择和聚集查询。\n投影查询包括基本投影和广义投影，基本投影是指选取表中的某些列的列值；广义投影是指在选取属性列时，允许进行一些适当的运算。例如，从student表中查找全部的学生id以及学生名字，输出每一行的id以及stu_name：\nsqlSELECT id , stu_name\nFROM student一般可以用*号代表全部列。\nsqlSELECT *\nFROM student广义投影（SELECT后面跟表达式）：查询所有id以及与100分的差值\nsqlSELECT id,100-grade\nFROM student用ORDER BY对结果进行排序，查询全体学生，按成绩升序，按年龄降序。\nsqlSELECT *\nFROM student\nORDER BY grade ASC,age DESC投影结果中可能出现所有列值均相等的重复行，但从数据库管理系统实现的角度看，投影过程会对每个新产生的结果行进行标识，即系统能区分每个行，也就是说，由于去重是一项耗时的工作，DBMS采取惰性原则:除非在SELECT后跟DISTINCT明确指出要求去重，否则，默认情况下、或者SELECT后跟ALL时都保留重复。\n选择查询：选择所有年龄大于20的学生的行\nsqlSELECT *\nFROM student\nWHERE age&gt;20;数据库用于选择查询的的关系运算符：\n聚集查询：从多个输入行中计算出一个结果。如sum等。还可以使用GROUP BY使得所有给出列上取值相同的行被分在一个组，将聚集函数作用在组上。\nsqlSELECT department, AVG(age) AS avgage\nFROM student\nGROUP BY department\nORDER BY avgage;这里AS的意思是给AVG(age)起了个avgage别名。还可以使用HAVING对分组进行筛选，HAVING子句给出的条件只针对GROUP BY子句形成的分组起作用，也可以使用聚集函数。\n联接查询如果查询的数据涉及两个或多个表，可以使用联接操作，称为联接查询。\n联接条件决定了两个表中哪些行是匹配的，以联接结果中出现哪些列\n联接类型是按照对悬浮行的不同处理方式来分的，即内联接，左外联接，右外联接，全外联接。\n在写多表联接查询语句的时候，如果查询涉及多个表，最简单直接的方法就是在FROM后面依次写上这些表名，并以逗号或CROSS JOIN分隔。FROM子句的结果表就是这些表的笛卡尔积，结果表包含所有这些表的所有列。如果两个表中有同名列，在列名前加上表名作前缀，表明该列的来源表。根据查询需要，还可通过WHERE子句对笛卡尔积结果表施加选择操作，以撷取那些符合查询条件的行。\n如果是自然联接，则用NATURAL JOIN来分割表名。\n如果是属性联接，用到的是JOIN USING语法\nsqlSELECT *\nFROM math_exam JOIN english_exam USING(id);如果是条件联接，用到的是JOIN ON语法\nsqlSELECT *\nFROM math_exam JOIN english_exam ON math_exam.id=english_exam.id;内联接用INNER而外联接用OUTER默认为INNERLEFT、RIGHT、FULL均隐含外联接  \n嵌套查询一个SELECT-FROM-WHERE语句称为一个查询块，将一个查询块嵌套在另一个查询块的SELECT FROM、WHERE、GROUP BY、HAVING、ORDER BY、LIMIT、OFFSET或WITH子句中的查询称为嵌套查询。\n表式嵌套：嵌套查询的结果是一个表，可以在外层查询中使用。\nsqlWITH avgach(eeid,avgachieve)AS(\n  SELECT eeid,AVG(achieve)FROM eeexam\n  GROUP BY eeid\n  )\nSELECT COUNT(*)\nFROM avgach\nWHERE avgachieve&gt;=80;sqlSELECT COUNT(*)\nFROM ( SELECT eeid,avg(achieve)\n  FROM eeexam\n  GROUP BY eeid\n  )AS avgach (eeid,avgachieve)\nWHERE avgachieve&gt;=80;\n注意：WITH子句只在包含它自己的查询语句中有效,WITH子句中的AS不能省略。\n\n\n\n\n\n\n\n\n\n相关嵌套查询：嵌套查询的结果是一个表，可以在外层查询中使用。外层查询中的表达式中包含内层查询的结果。\n集合嵌套：嵌套查询的结果是一个集合，可以在外层查询中使用。\nsqlSELECT eid,ename\nFROM exampaper\nWHERE eid IN\n  (SELECT eid\n  FROM eeexam\n  WHERE eeid='218811011013');sqlSELECT *\nFROM examinee\nWHERE EXISTS\n  (SELECT*\n  FROM eeexam\n  WHERE eeid=examinee.eeid AND eid= '0205000002');\n\n\n\n\n\n\n\n\n不相关嵌套查询：嵌套查询的结果是一个集合，可以在外层查询中使用。外层查询中的表达式中不包含内层查询的结果。\n标量式嵌套：嵌套查询的结果是一个标量，可以在外层查询中使用。\nsqlSELECT dname,\n  (SELECT COUNT(*)\n  FROM examiner\n  WHERE examiner.erdepa=department.dname)\nFROM department;sqlSELECT eeid，eename\nFROM examineeWHERE eedepa =\n  (SELECT eedepa\n  FROM examinee\n  WHERE eeid='218811011028');sqlSELECT (\n  SELECT eedepa\n  FROM examinee\n  WHERE eeexam.eeid=examinee.eeid) ,\n  avg(achieve)\nFROM eeexam\nGROUP BY(\n  SELECT eedepa\n  FROM examinee\n  WHERE eeexam.eeid=examinee.eeid);\n\n\n\n\n\n\n\n\n查询块可以出现在任何表名可以出现的地方，也可以出现在集合可以出现的地方，如果能确定查询块只返回单行单列的单个值，查询块可以出现在单个属性名、单个表达式、单个常量 可以出现的地方。\n","slug":"数据库系统原理（二）","date":"2023-03-29T08:37:00.000Z","categories_index":"数据库","tags_index":"数据库,学习笔记","author_index":"Ac-Accelerator"},{"id":"13bf866f8a267e47702ed2383b6aca22","title":"数据库系统原理（一）","content":"绪论数据库是什么广义定义：指包含关于某单位、机构、部门，或是某领域、业务主题，或是某对象的信息、互相关联的大量数据的集合。\n狭义定义：特指用专门通用软件管理，长期储存在计算机内、有组织、可共享的大量数据的集合。\n数据库管理系统定义：英语是 Database Management System ，缩写为DBMS.DBMS是位于用户与操作系统之间的一层软件，它是一个大型的复杂的系统软件。领先的著名数据库管理系统DBMS有PostgreSQL、IBM DB2、Oracle、Microsoft SQL Server等。\n模式和实例：数据库模式相对稳定，很少需要修改。实例是其对应模式的一个具体值，反映的是某一时刻数据库的状态。同一个模式可以有很多实例，实例的值随数据库中数据的更新而不断变化。\n基本功能：数据库管理系统最基本的功能就是允许用户逻辑地使用数据而无需关注这些数据在计算机中是如何存放如何处理的。\n数据抽象的层次对现实世界事物的状态进行选择、加工、组织，形成人对全部用户数据需求在大脑当中的认识，就是概念层。概念层数据模型通常使用实体-联系模型（E-R模型），一般用E-R图来表示。\n又数据库管理系统提供，通过便于人理解的相对简单的结构来描述数据库当中存储的数据以及这些数据之间存在的联系，这是逻辑层，逻辑层描述全部用户数据的整体结构。\n数据库一般有多个用户，一个用户不一定要使用所有数据，视图层从某个或某类用户角度出发，只描述与其相关的那一部分数据。\n物理层描述数据实际上是怎样在磁盘设备上组织的，典型的物理层数据模型是B+树\n\n\n\n逻辑层的数据模式也称为模式。视图层的数据模式也称为外模式。物理层的数据模式也称为内模式。\n有了外模式后，应用程序员不必关心逻辑模式。只与外模式发生联系。\n逻辑独立性：当模式改变时，由数据库管理员DBA对各外模式/模式映射作相应的改变，外模式保持不变。应用程序完全无需修改。\n物理独立性：如果数据库的内模式改变，只要对模式/内模式映射作相应的修改，可以使模式保持不变。外模式无需修改。\n三层模式两级映射：数据库管理系统的三层模式及两级映射，既为简单、安全地共享数据提供支持，又为应用系统易于扩展来适应应用需求的变化奠定了基础。\nSQL语言SQL包括数据定义、数据操作和数据保护三个部分\nSQL语言非常接近自然语言，易学易用。\n\n\n用户查询时，经由外模式-模式的映射转换到模式上的操作，然后在统计数据的帮助下找出尽可能好的执行计划，最后翻译成存储管理模块能够执行的形式，存储管理模块利用数据字典、数据索引，从磁盘上取到查询的目标数据。以上两个模块总是在保护管理模块下运行。保护管理模块负责检查用户权限，数据合法性。并以一种称为“事务”的方式在日志信息的帮助下维护多用户并发访问以及故障情况下的数据一致性\n数据库管理技术发展趋势关系数据库：关系数据库管理系统针对简单、高效和安全地共享数据这个中心目标已经发展出诸多极具特色的关键技术。\n关系数据库管理系统使用非常简单的关系模型，使得数据库设计和访问都像面对的是日常生活中广泛使用的最简单形式的表格。\n独立性、安全性、共享性是数据库中数据的特征。\n\n\n允许事务并发执行虽能带来性能上的好处，但需要对并发进行管控以保证数据完整性。\n并发控制机制保证并发情况下的数据完整性。恢复机制能保障故障情况下的数据完整性。\n随着大数据现象的出现，数据管理技术正面临基础架构变化带来的深刻变革。NoSQL系统利用计算机集群这种新架构来存储和处理大数据。当前的NoSQL系统强调可扩展性和高性能。在这种形势下，传统关系型数据库面临着巨大的挑战。\n关系模型关系结构和约束关系表：关系数据库使用一个或多个表来存储数据。数学上把一系列域上的笛卡尔积的子集称为关系。\n每个表有多个行，每个行有多个列，每个行列单元都是不能再分的原子值，同一表中各行相异，不允许重复出现完全相同的行。同一表中的行次序、列次序均无关紧要。考虑到表的实际应用，数据库中通常给每个列指定一个唯一的名字，也称作属性或字段。每个属性有一个允许值的集合，称为该属性的域或取值范围。给定一个关系表，习惯上把关系模式写成表名后面跟一对圆括号，里面罗列出一个个列名，例如：stu_info=(id,name,sex,class)。\n数据库保存现实世界的状态，并服务现实世界的应用，数据库中的数据应该与现实世界时时保持一致才有意义。理想情况下，系统能够判断数据库中的各个数据项值是否与现实世界一致，也就是数据是不是真实正确。然而，这个目标是没有办法实现的。退而求其次，可以在系统中定义一些正确数据应该满足的约束，系统自动检查数据库中的数据是否满足这些约束条件，并且只允许满足这些约束条件的数据进入数据库。也就是说，软件系统无法保证数据的真实正确性，可以保证数据符合可明确定义的约束。这种约束通常称为完整性约束，它是数据安全性的一部分。\n常见的简单约束有两种形式，一种是对属性取值范围的限定，比如性别只有男、女两种取值；另一种是对属性值之间相互关系的限定，最典型的就是关系模型里面键的概念，包括：超键、候选键、主键、外键。\n超键：在给定关系模式中，能唯一标识出各个元组的属性集合，被称为该关系模式的超键。超键中可能包含无关紧要的属性，也就是说超键的真子集也可能是超键。比如：(id)是stu_info的一个超键，(id,name)、(id,name,sex)、(id,name,sex,class)也都是stu_info的超键。\n候选键：在给定关系模式中，能够唯一标识出各个元组的属性集合，并且不含多余属性，就称这个属性集合是该关系模式的候选键。从概念我们可以看到说候选键是超键，但超键不一定是候选键，只有其任何真子集都不是超键的超键才是候选键。比如stu_info只有一个候选键，即(id)。\n主键：一个关系当中可能有多个候选键，通常指定其中一个，并且只一个，用来标识元组，就把这个候选键称为主键。由于主键具有唯一性，所以主键是候选键，但候选键不一定是主键。\n外键：如果关系表S1的一个属性子集A，必须匹配另外一个关系表S2中出现的数值，我们就把A称为是关系表S1的外键。其中，S1称为引用关系，S2称为被引用关系。外键的值，或与被引用关系中出现的数值对应，或者为空值。\n基本关系代数运算可以用代数、逻辑等方法描述关系操作，最基本最常用的是代数方法，也就是关系代数。\n通常，通常一门代数总是包括一些运算符和一些运算数，关系代数也是一门代数，关系代数包括一个运算集合，这些运算以一个或两个关系作为运算数，产生一个新的关系作为结果。\n关系运算的运算参数是关系，运算结果也是关系，这样，一个关系运算的结果可以作为另一个关系运算的参数，从而可以把多个关系代数运算组合在一起，形成复杂的关系代数表达式。\n\n\n关系代数运算分基本关系代数运算、附加关系代数运算和扩展关系代数运算。其中基本关系代数运算包括选择、投影 并、差、笛卡尔积以及更名运算。\n选择运算是选出满足给定谓词(条件)的元组，结果关系和原关系有着相同的模式。选择运算用希腊字母σ来表示，将谓词写作σ的右下标，并在σ后面的括号中给出作为参数的关系名。\n男\n投影运算用来从给定关系产生一个只有其部分列的新关系。投影运算用希腊字母 π 表示，所有希望在结果关系中出现的属性作为 π 的右下标，而作为参数的关系名紧跟在 π 后的括号中。结果关系的模式是 π 的下标中所有列出的所有属性，并按 π 下标中列出的顺序出现。需要注意的是，由于关系代数把表看作元组集合，既然是集合，就不包括重复元组。\n\n关系并运算：参与运算的关系必须是相容的。即两个关系必须是同元的，两个关系对应属性的域必须相同或者相容。\n关系差运算：是用来查询在一个关系中 而不在另一个关系中的那些元组 和并运算一样，差运算只能在相容的关系间进行。\n关系的笛卡尔积运算：结果关系的模式是参与运算的两个关系的模式的串接，在属性名称前加上来自的关系名，中间用小数点分隔。但对那些只在两个关系模式之一中出现的属性一般省略其关系名前缀，运算符左侧关系中的每一个元组与右侧关系的每一个元组拼接，形成结果关系中的一个元组。\n更名：更改关系名字。\n\n附加关系代数运算集合交运算：集合交运算的结果是由那些同时在参与运算关系中存在的元组组成，集合交运算只能在相容的关系间进行。\n自然联接运算：首先计算笛卡尔积，然后在笛卡尔积的结果上，基于两个关系模式中都出现的属性，即两个关系模式的所有同名属性进行属性值相等的选择运算，最后去除重复列。\n\n属性联接运算：首先计算笛卡尔积，然后在笛卡尔积的结果上，基于两个关系模式中都出现的属性，即按指定同名属性进行属性值相等的选择运算，最后去除重复列。属性联接与自然联接的区别在于，当参与联接运算的两个表有多个同名列时，自然联接的匹配条件是所有同名列全部取值相等，而属性联接的匹配条件是指定其中若干同名列取值相等。如果属性联接指定全部同名列来匹配，则等价于自然联接。\n\n条件联接运算：首先计算笛卡尔积，然后在笛卡尔积的结果上，选取满足给定条件的元组。\n\n赋值运算：赋值运算是将一右侧的表达式的结果赋给一左侧的关系变量，该关系变量可以在后续的表达式中使用。\n男\n扩展关系代数运算除了基本关系代数运算、附加关系代数运算，为了表达用户其他方面的查询需求，需要对关系代数运算做进一步的扩充。关系代数运算的进一步扩充，通常主要包括以下三个方面：广义投影——允许将算术运算作为投影的一部分、聚集——例如计算给定集合元素的总和、平均值等、外联接——使得关系代数表达式能够处理缺失信息。\n广义投影：允许在投影列表中使用算术表达式。形式如下：E是任意关系代数表达式，而F1,F2,…Fn中的每一个都是涉及E的属性的算术表达式，也可以仅仅是个属性或常量。\n\n聚集函数:sum、avg、count、max和min等,还可以对关系中的元组按某一条件进行分组，并对每个分组使用聚集函数。分组条件写在左下标，聚集函数写在右下标。\n\n外联接：有些元组不能跟另外关系的任何一个元组匹配，一些实际应用系统可能希望在结果中保留悬浮元组，这就有了外联接运算。相对于外连接，不考虑悬浮元组的自然联接、属性联接和条件联接都称为内联接。\n外联接有三种形式：左外联接、右外联接、全外联接首先计算内联接，然后加入左侧关系、右侧关系、两侧关系中的悬浮元组。运算符分别是在内联接运算符号的右上角加上L,R,F。\n\n","slug":"数据库系统原理（一）","date":"2023-03-28T10:56:00.000Z","categories_index":"数据库","tags_index":"数据库,学习笔记","author_index":"Ac-Accelerator"},{"id":"29c0bb26f17c8d5598125731d7dbd2bf","title":"C++多线程","content":"这是观看一位大佬双笙子佯谬的视频后写的笔记。\n时间标准库chrono（C++11）std::chrono定义于头文件&lt;chrono&gt;\n利用 C++ 强类型的特点，明确区分时间点与时间段，明确区分不同的时间单位。时间点类型：chrono::steady_clock::time_point 等时间段类型：chrono::milliseconds，chrono::seconds，chrono::minutes 等方便的运算符重载：时间点+时间段=时间点，时间点-时间点=时间段auto t0 = chrono::steady_clock::now(); //获取当前时间点auto t1 = t0 + chrono::seconds(30);// 当前时间点的30秒后auto dt = t1 - t0;// 获取两个时间点的差（时间段）int64_t sec = chrono::duration_cast&lt;chrono::seconds&gt;(dt).count();// 时间差的秒数  \n计算花费的时间ms。\ncppint main()\n{\n    auto t0 = std::chrono::steady_clock::now();\n    for (volatile int i = 0; i &lt; 10000000; i++)\n        ;\n    auto t1 = std::chrono::steady_clock::now();\n    auto dt = t1 - t0;\n    int64_t ms = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(dt).count();\n    std::cout &lt;&lt; \"time elapsed: \" &lt;&lt; ms &lt;&lt; \" ms\" &lt;&lt; std::endl;\n    return 0;\n}duration_cast 可以在任意的 duration 类型之间转换duration&lt;T, R&gt; 表示用 T 类型表示，且时间单位是 RR 省略不写就是秒，std::milli 就是毫秒，std::micro 就是微秒seconds 是 duration&lt;int64_t&gt; 的类型别名milliseconds 是 duration&lt;int64_t, std::milli&gt; 的类型别名  \n下面这样可以输出小数单位的时间段。\ncppint main()\n{\n    auto t0 = std::chrono::steady_clock::now();\n    for (volatile int i = 0; i &lt; 10000000; i++)\n        ;\n    auto t1 = std::chrono::steady_clock::now();\n    auto dt = t1 - t0;\n    double ms = std::chrono::duration_cast&lt;std::chrono::duration&lt;double, std::milli&gt;&gt;(dt).count();\n    std::cout &lt;&lt; \"time elapsed: \" &lt;&lt; ms &lt;&lt; \" ms\" &lt;&lt; std::endl;\n    return 0;\n}sleepstd::this_thread::sleep_for可以让当前线程休眠一段时间，然后继续。而且单位也可以自己指定，比如这里是 milliseconds 表示毫秒，也可以换成 microseconds 表示微秒，seconds 表示秒，chrono 的强类型让单位选择更自由。\ncpp\nint main()\n{\n    std::this_thread::sleep_for(std::chrono::milliseconds(400));\n    return 0;\n}std::this_thread::sleep_until让当前线程休眠直到某个时间点。\ncpp#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;chrono&gt;\nint main()\n{\n    auto t = std::chrono::steady_clock::now() + std::chrono::milliseconds(400);\n    std::this_thread::sleep_until(t);\n    return 0;\n}线程std::thread定义于头文件&lt;thread&gt;\nC++11 开始，为多线程提供了语言级别的支持。std::thread 这个类来表示线程。std::thread构造函数的参数可以是任意可调用对象。当那个线程启动时，就会执行这个可调用对象的内容。用 std::thread 类的成员函数 join() 来等待该进程结束。  \n作为一个 C++ 类，std::thread 同样遵循 RAII 思想和三五法则：因为管理着资源，它自定义了解构函数，删除了拷贝构造/赋值函数，但是提供了移动构造/赋值函数。\ncppvoid download(std::string file)//模拟的一个下载过程\n{\n    for (int i = 0; i &lt; 10; i++)\n    {\n        std::cout &lt;&lt; \"Downloading \" &lt;&lt; file\n                  &lt;&lt; \" (\" &lt;&lt; i * 10 &lt;&lt; \"%)...\" &lt;&lt; std::endl;\n        std::this_thread::sleep_for(std::chrono::milliseconds(400));\n    }\n    std::cout &lt;&lt; \"Download complete: \" &lt;&lt; file &lt;&lt; std::endl;\n}\nvoid interact()//模拟与用户交互的函数\n{\n    std::string name;\n    std::cin &gt;&gt; name;\n    std::cout &lt;&lt; \"Hi, \" &lt;&lt; name &lt;&lt; std::endl;\n}\nint main()\n{\n    std::thread t1([&amp;]\n                   { download(\"hello.zip\"); });//构造函数，会执行这个 lambda 里的内容。\n    interact();\n    std::cout &lt;&lt; \"Waiting for child thread...\" &lt;&lt; std::endl;\n    t1.join();//使用join()来等待线程t1结束。如果没有这一步，随着interact的结束，父线程立刻退出，它的子线程t1也会随之销毁，download就无法完成了。\n    std::cout &lt;&lt; \"Child thread exited!\" &lt;&lt; std::endl;\n    return 0;\n}std::thread的析构函数会销毁线程，因此，当某个std::thread对象生命周期结束的时候，就会调用析构函数，这会销毁线程。\ncppvoid myfunc()\n{\n    std::thread t1([&amp;]\n                   { download(\"hello.zip\"); });\n    // 退出函数体时，会销毁 t1 线程的句柄！\n}调用成员函数 detach() 分离该线程，意味着线程的生命周期不再由当前 std::thread 对象管理，而是在线程退出以后自动销毁自己。不过这样还是会在进程退出时候自动退出。\n但是 detach 的问题是进程退出时候不会等待所有子线程执行完毕。所以另一种解法是把std::thread对象移动到一个全局变量去，从而延长其生命周期。\ncppstd::vector&lt;std::thread&gt; pool;//全局线程池\nvoid myfunc()\n{\n    std::thread t1([&amp;]\n                   { download(\"hello.zip\"); });\n    // t1.detach();//分离该线程，线程将继续执行直至退出。\n    pool.push_back(std::move(t1));// 移交控制权到全局的线程池，以延长 t1 的生命周期\n}\nint main()\n{\n    myfunc();\n    interact();\n    for (auto &amp;t : pool)\n        t.join(); // 等待池里的线程全部执行完毕\n    return 0;\n}main 函数退出后自动 join 全部线程我们可以自定义一个类 ThreadPool，并用它创建一个全局变量tpool，其析构函数会在 main 退出后自动调用。\ncppclass ThreadPool\n{\n    std::vector&lt;std::thread&gt; m_pool;\npublic:\n    void push_back(std::thread thr)\n    {\n        m_pool.push_back(std::move(thr));\n    }\n    ~ThreadPool()// lmain函数退出后会自动调用\n    {\n        for (auto &amp;t : m_pool)\n            t.join();//等待池里的线程全部执行完毕\n    }\n} tpool;std::jthread(C++20)C++20 引入了 std::jthread 类，和 std::thread 不同在于：它的析构函数里会自动调用 join() 函数，从而保证 pool 析构时会自动等待全部线程执行完毕。\n异步std::async定义于头文件&lt;future&gt;  \nstd::async 接受一个带返回值的可调用对象，自身返回一个 std::future 对象。可调用对象将在另一个线程里执行。  \n等到要用到异步返回值的时候，就调用 future 的 get() 方法，如果此时异步线程还没结束，会等待其完成，并获取该可调用对象的返回值。  \ncppint main()\n{\n    std::future&lt;int&gt; fret = std::async([&amp;]\n                                       { return download(\"hello.zip\"); });\n    interact();\n    int ret = fret.get();\n    std::cout &lt;&lt; \"Download result: \" &lt;&lt; ret &lt;&lt; std::endl;\n    return 0;\n}除了 get() 会等待外，wait() 也可以等待，但是不会返回其值。  \n只要线程没有执行完，wait() 会无限等下去。而 wait_for() 则可以指定一个最长等待时间，用 std::chrono 里的类表示单位。它会返回一个 std::future_status 表示等待是否成功。如果超过这个时间线程还没有执行完毕，则放弃等待，返回 future_status::timeout。如果线程在指定的时间内执行完毕，则认为等待成功，返回 future_status::ready。  \n同理还有 wait_until() 其参数是一个时间点。\nstd::async的第一个参数可以设为 std::launch::deferred，这时不会创建一个线程来执行，它只会把可调用对象的运算推迟到 future 的 get() 被调用时。\ncppint main()\n{\n    std::future&lt;int&gt; fret = std::async(std::launch::deferred, [&amp;]\n                                       { return download(\"hello.zip\"); });\n    interact();\n    int ret = fret.get();//现在才开始运行\n    std::cout &lt;&lt; \"Download result: \" &lt;&lt; ret &lt;&lt; std::endl;\n    return 0;\n}std::promise如果不想让 std::async 帮你自动创建线程，想要手动创建线程，可以直接用 std::promise。然后在线程返回的时候，用 set_value() 设置返回值。在主线程里，用 get_future() 获取其 std::future 对象，进一步 get() 可以等待并获取线程返回值。\nfuture 为了三五法则，删除了拷贝构造/赋值函数。如果需要浅拷贝，实现共享同一个 future 对象，可以用std::shared_future。如果不需要返回值，std::async 里可调用对象的返回类型可以为 void， 这时 future 对象的类型为 std::future&lt;void&gt;。同理有 std::promise&lt;void&gt;，它的 set_value() 不接受参数，仅仅作为同步用，不传递任何实际的值。  \n互斥量vector 不是多线程安全（MT-safe）的容器。多个线程同时访问同一个 vector 会出现数据竞争（data-race）现象。\ncppint main()\n{\n    std::vector&lt;int&gt; arr;\n    std::thread t1([&amp;]\n                   {\n        for (int i = 0; i &lt; 1000; i++) \n            arr.push_back(1); });\n    std::thread t2([&amp;]\n                   {\n        for (int i = 0; i &lt; 1000; i++) \n            arr.push_back(2); });\n    t1.join();\n    t2.join();\n    return 0;\n}这样会导致vector的顺序是随机的。\nstd::mutex定义在头文件&lt;mutex&gt;\n防止多个线程同时进入某一代码段\n调用 std::mutex 的 lock() 时，会检测 mutex 是否已经上锁。如果没有锁定，则对 mutex 进行上锁。如果已经锁定，则陷入等待，直到 mutex 被另一个线程解锁后，才再次上锁。而调用 unlock() 则会进行解锁操作。这样，就可以保证 mtx.lock() 和 mtx.unlock() 之间的代码段，同一时间只有一个线程在执行，从而避免数据竞争。  \ncppint main()\n{\n    std::vector&lt;int&gt; arr;\n    std::mutex mtx;\n    std::thread t1([&amp;]\n                   {\n        for (int i = 0; i &lt; 1000; i++) {\n            mtx.lock();\n            arr.push_back(1);\n            mtx.unlock();\n        } });\n    std::thread t2([&amp;]\n                   {\n        for (int i = 0; i &lt; 1000; i++) {\n            mtx.lock();\n            arr.push_back(2);\n            mtx.unlock();\n        } });\n    t1.join();\n    t2.join();\n    return 0;\n}std::lock_guard符合 RAII 思想的上锁和解锁\n根据 RAII 思想，可将锁的持有视为资源，上锁视为锁的获取，解锁视为锁的释放。std::lock_guard 就是这样一个工具类，它的构造函数里会调用 lock()，解构函数会调用unlock()。从而退出函数作用域时能够自动解锁，避免程序员粗心不小心忘记解锁。  \nstd::unique_lock更自由的std::lock_guard\nstd::lock_guard 严格在解构时 unlock()，但是有时候我们会希望提前 unlock()。这时可以用 std::unique_lock，它额外存储了一个 flag 表示是否已经被释放。它会在解构检测这个 flag，如果没有释放，则调用 unlock()，否则不调用。然后可以直接调用 unique_lock 的 unlock() 函数来提前解锁，但是即使忘记解锁也没关系，退出作用域时候它还会自动检查一遍要不要解锁。\ncppint main()\n{\n    std::vector&lt;int&gt; arr;\n    std::mutex mtx;\n    std::thread t1([&amp;]\n                   {\n        for (int i = 0; i &lt; 1000; i++) {\n            std::unique_lock grd(mtx);\n            arr.push_back(1);\n        } });\n    std::thread t2([&amp;]\n                   {\n        for (int i = 0; i &lt; 1000; i++) {\n            std::unique_lock grd(mtx);\n            arr.push_back(2);\n            grd.unlock();\n            printf(\"outside of lock\\n\");\n            // grd.lock();  // 如果需要，还可以重新上锁\n        } });\n    t1.join();\n    t2.join();\n    return 0;\n}std::unique_lock：用 std::adopt_lock 做参数如果当前 mutex 已经上锁了，但是之后仍然希望用 RAII 思想在解构时候自动调用 unlock()，可以用 std::adopt_lock 作为 std::unique_lock 或 std::lock_guard 的第二个参数，这时它们会默认对象已经上锁。\n多个对象就每个对象各分配一把锁\n上锁失败不等待lock() 如果发现 mutex 已经上锁的话，会等待它直到它解锁。也可以用无阻塞的 **try_lock()**，它在上锁失败时不会陷入等待，而是直接返回 false；如果上锁成功，则会返回 true。比如下面这个例子，第一次上锁，因为还没有上锁，所以成功了，返回 true。第二次上锁，由于已经上锁，所以失败了，返回 false。\ncppstd::mutex mtx1;\nint main()\n{\n    if (mtx1.try_lock())\n        printf(\"succeed\\n\");\n    else\n        printf(\"failed\\n\");\n    if (mtx1.try_lock())\n        printf(\"succeed\\n\");\n    else\n        printf(\"failed\\n\");\n    mtx1.unlock();\n    return 0;\n}std::unique_lock：用 std::try_to_lock 做参数和无参数相比，它会调用 try_lock() 而不是 lock()。之后，可以用owns_lock() 判断是否上锁成功。\n上锁失败等待一段时间try_lock() 碰到已经上锁的情况，会立即返回 false。如果需要等待，但仅限一段时间，可以用 std::timed_mutex 的 try_lock_for() 函数，它的参数是最长等待时间，同样是由 chrono 指定时间单位。超过这个时间还没成功就会“不耐烦地”失败并返回 false；如果这个时间内上锁成功则返回 true。同理还有接受时间点的 **try_lock_until()**。\ncppstd::timed_mutex mtx1;\nint main()\n{\n    if (mtx1.try_lock_for(std::chrono::milliseconds(500)))\n        printf(\"succeed\\n\");\n    else\n        printf(\"failed\\n\");\n    if (mtx1.try_lock_for(std::chrono::milliseconds(500)))\n        printf(\"succeed\\n\");\n    else\n        printf(\"failed\\n\");\n    mtx1.unlock();\n    return 0;\n}unique_lock和mutex接口相同其实 std::unique_lock 具有 mutex 的所有成员函数：lock(), unlock(), try_lock(), try_lock_for() 等。除了它会在解构时按需自动调用 unlock()。因为 std::lock_guard 无非是调用其构造参数名为 lock() 的成员函数，所以 std::unique_lock 也可以作为 std::lock_guard 的构造参数！这种只要具有某些指定名字的成员函数，就判断一个类是否满足某些功能的思想，在 Python 称为鸭子类型，而 C++ 称为 concept（概念）。比起虚函数和动态多态的接口抽象，concept 使实现和接口更加解耦合且没有性能损失。 \n死锁两个锁互相锁由于同时执行的两个线程，它们中发生的指令不一定是同步的，因此有可能出现这种情况：t1 执行 mtx1.lock()。t2 执行 mtx2.lock()。t1 执行 mtx2.lock()：失败，陷入等待t2 执行 mtx1.lock()：失败，陷入等待双方都在等着对方释放锁，但是因为等待而无法释放锁，从而要无限制等下去。 \ncppint main()\n{\n    std::mutex mtx1;\n    std::mutex mtx2;\n\n    std::thread t1([&amp;]\n                   {\n        for (int i = 0; i &lt; 1000; i++) {\n            mtx1.lock();\n            mtx2.lock();\n            mtx2.unlock();\n            mtx1.unlock();\n        } });\n    std::thread t2([&amp;]\n                   {\n        for (int i = 0; i &lt; 1000; i++) {\n            mtx2.lock();\n            mtx1.lock();\n            mtx1.unlock();\n            mtx2.unlock();\n        } });\n    t1.join();\n    t2.join();\n    return 0;\n}这种现象称为死锁（dead-lock）。  \n解决1：永远不要同时持有两个锁最简单的方法，就是保证在一个线程中，得处于lock状态的锁不超过一个，即可以避免死锁。  \n解决2：保证两个锁双方上锁顺序一致比方有两个锁，mtx1和mtx2，每个运行的线程都保证先锁mtx1，再锁mtx2。这时，无论实际执行顺序是怎样，都不会出现一方等着对方的同时持有了对方等着的锁的情况。。\n解决3：用 std::lock 同时对多个上锁（更推荐）如果没办法保证上锁顺序一致，可以用标准库的 std::lock(mtx1, mtx2, …) 函数，一次性对多个 mutex 上锁。它接受任意多个 mutex 作为参数，并且它保证在无论任意线程中调用的顺序是否相同，都不会产生死锁问题。\nstd::lock 的 RAII 版本：std::scoped_lock和 std::lock_guard 相对应，std::lock 也有 RAII 的版本 std::scoped_lock。只不过他可以同时对多个 mutex 上锁。\n一个锁自己锁自己除了两个线程同时持有两个锁会造成死锁外，即使只有一个线程一个锁，如果 lock() 以后又调用 lock()，也会造成死锁。比如下面的 func 函数，上了锁之后，又调用了 other 函数，他也需要上锁。而 other 看到 mtx1 已经上锁，还以为是别的线程上的锁，于是陷入等待。殊不知是调用他的 func 上的锁，other 陷入等待后 func 里的 unlock() 永远得不到调用。\ncppstd::mutex mtx1;\nvoid other()\n{\n    mtx1.lock();\n    // do something\n    mtx1.unlock();\n}\nvoid func()\n{\n    mtx1.lock();\n    other();\n    mtx1.unlock();\n}\nint main()\n{\n    func();\n    return 0;\n}解决1：other 里不要再上锁把 other 里的 lock() 去掉，并在其文档中说明：“other 不是线程安全的，调用本函数之前需要保证某 mutex 已经上锁。”\n解决2：改用 std::recursive_mutex如果实在不能改的话，可以用 std::recursive_mutex。他会自动判断是不是同一个线程 lock() 了多次同一个锁，如果是则让计数器加1，之后 unlock() 会让计数器减1，减到0时才真正解锁。但是相比普通的std::mutex有一定性能损失。同理还有std::recursive_timed_mutex，如果你同时需要 try_lock_for()的话。\n数据结构std::vectorvector 不是多线程安全的容器。多个线程同时访问同一个 vector 会出现数据竞争（data-race）现象。我们可以封装一个线程安全的vector，类似下面的。\ncppclass MTVector\n{\n    std::vector&lt;int&gt; m_arr;\n    mutable std::mutex m_mtx;//设为mutable否则size()函数报错\npublic:\n    void push_back(int val)\n    {\n        m_mtx.lock();\n        m_arr.push_back(val);\n        m_mtx.unlock();\n    }\n    size_t size() const\n    {\n        m_mtx.lock();\n        size_t ret = m_arr.size();\n        m_mtx.unlock();\n        return ret;\n    }\n};在数据结构中：读可以共享，写必须独占，且写和读不能共存。那么在这种要求下，我们引入读写锁的概念。\nstd::shared_mutex上锁时，可以指定你的需求是写入还是读取，负责调度的读写锁会帮你判断要不要等待。如果需要写入数据，使用 lock() 和 unlock() 的组合。如果是要读取数据，使用 lock_shared() 和 unlock_shared() 的组合。\nstd::shared_lock在函数体退出时自动调用 unlock_shared()。\n访问者模式只需一次性上锁，且符合 RAII 思想\ncppclass MTVector\n{\n    std::vector&lt;int&gt; m_arr;\n    std::mutex m_mtx;\npublic:\n    class Accessor\n    {\n        MTVector &amp;m_that;\n        std::unique_lock&lt;std::mutex&gt; m_guard;\n    public:\n        Accessor(MTVector &amp;that)\n            : m_that(that), m_guard(that.m_mtx) {}\n        void push_back(int val) const { return m_that.m_arr.push_back(val); }\n        size_t size() const { return m_that.m_arr.size(); }\n    };\n    Accessor access() { return {*this}; }\n};\nint main()\n{\n    MTVector arr;\n    std::thread t1([&amp;]()\n                   {\n        auto axr = arr.access();\n        for (int i = 0; i &lt; 1000; i++) {\n            axr.push_back(i);\n        } });\n\n    std::thread t2([&amp;]()\n                   {\n        auto axr = arr.access();\n        for (int i = 0; i &lt; 1000; i++) {\n            axr.push_back(1000 + i);\n        } });\n    t1.join();\n    t2.join();\n    std::cout &lt;&lt; arr.access().size() &lt;&lt; std::endl;\n    return 0;\n}条件变量定义于头文件&lt;condition_variable&gt;\n等待被唤醒cppint main()\n{\n    std::condition_variable cv;\n    std::mutex mtx;\n    std::thread t1([&amp;]\n                   {\n        std::unique_lock lck(mtx);\n        cv.wait(lck);\n        std::cout &lt;&lt; \"t1 is awake\" &lt;&lt; std::endl; });\n    std::this_thread::sleep_for(std::chrono::milliseconds(400));\n    std::cout &lt;&lt; \"notifying...\" &lt;&lt; std::endl;\n    cv.notify_one(); // 唤醒t1\n    t1.join();\n\n    return 0;\n}cv.wait(lck) 将会让当前线程陷入等待。在其他线程中调用 cv.notify_one() 则会唤醒那个陷入等待的线程。可以发现 std::condition_variable 必须和 std::unique_lock&lt;std::mutex&gt; 一起用，稍后会解释原因。\n等待条件为true给成员函数wait额外指定一个参数，变成 wait(lock, expr) 的形式，其中 expr 是一个可调用对象，只有其返回值为 true 时才会真正唤醒，否则继续等待。\ncppint main()\n{\n    std::condition_variable cv;\n    std::mutex mtx;\n    bool ready = false;\n    std::thread t1([&amp;]\n                   {\n        std::unique_lock lck(mtx);\n        cv.wait(lck, [&amp;] { return ready; });\n        std::cout &lt;&lt; \"t1 is awake\" &lt;&lt; std::endl; });\n    std::cout &lt;&lt; \"notifying not ready\" &lt;&lt; std::endl;\n    cv.notify_one(); // 没用，因为ready为false\n    ready = true;\n    std::cout &lt;&lt; \"notifying ready\" &lt;&lt; std::endl;\n    cv.notify_one(); // t1被唤醒，因为ready为true\n    return 0;\n}多个等待者std::condition_variable成员函数notify_all() 唤醒全部等待中的线程。这就是为什么 wait() 需要一个 unique_lock 作为参数，因为要保证多个线程被唤醒时，只有一个能够被启动。如果不需要，在 wait() 返回后调用 unlock() 即可。wait() 的过程中会暂时 unlock() 这个锁。\ncppint main()\n{\n    std::condition_variable cv;\n    std::mutex mtx;\n    std::thread t1([&amp;]\n                   {\n        std::unique_lock lck(mtx);\n        cv.wait(lck);\n        std::cout &lt;&lt; \"t1 is awake\" &lt;&lt; std::endl; });\n    std::thread t2([&amp;]\n                   {\n        std::unique_lock lck(mtx);\n        cv.wait(lck);\n        std::cout &lt;&lt; \"t2 is awake\" &lt;&lt; std::endl; });\n    std::thread t3([&amp;]\n                   {\n        std::unique_lock lck(mtx);\n        cv.wait(lck);\n        std::cout &lt;&lt; \"t3 is awake\" &lt;&lt; std::endl; });\n    std::this_thread::sleep_for(std::chrono::milliseconds(400));\n    std::cout &lt;&lt; \"notifying one\" &lt;&lt; std::endl;\n    cv.notify_one(); // 仅仅唤醒t1\n    std::this_thread::sleep_for(std::chrono::milliseconds(400));\n    std::cout &lt;&lt; \"notifying all\" &lt;&lt; std::endl;\n    cv.notify_all(); // 唤醒剩下的t2和t3\n    t1.join();\n    t2.join();\n    t3.join();\n    return 0;\n}实现生产者-消费者模式cppint main()\n{\n    std::condition_variable cv;\n    std::mutex mtx;\n    std::vector&lt;int&gt; foods;\n    std::thread t1([&amp;]\n                   {\n        for (int i = 0; i &lt; 2; i++) {\n            std::unique_lock lck(mtx);\n            cv.wait(lck, [&amp;] {\n                return foods.size() != 0;\n            });\n            auto food = foods.back();\n            foods.pop_back();\n            lck.unlock();\n            std::cout &lt;&lt; \"t1 got food:\" &lt;&lt; food &lt;&lt; std::endl;\n        } });\n    std::thread t2([&amp;]\n                   {\n        for (int i = 0; i &lt; 2; i++) {\n            std::unique_lock lck(mtx);\n            cv.wait(lck, [&amp;] {\n                return foods.size() != 0;\n            });\n            auto food = foods.back();\n            foods.pop_back();\n            lck.unlock();\n            std::cout &lt;&lt; \"t2 got food:\" &lt;&lt; food &lt;&lt; std::endl;\n        } });\n    foods.push_back(42);\n    foods.push_back(233);\n    cv.notify_one();\n    foods.push_back(666);\n    foods.push_back(4399);\n    cv.notify_all();\n    t1.join();\n    t2.join();\n    return 0;\n}\n\n\n\n\n\n\n\n\nstd::condition_variable 仅仅支持 std::unique_lock&lt;std::mutex&gt; 作为 wait 的参数，如果需要用其他类型的 mutex 锁，可以用 std::condition_variable_any。他还有 wait_for() 和 wait_until() 函数，分别接受 chrono 时间段和时间点作为参数。\n原子操作定义于头文件&lt;atomic&gt;\n多个线程修改同一个计数器多个线程同时往一个 int 变量里累加，这样肯定会出错，因为 counter += i 在 CPU 看来会变成三个指令：读取 counter 变量到 rax 寄存器rax 寄存器的值加上 1把 rax 写入到 counter 变量即使编译器优化成 add [counter], 1 也没用，因为现代 CPU 为了高效，会把一条汇编指令拆分成很多微指令 (micro-ops)，具体是如何实现的跟硬件有很大的关系。  \n如果有多个线程同时运行，顺序是不确定的：t1：读取 counter 变量，到 rax 寄存器t2：读取 counter 变量，到 rax 寄存器t1：rax 寄存器的值加上 1t2：rax 寄存器的值加上 1t1：把 rax 写入到 counter 变量t2：把 rax 写入到 counter 变量如果是这种顺序，最后 t1 的写入就被 t2 覆盖了，从而 counter 只增加了 1，而没有像预期的那样增加 2。更不用说现代 CPU 还有高速缓存，乱序执行，指令级并行等优化策略，你根本不知道每条指令实际的先后顺序。  \n解决1：std::mutex 上锁防止多个线程同时修改 counter 变量，从而不会冲突。问题：mutex 太过重量级，他会让线程被挂起，从而需要通过系统调用，进入内核层，调度到其他线程执行，有很大的开销。\n解决2：std::atomic（推荐）因此可以用更轻量级的 atomic，对他的 += 等操作，会被编译器转换成专门的指令。CPU 识别到该指令时，会锁住内存总线，放弃乱序执行等优化策略（将该指令视为一个同步点，强制同步掉之前所有的内存操作），从而向你保证该操作是原子 (atomic) 的，不会加法加到一半另一个线程插一脚进来。对于程序员，只需把 int 改成 atomic&lt;int&gt; 即可，也不必像 mutex 那样需要手动上锁解锁，因此用起来也更直观。\n\n\n\n\n\n\n\n注意\n不过要注意了，这种写法：counter = counter + 1;  // 错，不能保证原子性counter += 1;                // OK，能保证原子性counter++;                    // OK，能保证原子性\n\n\n","slug":"C-多线程","date":"2022-11-08T17:02:00.000Z","categories_index":"C++","tags_index":"C++进阶,多线程","author_index":"Ac-Accelerator"},{"id":"654198c9751861f6164cbde797aab0ed","title":"编译器优化","content":"这是观看一位大佬双笙子佯谬的视频后写的笔记。\n汇编基础x64架构CPU寄存器模型\n\n汇编语言\n\ngcc编译器里函数的前6个参数：分别通过*di，*si，*dx，*cx，r8*，r9*传入,如果有六个以上的参数，则使用程序的堆栈将其他参数传递给该函数。  gcc编译器里的返回值：通过 eax 传出\n如何用编译器产生汇编语言？添加下面几个编译参数。第一个参数用于简化汇编代码，第二个参数用于在汇编代码旁边附带源码注释。第三个是告诉编译器生成目标是汇编语言。至于第四个是优化等级，有O0,O1,O2,O3等等，优化程度由低到高，可自行选择。\ntxt-fomit-frame-pointer -fverbose-asm -S -O2化简代数化简cppint func(int a, int b)\n{\n    int c = a + b;\n    int d = a - b;\n    return (c + d) / 2;//其实就是return a;\n}编译优化后\ntxt_Z4funcii:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:2: {\n    movl\t%ecx, %eax\t # tmp86, a\n # exam1.cpp:6: }\n    ret\t常量折叠示例1：\ncppint func() \n{\n    int a = 32;\n    int b = 10;\n    return a + b;\n}编译优化后\ntxt_Z4funcv:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:5: }\n    movl\t$42, %eax\t #,\n    ret\t示例2\ncppint func(int n)\n{\n    int ret = 0;\n    for (int i = 1; i &lt;= 100; i++) \n        ret += i;\n    return ret;\n}编译优化后\ntxt_Z4funci:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:6: }\n    movl\t$5050, %eax\t #,\n    ret\t但是像这种就会优化失败：\ncpp#include &lt;vector&gt;\nint func()\n{\n    std::vector&lt;int&gt; arr;\n    for (int i = 1; i &lt;= 100; i++)\n        arr.push_back(i);\n    return std::reduce(arr.begin(), arr.end());\n}\n\n\n\n\n\n\n\n\n结论：尽量避免代码复杂化，避免使用会造成内存分配在堆上的容器。简单的代码，比什么优化手段都强。\n存储在堆上（妨碍优化）：vector, map, set, string, function, anyunique_ptr, shared_ptr, weak_ptr。\n存储在栈上（利于优化）：array, bitset, glm::vec, string_viewpair, tuple, optional, variant\n那把vector改为array试试？\ncpp#include &lt;array&gt;\nint func()\n{\n    std::array&lt;int,100&gt; arr;\n    for (int i = 1; i &lt;= 100; i++)\n        arr[i-1]=i;\n    return std::reduce(arr.begin(), arr.end());\n}优化失败的。\n那再改用手写的reduce？\ncpp#include &lt;array&gt;\nint func() {\n    std::array&lt;int, 100&gt; arr;\n    for (int i = 1; i &lt;= 100; i++) \n        arr[i - 1] = i;\n    int ret = 0;\n    for (int i = 1; i &lt;= 100; i++) \n        ret += arr[i - 1];\n    return ret;\n}优化还是失败。把数字改小一点试试？\ncpp#include &lt;array&gt;\nint func() {\n    std::array&lt;int, 10&gt; arr;\n    for (int i = 1; i &lt;= 10; i++) \n        arr[i - 1] = i;\n    int ret = 0;\n    for (int i = 1; i &lt;= 10; i++) \n        ret += arr[i - 1];\n    return ret;\n}实测优化成功。\n\n\n\n\n\n\n\n\n\n结论：代码过于复杂，涉及的语句数量过多时，编译器会放弃优化！简单的代码，比什么优化手段都强。\nconstexpr：强迫编译器在编译期求值\ncpp#include &lt;vector&gt;\n#include &lt;numeric&gt;\nconstexpr int func1()\n{\n    std::vector&lt;int&gt; arr;\n    for (int i = 1; i &lt;= 100; i++)\n        arr.push_back(i);\n    return std::reduce(arr.begin(), arr.end());\n}\nint func2()\n{\n    constexpr int con = func1();\n    return con;\n}C++20实测可优化成功。C++20以下不支持对vector的优化，但是可以优化前面几个没优化成功的。\n过度依赖编译器c常量优化可能会导致编译速度变慢。\n内联编译器优化：call 变 jmp调用外部函数：call 指令\ncppint other(int a);\nint func()\n{\n    return other(233);\n}优化前：\ntxt_Z4funcv:\n.LFB0:\n    subq\t$40, %rsp\t #,\n    .seh_stackalloc\t40\n    .seh_endprologue\n # exam1.cpp:4:     return other(233);\n    movl\t$233, %ecx\t #,\n    call\t_Z5otheri\t #\n # exam1.cpp:5: }\n    addq\t$40, %rsp\t #,\n    ret\t优化后\ntxt_Z4funcv:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:4:     return other(233);\n    movl\t$233, %ecx\t #,\n # exam1.cpp:5: }\n # exam1.cpp:4:     return other(233);\n    jmp\t_Z5otheri\t #如果 _Z5otheri 定义在同一个文件中，编译器会直接调用，减轻了链接器的负担。\n内联化内联：当编译器看得到被调用函数（other）实现的时候，会直接把函数实现贴到调用他的函数（func）里。只有定义在同一个文件的函数可以被内联！否则编译器看不见函数体里的内容怎么内联呢？  \ncppint other(int a)\n{\n    return a;\n}\nint func()\n{\n    return other(233);\n}txt_Z4funcv:\n.LFB1:\n    .seh_endprologue\n # exam1.cpp:8: }\n    movl\t$233, %eax\t #,\n    ret\t为了效率我们可以尽量把常用函数定义在头文件里，然后声明为 static。这样调用他们的时候编译器看得到他们的函数体，从而有机会内联。 因为 static 声明表示不会暴露 other 给其他文件，而且 func 也已经内联了 other，所以编译器干脆不定义 other 了。\n指针看下面这个例子\ncppvoid func(int *a, int *b, int *c)\n{\n    *c = *a;\n    *c = *b;\n}txt_Z4funcPiS_S_:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:3:     *c = *a;\n    movl\t(%rcx), %eax\t # *a_4(D), _1\n # exam1.cpp:3:     *c = *a;\n    movl\t%eax, (%r8)\t # _1, *c_5(D)\n # exam1.cpp:4:     *c = *b;\n    movl\t(%rdx), %eax\t # *b_7(D), _2\n # exam1.cpp:4:     *c = *b;\n    movl\t%eax, (%r8)\t # _2, *c_5(D)\n # exam1.cpp:5: }\n    ret\t为什么编译器不优化掉 *c = *a？\n指针别名现象（pointer aliasing）如果b和c指向同一个变量，优化就会产生错误，编译器宁肯不优化也不肯出现错误！\n__restrict关键字优化如果用户能够向编译器保证这些指针之间不会重叠，就可以使用__restrict关键字，告诉编译器让它大胆优化。\ncppvoid func(int *__restrict a, int *__restrict b, int *__restrict c)\n{\n    *c = *a;\n    *c = *b;\n}txt_Z4funcPiS_S_:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:3:     *c = *b;\n    movl\t(%rdx), %eax\t # *b_5(D), *b_5(D)\n    movl\t%eax, (%r8)\t # *b_5(D), *c_4(D)\n # exam1.cpp:4: }\n    ret\t实际上，__restrict 只需要加在所有具有写入访问的指针（这里是 c）上，就可以优化成功。而我们可以用 const 禁止写入访问。  \n\n\n\n\n\n\n\n\n\n结论：所有非 const 的指针都可尝试声明 __restrict。 \n禁止优化：volatile\ncppint func(int volatile *a)\n{\n    *a = 42;\n    return *a;\n}txt_Z4funcPVi:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:3:     *a = 42;\n    movl\t$42, (%rcx)\t #, *a_2(D)\n # exam1.cpp:4:     return *a;\n    movl\t(%rcx), %eax\t # *a_2(D), &lt;retval&gt;\n # exam1.cpp:5: }\n    ret\t\n\n\n\n\n\n\n\n\n结论：加了 volatile 的对象，编译器会放弃优化对他的读写操作。做性能实验的时候非常有用。\n合并写入\ncppvoid func(int *a)\n{\n    a[0] = 123;\n    a[1] = 456;\n}将两个 int32 的写入合并为一个 int64 的写入。\ntxt_Z4funcPi:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:3:     a[0] = 123;\n    movq\t.LC0(%rip), %rax\t #, tmp83\n    movq\t%rax, (%rcx)\t # tmp83, MEM &lt;vector(2) int&gt; [(int *)a_2(D)]\n # exam1.cpp:5: }\n    ret\t\n    .seh_endproc\n    .section .rdata,\"dr\"\n    .align 8\n.LC0:\n    .long\t123\n    .long\t456但如果访问的两个元素地址间有跳跃，就不能合并了。\ncppvoid func(int *a)\n{\n    a[0] = 123;\n    a[2] = 456;\n}txt_Z4funcPi:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:3:     a[0] = 123;\n    movl\t$123, (%rcx)\t #, *a_2(D)\n # exam1.cpp:4:     a[2] = 456;\n    movl\t$456, 8(%rcx)\t #, MEM[(int *)a_2(D) + 8B]\n # exam1.cpp:5: }\n    ret\t矢量化SIMD更宽的合并写入：矢量化指令（SIMD）  两个 int32 可以合并为一个 int64四个 int32 可以合并为一个 __m128xmm0 由 SSE 引入，是个 128 位寄存器他可以一次存储 4 个 int，或 4 个 floatmovups：move unaligned packed singlemovaps：move aligned packed single  \ncppvoid func(int *a)\n{\n    a[0] = 111;\n    a[1] = 222;\n    a[2] = 333;\n    a[3] = 444;\n}txt_Z4funcPi:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:2:     a[0] = 111;\n    movdqu\t.LC0(%rip), %xmm0\t #, tmp83\n    movups\t%xmm0, (%rcx)\t # tmp83, MEM &lt;vector(4) int&gt; [(int *)a_2(D)]\n # exam1.cpp:6: }\n    ret\t\n    .seh_endproc\n    .section .rdata,\"dr\"\n    .align 16\n.LC0:\n    .long\t111\n    .long\t222\n    .long\t333\n    .long\t444能再宽一点吗？两个 int32 可以合并为一个 int64四个 int32 可以合并为一个 __m128八个 int32 可以合并为一个 __m256！  \ncppvoid func(int *a)\n{\n    a[0] = 111;\n    a[1] = 222;\n    a[2] = 333;\n    a[3] = 444;\n    a[4] = 555;\n    a[5] = 666;\n    a[6] = 777;\n    a[7] = 888;\n}但是编译器默认没有用256位的 ymm0而是用了两次xmm0,因为他不敢保证运行这个程序的电脑支持 AVX 指令集…… \ntxt_Z4funcPi:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:3:     a[0] = 111;\n    movdqu\t.LC0(%rip), %xmm0\t #, tmp83\n    movups\t%xmm0, (%rcx)\t # tmp83, MEM &lt;vector(4) int&gt; [(int *)a_2(D)]\n    movdqu\t.LC1(%rip), %xmm0\t #, tmp84\n    movups\t%xmm0, 16(%rcx)\t # tmp84, MEM &lt;vector(4) int&gt; [(int *)a_2(D) + 16B]\n # exam1.cpp:11: }\n    ret\t\n    .seh_endproc\n    .section .rdata,\"dr\"\n    .align 16\n.LC0:\n    .long\t111\n    .long\t222\n    .long\t333\n    .long\t444\n    .align 16\n.LC1:\n    .long\t555\n    .long\t666\n    .long\t777\n    .long\t888编译选项-march=native 让编译器自动判断当前硬件支持的指令。但是这会导致程序兼容性降低。\ntxt_Z4funcPi:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:3:     a[0] = 111;\n    vmovdqu\t.LC0(%rip), %ymm0\t #, tmp83\n    vmovdqu\t%ymm0, (%rcx)\t # tmp83, MEM &lt;vector(8) int&gt; [(int *)a_2(D)]\n    vzeroupper\n # exam1.cpp:11: }\n    ret\t\n    .seh_endproc\n    .section .rdata,\"dr\"\n    .align 32\n.LC0:\n    .long\t111\n    .long\t222\n    .long\t333\n    .long\t444\n    .long\t555\n    .long\t666\n    .long\t777\n    .long\t888成功使用了ymm0\n清零拷贝：自动调用标准库cppvoid func(int *a, int n)\n{\n    for (int i = 0; i &lt; n; i++)\n        a[i] = 0;\n}txt_Z4funcPii:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:2:     for (int i = 0; i &lt; n; i++) {\n    testl\t%edx, %edx\t # n\n    jle\t.L3\t #,\n # exam1.cpp:3:         a[i] = 0;\n    movl\t%edx, %edx\t # n, n\n    leaq\t0(,%rdx,4), %r8\t #,\n    xorl\t%edx, %edx\t #\n # exam1.cpp:5: }\n # exam1.cpp:3:         a[i] = 0;\n    jmp\tmemset\t #\n    .p2align 4\n    .p2align 3\n.L3:\n # exam1.cpp:5: }\n    ret\t\n    .seh_endproc\n    .ident\t\"GCC: (Rev2, Built by MSYS2 project) 12.1.0\"\n    .def\tmemset;\t.scl\t2;\t.type\t32;\t.endefmemcpy 同理，不必为了高效，手动改写成对 memcpy/memset 的调用，影响可读性。编译器会自动分析你是在做拷贝或是清零，并优化成对标准库这俩的调用。\n从0到1024填充：SIMD加速paddd：四个 int 的加法movdqa：加载四个 int  如果次数是4的倍数（如下面的1024）\ncppvoid func(int *a)\n{\n    for (int i = 0; i &lt; 1024; i++)\n        a[i] = i;\n}txt_Z4funcPi:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:2: {\n    movdqu\t.LC0(%rip), %xmm0\t #, vect_vec_iv_.4\n    movdqu\t.LC1(%rip), %xmm2\t #, tmp89\n    leaq\t4096(%rcx), %rax\t #, _9\n    .p2align 4,,10\n    .p2align 3\n.L2:\n    movdqa\t%xmm0, %xmm1\t # vect_vec_iv_.4, vect_vec_iv_.4\n    addq\t$16, %rcx\t #, ivtmp.10\n    paddd\t%xmm2, %xmm0\t # tmp89, vect_vec_iv_.4\n # exam1.cpp:5:         a[i] = i;\n    movups\t%xmm1, -16(%rcx)\t # vect_vec_iv_.4, MEM &lt;vector(4) int&gt; [(int *)_2]\n    cmpq\t%rcx, %rax\t # ivtmp.10, _9\n    jne\t.L2\t #,\n # exam1.cpp:7: }\n    ret\t\n    .seh_endproc\n    .section .rdata,\"dr\"\n    .align 16\n.LC0:\n    .long\t0\n    .long\t1\n    .long\t2\n    .long\t3\n    .align 16\n.LC1:\n    .long\t4\n    .long\t4\n    .long\t4\n    .long\t4一次写入 4 个 int，一次计算 4 个 int 的加法，从而更加高效但这样有个缺点，那就是数组的大小必须为 4 的整数倍，否则就会写入越界的地址！\n如果不一定是 4 的倍数？边界特判法  \ncppvoid func(int *a, int n)\n{\n    for (int i = 0; i &lt; n; i++)\n        a[i] = i;\n}假设 n = 1023：  先对前 1020 个元素用 SIMD 指令填入，每次处理 4 个剩下 3 个元素用传统的标量方式填入，每次处理 1 个思想：对边界特殊处理，而对大部分数据能够矢量化编译器做优化时会自动处理边界特判。如果你是自己手写 SIMD 指令的话就要考虑一下这个。  \nn总是4的倍数？避免边界特判  这样写\ncppvoid func(int *a, int n)\n{\n    n = n / 4 * 4;\n    for (int i = 0; i &lt; n; i++)\n        a[i] = i;\n}编译器会发现 n % 4 = 0，从而不会生成边界特判的分支。\n假定指针是 16 字节对齐的：assume_aligned如果能保证指针 a 总是对齐到 16 字节，这样写(C++20),对性能有微弱的提升。\ncppvoid func(int *a, int n)\n{\n    n = n / 4 * 4;\n    a = std::assume_aligned&lt;16&gt;(a);\n    for (int i = 0; i &lt; n; i++)\n        a[i] = i;\n}数组求和：reduction 的优化cppfloat func(float *a)\n{\n    float ret = 0;\n    for (int i = 0; i &lt; 1024; i++)\n        ret += a[i];\n    return ret;\n}txt_Z4funcPf:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:3:     float ret = 0;\n    pxor\t%xmm0, %xmm0\t # &lt;retval&gt;\n    leaq\t4096(%rcx), %rax\t #, _4\n    .p2align 4,,10\n    .p2align 3\n.L2:\n    addss\t(%rcx), %xmm0\t # BIT_FIELD_REF &lt;MEM &lt;vector(4) float&gt; [(float *)_3], 32, 0&gt;, stmp_ret_10.7\n    addq\t$16, %rcx\t #, ivtmp.13\n    addss\t-12(%rcx), %xmm0\t # BIT_FIELD_REF &lt;MEM &lt;vector(4) float&gt; [(float *)_3], 32, 32&gt;, stmp_ret_10.7\n # exam1.cpp:5:         ret += a[i];\n    addss\t-8(%rcx), %xmm0\t # BIT_FIELD_REF &lt;MEM &lt;vector(4) float&gt; [(float *)_3], 32, 64&gt;, stmp_ret_10.7\n    addss\t-4(%rcx), %xmm0\t # BIT_FIELD_REF &lt;MEM &lt;vector(4) float&gt; [(float *)_3], 32, 96&gt;, &lt;retval&gt;\n    cmpq\t%rcx, %rax\t # ivtmp.13, _4\n    jne\t.L2\t #,\n # exam1.cpp:7: }\n    ret\t循环循环中的矢量化cppvoid func(float *a, float *b) \n{\n    for (int i = 0; i &lt; 1024; i++)\n        a[i] = b[i] + 1;\n}考虑 func(a, a + 1) 的情况，那样会产生数据依赖链，没法 SIMD 化。为了优化而不失正确性，他索性生成两份代码：一份是 SIMD 的，一份是传统标量的他在运行时检测 a, b 指针的差是否超过 1024 来判断是否有重叠现象。如果没有重叠，则跳转到 SIMD 版本高效运行。如果重叠，则跳转到标量版本低效运行，但至少不会错。  \n可以通过使用__restrict,仅仅生成SIMD版本进行矢量化。\n循环中的if语句循环中的if语句会导致SIMD矢量化困难。\ncppvoid func(float *__restrict a, float *__restrict b, bool is_mul)\n{\n    for (int i = 0; i &lt; 1024; i++)\n        if (is_mul)\n            a[i] = a[i] * b[i];\n        else\n            a[i] = a[i] + b[i];\n}在这里，编译器的看到is_mul是常量，就会将条件判断提到前面，然后使用SIMD矢量化，下面这个代码和上面这个代码编译优化后是一样的。\ncppvoid func(float *__restrict a, float *__restrict b, bool is_mul) {\n    if (is_mul) \n        for (int i = 0; i &lt; 1024; i++) \n            a[i] = a[i] * b[i];\n    else \n        for (int i = 0; i &lt; 1024; i++) \n            a[i] = a[i] + b[i];\n}同样的，如果循环中有在循环期间不变的表达式，在优化的时候也会把它提到循环体外。\n循环体内调用函数下面这个代码无法优化。\ncppvoid other();\nfloat func(float *a)\n{\n    float ret = 0;\n    for (int i = 0; i &lt; 1024; i++)\n    {\n        ret += a[i];\n        other();\n    }\n    return ret;\n}因为编译器看不到那个文件的 other 函数里是什么，哪怕 other 在定义他的文件里是个空函数，他也不敢优化掉。   \n解决方案：把函数实现放在同一个文件里编译器看得到 other 的函数体，就可以内联化该函数\n\n\n\n\n\n\n\n\n\n结论：避免在 for 循环体里调用外部函数，或者把他们移到同一个文件里，或者放在头文件声明为 static 函数。\n下标随机访问矢量化失败\ncppvoid func(float *a, int *b)\n{\n    for (int i = 0; i &lt; 1024; i++)\n        a[b[i]] += 1;\n}下标跳跃访问矢量化部分成功，但是很艰难\ncppvoid func(float *a)\n{\n    for (int i = 0; i &lt; 1024; i++)\n        a[i * 2] += 1;\n}下标连续访问矢量化成功\ncppvoid func(float *a)\n{\n    for (int i = 0; i &lt; 1024; i++)\n        a[i] += 1;\n}\n\n\n\n\n\n\n\n\n结论：不管是编译器还是 CPU，都喜欢顺序的连续访问。\n循环展开cppvoid func(float *a)\n{\n#pragma GCC unroll 4\n    for (int i = 0; i &lt; 1024; i++)\n        a[i] = 1;\n}每次执行循环体 a[i] = 1后，都要进行一次判断 i &lt; 1024。导致一部分时间花在判断是否结束循环，而不是循环体里。如果循环体内容非常简单，那么相对的来说，判断的代价就会很高。所以要循环展开避免判断。\n对小的循环体进行 unroll 可能是划算的，但最好不要 unroll 大的循环体，否则会造成指令缓存的压力反而变慢！\n对于 GCC 编译器，可以用#pragma GCC unroll 4表示把循环体展开为4个  就像这样（但是不建议手动这样写，可能会妨碍编译器矢量化）\ncppvoid func(float *a)\n{\n    for (int i = 0; i &lt; 1024; i += 4)\n    {\n        a[i + 0] = 1;\n        a[i + 1] = 1;\n        a[i + 2] = 1;\n        a[i + 3] = 1;\n    }\n}结构体两个 float：对齐到 8 字节，成功矢量化。\ncppstruct MyVec\n{\n    float x;\n    float y;\n};\nMyVec a[1024];\nvoid func()\n{\n    for (int i = 0; i &lt; 1024; i++)\n        a[i].x *= a[i].y;\n}三个 float：对齐到 12 字节，矢量化失败。生成了标量的低效汇编代码\ncppstruct MyVec\n{\n    float x;\n    float y;\n    float z;\n};\nMyVec a[1024];\nvoid func()\n{\n    for (int i = 0; i &lt; 1024; i++)\n        a[i].x *= a[i].y;\n}添加一个辅助对齐的变量：对齐到 16 字节,追加了一个没有用的 4 字节变量，整个结构体变成 16 字节大小，矢量化成功\ncppstruct MyVec\n{\n    float x;\n    float y;\n    float z;\n    char padding[4];\n};\nMyVec a[1024];\nvoid func()\n{\n    for (int i = 0; i &lt; 1024; i++)\n        a[i].x *= a[i].y;\n}\n\n\n\n\n\n\n\n\n结论：计算机喜欢 2 的整数幂，2, 4, 8, 16, 32, 64, 128…结构体大小若不是 2 的整数幂，往往会导致 SIMD 优化失败。\n让编译器自动对齐 alignas（c++11）在 struct 后加上 alignas(要对齐到的字节数) 即可实现同样效果，就不需要手动写 padding 变量了。\ncppstruct alignas(16) MyVec\n{\n    float x;\n    float y;\n    float z;\n};\nMyVec a[1024];\nvoid func()\n{\n    for (int i = 0; i &lt; 1024; i++)\n        a[i].x *= a[i].y;\n}\n\n\n\n\n\n\n \nSIMD 和缓存行对齐只是性能优化的一个点，又不是全部。还要考虑结构体变大会导致内存带宽的占用，对缓存的占用等一系列连锁反应，总之，要根据实际情况选择优化方案。\n\n\n结构体的内存布局：AOS、SOA和AOSOA\nSTL容器std::vector也有指针别名问题。此时__restrict对于STL容器的指针或引用是无效的。解决方案：#pragma omp simd 或 #pragma GCC ivdep\nstd::vector也能实现 SOA！\n数学运算除法变为乘法计算机做乘法的速度比除法快两倍甚至三倍。\ncppfloat func(float a)\n{\n    return a / 2;\n}相当于变成了 a * 0.5f\ntxt_Z4funcf:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:3:     return a / 2;\n    mulss\t.LC0(%rip), %xmm0\t #, tmp84\n # exam1.cpp:4: }\n    ret\t\n    .seh_endproc\n    .section .rdata,\"dr\"\n    .align 4\n.LC0:\n    .long\t1056964608编译器放弃的优化：分离公共除数因为担心b=0,编译器放弃优化。\ncppvoid func(float *a, float b) \n{\n    for (int i = 0; i &lt; 1024; i++) \n        a[i] /= b;\n}解决方法1\ncppvoid func(float *a, float b) \n{\n    float inv_b = 1 / b;\n    for (int i = 0; i &lt; 1024; i++) \n        a[i] *= inv_b;\n}解决方法2编译参数-ffast-math选项让 GCC 更大胆地尝试浮点运算的优化，有时能带来 2 倍左右的提升。作为代价，他对 NaN 和无穷大的处理，可能会和 IEEE 标准（腐朽的）规定的不一致。如果你能保证，程序中永远不会出现 NaN 和无穷大，那么可以放心打开 -ffast-math。\n嵌套循环：直接累加，有指针别名问题编译器担心 c 和 a 可能会指向同一个地址，而判断多个指针是否有重合又过于复杂。编译器选择直接放弃矢量化。\ncppvoid func(float *a, float *b, float *c)\n{\n    for (int i = 0; i &lt; 1024; i++)\n        for (int j = 0; j &lt; 1024; j++)\n            c[i] += a[i] * b[j];\n}解决方法1先累加到初始为 0 的局部变量，再累加到 c\ncppvoid func(float *a, float *b, float *c)\n{\n    for (int i = 0; i &lt; 1024; i++)\n    {\n        float tmp = 0;\n        for (int j = 0; j &lt; 1024; j++)\n            tmp += a[i] * b[j];\n        c[i] += tmp;\n    }\n}总结\n函数尽量写在同一个文件内\n避免在 for 循环内调用外部函数\n非 const 指针加上 __restrict 修饰\n试着用 SOA 取代 AOS\n对齐到 16 或 64 字节\n简单的代码，不要复杂化\n试试看 #pragma omp simd\n循环中不变的常量挪到外面来\n对小循环体用 #pragma unroll\n-ffast-math 和 -march=native\n\n","slug":"编译器优化","date":"2022-11-08T09:13:00.000Z","categories_index":"C++","tags_index":"C++进阶,编译器优化","author_index":"Ac-Accelerator"},{"id":"182933b43edb5a2e2aab1a699c004ce0","title":"C++ RAII与智能指针","content":"这是观看一位大佬双笙子佯谬的视频后写的笔记。\nRAII（Resource Acquisition Is Initialization）资源获取视为初始化，反之，资源释放视为销毁C++ 除了用于初始化的构造函数（constructor）还包括了用于销毁的析构函数（destructor）\n传统内存管理\nc#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\nint main()\n{\n    size_t nv = 4;\n    int *v = (int *)malloc(nv * sizeof(int));//分配内存得到一个指针\n    v[0] = 4;\n    v[1] = 3;\n    v[2] = 2;\n    v[3] = 1;\n    int sum = 0;\n    for (size_t i = 0; i &lt; nv; i++)\n        sum += v[i];\n    printf(\"%d \\n\", sum);\n    free(v);//需要手动释放指针所对应的内存\n    return 0;\n}RAII的内存管理\ncpp#include &lt;iostream&gt;\n#include &lt;vector&gt;\nint main()\n{\n    std::vector&lt;int&gt; v(4);//调用构造函数获得对象的同时即可自动分配内存\n    v[0] = 4;\n    v[1] = 3;\n    v[2] = 2;\n    v[3] = 1;\n    int sum = 0;\n    for (size_t i = 0; i &lt; v.size(); i++)\n        sum += v[i];\n    std::cout &lt;&lt; sum;\n    return 0;\n}//离开大括号作用域时自动调用析构函数释放内存\n乍一看C语言的内存管理也只是有一点点不方便而已啊，只要留点心就好了啊。但是看下面这个例子，每个带有返回的分支都要手动释放所有之前的资源，如果分支很多很复杂，就很容易造成疏忽。\nc#include &lt;fstream&gt;\n#include &lt;vector&gt;\n#include &lt;cstdio&gt;\nint main()\n{\n    std::ifstream f1(\"1.txt\");\n    if (checkFileContent(f1))\n    {\n        printf(\"bad file 1!\\n\");\n        f1.close();\n        return 1;\n    }\n    std::ifstream f2(\"2.txt\");\n    if (checkFileContent(f2))\n    {\n        printf(\"bad file 2!\\n\");\n        f1.close();\n        f2.close();\n        return 1;\n    }\n    std::vector&lt;std::ifstream&gt; files;\n    files.push_back(std::ifstream(\"3.txt\"));\n    files.push_back(std::ifstream(\"4.txt\"));\n    files.push_back(std::ifstream(\"5.txt\"));\n    for (auto &amp;file : files)\n        file.close();\n    f1.close();\n    f2.close();\n    return 0;\n}可见RAII的思想可以帮助我们及时释放不再使用的内存，避免了手动内存管理可能导致的内存泄漏问题。\n与 Java，Python 等垃圾回收语言不同，C++ 的析构函数是显式的，离开作用域自动销毁，毫不含糊（有好处也有坏处，对高性能计算而言利大于弊）\n其次，C++ 标准保证当异常发生时，会调用已创建对象的析构函数。\n类设计规则：三五法则\n如果一个类定义了析构函数，那么您必须同时定义或删除拷贝构造函数和拷贝赋值运算符，否则出错。\n如果一个类定义了拷贝构造函数，那么您必须同时定义或删除拷贝赋值运算符，否则出错，删除可导致低效。\n如果一个类定义了移动构造函数，那么您必须同时定义或删除移动赋值运算符，否则出错，删除可导致低效。\n如果一个类定义了拷贝构造函数或拷贝赋值运算符，那么您必须最好同时定义移动构造函数或移动赋值运算符，否则低效。\n\n智能指针智能指针类重载了operator -&gt; ,使它的对象的行为看上去像是一个指针。\nunique_ptr:智能指针类unique_ptr，他的解构函数中会调用 delete，因此当对象生命周期结束的时候能够自动释放对象的内存，避免了这里 make_unique&lt;C&gt;(…) 可以理解为和之前的 new C(…) 等价，括号里也可以有其他构造函数的参数。\ncpp#include &lt;cstdio&gt;\n#include &lt;memory&gt;\nstruct C\n{\n    C() { std::printf(\"分配内存! \\n\"); };\n    ~C() { std::printf(\"释放内存! \\n\"); };\n};\nint main()\n{\n    std::unique_ptr&lt;C&gt; p = std::make_unique&lt;C&gt;();\n    if (1 + 1 == 2)\n    {\n        std::printf(\"出了点小状况.......n \");\n        return 1;\n        //  自动释放p\n    }\n    return 0;\n    // 自动释放p\n}在旧时代 C++ 里，常常听到这样的说法：“释放一个指针后，必须把这个指针设为 nullptr，防止空悬指针！”delete p;p = nullptr;unique_ptr 则把他们封装成一个操作：只需要p = nullptr;      // 等价于：p.reset()即可。将其设为空指针的同时释放资源，体现了面向对象“封装：不变性”的思想。\nunique_ptr禁止拷贝:这是因为 unique_ptr 删除了拷贝构造函数导致的。为什么他要删除拷贝构造函数？（unique指针不unique是吧）,原因还是三五法则，如果拷贝了指针，那么就会出现重复释放的问题。\n那么这个unique_ptr我们该怎么使用呢？看看下面这两个函数。\ncppvoid func1(C* p)\n{\n    p-&gt;do_something();\n}\nvoid func2(std::unique_ptr&lt;C&gt;p)\n{\n    p-&gt;do_something();\n}func1传入一个传统的指针，我们在调用的时候使用p.get()获得一个传统的指针，没有接过掌管对象生命周期的大权。\nfunc2传入一个智能指针对象，我们在调用的时候需要使用std::move(p)将智能指针转换为右值（因为没有拷贝构造函数，必须调用移动构造函数），于是原智能指针指向对象的生命周期将交给func中的智能指针对象管理。\n移交控制权后仍希望访问到 p 指向的对象怎么办？如果还是用 p 去访问的话，因为被移动构造函数转移了，p 已经变成空指针，从而出错。最简单的办法是，在移交控制权给 func2 前，提前通过 p.get() 获取原始指针raw_p;不过你得保证 raw_p 的存在时间不超过 p 的生命周期，否则会出现危险的空悬指针。\ncppint main()\n{\n    std::unique_ptr&lt;C&gt; p = std::make_unique&lt;C&gt;();\n    C *raw_p = p.get();\n    raw_p-&gt;do_something(); // 正常执行\n    func2(std::move(p));   // 随着func2的结束，对象生命周期结束。\n    raw_p-&gt;do_something(); //错误！raw_p已经是悬垂指针了。\n    return 0;\n}shared_ptrunique_ptr使用起来很困难的原因，在于 unique_ptr 解决重复释放的方式是禁止拷贝，这样虽然有效率高的优势，但导致使用困难，容易犯错等。相比之下， 牺牲效率换来自由度的 shared_ptr 则允许拷贝，他解决重复释放的方式是通过引用计数：当一个 shared_ptr 初始化时，将计数器设为1。当一个 shared_ptr 被拷贝时，计数器加1。当一个 shared_ptr 被解构时，计数器减1。减到0时，则自动销毁他指向的对象。从而可以保证，只要还有存在哪怕一个指针指向该对象，就不会被解构。  \n所以shared_ptr是可以被拷贝的。\nshared_ptr循环引用导致内存泄漏\ncpp#include &lt;memory&gt;\nstruct C\n{\n    std::shared_ptr&lt;C&gt; m_child;\n    std::shared_ptr&lt;C&gt; m_parent;\n};\nint main()\n{\n    auto parent = std::make_shared&lt;C&gt;();\n    auto child = std::make_shared&lt;C&gt;();\n    // 建立相互引用∶\n    parent-&gt;m_child = child;\n    child-&gt;m_parent = parent;\n    parent = nullptr; // parent不会被释放 !因为child还指向他 !\n    child = nullptr;  // child也不会被释放 !因为parent还指向他 !\n    return 0;\n}week_ptr的概念为了解决循环引用的问题，引入了week_ptr。\n有时候我们希望维护一个 shared_ptr 的弱引用 weak_ptr，即：弱引用的拷贝与解构不影响其引用计数器。之后有需要时，可以通过 lock() 随时产生一个新的 shared_ptr 作为强引用。但不 lock 的时候不影响计数。如果失效（计数器归零）则 expired() 会返回 false，且 lock() 也会返回 nullptr。\n可以把 C * 理解为 unique_ptr 的弱引用。weak_ptr 理解为 shared_ptr 的弱引用。但 weak_ptr 能提供失效检测，更安全。  \nweek_ptr示例：\ncpp#include &lt;memory&gt;\n#include &lt;vector&gt;\nstruct C\n{\n    std::shared_ptr&lt;C&gt; m_child;\n    std::shared_ptr&lt;C&gt; m_parent;\n};\nstd::vector&lt;std::shared_ptr&lt;C&gt;&gt; objlist;\nvoid func3(std::shared_ptr&lt;C&gt; p)\n{\n    p-&gt;do_something();\n    objlist.push_back(std::move(p));\n}\nint main()\n{\n    std::shared_ptr&lt;C&gt; p = std::make_shared&lt;C&gt;(); //引用计数初始化为1\n    printf(\"use count = %ld\\n\", p.use_count());   // 1\n    std::weak_ptr&lt;C&gt; weak_p = p;                  // 创建一个不影响计数器的弱引用\n    printf(\"use count = %ld\\n\", p.use_count());   // 1\n    func3(std::move(p));                          //控制权转移，p变为null，引用计数加不变\n    if (weak_p.expired())\n        printf(\"错误︰弱引用已失效! \");\n    else\n        weak_p.lock()-&gt;do_something(); //正常执行，p的生命周期仍被objlist延续着\n    objlist.clear();                   //刚刚p移交给func的生命周期结束了!引用计数减1，变成0了\n    if (weak_p.expired())              //因为shared_ptr指向的对象已释放，弱引用会失效\n        printf(\"错误︰弱引用已失效! \");\n    else\n        weak_p.lock()-&gt;do_something(); // 不会执行\n    return 0;                          //到这里最后一个弱引用weak_p也被释放，他指向的“管理块”被释放\n}循环引用：解决方案1 用week_ptr和shared_ptr只需要把其中逻辑上“不具有所属权”的那一个改成 weak_ptr 即可：因为父窗口“拥有”子窗口是天经地义的，而子窗口并不“拥有”父窗口。其实主要是一个父窗口可以有多个子窗口，只有规定子窗口从属于父窗口才能解决引用计数的问题……\ncpp#include &lt;memory&gt;\nstruct C\n{\n    std::shared_ptr&lt;C&gt; m_child;\n    std::week_ptr&lt;C&gt; m_parent;\n};\nint main()\n{\n    auto parent = std::make_shared&lt;C&gt;();\n    auto child = std::make_shared&lt;C&gt;();\n    // 建立相互引用∶\n    parent-&gt;m_child = child;\n    child-&gt;m_parent = parent;\n    parent = nullptr; // parent会被释放 !因为child指向他的是一个弱引用 !\n    child = nullptr;  // child会被释放 !因为parent已经被释放 !\n    return 0;\n}循环引用：解决方案2还有一种更适应“父子窗口”这一场景的解决方案。刚才提到原始指针的应用场景是“当该对象不属于我，但他释放前我必然被释放时”。这里我们可以发现父窗口的释放必然导致子窗口的释放。因此我们完全可以把 m_parent 变成原始指针。这样也不需要 weak_ptr 判断是否 expired() 了。\ncpp#include &lt;memory&gt;\nstruct C\n{\n    std::shared_ptr&lt;C&gt; m_child;\n    C* m_parent;\n};\nint main()\n{\n    auto parent = std::make_shared&lt;C&gt;();\n    auto child = std::make_shared&lt;C&gt;();\n    // 建立相互引用∶\n    parent-&gt;m_child = child;\n    child-&gt;m_parent = parent.get();\n    parent = nullptr; // parent会被释放 !因为child指向他的是一个原始指针\n    child = nullptr;  // child会被释放 !因为parent已经被释放 !\n    return 0;\n}解决方案2还可以更好！就是用原始指针和unique_ptr刚才提到 unique_ptr 的应用场景是“当该对象仅仅属于我时”。既然都用了原始指针（假定他释放前我必然被释放）。因为因此我们完全可以把 m_child 变成一个标志这“完全所有权”的 unique_ptr。这样也不需要 shared_ptr 维护一个原子计数器的开销了。\ncpp#include &lt;memory&gt;\nstruct C\n{\n    std::unique_ptr&lt;C&gt; m_child;\n    C* m_parent;\n};\nint main()\n{\n    auto parent = std::make_unique&lt;C&gt;();\n    auto child = std::make_unique&lt;C&gt;();\n    // 建立相互引用∶\n    parent-&gt;m_child = std::move(child);//移交所属权\n    child-&gt;m_parent = parent.get();\n    parent = nullptr; // parent会被释放 !因为child指向他的是一个原始指针\n    child = nullptr;  // child会被释放 !因为parent已经被释放 !\n    return 0;\n}综上所述：原始指针和unique_ptr是一对的，week_ptr和shared_ptr是一对的。我们在对性能要求比较高的时候使用原始指针和unique_ptr，这样是可以减小维护开销的。但是明显week_ptr和shared_ptr这一对安全性更高。\n哪些类型是安全的三五法则：什么时候需要担心一般来说，可以认为符合三五法则的类型是安全的。以下类型是安全的：int id;                                        // 基础类型std::vector&lt;int&gt; arr;                  // STL 容器std::shared_ptr&lt;Object&gt; child; // 智能指针Object *parent;                         // 原始指针，如果是从智能指针里 .get() 出来的  \n以下对象是不安全的：char *ptr;                                   // 原始指针，如果是通过 malloc/free 或 new/    delete 分配的GLint tex;                                  // 是基础类型 int，但是对应着某种资源std::vector&lt;Object *&gt; objs;       // STL 容器，但存了不安全的对象  \n成员都是安全的类型成员都是安全的类型：五大函数，一个也不用声明如果你的类所有成员，都是安全的类型，那么五大函数都无需声明（或声明为 = default），你的类自动就是安全的。最好的判断方式是：如果你不需要自定义的解构函数，那么这个类就不需要担心。因为如果用到了自定义解构函数，往往意味着你的类成员中，包含有不安全的类型。一般无外乎两种情况：你的类管理着资源。你的类是数据结构。 \n管理着资源管理着资源：删除拷贝函数，然后统一用智能指针管理这个类管理着某种资源，资源往往不能被“复制”。比如一个 OpenGL 的着色器，或是一个 Qt 的窗口。如果你允许 GLShader 拷贝，就相当于把 glCreateShader 返回的 int 拷贝两遍，解构时就会出现重复释放 (double free) 错误。你会想“那我是不是可以在 GLShader 里加一个引用计数器呢，这样就可以算拷贝次数避免重复释放了！”可以，但是既然标准库已经提供了 shared_ptr，还不如用 shared_ptr&lt;GLShader&gt; 来管理，省的每个类实现一遍原子引用计数器。  \n数据结构是数据结构：如果可以，定义拷贝和移动这个类是你精心设计的数据结构，如果这些数据结构是可以支持拷贝的，你可能需要自己一个个定义。如果不支持，那就删除（= delete）。\n函数参数类型优化规则函数参数类型优化规则：按引用还是按值？如果是基础类型（比如 int，float）则按值传递：float squareRoot(float val);如果是原始指针（比如 int *，Object *）则按值传递：void doSomethingWith(Object *ptr);如果是数据容器类型（比如 vector，string）则按常引用传递：int sumArray(std::vector &lt;int&gt; const &amp;arr);如果数据容器不大（比如 tuple&lt;int, int&gt;），则其实可以按值传递：glm::vec3 calculateGravityAt(glm::vec3 pos);如果是智能指针（比如 shared_ptr），且需要生命周期控制权，则按值传递：void addObject(std::shared_ptr&lt; Object &gt;obj);如果是智能指针，但不需要生命周期，则通过 .get() 获取原始指针后，按值传递：void modifyObject(Object *obj);\n","slug":"C-RAII与智能指针","date":"2022-11-06T04:22:00.000Z","categories_index":"C++","tags_index":"内存安全,C++进阶","author_index":"Ac-Accelerator"},{"id":"deafe07fcf5e4e17bdc29bc3bc203d8e","title":"深度学习多模态：CLIP","content":"本篇章搬运自同校同学snowy的笔记。\n什么是CLIPContrastive Language-Image Pre-Training—CLIP利用文本的监督信号训练一个迁移能力强的视觉模型\n\n这个模型有什么用呢？想象我们有一个图像分类的任务\n训练1000个类别，预测一张图片是这1000个类别中的哪一类\n现在如果加入50个新的类别的图像，试想会发生什么呢？\n传统的图像分类模型无法对类别进行拓展，想要保证准确率只能从头开始训练，费时费力。\nCLIP模型就可以用来解决这种问题，预训练后的模型就可以直接进行zero-shot\n\n与前人工作对比：\n\nCLIP论文指出，17年就已经开始有这些方法了，但是没获得太多关注。\n17年类似方法在ImageNet上的效果有17%。\n然后openAI说：不是方法不行，而是资源不到位（暴力出奇迹）\n一个648解决不了，那就再来十次648.。。。\n\nCLIP的成果：\n\nCLIP在完全不使用ImageNet中所有训练数据的前提下\n直接Zero-shot得到的结果与ResNet在128W ImageNet数据训练效果一致\nCLIP使用4亿个配对的数据和文本来进行训练，不标注直接爬取（没有解决transformer训练所需数据量大的缺点）\n\n监督训练和zero-shot在监督学习中，计算机通过示例学习。它从过去的数据中学习，并将学习的结果应用到当前的数据中，以预测未来的事件。在这种情况下，输入和期望的输出数据都有助于预测未来事件。无监督学习是训练机器使用既未分类也未标记的数据的方法。这意味着无法提供训练数据，机器只能自行学习。机器必须能够对数据进行分类，而无需事先提供任何有关数据的信息。简而言之：\n\n有监督训练：利用已经打好标签的数据训练模型。\n无监督训练：训练所用的数据没有任何标签。\n\n什么是zero-shot（零样本学习）：\n\n定义 zero-shot顾名思义即是对某些类别完全不提供训练样本，也就是说没有标注样本的迁移任务被称为zero-shot。\n不需要任何训练样本就可以直接进行预测\n模仿人脑的学习能力和知识的迁移能力，根据以往的经验对未知的事物做出预测。\n\n简单的zero-shot的实例：首先，我们可以将其视为一个类似于自然语言处理的任务，它使用词嵌入（将词汇表中的词或短语映射到实数向量，要求具有相似含义的词将具有相似的词嵌入）。那么对于上面的例子，零样本学习是下面这样来处理的，\n\n训练数据中并没有斑马的图像，但是有带条纹的动物（如老虎），有跟马长得相似的一类动物（如马、驴），还有黑白色的动物（如熊猫）的各种图像。可以提取这些图像的特征（条纹、形状似马、黑/白色）并生成词嵌入，组成字典。\n然后，我们描述斑马的外观，并使用前面训练集里提出的特征来将斑马的外观转化成相应的词嵌入。\n最后，当你给模型输入一张斑马的图像，它会先提取图像的特征，转化成词嵌入，然后与字典中最接近的词嵌入进行比较，得出那图像可能是只斑马。\n\n\n\n\n\n\n\n\n\n\n\nCLIP模型的基本架构模型训练：\n\n输入图片-&gt;图像编码器（vision transformer）-&gt;图片特征向量\n输入文字-&gt;文本编码器（text ）-&gt;文本特征向量\n对两个特征进行线性投射，得到相同维度的特征，并进行L2归一化\n计算两个特征向量的相似度（夹角余弦）\n对n个类别进行softmax，确定个正样本和个负样本，并最大化正样本的权重。\n\npython# 分别提取图像特征和文本特征\nI_f = image_encoder(I) #[n, d_i]\nT_f = text_encoder(T) #[n, d_t]\n\n# 对两个特征进行线性投射，得到相同维度的特征，并进行l2归一化\nI_e = l2_normalize(np.dot(I_f, W_i), axis=1)\nT_e = l2_normalize(np.dot(T_f, W_t), axis=1)\n\n# 计算缩放的余弦相似度：[n, n]\nlogits = np.dot(I_e, T_e.T) * np.exp(t)\n\n# 对称的对比学习损失：等价于N个类别的cross_entropy_loss\nlabels = np.arange(n) # 对角线元素的labels\nloss_i = cross_entropy_loss(logits, labels, axis=0)\nloss_t = cross_entropy_loss(logits, labels, axis=1)\nloss = (loss_i + loss_t)/2模型预测：\n\n给出一些文本提升（给出选项）\n选项中要包含正确答案\n然后计算每一个文本提升和图片特征的相似度。\n找到相似度最高的即为正确答案\n\n合理的提示：\n\n预测时的提示非常重要\n首先是需要一句话或者几个词来提示\n最好要加上预测的场景，要具有情景的相关性\n提示要全面，这样预测准确率也会提高。\n\n\nCLIP模型的展示","slug":"深度学习多模态：CLIP","date":"2022-11-06T03:54:00.000Z","categories_index":"人工智能","tags_index":"Transformer,多模态学习","author_index":"Ac-Accelerator"},{"id":"4d1e3a4a4afff0b0d31e07df9ad79915","title":"强化学习","content":"回顾监督学习： 学习一个模型，使得其能正确的将数据X映射到标签Y无监督学习 学习数据中潜在的结构以及信息\n强化学习的概念强化学习主要由两个对象组成：Environment(环境)和Agent(代理)。代理可以在环境中采取行动，改变环境的状态；环境返回给代理采取行动后整个环境的状态以及该行动的奖励；随后，代理根据新的状态和环境反馈的奖励，按照一定策略执行新的动作。\n强化学习的目的是学习如何根据环境的状态来采取行动以获得最大的奖励。\n在强化学习的过程中，代理将不被告知接下来该执行什么动作，而是通过多次的随机决策进行尝试，来发现获得最大奖励的行为。另外，随机决策的行为是对是错并不能马上得知，通常在完整的动作序列执行完毕才能得知，可以说是一个连续决策的问题。正因如此，当代理获得奖励的时候，将很难判断是过去的哪个行为导致获得了奖励，所以奖励分配在强化学习中显得非常重要。\n其次，在强化学习的过程中存在一些干扰，我们得到的状态可能是不完整的或者嘈杂的场景信息。同样，获得的奖励也可能带有干扰。例如：对同一个状态作出同一个动作，会在不同的时间步中获得不同的奖励。这里便是强化学习中随机性的来源。\n最后，强化学习存在不可微分的问题，因为我们并不知道环境是如何工作的，没有一个模型说明环境的行为方式。所以在进行反向传播的时候必须依靠其他的方法。\n强化学习的数学表达(马尔科夫决策过程)\n马尔科夫决策过程主要由如下的参数进行参与。  \n\n：可能状态的集合：可能采取动作的集合：通过状态和行为给予奖励的函数：下一个状态的转移概率分布：为近期奖励和远期奖励分配权重\n在时间步骤t=0的时候，环境从初始状态分布中采样得到，并将一些初始状态设置为0。对于每一个时间步：代理将选择一个行动。对于这个行动，环境从奖励函数采样返回一个奖励。然后环境再从中采样得到新的状态。最后代理接受环境的奖励和下一个状态，并继续根据最新的奖励和状态作出决策，直到接收到环境的终止信号。  \n基于以上的过程，我我们可以定义一个将状态映射到行为的函数，它指定了每个状态下要采取的行动，这个行动可以是确定性的也可以是随机的。\n可是，对于状态转移概率分布函数的抽样存在随机性；在不同的时间步中获得的奖励也有随机性。如何处理MDP中的随机性呢？解决方法是最大化预期奖励的总和，因为我们将获得实际奖励和实际结果在某种程度上是随机的，所以我们能做的是找到一个策略，将获得的期望值最大化\n\n其中：，，~\n定义：Value函数和Q-value函数：当我们遵循某个策略函数决策的时候，每次迭代都会产生一组行为轨迹(我们将把我们的初始状态设为零，然后进行马尔科夫决策过程，我们就会有一个状态、行动和奖励的轨迹)\n如何来评价：如果采取策略来行动，目前所处的状态有多好呢？价值函数的值，是遵循决策函数的条件下，从各个状态的决策中获得的预期累积奖励。\n\n如果状态值很高，这意味着从该状态开始以策略操作时，我们将在将来获得更多的奖励。\n如何来评估在状态s时采取的行动有多好呢？Q价值函数的值，是遵循决策函数，在状态下采取行动的预期累计奖励。\n\n不同场景下我们会选择动作值函数或者状态值函数来寻找最优策略\n最优值函数是从给定的(状态、行为)对中获得的最大期望累积报酬：\n\n告诉我：假设我们从状态s开始，然后在状态s中执行动作a，然后我们根据做在这种环境下我们能做的最好的事情，在接下来的时间里能获得多少奖励。和的关系：\n\n函数还满足Bellman等式  \n马尔科夫决策过程和贝尔曼方程\n\n如果下一个时间步骤的最优状态-动作已知，那么最优策略是采取是预期值最大化的动作。\n意思是：如果我们找到一个，那么它一定是。\n如何获得满足Bellman方程的函数呢？值迭代算法使用Bellman等式来迭代更新，可以使得无限接近于。\n\n但是这种方法需要显式的计算每个状态每个动作对应的值。对于小且有限的状态空间可以很好的运行。如果是对于很大的状态空间，基本上是不可计算的。如何解决？\n解决方法是通过一个神经网络去拟合，使用Bellman等式来提供一个损失函数。\nDeep Q-Learning训练一个带有权重的神经网络来近似。\n\n使用Bellman等式来告诉Q如何将状态和动作映射为输出。\n\n定义损失函数\n\n但是这种方法存在一些问题。问题一：预测的“目标”取决于当前网络本身的输出，随着网络的学习，网络预测的的结果会随着时间的推移进而改变。产生饿了非平稳性的问题。问题二：如何对训练中的批量数据进行采样。\nQ-Learning 和 策略梯度对于一些问题，可能很难学习到Q函数。对于某些问题，更容易学习从状态到操作的映射。  \n策略梯度：训练一个以状态为输入的网络，分配在该状态下采取的行动。\n目标函数：遵循决策时的预期累计奖励。输入神经网络的权重，给出如果我们执行该网络中的策略，我们在环境中获得的预期回报是多少。\n\n使用梯度上升来最大化奖励找到最优决策\n\n但是问题是无法计算，因为不可微。\n解决方法：定义为我们在遵循策略时的状态-行为轨迹。J为遵循策略下的预期奖励。\n\n\n\n\n这样我们就可以从策略中采样一些有限数量的轨迹来近似这个期望。\n\n转移概率分布依赖于无法直接观察到的环境，我们很难进行计算，但是我们可以学习到策略的行动可能性。\n\n求偏导，转移概率分布是无关项。\n\n这样，我们就可以让策略在环境中运行并收集轨迹x。预测行动分数相对于模型权重的梯度，反向传播至模型\n训练模型：1.初始化随机权值2.运行策略，收集轨迹x和使用政策  奖励f(X)3.计算4.梯度上升5.继续执行第二步\n如果f(x)较大，说明这个轨迹上的步骤都比较正确；如果如果f(x)较小，说明这个轨迹上的步骤都不太好。\n这个方法的缺点是我们需要很多轨迹来进行采样，才有可能获得较好的效果。\nActor-Critic训练一个预测行动的演员Actor(比如策略梯度)，一个评论家Critic预测我们从这些行动中得到的未来回报(比如Q-学习)。\nModel-Based学习世界状态转换函数的模型，然后通过模型进行规划决策.\nImitation Learning收集有关专家在环境中表现的数据，学习模仿他们所做的事情的函数(监督学习方法)\nInverse Reinforcement收集专家在环境中执行的数据，学习他们似乎正在优化的区域函数，然后在该奖励函数上使用强化学习。\nAdversarial Learning学会愚弄一个将行为分类为真实/假的鉴别者。\n","slug":"强化学习","date":"2022-07-14T13:23:00.000Z","categories_index":"人工智能","tags_index":"强化学习","author_index":"Ac-Accelerator"},{"id":"298601bdff7402f7c70804cf98e17980","title":"Python小应用——删除答案","content":"初衷有时候呢，考试前学校会发一些docx文档型的资料。这些资料类似于填了答案的填空题，方便我们快速复习、查找重点。然而一旦我们想要测试一下自己是不是真正记住了，就会想这如何不去看“答案”而把问题回答出来，就像做真正的填空题一样。你可以用手指蒙住，也可以手动将他们全部删除。  \n\n\n但是就我而言，手指蒙住根本抵挡不了看答案诱惑。我又是个懒鬼，不想一个一个删除（其实我还想通过看下划线的长短，或多或少的记起答案）。虽然这次一个一个删除省事一些，可是一想到以后可能还会遇到这种情况，我就忍不住偷懒了，加上我对编程感兴趣，索性用python来做一个小脚本。\n准备工作安装python-docx库。\ntxtpip install python-docxpython-docx的官方使用文档  \n可以参考B站的一个视频。稍微了解一下这个库的功能结构，我们便可以对docx文档进行任何想进行的操作。\n实践操作下面贴上代码和注释：\npythonfrom docx import Document\nimport docx\n\n#用已存在的文件'知识汇总.docx'创建一个Document对象，赋值给变量doc。这里可以是文件的绝对路径也可以是相对路径。\ndoc=Document('知识汇总.docx')\nprint(\"opened successfully,start processing\")\n\n#文章是由一个一个段落组成的，我们遍历所有段落\nfor p in doc.paragraphs:\n    #段落是由块组成的，我们遍历文章里的每一个块。\n    for block in p.runs:\n        #我这里是希望找到有下划线格式的块进行操作。你可以改变条件或者操作达到你想要的效果。\n        if(block.font.underline):\n            #替换\n            block.text='  '*len(block.text)\nprint('changed successfully')\n\n# doc.save('知识汇总.docx')#直接覆盖\ndoc.save('知识汇总(无答案版).docx')#保存到新的文件\nprint(\"saved successfully\")效果是这样啦\n","slug":"Python小应用——删除答案","date":"2022-06-01T09:22:00.000Z","categories_index":"Python","tags_index":"python-docx,docx,Python","author_index":"Ac-Accelerator"},{"id":"3adc7cb84d4ac3fb8fab9c8bd90e7a93","title":"计算机网络(四)","content":"传输层只有主机才有的层次  \n功能\n传输层提供进程和进程之间的逻辑通信  \n分用和复用。  \n对收到的报文进行差错检测。  \nTCP和UDP。\n\n复用:应用层所有的应用进程都可以通过传输层再传输到网络层。分用:传输层从网络层收到数据后交付指明的应用进程。  \n端口是传输层的SAP，标识主机中的应用进程。端口号只有本地意义，在因特网中不同计算机的相同端口是没有联系的。端口号长度为16bit，能表示65536个不同的端口号。  \n\n端口号\n服务端使用的端口号\n熟知端口号：给TCP/IP最重要的一些应用程序，让所有用户都知道。0~1023。\n登记端口号:为没有熟知端口号的应用程序使用的。1024~49151。\n\n\n客户端使用的端口号：客户端使用:仅在客户进程运行时才动态选择。49152~65535。\n\n\n\n\n\n\n应用程序\nFTP\nTELNET\nSMTP\nDNS\nTFTP\nHTTP\nSNMP\n\n\n\n熟知端口号\n21\n23\n25\n53\n69\n80\n161\n\n\n在网络中采用发送方和接收方的套接字组合来识别端点，套接字唯一标识了网络中的一个主机和它上面的一个进程。套接字Socket=(主机IP地址，端口号)\nUDP协议UDP只在IP数据报服务之上增加了很少功能，即复用分用和差错检测功能。\n特点\nUDP是无连接的，减少开销和发送数据之前的时延。\nUDP使用最大努力交付，即不保证可靠交付。\nUDP是面向报文的，适合一次性传输少量数据的网络应用。\nUDP无拥塞控制，适合很多实时应用。\nUDP首部开销小，8Bit，而TCP有20Bit。\n\n面向报文：应用层给UDP多长的报文，UDP就照样发送，即一次发一个完整报文。\n分用时，找不到对应的目的端口号，就丢弃报文，并给发送方发送ICMP“端口不可达”差错报告报文。\nTCP协议TCP协议的特点\nTCP是面向连接（虚连接）的传输层协议。\n每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的。\nTCP提供可靠交付的服务，无差错、不丢失、不重复、按序到达。\nTCP提供全双工通信。\nTCP面向字节流，把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。\n\n为了提供全双工通信，设立一个发送缓存和一个接收缓存。发送缓存是保存准备发送的数据和己发送但尚未收到确认的数据。接收缓存是保存按序到达但尚未被接受应用程序读取的数据和不按序到达的数据。  \nTCP的连接管理TCP连接传输三个阶段：连接建立→数据传送→连接释放 \nTCP连接的建立采用客户服务器方式，主动发起连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫服务器。  \n建立过程假设运行在一台主机（客户)上的一个进程想与另一台主机（服务器）上的一个进程建立一条连接，客户应用进程首先通知客户TCP，他想建立一个与服务器上某个进程之间的连接，客户中的TCP会用以下步骤与服务器中的TCP建立一条TCP连接。\n\n客户端发送连接请求报文段，无应用层数据。\n服务器端为该TCP连接分配缓存和变量，并向客户端返回确认报文段，允许连接，无应用层数据。\n客户端为该TCP连接分配缓存和变量，并向服务器端返回确认的确认，可以携带数据。\n\nSYN洪泛攻击SYN洪泛攻击发生在OSI第四层，这种方式利用TCP协议的特性，就是三次握手。攻击者发送TCP SYN，SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者。这样更加会浪费服务器的资源。攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。\n可以通过设置SYN cookie来解决。\n释放过程参与一条TCP连接的两个进程中的任何一个都能终止该连接，连接结束后，主机中的“资源”（缓存和变量）将被释放。\n\n客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接。\n服务器端回送一个确认报文段,客户到服务器这个方向的连接就释放了————半关闭状态。\n服务器端发完数据,就发出连接释放报文段,主动关闭TCP连接。\n客户端回送一个确认报文段，再等到时间等待计时器设置的2MSL(最长报文段寿命）后，连接彻底关闭。\n\nTCP可靠传输确认重传不分家，TCP的发送方在规定的时间内没有收到确认就要重传己发送的报文段。重传时间采用自适应算法，动态改变重传时间RTTs （加权平均往返时间）。\n其实实现方法与链路层大同小异。\nTCP流量控制TCP利用滑动窗口机制实现流量控制。  \n在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，即接收窗口rwnd（接收方设置确认报文段的窗口字段来将rwnd通知给发送方），发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值。\nTCP为每一个连接设有一个持续计时器，只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期,就发送一个零窗口探测报文段。接收方收到探测报文段时给出现在的窗口值。若窗口仍然是0，那么发送方就重新设置持续计时器。\nTCP拥塞控制出现拥塞的条件:对资源需求的总和&gt;可用资源\n网络中有许多资源同时呈现供应不足→网络性能变坏→网络吞吐量将随输入负荷增大而下降\n拥塞控制:防止过多的数据注入到网络中。\n慢开始和拥塞避免快重传和快回复\n应用层应用层对应用程序的通信提供服务。  \n应用层协议定义:应用进程交换的报文类型，请求还是响应?各种报文类型的语法，如报文中的各个字段及其详细描述。字段的语义，即包含在字段中的信息的含义。进程何时、如何发送报文，以及对报文进行响应的规则。  \n应用层的重要协议;FTP、SMTP、POP3、HTTP、DNS\n应用层的功能\n文件传输、访问和管理\n电子邮件\n虚拟终端\n查询服务和远程作业登录\n\n网络应用模型客户/服务器模型(Client/Server)服务器:提供计算服务的设备。\n\n永久提供服务\n永久性访问地址/域名\n\n客户机:请求计算服务的主机。\n\n与服务器通信，使用服务器提供的服务\n间歇性接入网络\n可能使用动态IP地址\n不与其他客户机直接通信\n\nP2P模型(Peer-to-peer)\n\n不存在永远在线的服务器  \n每个主机既可以提供服务，也可以请求服务\n任意端系统/节点之间可以直接通讯  \n节点间歇性接入网络  \n节点可能改变IP地址可扩展性好  \n网络健壮性好\n\n域名解析系统DNS随着网络的发展，对于上网的网民，记住各个网站IP地址是极为困难的。为了解决这个问题，计算机网络使用了域名，即通过有意义的字符串来代替网络中的主机。但是归根结底，设备间的通信还是要知道IP地址的，DNS就是提供了域名到IP地址的转换。\n比如www.baidu.com就是域名，最右边的叫做顶级域名，从右向左以此类推：顶级域名，二级域名，三级域名……\n域名服务器当一个主机发出DNS查询请求时，这个查询请求报文就发给本地域名服务器。如果本地域名服务器没有记录对应域名的IP地址，则查找根域名服务器，根域名服务器返回顶级域名服务器的IP地址，如果顶级域名服务器无法解析，则返回对应权限域名服务器。依次进行查询。\n域名查询方式  \n\n递归查询  \n迭代查询一般采取递归和迭代相结合的方式\n\n文件传输协议FTP提供不同种类主机系统（硬、软件体系等都可以不同）之间的文件传输能力。  \nFTP服务器和用户端FTP是基于客户/服务器（C/S）的协议。用户通过一个客户机程序连接至在远程计算机上运行的服务器程序。依照FTP协议提供服务，进行文件传送的计算机就是FTP服务器。连接FTP服务器，遵循FTP协议与服务器传送文件的电脑就是FTP客户端。  \nFTP工作原理要连接到FTP服务器并且从FTP服务器中操作数据，就需要：FTP服务器的地址，注册的用户名密码。\n匿名登录：互连网中有很大一部分FTP服务器被称为“匿名”(Anonymous）FTP服务器。这类服务器的目的是向公众提供文件拷贝服务，不要求用户事先在该服务器进行登记注册，也不用取得FTP服务器的授权。Anonymous（匿名文件传输）能够使用户与远程主机建立连接并以匿名身份从远程主机上拷贝文件，而不必是该远程主机的注册用户。用户使用特殊的用户名“anonymous”登陆FTP服务，就可访问远程主机上公开的文件。\nFTP实现TCP实现可靠传输。\n服务器的进程分为一个主进程和其他多个从属进程，主进程负责打开端口接受其他主机的请求。收到一个请求，就会启动一个从属进程为该请求的主机提供服务。\n控制连接始终保持数据连接保持一会  \n数据连接的端口号与传输方式有关：主动方式使用TCP 20端口被动方式由服务器和客户端自行协商决定（端口&gt;1024)  \nFTP传输模式：文本模式: A5CI模式，以文本序列传输数据;二进制模式: Binary模式,以二进制序列传输数据。\n电子邮件简单邮件传送协议SMTP：SMTP规定了在两个相互通信的SMTP进程之间应如何交换信息。负责发送邮件的SMTP进程就是SMTP客户，负责接收邮件的进程就是SMTP服务器。SMTP规定了14条命令(几个字母）和21种应答信息（三位数字代码t简单文字说明）。SMTP使用TCP协议连接，端口号25\nSMTP通信三个阶段:连接建立→邮件传送→连接释放\n通用因特网邮件扩充协议MIME：SMTP的缺点:1.SMTP不能传送可执行文件或者其他二进制对象。2.SMTP仅限于传送7位ASCIl码，不能传送其他非英语国家的文字。3.SMTP服务器会拒绝超过一定长度的邮件。\nMIME协议通过将非ASCII码转化成ASCII码，然后再交付给STMP进行传输，从而达到相关的目的。MIME使电子邮件系统可以支持声音、图像、视频、多种国家语言等等。使得传输内容丰富多彩。 \n邮局协议POP3POP3使用TCP协议连接，端口号110\n网际报文存取协议IMAP：由于POP3协议存在某些缺点，功能有限，于是产生了IMAP协议。IMAP协议比POP协议复杂。当用户PC上的IMAP客户程序打开IMAP服务器的邮箱时，用户可以看到邮箱的首部，若用户需要打开某个邮件，该邮件才上传到用户的计算机上。IMAP可以让用户在不同的地方使用不同的计算机随时上网阅读处理邮件，还允许只读取邮件中的某一个部分(先看止文，有WiFi的时候再下载附件)。\n基于万维网的电子邮件使用HTTP协议和SMTP协议。用户到服务器使用HTTP，服务器之间使用的还是SMTP协议\n万维网和HTTP协议万维网WWW （World Wide Web）是一个大规模的、联机式的信息储藏所/资料空间，是无数个网络站点和网页的集合。  \n通过设置统一资源定位符URL唯一标识网络上某个资源（不区分大小写）。&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;协议：HTTP和FTP等主机：域名和IP地址都可以\n用户通过点击超链接（http;//www.baidu.com）获取资源，这些资源通过超文本传输协议（HTTP）传送给使用者。万维网以客户/服务器方式工作，用户使用的浏览器就是万维网客户程序，万维网文档所驻留的主机运行服务器程序。万维网使用超文本标记语言HTML，使得万维网页面设计者可以很方便地从一个界面的链接转到另一个界面，并能够在自己的屏幕上显示出来。\n超文本传输协议HTTPHTTP协议定义了浏览器（万维网客户进程）怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。  \n用户：1.输入URL2.点击超链接  \n服务器：有一个服务器进程监听TCP的端口80\n具体过程:  \n\n浏览器分析URL  \n浏览器向DNS请求解析IP地址  \nDNS解析出IP地址\n浏览器与服务器建立TCP连接  \n浏览器发出取文件命令  \n服务器响应  \n释放TCP连接  \n浏览器显示\n\nHTTP协议的特点：HTTP是无状态的。对于每个相同的HTTP请求，服务器都会给予同样的回应。\n但是在实际工作中，一些万维网站点常常希望能够识别用户。\nCookie是存储在用户主机中的文本文件，记录一段时间内某用户的访问记录。这样就可以提供个性化服务。\nHTTP采用TCP作为运输层协议，但HTTP协议本身是无连接的(通信双方在交换HTTP报文之前不需要先建立HTTP连接)。\n","slug":"计算机网络-四","date":"2022-05-30T14:18:00.000Z","categories_index":"网络","tags_index":"网络,传输层,应用层","author_index":"Ac-Accelerator"},{"id":"3a327b02e6446ad9da6af37fe8dd2226","title":"神经网络的反向传播","content":"反向传播基本思想向前传播函数：   \n\nSVM损失函数，计算每一个样本的损失：  \n  \n附带正则项的所有样本SVM损失的平均值函数，带上正则项可以使得模型更加简单，更容易泛化。\n\n所以在损失函数中，我们希望找到一个合适的，使得这个更小，因为这样模型精度更高，准确率更好。\n那如何去找最优解呢？我们需要将作为函数的自变量，然后求解出当前状态下的对于的梯度,即，然后将朝着与梯度相反的方向调整，就可以使得损失函数的值最快地下降，如此往复迭代，就可以找到损失函数的最小值点。  \n使用计算图框架来理解反向传播算法如何递归的调用链式法则()来计算每个变量的梯度。\n为什么我们不直接解出中每个元素对的导函数，但是这种方法不推荐。因为对于计算机来说，可能会求解出非常复杂且多余的表达式(比如没有合并同类项)，这样会降低训练的效率；如果函数非常复杂，对其求导的步骤也会很冗杂，并且不能有效的利用之前的计算结果；递归更加容易理解和表达。\n计算图框架如下：\n如果出现分支的情况，则梯度需要相加:\n对矩阵求偏导公式：对于函数其偏导公式为更多求导公式\n神经网络介绍神经网络就是由简单函数构成的一组函数在顶层堆叠在一起。我们用一种层次化的方式将它们堆叠起来去形成一个更复杂的非线性函数。主要使用矩阵乘法来实现。\n神经网络有多层，每一层之间需要激活函数来连接，否则在逻辑上相当于没有分层。\n每一层的权重参数矩阵相当于多个特征的模板，一个分类的模板代表着使得该分类的神经元输出值最大的输入，形象的说就是该神经元希望在输入中寻找的特征。例如该卷积网络\n每一层的输出都是对该层输入的一个特征提取的得分，这些得分可以作为输入进入到下一层进行更加高级的处理。\n和生物学神经网络的联系：生物学的神经网络异常复杂，人工神经网络只是对真实神经网络的简化、抽象的表达。(有研究表明ReLU激活函数同真实神经激活相似，但仍需考虑真实神经网络中激活阈值发生变化的可能性。)\n","slug":"神经网络的反向传播","date":"2022-05-18T02:11:00.000Z","categories_index":"人工智能","tags_index":"反向传播","author_index":"Ac-Accelerator"},{"id":"0ca60c06fd1d7a39272aeb0b754b415e","title":"计算机网络(三)","content":"网络层把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。网络层传输单位是数据报。\n功能功能一:路由选择与分组转发最佳路径功能二:异构网络互联功能三:拥塞控制（开环控制、静闭环控制）\n数据交换方式电路交换当两台主机要通信的时候，将建立一条物理上的链路用于通信，类似于过去的电话进行接线。\n特点：独占资源\n优点:\n\n通信时延小\n有序传输\n没有冲突\n实时性强\n\n缺点:\n\n建立连接时间长\n线路独占,使用效率低\n灵活性差\n无差错控制能力\n\n报文交换当两个主机要通信的时候，会将报文发送到交换设备上，交换设备会先对报文进行储存，等到目标链路空闲的时候，再对报文进行转发。\n优点：\n\n无需建立连接\n存储转发,动态分配线路\n线路可靠性较高\n线路利用率较高\n多目标服务（一个报文可以发往多个目标地址）\n\n缺点：\n\n有存储转发时延（串行转发）\n报文大小不定,需要网络节点有较大缓存空间\n\n分组交换分组:把大的数据块分割成小的数据块。在报文交换中,因为报文大小不定,需要网络节点有较大缓存空间。分组交换通过把大的数据块分割成小的数据块改善了这点。\n优点：\n\n无需建立连接\n存储转发,动态分配线路\n线路可靠性较高\n线路利用率较高\n相对于报文交换，存储管理更容易\n时延比报文交换要小（并行转发）\n\n缺点：\n\n有存储转发时延（相对于电路交换）\n需要传输额外的信息量\n乱序到目的主机时，要对分组排序重组\n\n数据报方式（Internet正在使用的）提供无连接服务  \n无连接服务:不事先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同。\n路由器根据分组的目的地址转发分组:基于路由协议/算法构建转发表、检索转发表;每个分组独立选路。\n不保证分组的有序到达。\n虚电路方式提供连接服务，是数据报方式和电路交换方式的结合。\n连接服务:首先为分组的传输确定传输路径（建立连接），然后沿该路径(连接）传输系列分组，系列分组传输路径相同，传输结束后拆除连接。\n虚电路:一条源主机到目的主机类似于电路的路径（逻辑连接)，路径上所有结点都要维持这条虚电路的建立,都维持一张虚电路表，每一项记录了一个打开的虚电路的信息。\n目的地址仅在建立连接阶段使用,之后每个分组使用长度较短的虚电路号\n比较\n\n\n\n特点\n数据报服务\n虚电路服务\n\n\n\n连接的建立\n不要\n必须要\n\n\n目的地址\n每个分组都有完整的目的地址\n仅在建立连接阶段使用，之后每个分组使用长度较短的虚电路号\n\n\n路由选择\n每个分组独立地进行路由选择和转发\n属于同一条虚电路的分组按照同一路由转发\n\n\n分组顺序\n不保证分组的有序到达\n保证分组的有序到达\n\n\n可靠性\n不保证可靠通信，可靠性由用户主机来保证\n可靠性由网络保证\n\n\n对网络故障的适应性\n出故障的结点丢失分组，其他分组路径选择发生变化，可正常传输\n所有经过故障结点的虚电路均不能正常工作\n\n\n差错处理和流量控制\n由用户主机进行流量控制，不保证数据报的可靠性\n可由分组交换网负责，也可由用户主机负责\n\n\n路由算法静态路由算法管理员手工配置路由信息。优点：简便、可靠,在负荷稳定、拓扑变化不大的网络中运行效果很好，广泛用于高度安全性的军事网络和较小的商业网络。缺点：路由更新慢，不适用于大型网络\n动态路由算法路由器间彼此交换信息，按照路由算法优化出路由表项。优点：路由更新快，适用大型网络，及时响应链路费用或网络拓扑变化。缺点:算法复杂，增加网络负担。\n全局性链路状态路由算法(OSPF)网络层协议,直接IP传输所有路由器掌握完整的网络拓扑和链路费用信息，每隔30分钟刷新一次数据库中的链路状态，适用于大规模网络，收敛速度很快。\n迪杰斯塔拉算法。。。梦回离散数学。。。\nOSPF协议如何工作：\n\n使用洪泛法向自治系统内所有路由器发送信息，即路由器通过输出端口向所有相邻的路由器发送信息，而每一个相邻路由器又再次将此信息发往其所有的相邻路由器。最终整个区域内所有路由器都得到了这个信息的一个副本\n发送的信息就是与本路由器相邻的所有路由器的链路状态（本路由器和哪些路由器相邻，以及该链路的度量/代价――费用、距离、时延、带宽等）。\n只有当链路状态发生变化时，路由器才向所有路由器洪泛发送此信息。\n\n链路状态路由算法：\n\n每个路由器发现它的邻居结点[HELLO问候分组]，并了解邻居节点的网络地址。\n设置到它的每个邻居的成本度量metric。\n构造[DD数据库描述分组]，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。\n如果DD分组中的摘要自己都有，则邻站不做处理;如果有没有的或者是更新的，则发送[LSR链路状态请求分组]请求自己没有的和比自己更新的信息。\n收到邻站的LSR分组后，发送[LSU链路状态更新分组]进行更新。\n更新完毕后，邻站返回一个[LSAck链路状态确认分组]进行确认。\n\n只要一个路由器的链路状态发生变化:\n\n泛洪发送[LSU链路状态更新分组]进行更新。\n更新完毕后，其他站返回一个[LSAck链路状态确认分组]进行确认。\n\n最后使用Dijkstra根据自己的链路状态数据库构造到其他节点间的最短路径。\n分散性距离向量路由算法(RIP)应用层协议，采用UDP传输。RIP是一种分布式的基于距离向量的路由选择协议，是因特网的协议标准，最大优点是简单，但是如果出现网络故障，该网络故障信息就会传播的比较慢。网络中每一个路由器都维护从它自己到其他每一个目的网络的唯一最佳距离(从源端口到目的端口所经过的路由器个数)记录。RIP允许一条路由最多只能包含15个路由器，因此距离为16表示网络不可达，所以只适用于小互联网。  \nRIP协议如何工作：\n\n仅和相邻路由交换RIP报文，一个RIP报文最多可包括25个路由，如超过，必须再用一个RIP报文传送。\n每30秒交换一次路由信息，然后路由器根据新信息更新路由表。若超过180s没收到相邻路由器的通告，则判定该相邻路由器失效，并更新自己路由表。\n经过若干次更新后，所有路由器最终都会知道到达本自治系统任何一个网络的最短距离和下一跳路由器的地址，即“收敛”。\n\n距离向量算法\n\n修改相邻路由器发来的RIP报文中所有表项对地址为x的相邻路由器发来的RIP报文，修改此报文中的所有项目:把“下一跳”字段中的地址改为X，并把所有的“距离”字段+1。\n对修改后的RIP报文中的每一个项目，进行以下步骤:\nR1路由表中若没有Net3，则把该项目填入R1路由表\nR1路由表中若有Net3，则查看下一跳路由器地址:若下一跳是x，则用收到的项目替换源路由表中的项目;若下一跳不是x，原来距离比从x走的距离远则更新，否则不作处理。\n\n\n若180s还没收到相邻路由器x的更新路由表，则把x记为不可达的路由器，即把距离设置为16\n\n路由选择协议因特网规模很大，而且许多单位不想让外界知道自己的路由选择协议，但还想连入因特网，因此诞生了路由分层次的路由选择协议\n自治系统AS:在单一的技术管理下的一组路由器，而这些路由器使用一种AS内部的路由选择协议和共同的度量以确定分组在该AS内的路由，同时还使用一种AS之间的路由协议以确定在AS之间的路由。一个AS内的所有网络都属于一个行政单位来管辖，一个自治系统的所有路由器在本自治系统内都必须连通。\n内部网关协议IGP常用算法为RIP和OSPF\n外部网关协议BGP常用算法为BGP\nBGP协议：属于应用层协议，TCP传输BGP支持CIDR，因此 BGP的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。与其他AS的邻站BGP发言人交换网络可达性的信息，即要到达某个网络所要经过的一系列AS。发生变化时更新有变化的部分。当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各AS的较好路由。\nBGP-4的四种报文\n\nOPEN(打开）报文:用来与相邻的另一个BGP发言人建立关系，并认证发送方。\nUPDATE（更新）报文:通告新路径或撤销原路径\nKEEPALIVE（保活）报文:在无UPDATE时，周期性证实邻站的连通性;也作为OPEN的确认。\nNOTIFICATION(通知）报文:报告先前报文的差错;也被用于关闭连接。\n\n网络地址转换网络地址转换NAT(Network Address Translation):在专用网连接到因特网的路由器上安装NAT软件，安装了NAT软件的路由器叫NAT路由器，它至少有一个有效的外部全球IP地址。NAT百度百科\n子网划分和子网掩码某单位划分子网后，对外仍表现为一个网络，即本单位外的网络看不见本单位内子网的划分。子网划分就是将IP地址划分为网络前缀和主机号。  \n目标地址和子网掩码逐位相与，则得到目标所在的子网的地址。  \n子网掩码由连续的1和0组成，将网络前缀全部改成1，主机号全部改成0，即可得到当前子网的子网掩码\n无分类域间路由选择CIDR:消除了传统的A类，B类和c类地址以及划分子网的概念。记法:IP地址后加上“/”，然后写上网络前缀（可以任意长度)的位数。e.g.128.14.32.0/20。\n使用CIDR时，查找路由表可能得到几个匹配结果，应选择具有最长网络前缀的路由。前缀越长，地址块越小，路由越具体。\n构成超网和划分子网相逆的过程。将多个子网聚合成一个较大的子网，叫做构成超网，或路由聚合。方法：将网络前缀缩短。\n这也是为什么使用CIDR时，在路由表的几个匹配结果中，要选择具有最长网络前缀的路由。\nARP协议由于在实际网络的链路上传送数据帧时，最终必须使用MAC地址。ARP协议:完成主机或路由器IP地址到MAC地址的映射。解决下一跳走哪的问题。  \nARP协议使用过程:检查ARP高速缓存，有对应表项则写入MAC帧，没有则用目的MAC地址为FF-FF-FF-FF-FF-FF的帧封装并广播ARP请求分组，同一局域网中所有主机都能收到该请求。目的主机收到请求后就会向源主机单播一个ARP响应分组，源主机收到后将此映射写入ARP缓存（10-20min更新一次）。ARP协议4种典型情况:  \n\n主机A发给本网络上的主机B:用ARP找到主机B的硬件地址;\n主机A发给另一网络上的主机B:用ARP找到本网络上一个路由器（网关）的硬件地址;\n路由器发给本网络的主机A:用ARP找到主机A的硬件地址;\n路由器发给另一网络的主机B:用ARP找到本网络上的一个路由器的硬件地址。\n\nDHCP协议用于动态分配IP地址，是一种基于UDP的应用层协议。\nDHCP提供即插即用联网的机制，主机可以从服务器动态获取IP地址、子网掩码、默认网关、DNS服务器名称与IP地址,允许地址重用，支持移动用户加入网络，支持在用地址续租*。\n运行方法：\n\n主机广播DHCP发现报文，查找网络中的DHCP服务器，服务器获得一个IP地址。\nDHCP服务器广播DHCP提供报文，服务器拟分配给主机一个IP地址及相关配置。主机收到该报文之后，停止接受其他的DHCP提供报文。\n主机广播DHCP请求报文，告知其他的DHCP服务器，主机已经获得该IP地址。\nDHCP服务器广播DHCP确认报文，正式将地址分配给主机。\n\nICMP协议ICMP五种差错报文：\n\n终点不可达:当路由器或主机不能交付数据报时就向源点发送终点不可达报文。\n源点抑制(不再使用):当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。\n时间超过:当路由器收到生存时间TTL=O的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。\n参数问题:当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。\n改变路由(重定向)﹔路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器(可通过更好的路由）。\n\n不发送ICMP差错报文的情况\n\n对ICMP差错报告报文不再发送ICMP差错报告报文。\n对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文。\n对具有组播地址的数据报都不发送ICMP差错报告报文。\n对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错报告报文。\n\nICMP询问报文：\n\n回送请求和回答报文：主机或路由器向特定目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。测试目的站是否可达以及了解其相关状态。\n时间戳请求和回答报文︰请某个主机或路由器回答当前的日期和时间。用来进行时钟同步和测量时间。\n掩码地址请求和回答报文(不再使用)\n路由器询问和通告报文(不再使用)\n\nICMP的应用PING：测试两个主机之间的连通性，使用了ICMP回送请求和回答报文。Traceroute：跟踪一个分组从源点到终点的路径，使用了ICMP时间超过差错报告报文。\n移动IPA刚进入外部网络:\n\n在外部代理登记获得一个转交地址，离开时注销。\n外地代理向本地代理登记转交地址。\n\nB给A发送数据报:\n\n本地代理截获数据报。\n本地代理再封装数据报，新的数据报目的地址是转交地址，发给外部代理（隧道)。\n外部代理拆封数据报并发给A。\n\nA给B发送数据报:A用自己的主地址作为数据报源地址，用B的IP地址作为数据报的目的地址。\nA移动到了下一个网络:\n\n在新外部代理登记注册一个转交地址。\n新外部代理给本地代理发送新的转交地址（覆盖旧的）。3.通信\n\nA回到了归属网络:\n\nA向本地代理注销转交地址。\n按原始方式通信。\n\n网络层设备路由器：路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组。功能：\n\n路由选择：根据所选定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表。 \n分租转发\n交换结构:根据转发表（路由表得来〉对分组进行转发。\n\n分组若收到RIP/OSPF分组等，则转发把分组送往路由选择处理机;若收到数据分组，则查找转发表并输出。\n\n\n\n\n若路由器处理分组的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃。\n","slug":"计算机网络-三","date":"2022-05-16T06:14:00.000Z","categories_index":"网络","tags_index":"网络,网络层","author_index":"Ac-Accelerator"},{"id":"0c89500007ef3b784b27319aeed34361","title":"Java学习笔记(三)","content":"Maven构建工具构建工具功能:\n\n自动帮程序员甄别和下载第三方库(jar)\n完成整个项目编译(调用javac.exe)\n完成整个项目单元测试流程(调用Junit工具)\n完成项目打包(jar/war等格式，调用jar.exe)\nMaven是通过pom.xml文件来进行项目管理的。\n第三方库的使用方法：在中心库里面搜索自己想要的库，然后将依赖文本拷贝到pom.xml中的dependencies标签内部，即完成引入。\n\nMaven工具是单独下载的并且需要为其配置环境变量。必须保证系统变量中有JAVA_HOME变量且指向正确的地址。安装路径下的/conf/settings.xml文件是该应用的设置，内部有详细的注释帮助用户来个性化maven。安装完成后在cmd里面输入mvn help:system进行初始化，会下载大量文件。某个jar包一旦被Maven下载过，即可永久地安全缓存在本地\n我由始至终都坚持使用Visual Studio Code进行开发。这里推荐几个别人的视频，对我的帮助很大，本人已经三连。VSCode及JDK配置Maven安装和配置VSCode创建Maven项目\n\n\n\n\n\n\n提示\nmaven管理的依赖是传递的。即在引入依赖时，会递归的引入所需的所有依赖。\n\n\n项目结构maven的项目目录结构如下所示：\ntxtmaven-project\n├── pom.xml\n├── src\n│   ├── main\n│   │   ├── java\n│   │   └── resources\n│   └── test\n│       ├── java\n│       └── resources\n└── target根目录下有一个pom.xml文件，这是maven的核心文件，用于描述整个maven项目。根目录下的src文件夹用于存放程序源代码和资源文件。其中里面的main文件夹用于存放主程序代码，test文件夹用于存放测试程序代码。根目录下的target文件夹用于存放编译后的class文件、jar包、war包等。\n\n\n\n\n\n\n\n注意\n尽量不要修改maven项目的目录结构！例如更改上述文件夹的名称等。否则可能需要特殊配置才能正常运行。\n\n\npom文件解析xml&lt;project ... &gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.neuq&lt;/groupId&gt;\n    &lt;artifactId&gt;shmetro2&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n    &lt;name&gt;shmetro2&lt;/name&gt;\n    &lt;packaging&gt;war&lt;/packaging&gt;\n\n    &lt;parent&gt;\n      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n      &lt;version&gt;2.6.0&lt;/version&gt;\n      &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n    &lt;/parent&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;\n        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;\n        &lt;junit.version&gt;5.9.2&lt;/junit.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;javax&lt;/groupId&gt;\n            &lt;artifactId&gt;javaee-web-api&lt;/artifactId&gt;\n            &lt;version&gt;8.0.1&lt;/version&gt;\n            &lt;scope&gt;provided&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;\n                &lt;version&gt;3.3.2&lt;/version&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n&lt;project&gt;pom.xml文件的根元素\n&lt;modelVersion&gt;标签用于指示pom.xml的版本，这个值与maven版本有关。但是大多数情况设置为4.0.0即可。\n&lt;groupId&gt;可以理解为Java的包名，一般是公司或者组织的名称。\n&lt;artifactId&gt;可以理解为Java的类名，一般是该项目的名称。\n&lt;version&gt;这个是当前的版本号。\n&lt;name&gt;用于设置maven项目的名称。可以不写\n&lt;packaging&gt;指定Maven项目的打包方式。常见的打包方式有jar、war、ear等。不写默认为jar。\n&lt;parent&gt;可以将一个POM文件定义为另一个POM文件的父级。子POM文件可以继承父POM文件中的所有配置信息，如依赖项、插件、属性等。（可不写，不继承）\n&lt;artifactId&gt;父POM文件的类名\n&lt;version&gt;父POM文件的版本号\n&lt;relativePath&gt;父POM文件的相对路径，如果不写则默认为../pom.xml，即父POM文件在当前目录的上一级目录。\n\n\n&lt;properties&gt;这个用于设置属性值，参考这个\n&lt;dependencies&gt;为项目定义的依赖项列表，从中心库复制来的依赖文本拷贝到该元素里面即可完成依赖引入。\n&lt;dependency&gt;定义了一个依赖项，maven根据里面的信息从中心仓库下载对应的包并包含进项目。\n&lt;groupId&gt;要引入的Java的包名\n&lt;artifactId&gt;要引入的Java的类名\n&lt;version&gt;要引入的版本\n&lt;type&gt;依赖的类型。常见的类型有jar、war、pom等。不写默认为jar。\n&lt;executions&gt;该依赖项会包含一些子依赖项，这是不希望引入的子依赖项列表。\n&lt;execution&gt;要排除的子依赖项\n&lt;groupId&gt;子依赖项的包名\n&lt;artifactId&gt;子依赖项的类名\n\n\n\n\n&lt;scope&gt;用于指定该包在maven项目中依赖范围。\n\n\n\n\n&lt;build&gt;用来定义项目构建的相关信息包括源代码目录，目标构建目录，插件配置等。\n\n\n\n\n\n\n\n\n\n依赖范围\n有的依赖需要在不同的时候提供，如servlet-api在package的时候是不应该包含进去的。依赖范围指定了在不同情况下是否包含该依赖，默认不写是compile。\n\n\n\nscope值\n主程序\n测试程序\n打包（运行）\n范例\n\n\n\ncompile\n✅\n✅\n✅\nlog4j\n\n\ntest\n❌\n✅\n❌\njunit-jupiter-api\n\n\nprovided\n✅\n✅\n❌\njavax.servlet-api\n\n\nruntime\n❌\n✅\n✅\nmysql-connector-java\n\n\n\n\n生命周期life circle生命周期是指maven在构建项目时候的一系列动作，有三个生命周期，分别是clean、default、site。\n如果要执行某个操作，如compile，那么maven会先执行该操作所在的生命周期（即default）在该操作之前的所有操作。\nclean\npre-clean:执行清理前的工作\nclean:清理上一次构建生成的所有文件\npost-clean:执行清理后的工作\n\ndefault\nvalidate:验证项目是否正确，所有需要的信息是否可用\ninitialize:初始化构建环境，如设置属性、创建目录等\ngenerate-sources:生成项目的源代码\nprocess-sources:处理项目的源代码，如过滤值、替换值等\ngenerate-resources:生成项目的资源文件，如图片、配置文件等\nprocess-resources:处理项目的资源文件，如压缩图片、转换配置文件格式等\ncompile:编译项目的源代码\nprocess-classes:处理编译后的文件，如生成Javadoc、复制额外的文件等\ngenerate-test-sources:生成测试项目的源代码\nprocess-test-sources:处理测试项目的源代码，如过滤值、替换值等\ngenerate-test-resources:生成测试项目的资源文件，如图片、配置文件等\nprocess-test-resources:处理测试项目的资源文件，如压缩图片、转换配置文件格式等\ntest-compile:编译测试项目的源代码\nprocess-test-classes:处理编译后的文件，如生成Javadoc、复制额外的文件等\ntest:运行测试\nprepare-package:打包前的准备工作\npackage:打包，将编译后的代码打包成可发布的格式，如jar、war等\nverify:对打包后的结果进行检查，以保证质量\ninstall:将打包后的文件安装到本地仓库，以供其他项目使用\ndeploy:将打包后的文件复制到远程仓库，以供其他开发人员和项目使用\n\nsite\npre-site:执行生成文档前的工作\nsite:生成项目的站点文档\npost-site:执行生成文档后的工作，如清理现场等\nsite-deploy:将生成的文档部署到远程服务器上\n\n\n\n\n\n\n\n\nclean和package不在同一个生命周期。\n这意味着在package的时候，clean并不会被执行！\n如果一个项目中，在打包过一次之后（会生成被打包的文件夹），再删除某个依赖项（这并不会使该项从被打包的文件夹中删除）再进行打包的时候，依然会把该项打包进去，这就会导致打的包有多余的依赖项，严重时可能产生错误。\n因此，如果在打包之前删除了某个依赖项，那么需要先执行clean，再执行package。\n\n\n插件对于lifecycle，maven是使用插件来实现的。例如：compile操作对应的真实操作是compiler:compile，即执行mvn compile和mvn compiler:compile是等价的，compile只不过是compiler:compile对应的简称。而compiler:compile是maven-compiler-plugin插件的compile目标。实际上执行命令的是插件哦。\n上述例子中的compile，通常被称为phase，而compiler:compile被称为goal。phase是一组goal的集合，goal是maven中最小的执行单元。\nMaven已经内置了一些常用的标准插件，如果标准插件无法满足需求，我们还可以使用自定义插件。\n常用的插件有（用法自搜）：\n\nmaven-shade-plugin：打包所有依赖包并生成可执行jar；\ncobertura-maven-plugin：生成单元测试覆盖率报告；\nfindbugs-maven-plugin：对Java源码进行静态分析以找出潜在问题。\n\n模块管理单元测试和JUnit测试：\n\n*白盒测试(white-box testing)*，全面了解程序内部逻辑结构，对所有的逻辑路径都进行测试。一般由程序员完成。  \n*黑盒测试(black-box testing)*，又名功能测试，将程序视为一个不能打开的黑盒子。在完全不考虑程序内部结构和内部特性的情况下，检查程序功能是否按照需求规格说明书的规定正常使用。一般由独立的使用者完成。\n单元测试(unit testing) ，是指对软件中的最小可测试单元进行检查和验证。通常是一个函数/方法。单元测试是已知代码结构进行的测试，属于白盒测试。\n集成测试是将多个单元相互作用，形成一个整体，对整体协调性进行测试。一般从构成系统的最小单元开始，持续推进到单元之间的接口直到集成为一个完成的软件系统为止。\n自动测试︰用程序批量、反复测试程序，并可自动检查程序结果是否满足预定的要求。\n手动测试:手动执行程序，手动输入所需要的参数，手动检查程序结果是否满足预定的要求。\n回归测试︰修改旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。回归测试在整个软件测试过程中占有很大的比重。软件快速迭代开发过程中，新版本的连续发布(Daily /Nightly Build)使得回归测试进行的更加频繁。\n\n测试策略\n\n基于main函数的策略\n优点:简单\n缺点:无法自动判断被测对象的行为是否符合预期，main方法需要添加大量的代码，这些代码在发布时候也需要手动删除，分散程序员在开发时的关注点\n\n\n基于自动化测试框架的策略\n初始化-&gt;输入测试数据执行被测代码-&gt;获取系统实际结果-&gt;比较结果是否一致-&gt;输出测试结论\n\n\n\n使用Maven构建的程序会自带一个test文件，在VSCode中可以很方便的进行测试。\nJava语法糖语法糖:Syntactic sugar / Syntax sugar语法糖使得程序员更容易编写程序，更清晰准确表达业务逻辑。不仅仅是语法的转换，也包括一些小的改进。\nfor和for-each\nfor-each 从JDK5.0开始引入，语法更简洁\nfor-each 可以避免越界错误\nfor可以删除元素，for-each不可以删除/替换元素\nfor-each遍历的时候，是不知道当前元素的具体位置索引\nfor-each只能正向遍历，不能反向遍历\nfor-each不能同时遍历2个集合\nfor和for-each性能接近\n\n使用方法如下：nums是某个可迭代数据类型的对象，item是其中的每个数据，和C++一样。\njavafor(double item : nums){\n    system.out.println(item);\n}枚举类型：枚举变量:变量的取值只在一个有限的集合内，如性别、星期几、颜色等。\n\nenum关键字声明枚举类，且都是Enum的子类(但不需写extends)\nenum内部有多少个枚举量，就有多少个实例对象\n不能直接new枚举类对象\n除了枚举量，居然还可以添加属性/构造函数/方法?!\n构造函数只能是package-private(default)或者private，内部调用。\nordinal()返回枚举量所在的索引位置,从0开始\ncompareTo()比较两个枚举量的索引位置大小\ntoString()返回枚举量的字符串表示\nvalueOf()将字符串初始化为枚举对象\nvalues()返回所有的枚举量\n\n使用方法如下：个人感觉比和C++ 有很多不同。\njavaenum Fruit\n{\n    APPLE,ORANGE,BANANA(8),PEACH;\n  //使用括号定义索引位置，和C++使用\"=\"不同；索引位置的值只能是整数。\n  //每个枚举量都有一个索引位置，如果如上定义，则apple值是0，orange值为1，banana为8，peach为9；\n    private int price;\n    Fruit(int price) {\n        this.price = price;\n    }\n    public int getPrice() {\n        return this.price;\n    }\n}不定项参数和C++ 不同的是 C++ 要使用函数模板来实现。C++ :\ncpptemplate &lt;class... Tmp&gt;\nvoid print(Tmp... pargs);Java就是这样的：\njavapublic static void print(String... args){\n  system.out.println(args.length);\n  for (String arg : args){\n    system.out.println(arg);\n  }\n}\n一个方法只能有一个不定项参数，且必须位于参数列表的最后\n重载的优先级规则1:固定参数的方法，比可变参数优先级更高\n重载的优先级规则2:调用语句，同时与两个带可变参数的方法匹配，则报错。\n\n静态导入import static导入一个类的静态方法和静态变量。\njavaimport static java.lang.Math.pow;//引入pow函数\nimport static java.lang.Math.sqrt;//引入sqrt函数\nimport static java.lang.System.* ;//引入System下的所有静态方法和静态变量。\nimport static java.lang.System.out;//引入System的静态变量out。少使用*通配符，不滥用，最好具体到静态变量或方法。静态方法名具有明确特征，如有重名，需要补充类名。  \n自动装箱和拆箱\n装箱和拆箱是编译器的工作，在class中已经添加转化。虚拟机没有自动装箱和拆箱的语句。\n==:基本类型是内容相同，对象是指针是否相同(内存同一个区域)\n基本类型没有空值，对象有null，可能触发NullPointerException。\n当一个基础数据类型与封装类进行==、+、-、*、/运算时，会将封装类进行拆箱，对基础数据类型进行运算。\n谨慎使用多个非同类的数值类对象进行运算。\n\njavaInteger obj1 = 5;//自动装箱\nInteger obj2= Integer.valueOf(5);\nint a1 = obj1;//自动拆箱\nint a2 = obj1.intValue();\n\nArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\nlist.add(1);//自动装箱\nlist.add(Integer.valueOf(2));\nint a3 = list.get(1);//自动拆箱\nint a4 = list.get(1).intValue();\n多异常并列javatry{\n  //code\n}\ncatch( IOException | FileNotFoundException ex){\n  //code\n}数值类型赋值优化整型用二进制赋值\njava//整型用二进制赋值\nbyte a1 = (byte) 0b00100001;\nshort a2= (short) 0b1010000101000101;\nint a3= 0b10100001010001011010000101000101;int a4 = 0b101;\nint a5 = 0B101;//B可以大小写\nlong a6 = 0b1010000101000101101000010110001011010000101000101L;\nfinal int[] s1 = { 0b00110001，0b01100010，0b11000100，0b10000100 };在数值字面量中使用下划线  \n下划线只能出现数字中间，前后必须都是数字。允许在二/八/十/十六进制的数字中使用。\njava//在数值字面量中使用下划线\nint a3 = 0b0111_1011_0001;//二进制\nint a4 = 02_014;//八进制\nint a5 = 123__45;//可以多个下划线\nint a6 = 0x7_B_1;//十六进制\nfloat a7 = 3.56_78f;//float接口方法Java最初的设计中，接口的方法都是没有实现的、公开的。Java 8推出接口的默认方法/静态方法(都带实现的)，为Lambda表达式提供支持。\n默认方法：以default关键字标注，其他的定义和普通函数一样\n\n规则1:默认方法不能重写Object中的方法\n规则2:实现类可以继承/重写父接口的默认方法\n规则3:接口可以继承/重写父接口的默认方法\n规则4:当父类和父接口都有(同名同参数)默认方法，子类继承父类的默认方法，这样可以兼容JDK7及以前的代码\n规则5:子类实现了2个接口(均有同名同参数的默认方法)，那么编译失败，必须在子类中重写这个default方法\n\n静态方法:该静态方法属于本接口的，不属于子类/子接口。子类(子接口)没有继承该静态方法，只能通过所在的接口名来调用。\n私有方法：解决多个默认方法/静态方法的内容重复问题。\n\n私有方法属于本接口，只在本接口内使用，不属于子类/子接口  \n子类(子接口)没有继承该私有方法，也无法调用。  \n静态私有方法可以被静态/默认方法调用，非静态私有方法被默认方法调用。\n\ntry-with-resource\n程序如果打开外部资源，那么在使用后需要正确关闭。\n考虑异常因素，Java提供try-catch-finally进行保证。\nJDK7提供try-with-resource，比try-catch-finally更简便。\n资源对象必须实现AutoCloseable接口，即实现close方法。\n\n局部变量推断Java 10推出var，使得在定义变量的时候不用指定数据类型:\n\n避免信息冗余\n对齐了变量名\n更容易阅读\n\n看上去Java变成了弱类型的语言，本质上还是强类型语言。编译器负责推断类型，并写入字节码文件。因此推断后不能更改! ! !注意事项：\n\n可以用在局部变量上，非类成员变量\n可以用在for/for-each循环中\n声明时必须初始化！\n不能用在方法(形式)参数和返回类型\n大面积滥用会使代码整体阅读性变差\nvar只在编译时起作用，没有在字节码中引入新的内容，也没有专门的JVM指令处理var\n\nswitchjava//多分支合并\nswitch(month){\n    case \"Jan\" , \"Mar\", \"May\",\"July\" , \"Aug\", \"oct\", \"Dec\" -&gt; result = 31;\n    case \"Apr\". \".une\" , \"sep\", \"Nov\" -&gt;result = 30;\n    case \"Feb\" -&gt; result = 28;\n    default -&gt; result = -1;\n}\n\n//switch直接在表达式赋值\nint num = 1;\nint days = switch.(num){\n    case 1,3,5,7,8,10,12-&gt;31;\n    case 4,6,9,11-&gt;30;\n    default -&gt;{\n        int result=28;\n        break result;//代码块中break返回结果\n    }\n};泛型Generic Programming，JDK1.5推出的特性编写的代码可以被很多不同类型的对象所重用。说的倒是这么高级,这不就是C++的template吗？\n\n泛型类: ArrayList，HashSet，HashMap等\n泛型方法:Collections.binarySearch，Arrays.sort等\n泛型接口: List, Iterator等\n\n泛型类\n具有泛型变量的类\n在类名后用&lt;T&gt;代表引入类型\n多个字母表示多个引入类型如&lt;T,U&gt;等\n引入类型可以修饰成员变量/局部变量/参数/返回值\n没有专门的template关键字\n\n\n\n类似于这样使用：\njavapublic class Interval&lt;T&gt;{\n    private T lower;\n    private T upper;\n    public Interval(lower, upper) {\n        this. lower = lower;\n        this. upper = upper;\n    }\n    public T getLower() {\n        return lower;\n    }\n    //部分get/set方法省略\n    public static void main (String[] args){\n        Interval&lt;Integer&gt; v1 = new Interval&lt;Integer&gt;(1,2);\n        int lower = v1.getLower() ;\n        int upper = v1.getUpper() ;\n        system.out.println(lower + \",\" + upper);\n        Interval&lt;Integer&gt; v2 = new Interval&lt;&gt;(1,2);Interval&lt;Integer&gt; v3 = getReverse(v2);\n        system.out.println(v3.getLower() +\",\" + v3.getUpper());\n    }\n    public static &lt;Interval&lt;T&gt;getReverse(Interval&lt;T&gt; interval) {\n        return new Interval&lt;T&gt;(interval.getUpper(),interval.getLower());\n    }\n}泛型方法：\n具有泛型参数的方法\n该方法可在普通类/泛型类中\n&lt;T&gt;在修饰符后,返回类型前\n\njavapublic class Arrayutil {\n    public static &lt;T&gt; T getMiddle(T... a){\n        return a[a.length/2];\n    }\n}泛型接口\n和泛型类相似，在类名后加&lt;T&gt;\nT用来指定方法返回值和参数,T可以是一个普通类也可以是一个泛型类\n实现接口时，指定类型\n\n泛型限定\n&lt;T extends Comparable&gt;约定T必须是Comparable的子类\nextends固定，后面可以多个，以&amp;拼接，如&lt;T extendsComparable &amp; Serializable&gt;\nextends限定可以有多个接口，但只能一个类，且类必须排第一位\n逗号隔参数，&lt;T extends File &amp; Cloneable, U extends Serializable&gt;\n\n上线界定符：&lt;? extends S&gt;，意思是能接收的参数类型是S自身或子类。只能get不能set，编译器只能保证出来的类型，但不保证放入的对象是什么类型。  \njavaPair&lt;? extends Fruit&gt;//代表Pair&lt;Fruit&gt;, Pair&lt;Apple&gt;, Pair&lt;Orange&gt;等\n? extends Fruit getFirst();//肯定可以转型到Fruit\nvoid setFirst(? extends Fruit)//未知具体的类型，错误下界鉴定符：&lt;? super S&gt;，意思是能接收的参数类型S的自身或超类。只能set不能get，编译器保证放入的是S本身或超类，但不保证出来是什么具体类型。\njavaPair&lt;? super Apple&gt;//代表Pair&lt;Object&gt;, Pair&lt;Fruit&gt;, Pair&lt;Apple&gt;等\nvoid setFirst(? super Apple)//可以放入Apple及子类对象\n? super Apple getFirst()//无法得知出来的对象类型，只能是Object无限定类型的泛型：&lt;?&gt;，摆烂了属于是，set和get都不能用。\n泛型PECS原则Producer Extends, Consumer Super\n\n要从泛型类读取类型T的数据，并且不能写入，可以使用 ? extends 通配符;(Producer Extends，泛型类是生产者，往外输出东西)\n如果要向泛型类写入类型T的数据，并且不需要读取，可以使用 ? super 通配符;(Consumer Super，泛型类是消费者，往内增加东西)\n如果既想写入又想读出，那就不用通配符\n\nJava类型的变化定义：A、B是类型，f(·)表示类型转换，≤表示继承关系，如A≤B,表示A继承于B  \n\nf(·)是协变(covariant)的，如果A≤B，有f(A)≤f(B)\nf(·)是逆变(contravariant)的，如果A≤B，有f(B)≤f(A)\nf(·)是不变(invariant)的，当上述两种都不成立，即f(A)和f(B)没有关系\nf(·)是双变(bivariant)的，如果A≤B，有f(B)≤f(A)和f(A)≤f(B)同时成立\n\n类型变化相关：\n\n数组是协变的(covariant)\n原始的泛型是不变的(invariant)-\n&lt;?extends A&gt;支持协变(covariant)\n&lt;?super B&gt;支持逆变(contravariant)\nJDK1.4重写的方法参数和返回值要求一样,JDK1.5＋重写的方法，参数要求一样的，返回值是协变的\n\n","slug":"Java学习笔记-三","date":"2022-05-12T12:04:00.000Z","categories_index":"Java","tags_index":"Java,Maven,语法糖,泛型","author_index":"Ac-Accelerator"},{"id":"f72442027e50aabe63bc800cc8297c91","title":"Java学习笔记(二)","content":"Java常用类Java类库*包名以Java开始的包是Java核心包(Java Core Package)*：  \n\n\n\nModule\nDescription\n\n\n\njava.applet.*\n提供了创建applet需要的所有类。\n\n\njava.awt.*\n提供了创建用户界面以及绘制和管理图形、图像的类\n\n\njava.beans.*\n提供了开发Java Beans需要的所有类。\n\n\njava.io.*\n提供了通过数据流、对象序列以及文件系统实现的系统输入、输出。\n\n\njava.lang.*\nJava编程语言的基本类库。\n\n\njava.math.*\n提供了简明的整数算术以及十进制算术的基本函数。\n\n\njava.net.*\n提供了用于实现网络通讯应用的所有类。\n\n\njava.nio.*,\n提供用于实现nio应用的所有类。\n\n\njava.rmi.*\n提供了与远程方法调用相关的所有类。\n\n\njava.security.*\n提供了设计网络安全方案需要的一些类。\n\n\njava.sql.*\n捉供了访问和处理来自于Java标准数据源数据的类。\n\n\njava.text.*\n包括以一种独立于自然语言的方式处理文本、日期、数字和消息的类和接口。\n\n\njava.time.*\n捉供Java日期、时间类(Java 8新增的包)。\n\n\njava.util.*\n包括集合类、时间处理模式、日期时间工具等各类常用工具包。\n\n\n包名以Javax开始的包是Java扩展包(Java Extension Package)\n数字相关类除了基本类及其包装类，还有大数类。\n\njava.math.Biglnteger 支持无限大的整数运算\n\njava.math.BigDecimal 支持无限大的小数运算(注意精度)。\n\njava.util.Random\n\nnextInt()返回一个随机int\nnextInt(int a)返回一个[0,a)之间的随机int\nints方法批量返回随机数数组\nnextDouble()返回一个[0.0,1.0]之间double\njava.lang.Math.random()返回一个[0.0,1.0]之间double\n\n\n\n\njava.lang.Math\n绝对值函数abs\n对数函数log\n比较函数max、 min\n幂函数pow\n四舍五入函数round等\n向下取整floor\n向上取整ceil\n\n\n\n字符串相关类：\njava.lang.String\njava.lang.StringBuffer\njava.lang.StringBuilder\n\n时间相关类：java.util.Calendar\n\nget(Field)来获取时间中每个属性的值.注意，月份0-11.\ngetTime()，返回相应的Date对象\ngetTimeInMillis(),返回自1970.1.1以来的毫秒数\nset(Field)设置时间字段\nadd(field, amount)根据指定字段增加/减少时间\nroll(field, amount)根据指定字段增加/减少时间，但不影响上一级的时间段\n\nJAVA8提供的新的包：\n\nLocalDate: 日期类\nLocalTime: 时间类(时分秒-纳秒)\nLocalDateTime: LocalDate +LocalTime\nInstant:时间戳\n\n格式化相关类：\n\nNumberFormat:数字格式化，抽象类\nDecimalFormat\n\n\nMessageFormat:字符串格式化\nDateFormat:日期/时间格式化，抽象类 \nSimpleDateFormat\n\n\n\n\n\nDateTimcFormatter\n\n异常及其处理异常分类\nThrowable:所有错误的祖先\nError:系统内部错误或者资源耗尽。\nException:程序有关的异常。\nRuntimcExccption:程序自身的错误\n非RuntimcException:外界相关的错误\n\n\n\n异常处理try:正常业务逻辑代码。catch:当try发生异常，将执行catch代码。若无异常，绕之。catch块可以有多个，每个有不同的入口形参。当已发生的异常和某一个catch块中的形参类型一致，那么将执行该catch块中的代码。一个异常只能进入一个catch块(通常小异常放在前面，大异常放在后面)。finally:当try或catch执行结束后，必须要执行finally。上述结构是可以嵌套的对于throw的写法类似于C++ 的异常规范，但两者有很大的不同：\njavapublic int divide(int x, int y) throws ArithmeticException\n{\n    int result = x/y ;\n    return x/y;\n}一个方法被覆盖，覆盖它的方法必须抛出相同的异常，或者异常的子类。如果父类的方法抛出多个异常，那么重写的子类方法必须抛出那些异常的子集，也就是不能抛出新的异常。\n自定义异常自定义异常，需要继承Exception类或其子类。\n\n继承自Exception，就变成Checked Exception\n继承自RuntimeException,就变成Unchecked Exception\n\n自定义重点在构造函数\n\n调用父类Exception的message构造函数\n可以自定义自己的成员变量在程序中采用throw主动抛出异常\n\n数据结构数组：  \njavaint a[]; //a 还没有new操作实际上是nu1l，也不知道内存位置\nint[] b; //b 还没有new操作实际上是null，也不知道内存位置\nint[] c = new int[2]; //c有2个元素，都是0\nc[0]= 10; c[1] = 20;//逐个初始化\nint d[] = new int[]{0,2,4};//d有3个元素,0,2,4，同时定义和初始化\nint d1[] = {1,3,5};//d1有3个元素,1,3,5同时定义和初始化\n//规则数组\nint a[][] = new int[2][3];\n//不规则数组\nint b[][];\nb =new int[3][];\nb[0]=new int[3];\nb[1]=new int[4];\nb[2]=new int[5];\n\n//注意声明变量时候没有分配内存，不需要指定大小，以下是错误示例\n//int e[5];\n//int[5] f;\n//int[5] g = new int[5];\n//int h[5] = new int[5];索引和遍历与C++相同。\nJCF:相当于C++的STL。JCF主要的数据结构实现类\n\n列表: \n(接口) \n) ,\n) \n\n\n\n集合:\n\n\n\n\n\n\n映射：\n\n\n\n\n\n\n\n\nJCF主要的算法类\n\n\nCollections:对Collection及其子类进行排序和查找操作\nComparable&lt;T&gt;(接口)：通过实现其中int compareTo(T obj)方法来实现自定义的排序；\n\n\n\n\n\n\n\n\n\n&gt;返回1，==返回0，&lt;返回-1\n\nComparator&lt;T&gt;(接口)：新建一个类来实现Comparator中的int compare(T obj1, T obj2)然后将该类的一个对象作为参数传入工具类的sort方法，这个对象叫做比较器。\n\n\n\n\n\n\n\n\n\n&gt;返回1，==返回0，&lt;返回-1\n\n\n文件操作java.io.File\n\nisDirectory是否是目录\nisFile是否是文件\ngetName获取文件名字\ngetParent获取上一层目录路径\ngetPath 获取这个文件的全路径\nlength获取文件的大小\nlastModified返回文件最后一次修改时间\n\njava.io(包括大部分文件操作)java.nio(Java7提供新IO包，是对原有的IO包的补充扩展)\n文本文件读写：读：\njavaimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.InputStreamReader;\n\npublic class TxtFileRead {\n    public static void main(String[] args) {\n        readFile1();\n        System.out.println(\"===================\");\n    }\n  //法1\n    public static void readFile1() {\n        FileInputStream fis = null;\n        InputStreamReader isr = null;\n        BufferedReader br = null;\n        try {\n            fis = new FileInputStream(\"c:/temp/abc.txt\"); // 节点类\n            isr = new InputStreamReader(fis, \"UTF-8\"); // 转化类\n            br = new BufferedReader(isr); // 装饰类\n            // 上面3行可以直接缩写为下面一行\n            // br = new BufferedReader(newInputStreamReader(newFileInputStream(\"c:/temp/abc.txt\"),\"UTF-8\"))\n            String line;\n            while ((line = br.readLine()) != null) // 每次读取一行\n            {\n                System.out.println(line);\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                br.close(); // 关闭最后一个类，会将所有的底层流都关闭\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n  //法2\n    public static void readFile2() {\n        String line;\n        // try-resource 语句，自动关闭资源\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(\"c:/temp/abc.txt\")))) {\n            while ((line = in.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n}写：\njavaimport java.io.*;\n\npublic class TxtFileWrite {\n    public static void main(String[] args) {\n        writeFile1();\n        System.out.println(\"===================\");\n    }\n  //法1\n    public static void writeFile1() {\n        FileOutputStream fos = null;\n        OutputStreamWriter osw = null;\n        BufferedWriter bw = null;\n        try {\n            fos = new FileOutputStream(\"c:/temp/abc.txt\"); // 节点类\n            osw = new OutputStreamWriter(fos, \"UTF-8\"); // 转化类\n            bw = new BufferedWriter(osw); // 装饰类\n            // 上面三行可替换为下面一行\n            // br = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(\"c:/temp/abc.txt\"),\"UTF-8\"))\n            bw.write(\"我们是\");\n            bw.newLine();\n            bw.write(\"Ecnuers.^^\");\n            bw.newLine();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                bw.close(); // 关闭最后一个类，会将所有的底层流都关闭\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n  //法2\n    public static void writeFile2() {\n        // try-resource 语句，自动关闭资源\n        try (BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(\"c:/temp/abc.txt\")))) {\n            bw.write(\"我们是\");\n            bw.newLine();\n            bw.write(\"Ecnuers.^^\");\n            bw.newLine();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n\n}二进制文件读写读：\njavaimport java.io.*;\n\npublic class BinFileRead {\n    public static void main(String[] args) throws Exception {\n        readFile();\n    }\n\n    public static void readFile() {\n        // try-resource 语句，自动关闭资源\n        try (DataInputStream dis = new DataInputStream(\n                new BufferedInputStream(new FileInputStream(\"c:/temp/def.dat\")))) {\n            String a, b;\n            int c, d;\n            a = dis.readUTF();\n            c = dis.readInt();\n            d = dis.readInt();\n            b = dis.readUTF();\n            System.out.println(\"a: \" + a);\n            System.out.println(\"c: \" + c);\n            System.out.println(\"d: \" + d);\n            System.out.println(\"b: \" + b);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n}写：\njavaimport java.io.*;\n\npublic class BinFileWrite {\n    public static void main(String[] args) throws Exception {\n        writeFile();\n        System.out.println(\"done.\");\n    }\n\n    public static void writeFile() {\n        FileOutputStream fos = null;\n        DataOutputStream dos = null;\n        BufferedOutputStream bos = null;\n        try {\n            fos = new FileOutputStream(\"c:/temp/def.dat\"); // 节点类\n            bos = new BufferedOutputStream(fos); // 装饰类\n            dos = new DataOutputStream(bos); // 装饰类\t\t\n\n            dos.writeUTF(\"a\");\n            dos.writeInt(20);\n            dos.writeInt(180);\n            dos.writeUTF(\"b\");\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                dos.close(); // 关闭最后一个类，会将所有的底层流都关闭\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n}压缩文件读写单个文件压缩：\njavaimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\nimport java.io.FileOutputStream;\n\npublic class SingleFileZip {\n    public static void main(String args[]) throws Exception {\n        File file = new File(\"c:/temp/abc.txt\"); // 定义要压缩的文件\n        File zipFile = new File(\"c:/temp/single2.zip\"); // 定义压缩文件名称\n\n        InputStream input = new FileInputStream(file); // 定义文件的输入流\n        ZipOutputStream zipOut = null; // 声明压缩流对象\n        zipOut = new ZipOutputStream(new FileOutputStream(zipFile));\n        zipOut.putNextEntry(new ZipEntry(file.getName())); // 设置ZipEntry对象\n        zipOut.setComment(\"single file zip\"); // 设置注释\n\n        // 压缩过程\n        int temp = 0;\n        while ((temp = input.read()) != -1) { // 读取内容\n            zipOut.write(temp); // 压缩输出\n        }\n        input.close(); // 关闭输入流\n        zipOut.close(); // 关闭输出流\n\n        System.out.println(\"single file zip done.\");\n    }\n}多个文件压缩\njavaimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\nimport java.io.FileOutputStream;\n\npublic class MultipleFileZip {\n    public static void main(String args[]) throws Exception { // 所有异常抛出\n        File file = new File(\"c:/temp/multiple\"); // 定义要压缩的文件夹\n        File zipFile = new File(\"c:/temp/multiple2.zip\"); // 定义压缩文件名称\n\n        InputStream input = null; // 定义文件输入流\n        ZipOutputStream zipOut = null; // 声明压缩流对象\n        zipOut = new ZipOutputStream(new FileOutputStream(zipFile));\n        zipOut.setComment(\"multiple file zip\"); // 设置注释\n\n        // 开始压缩\n        int temp = 0;\n        if (file.isDirectory()) { // 判断是否是文件夹\n            File lists[] = file.listFiles(); // 列出全部子文件\n            for (int i = 0; i &lt; lists.length; i++) {\n                input = new FileInputStream(lists[i]); // 定义文件的输入流\n                zipOut.putNextEntry(new ZipEntry(file.getName()\n                        + File.separator + lists[i].getName())); // 设置ZipEntry对象\n                System.out.println(\"正在压缩\" + lists[i].getName());\n                while ((temp = input.read()) != -1) { // 读取内容\n                    zipOut.write(temp); // 压缩输出\n                }\n                input.close(); // 关闭输入流\n            }\n        }\n        zipOut.close(); // 关闭输出流\n        System.out.println(\"multiple file zip done.\");\n    }\n}单个文件解压缩\njavaimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.OutputStream;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\npublic class SingleFileUnzip {\n    public static void main(String args[]) throws Exception {\n        // 待解压文件, 需要从zip文件打开输入流，读取数据到java中\n        File zipFile = new File(\"c:/temp/single.zip\"); // 定义压缩文件名称\n        ZipInputStream input = null; // 定义压缩输入流\n        input = new ZipInputStream(new FileInputStream(zipFile)); // 实例化ZIpInputStream\n        ZipEntry entry = input.getNextEntry(); // 得到一个压缩实体\n        System.out.println(\"压缩实体名称：\" + entry.getName()); // 获取压缩包中文件名字\n\n        // 新建目标文件，需要从目标文件打开输出流，数据从java流入\n        File outFile = new File(\"c:/temp/\" + entry.getName());\n        OutputStream out = new FileOutputStream(outFile); // 实例化文件输出流\n        int temp = 0;\n        while ((temp = input.read()) != -1) {\n            out.write(temp);\n        }\n        input.close(); // 关闭输入流\n        out.close(); // 关闭输出流\n        System.out.println(\"unzip done.\");\n    }\n}多个文件解压缩\njavaimport java.io.File;\nimport java.io.OutputStream;\nimport java.io.InputStream;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipInputStream;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\n\npublic class MultipleFileUnzip {\n    public static void main(String args[]) throws Exception {\n        // 待解压的zip文件，需要在zip文件上构建输入流，读取数据到Java中\n        File file = new File(\"c:/temp/multiple.zip\"); // 定义压缩文件名称\n        File outFile = null; // 输出文件的时候要有文件夹的操作\n        ZipFile zipFile = new ZipFile(file); // 实例化ZipFile对象\n        ZipInputStream zipInput = null; // 定义压缩输入流\n\n        // 定义解压的文件名\n        OutputStream out = null; // 定义输出流，用于输出每一个实体内容\n        InputStream input = null; // 定义输入流，读取每一个ZipEntry\n        ZipEntry entry = null; // 每一个压缩实体\n        zipInput = new ZipInputStream(new FileInputStream(file)); // 实例化ZIpInputStream\n\n        // 遍历压缩包中的文件\n        while ((entry = zipInput.getNextEntry()) != null) { // 得到一个压缩实体\n            System.out.println(\"解压缩\" + entry.getName() + \"文件\");\n            outFile = new File(\"c:/temp/\" + entry.getName()); // 定义输出的文件路径\n            if (!outFile.getParentFile().exists()) { // 如果输出文件夹不存在\n                outFile.getParentFile().mkdirs();\n                // 创建文件夹 ,如果这里的有多级文件夹不存在,请使用mkdirs()\n                // 如果只是单纯的一级文件夹,使用mkdir()就好了\n            }\n            if (!outFile.exists()) { // 判断输出文件是否存在\n                if (entry.isDirectory()) {\n                    outFile.mkdirs();\n                    System.out.println(\"create directory...\");\n                } else {\n                    outFile.createNewFile(); // 创建文件\n                    System.out.println(\"create file...\");\n                }\n            }\n            if (!entry.isDirectory()) {\n                input = zipFile.getInputStream(entry); // 得到每一个实体的输入流\n                out = new FileOutputStream(outFile); // 实例化文件输出流\n                int temp = 0;\n                while ((temp = input.read()) != -1) {\n                    out.write(temp);\n                }\n                input.close(); // 关闭输入流\n                out.close(); // 关闭输出流\n            }\n\n        }\n        input.close();\n    }\n}","slug":"Java学习笔记-二","date":"2022-05-11T15:24:00.000Z","categories_index":"Java","tags_index":"Java,文件操作,异常","author_index":"Ac-Accelerator"},{"id":"4fcfa8e6703310350c6e3442c24e0c97","title":"Java学习笔记(一)","content":"前言本篇不具体介绍Java的具体细节和语法，只记录在笔者眼中的Java和C++ 的相同和不同之处，因此需要有C++ 基础。\n类的结构和主函数\nmain函数的写法固定为:public static void main(string[] args)  \n\nJava文件必须以.java作为扩展名  \n\n一个Java文件只能有一个public class  \n\npublic class的名字必须和文件名字一样，大小写都要完全一致  \n\n一个文件可以有多个class，但是只能有一个是public。不提倡一个文件里面放多个类（内部类除外)  \n\nSystem.out.print()输出Systen.out.println()换行输出System.out.printf()格式化的输出，输出方式与C语言基本相同\n\n类是Java中的最基础逻辑单位  \n\nJava所有的内容都是需要放在类的范围中  \n内容不允许游离在类以外  \n换言之，Java项目就是由一个个类组成的\n\n\n类的构成\n\n成员变量/属性\n成员方法/函数 \n代码块\n\n\n一个class最多只能有一个main函数。类可以没有main函数，没有main函数的类就不能主动执行，但可以被动执行(被别人调用执行)。\n\n程序的入口都是main函数，这点和C/C++ 一致。有一点不同的是，Java要求所有程序都必须放在类对象中，即所有的代码都要放在class的所辖范围内。\n\n严格意义上说,main函数不属于这个类的所拥有函数。只是因为Java要求所有的内容都必须放置在class的范围内，所以main函数“寄居”在某一个class中。\n\nmain函数是一个Java程序的总入口。\n\nmain函数也无法被其他方法/类所调用。一个Java程序可以调用多个其他Java class。\n\nmain函数的形参传入方法和C++类似。\n\n\n数据类型和运算符基本数据类型：\n\nboolean布尔：\n只有true，或者false两种值，默认是false，严格大小写\n\n\nbyte字节：\n1 byte = 8 bits (8位)\n\n\n存储有符号的，以二进制补码表示的整数-最小值-128，最大值127，默认值0，超过范围会进行截断。\nbyte类型用在大型数组中可以显著节约空间，主要代替小整数，因为byte变量占用的空间只有int类型的四分之一\nbyte在二进制文件读写中使用较多\n\n\n整型\nshort短整数16位,2个字节,有符号的以二进制补码表示的整数,默认值为0\nint整数32位,4个字节,有符号的以二进制补码表示的整数,默认值为0\nlong长整数64位,8个字节,有符号的以二进制补码表示的整数,默认值为0L\n整型超过范围会报错，long类型的赋值最好在数的末尾加上L。\n\n\n浮点\nfloat单精度32位,4个字节，赋值必须在数值末尾加f\ndouble双精度64位，8个字节，赋值可省略末尾的d\n都不能用来表示很精确的数值，float转double会使尾数变多\n两个小数无限接近的时候，会直接认为两个数相等\n\n\nchar字符\n一个单一的16位Unicode字符\n赋值的时候可直接使用字符或者是Unicode编码\n\n\n\n运算符：    同C++\n选择与循环结构    同C++\n自定义函数\n函数必须放在类的范围内  \n修饰词(public 或者 static) 返回值 (int或者void)，函数名(形参列表){函数体}  \n通常情况下，我们都建议方法是public。  \n函数可以调用其他的函数。  \n重载同C++\n\n类和对象\n类的实例化：A obj = new A();  \nobj可以看作是内存中一个对象(包括若干个数据)的句柄  \n在C/C++中，obj称为指针，在Java中称为Reference  \n对象赋值是Reference赋值，而基本类型是直接值拷贝。基本类型的变量值小,可直拷贝;对象包含多个值，不易复制,赋值采用共享同一内存区域。\n类的成员变量如果没有被初始化，将默认为0\n\n构造函数和析构函数：  \n\n构造函数同C++，但没有析构函数。\n\nJava具有内存自动回收机制的，当变量退出其生命周期后,JVM会自动回收所分配的对象的内存。所以不需要析构函数来释放内存变量的生命周期：同C++\nthis指针：  \n\n指向本类中的成员变量 this.member\n指向本类中的成员方法 this.methord()\n可以当做构造函数使用 this()\n\n继承、接口和抽象类继承：与C++相比：\n\n使用 extends 表示继承。\n没有诸如private，protect、public继承方式。\n没有关于继承方式的描述。\n每个类都只能继承一个类。\n访问权限除了private，protect、public，还有一个default，权限介于protect和private之间。前三个和C++相似，default意思是，只有在同一个包(package) 内才能访问。类成员的访问权限默认是default，通常不写。\n\n如下代码段就表示Derived类继承于Base类。\njavapublic class Derived extends Base{\n    private int num = 20;\n}特性：\n\n如果不写extends，Java类都默认继承java.lang.Object类\nJava所有类从java.lang.Object开始，构建出一个类型继承树\nObject类里面默认就有clone, equals, finalize, getClass,hashCode, toString等方法\n每个子类的构造函数的第一句话，都默认调用父类的无参数构造函数super()，除非子类的构造函数第一句话是super，而且super语句必须放在第一条，不会出现连续两条super语句。\n\n抽象类：  \n\n如果类中存在没有实现的方法，那所在的类就要被定义为抽象类。\n使用abstract关键字来声明类和类的abstract方法。\n子类可以继承于抽象类，但是一定要实现父类们所有abstract的方法。如果不能完全实现，那么子类也必须被定义为抽象类。\n有构造函数不能被new。\n\n例如这里定义了一个叫Shape的抽象类，以及类里面calArea抽象方法：\njavapublic abstract class Shape {\n    int area;\n    public abstract void calArea();\n}接口：   \n\n类似于C++由虚函数和若干静态常量成员组成的类。\n由关键字interface定义。  \n接口可以继承(多个)接口，多个接口之间用逗号隔开，没有实现的方法将会叠加。\n类只可以继承(extends)一个类，但是可以实现(implements)多个接口，多个接口之间用逗号隔开。继承和实现可以同时，但extends 必须写在implements前。\n类实现接口，就必须实现所有未实现的方法。如果没有全部实现，那么只能成为一个抽象类。\n接口里可以定义变量，但是会被编译器当做常量处理\n没有构造函数且不能被new\n\n例如：\njava// 接口\ninterface Animal {\n    public void eat();\n    public void move();\n}\n\n// 实现Animal接口的抽象类\nabstract class LandAnimal implements Animal {\n    public abstract void eat();\n\n    public void move() {\n        System.out.println(\"I can walk by feet\");\n    }\n}\n\n// 继承抽象类并且实现了抽象方法\nclass GrassEating extends LandAnimal {\n    public void eat() {\n        System.out.println(\"I eat grass\");\n    }\n}\n\n// 继承完整类\nclass Rabbit extends GrassEating {\n    public void climb() {\n        System.out.println(\"Rabbit: I can climb\");\n    }\n\n    public static void main(String[] args) {\n        Rabbit t = new Rabbit();\n        t.eat();\n        t.climb();\n        t.move();\n    }\n}转型、多态和契约设置转型：\n\n通过Reference之间的赋值来实现转型。\n类型可以相互转型，但是只限制于有继承关系的类。\n子类可以转换成父类，而父类不可以转为子类。\n子类继承父类所有的成员，子类可以变成父类(向上转型);\n从父类直接变成子类(向下转型)则不允许。\n如果这个父类本身就是从子类转化过来的，则也可以向下转型。\n\n多态：  \n\n和C++用虚函数实现不同，Java是通过接口和函数重写实现的。\n以统一的接口来操纵某一类中不同的对象的动态行为。\n\n契约:  \n\n规定规范了对象应该包含的行为方法\n接口定义了方法的名称、参数和返回值，规范了派生类的行为\n基于接口，利用转型和多态，不影响真正方法的调用，成功地将调用类和被调用类解耦(decoupling)\n\nstatic、final和常量static在类中的表现同C++。\n\nstatic块\n只在类第一次被加载时调用。\n在程序运行期间，这段代码只运行一次。一执行顺序:static块&gt;匿名块&gt;构造函数。\n\n\n\n单例模式：保证一个类只有一个对象\n\n采用static来共享对象实例\n采用private构造函数，防止外界new操作\n定义一个函数获取该static实例\n\nfinal：  \n\n位置不一样，C++是将final关键字放在后面，Java则是放在前面。\nJava的final用来修饰类、方法时，作用和C++差不多。\n用来修饰基本类型的时候，就和C++的const一样。\n如果作用于对象,则对象的指针的值不可改变，但是对象的数据可以改变。相当于C++的指针常量。\n\njavafinal public class GrassEating extends LandAnimal {\n    final int const_int=100;\n    final public void eat() {\n        final GrassEating const_object=new GrassEating();\n        System.out.println(\"I eat grass\");\n    }\n}常量：  \n\n使用public static final来修饰常量\n常量命名最好大写\n接口里定义的变量默认是常量，是public static final的缺省\n常量式赋值创建，放在栈内存(将被常量化).如：\nInteger a = 10;  \nString b =“abc”;\n\n\nnew对象进行创建，放在堆内存(不会常量化)。如：  \nInteger c = new Integer(10);\n\n\nString d = new String(“abc”);\n\n\n基本类型和包装类进行比较,包装类自动拆箱\n\n常量池：Java为很多基本类型的包装类/字符串常量都建立常量池保存在编译期间就已经确定的数据是一块特殊的内存相同的值只存储一份，节省内存，共享访问基本类型的包装类Boolean，Byte，Short，Integer，Long，Character \n\nBoolean: true, false\nByte : -128~127\nCharacter : 0~127\nShort,Int,Long: -128~127\n\n不可变对象：  \n\n所有的属性都是final和private的\n不提供setter方法\n类是final的，或者所有的方法都是final\n\npackage、import和classpathpackage和C++中的namespace相似。但是包名必须和目录名相同且该语句必须放在文件的第一行。如package neuq.cs.test;表示该文件是在 neuq/cs/test目录下。类的全称为”包名+类名”\nimport语句的使用和python相似。但仍需注意几个地方。  \n\nimport必须全部放在package之后，类定义之前。多个import的顺序无关。\n可以用*来引入一个目录下的所有类，比如import java.lang.*;此意思是引入java.lang下面所有的类文件，但不包括java.lang下面所有的子目录文件，即不能递归包含各个目录下的文件。\nimport尽量精确，不推荐用*，以免新增的同名程序会使得老程序报错。\n\njar：类似于C++的库文件。jar文件是Java所特有的一种文件格式，用于可执行程序文件的传播。jar文件实际上是一组class文件的压缩包。项目引入一个jar文件,就可以使用jar文件中所有类(.class文件),无需类的源码(.java文件)\n","slug":"Java学习笔记-一","date":"2022-05-09T08:43:00.000Z","categories_index":"Java","tags_index":"Java","author_index":"Ac-Accelerator"},{"id":"1400880ea83318bcbc365c9ffe072342","title":"计算机网络(二)","content":"数据链路层数据链路层负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报。  \n基本概念结点:主机、路由器链路:网络中两个结点之间的物理通道，链路的传输介质主要有双绞线、光纤和微波。分为有线链路、无线链路。数据链路:网络中两个结点之间的逻辑通道，把实现控制数据传输协议的硬件和软件加到链路上就构成数据链路帧︰链路层的协议数据单元，封装网络层数据报。\n功能数据链路层在物理层提供服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。  \n封装成帧封装成帧就是在一段数据的前后部分添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。首部和尾部包含许多的控制信息，他们的一个重要作用:帧定界（确定帧的界限）。\n帧同步:接收方应当能从接收到的二进制比特流中区分出帧的起始和终止。\n组帧的四种方法:（如何实现透明传输）  \n\n字符计数法:帧首部使用一个计数字段(第一个字节，八位)来标明帧内字符数。（若第一个字节出错，将导致灾难性的后果）    \n字符填充法:使用两个控制字符：SOH和EOT来标识帧的开始和结束。虽然在纯ASCII码传输中，这两个控制字符不会从键盘中被输入，不会引发帧定界错误，但是在非ASCII码传输中，可能出现帧中的数据部分的某个字节可能与帧的控制信息相同。这时候就要在该字节前添加转义字符ESC实现透明传输。（PPP协议异步传输）  \n零比特填充法:帧首部和尾部都是01111110。（PPP协议同步传输）在发送端，扫描整个信息字段，只要连续5个1，就立即填入1个0。在接收端收到一个帧时，先找到标志字段确定边界，再用硬件对比特流进行扫描。发现连续5个1时，就把后面的0删除。   \n违规编码法体现在物理层中。例如在曼彻斯特编码中，连续的高电平或连续第低电平是违规的。把这两种违规编码作为帧的起始和终止（MAC帧）。\n\n差错控制传输中的差错都是由于噪声引起的。位错：0→1或1→0  \n检错编码：  \n\n奇偶校验法（帧中的1的个数是奇数还是偶数）  \nCRC循环冗余码：  \n对发送端：  \n要传的数据%生成多项式=FCS帧检验序列(冗余码)最终发送的数据=要传的数据+FCS帧检验序列(冗余码)\n\n\n对接收端：  \n如果接受到的数据能被生成多项式整除，则有无限接近于1的概率判定传输无错。\n\n\n\n\n\n\n\n\n\n\n\n提示\n在数据链路层使用CRC检验，能够实现无比特差错的传输，但这不是可靠传输。可靠传输还要处理帧丢失、帧重复、帧失序等问题。过去OSI打算在数据链路层实现可靠传输，除了CRC检验外，还有帧编号、确认和重传机制。而现在由于性能问题，做了区别对待：对于有线传输，可靠传输的实现被放到了传输层；而对于无线传输，可靠传输的实现放到了数据链路层。\n\n\n纠错编码：海明码\n流量控制较高的发送速度和较低的接收能力的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作。数据链路层流量控制手段:接收方收不下就不回复确认。\n流量控制方法：停止-等待协议： \n\n条件：每个帧及其对应的ASK都需要进行编号  \n发送方：  \n每发送完一个帧就停止发送，并启动一个超时计时器，并且等待对方的确认。若在规定时间内收到确认则发送下一个帧。  \n若超出规定时间，则重新发送，若收到不属于当前传输的帧的确认，则直接忽略该确认。\n\n\n接受方：  \n每接受到一个帧就返回一个确认。\n若收到一个和之前收到过的某个帧相同的帧，则丢弃该帧，并重新发送之前那个帧的确认。\n\n\n\n以下两个协议的帧的编号是可以重复利用的。后退N帧协议（GBN）：\n\n发送窗口(多个):发送方维持一组连续的允许发送的帧的序号。发送窗口的长度应该大于等于1且小于等于帧的最大编号(从0开始编号)   \n接收窗口（单个）:接收方维持的一个允许接收帧的序号。  \n发送方：  \n上层的调用：上层要发送数据时，发送方先检查发送窗口是否已满，如果未满，则产生一个帧并将其发送;如果窗口已满,发送方只需将数据返回给上层，暗示上层窗口已满。上层等一会再发送。(实际实现中，发送方可以缓存这些数据，窗口不满时再发送帧）。  \n收到了一个ACK：GBN协议中，对n号帧的确认采用累积确认的方式，标明接收方已经收到n号帧和它之前的全部帧。  \n超时事件：协议的名字为后退N帧/回退N帧，来源于出现丢失和时延过长帧时发送方的行为。就像在停等协议中一样，定时器将再次用于恢复数据帧或确认帧的丢失。如果出现超时，发送方重传所有已发送但未被确认的帧。\n\n\n接收方：  \n如果正确收到n号帧，并且按序，那么接收方为n帧发送一个ACK，并将该帧中的数据部分交付给上层。  \n其余情况都丢弃帧，并为最近按序接收的帧重新发送ACK。接收方无需缓存任何失序帧，只需要维护一个信息:expectedseqnum(下一个按序接收的帧序号)。\n\n\n\n选择重传协议（SR）：GBN协议中，如果某个帧出错可能会导致批量重传。而在SR协议中，只重传出错的帧。  \n\n发送窗口长度等于接收窗口长度等于(帧的最大编号(从0开始)+1)/2。  \n发送方： \n上层的调用（同GBN）  \n收到了一个ACK：如果收到ACK，如果该帧序号在窗口内，则将那个被确认的帧标记为已接收。如果该帧序号是窗口的下界（还留在窗口中的且是最早进入窗口的序号），则窗口下界移动到下一个未确认帧处。如果窗口移动了并且有序号在窗口内的未发送帧，则发送这些帧。  \n超时事件：每个帧都有自己的定时器，一个超时事件发生后只重传一个帧。\n\n\n接受方\n返回每一个收到的帧的ASK。失序的帧将被缓存，并返回给发送方一个该帧的ASK，直到窗口下界的帧收到为止，这时才可以将一批帧按序交付给上层，然后移动滑动窗口。\n\n\n\n信道划分、介质访问控制（使用广播信道的数据链路层）这些技术使用在局域网的数据链路层中。\n信道划分介质访问控制:将使用介质的每个设备与来自同一信道上的其他设备的通信隔离开，把时域和频域资源合理地分配给网络上的设备。\n多路复用技术：把多个信号组合在一条物理信道上进行传输，使得多个计算机或终端设备共享信道资源,提高信道利用率。即把一条广播信道，逻辑上分成几条用于两个节点之间通信的互不干扰的子信道，实际就是把广播信道转变为点对点信道。  \n频分多路复用（FDM）：用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽(颜率带宽)资源。  \n时分多路复用（TDM）：将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙,所有用户轮流占用信道。  \n统计时分复用（STDM）：各用户有了数据就随时发往集中器的输入缓存，然后集中器按顺序依次扫描输入缓存，把缓存中的输入数据放入STDM帧中，一个STDM帧满了就发出。STDM帧不是固定分配时隙,而是按动态分配时隙。  \n波分多路复用（WDM）：波分多路复用就是光的频分多路复用，在一根光纤中传输的多种不同波长（频率）的光信号互不干扰，最后再用波长分解复用器将各路波长分解出来。  \n码分多路复用：码分多址（CDMA）是码分复用的一种方式。1个比特分为多个码片/芯片(chip)，每一个站点被指定一个唯一的m位的芯片序列。发送1时站点发送芯片序列，发送0时发送芯片序列反码。要求： \n\n发送:多个站点同时发送数据的时候，要求各个站点芯片序列相互正交  \n合并:各路数据在信道中被线性相加  \n分离:合并的数据和源站规格化内积\n\n\n轮询访问介质访问控制（环形网）：令牌传递协议、轮询协议\n\n介质访问控制协议纯ALOHA协议:不监听信道，不按时间槽发送，随机重发。如果发生冲突，接收方在就会检测出差错，然后不予确认，发送方在一定时间内收不到就判断发生冲突。   \n时隙ALOHA协议:把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道,若发生冲突，则必须等到下一个时间片开始时刻再发送。\n\n载波监听多路访问协议(CSMA):每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据。多点接入，表示许多计算机以多点接入的方式连接在一根总线上。若信道空闲，则发送完整帧；如果信道忙，则推迟发送。这个协议需要一边发送一边监听信道，是个半双工协议，只能在半双工信道上使用。\n缺点：发生冲突后还是要坚持把数据帧发送完，造成了浪费。？  \n1-坚持CSMA:\n\n如果一个主机要发送消息，那么它先监听信道。\n空闲则直接传输，不必等待。忙则一直监听，直到空闲马上传输。  \n如果有冲突（一段时间内未收到肯定回复），则等待一个随机长的时间（截断二进制指数退避）再监听，重复上述过程。 \n优点:只要媒体空闲，站点就马上发送，避免了媒体利用率的损失。  \n缺点:假如有两个或两个以上的站点有数据要发送，冲突就不可避免。\n\n非坚持CSMA:\n\n如果一个主机要发送消息，那么它先监听信道。\n空闲则直接传输，不必等待。忙则等待一个随机的时间（截断二进制指数退避）之后再进行监听。 \n优点:采用随机的重发延迟时间可以减少冲突发生的可能性。  \n缺点:可能存在大家都在延迟等待过程中，使得媒体仍可能处于空闲状态，媒体使用率降低。\n\np-坚持CSMA:\n\n如果一个主机要发送消息，那么它先监听信道。\n空闲则以p概率直接传输，不必等待;概率1-p等待到下一个时间槽再传输。忙则等待一个随机的时间之后再进行监听。  \n优点:既能像非坚持算法那样减少冲突，又能像1-坚持算法那样减少媒体空闲时间的这种方案。\n\n\nCSMA/CD协议：(常用于总线以太网、树形网络)CSMA/CD  \nCSMA/CA协议：(常用于无线局域网)CSMA/CA\n以太网以太网提供无连接、不可靠的服务无连接:发送方和接收方之间无“握手过程”。不可靠:不对发送方的数据帧编号，接收方不向发送方进行确认，差错帧直接丢弃，差错纠正由高层负责。  \n\n\n\n\n\n\n\n\n\n以太网只实现无差错接收，不实现可靠传输。\n10BASE-T以太网:10BASE-T是传送基带信号的双绞线以太网，T表示采用双绞线，现10BASE-T采用的是无屏蔽双绞线(UTP），传输速率是10Mb/s。  \n\n\n\n\n\n\n\n\n\n物理上采用星型拓扑，逻辑上总线型，每段双绞线最长为100m。采用曼彻斯特编码。采用CSMA/CD介质访问控制。\n100BASE-T以太网:在双绞线上传送100Mb/s基带信号的星型拓扑以太网，仍使用IEEE802.3的CSMA/CD协议。支持全双工和半双工，可在全双工方式下工作而无冲突。  \n吉比特以太网:在光纤或双绞线上传送1Gb/s信号。支持全双工和半双工，可在全双工方式下工作而无冲突。  \n10吉比特:10吉比特以太网在光纤上传送10Gb/s信号。只支持全双工，无争用问题。\n链路层设备网段（冲突域）:一般指一个计算机网络中使用同一物理层设备(传输介质，中继器，集线器等)能够直接通讯的那一部分。\n网桥：网桥根据MAC帧的目的地址对帧进行转发和过滤。当网桥收到一个帧时，并不向所有接口转发此帧，而是先检查此帧的目的MAC地址，然后再确定将该帧转发到哪一个接口，或者是把它丢弃（即过滤）。优点:  \n\n过滤通信量，增大吞吐量。  \n扩大了物理范围。  \n提高了可靠性。  \n可互连不同物理层、不同MAC子层和不同速率的以太网。\n\n网桥分类  \n\n透明网桥:以太网上的站点并不知道所发送的帧将经过哪几个网桥，是一种即插即用设备  \n源路由网桥:在发送帧时，把详细的最佳路由信息（路由最少/时间最短）放在帧的首部中。\n\n多接口网桥――以太网交换机直通式交换机：  \n\n查完目的地址（6B）就立刻转发。  \n延迟小，可靠性低，无法支持具有不同速率的端口的交换。\n\n存储转发式交换机:  \n\n将帧放入高速缓存，并检查否正确，正确则转发，错误则丢弃。  \n延迟大，可靠性高，可以支持具有不同速率的端口的交换。\n\n","slug":"计算机网络-二","date":"2022-05-08T03:29:00.000Z","categories_index":"网络","tags_index":"网络,数据链路层","author_index":"Ac-Accelerator"},{"id":"f667b4d44d41991982b8841954899495","title":"计算机网络(一)","content":"计算机网络初步概念计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。\n计算机网络是互连的、自治的计算机集合。互连:互联互通  通信链路自治:即无主从关系  \n功能计算机网络的功能包括：  \n\n数据通信  \n资源共享（硬件、软件、数据）  \n分布式处理（多台计算机各自承担同一工作的不同部分）  \n提高可靠性（替代机）  \n负载均衡。\n\n组成组成部分：硬件 软件 协议  \n工作方式：边缘部分（用户直接使用）C/S方式 or P2P方式核心部分（为边缘部分服务） \n功能组成:通信子网(实现数据通信)  包括应用层、表示层、会话层资源子网(实现资源共享/数据处理)  包括网络层、数据链路层、物理层（传输层是两个子网之间的接口）\n分类按分布范围分：广域网WAN、城域网MAN、局域网WAN、个人区域网PAN按使用者分: 公用网、专用网按交换技术分： 电路交换、报文交换、分组交换按拓扑结构分：总线型、星型、环形、网状型（常用于广域网）按传输技术分：广播式网络（共享公共通信通道）、点对点网络（使用分组存储转发和路由选择机制）\n速率相关性能指标速率即数据率或称数据传输率或比特率。连接在计算机网络上的主机在数字信道上传送数据位数的速率。单位是b/s，kb/s，Mb/s，Gb/s，Tb/s。单位之间是以进行换算。（注意区分描述数据存储时使用的KB、MB、GB、TB，它们之间是以进行换算）  \n带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。单位是“比特每秒”，b/s，kb/s，Mb/s，Gb/s。网络设备所支持的最高速度   \n吞吐量表示在单位时间内通过某个网络或信道、接口的数据量。单位b/s，kb/s，Mb/s等。吞吐量受网络的带宽或网络的额定速率的限制。\n时延、时延带宽积、RTT和利用率时延：  \n\n发送时延（传输时延） ：从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需的时间。（数据大小信道带宽）  \n传播时延:取决于电磁波的传播速度和链路的长度  （信道长度电磁波在信道上传播的速率）  \n排队时延：等待输入/输出链路可用的时间  \n处理时延：检查错误，找出口的时间。\n\n时延带宽积：以比特为单位的链路长度传播时延带宽\n往返时间RTT:从发送方发送数据开始，到发送方收到接收方的确认（接收方收到数据后立即发送确认)总共经历的时延。往返传播时延传播时延末端处理时间RTT越大，在收到确认之前，可以发送的数据越多。  \n利用率：信道利用率有数据通过时间总时间网络利用率=信道利用率加权平均值\n利用率趋向于1时，时延急剧增大，传输效率反而下降。\n网络体系结构分层结构、协议、接口、服务分层的原因：发送文件前要完成的工作:(1)发起通信的计算机必须将数据通信的通路进行激活。(2)要告诉网络如何识别目的主机。(3)发起通信的计算机要查明目的主机是否开机，并且与网络连接正常。(4)发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作。(5）确保差错和意外可以解决。  \n分层的基本原则：(1)各层之间相互独立，每层只实现一种相对独立的功能。(2)每层之间界面自然清晰，易于理解，相互交流尽可能少。(3)结构上可分割开。每层都采用最合适的技术来实现。(4)保持下层对上层的独立性，上层单向使用下层提供的服务。(5)整个分层结构应该能促进标准化工作。\n分层的相关概念：实体:第n层中的活动元素称为n层实体。同一层的实体叫对等实体。协议:为进行网络中的对等实体数据交换而建立的规则、标准或约定称为网络协议。（水平 ）协议包括：    \n\n语法:规定传输数据的格式  \n语义:规定所要完成的功能  \n同步:规定各种操作的顺序\n\n接口（访问服务点SAP):上层使用下层服务的入口。服务:下层为相邻上层提供的功能调用。（垂直）SDU服务数据单元:为完成用户所要求的功能而应传送的数据。PCI协议控制信息:控制协议操作的信息。PDU协议数据单元:对等层次之间传送的数据单位。  \n\n\n\n\n\n\n\n\n\n网络体系结构是从功能上描述计算机网络结构。计算机网络体系结构简称网络体系结构是分层结构。每层遵循某个/些网络协议以完成本层功能。计算机网络体系结构是计算机网络的各层及其协议的集合。第n层在向n+1层提供服务时，此服务不仅包含第n层本身的功能，还包含由下层服务提供的功能。仅仅在相邻层间有接口，且所提供服务的具体实现细节对上一层完全屏蔽。体系结构是抽象的，而实现是指能运行的一些软件和硬件。  \nOSI(开放系统互联)参考模型七层结构： \n\n应用层  \n表示层  \n会话层  \n传输层  \n网络层  \n数据链路层  \n物理层\n\n数据链路层与其以上层不一样的地方就是：数据链路层会在其上一层的PDU的首尾都加上信息，而其它层只会在首部加信息。物理层不会对上层信息进行处理。   \n应用层：所有能和用户交互产生网络流量的程序。  \n表示层：用于处理在两个通信系统中交换信息的表示方式(语法和语义)功能一:数据格式变换功能二:数据加密解密功能三:数据压缩和恢复  \n会话层：向表示层实体/用户进程提供建立连接并在连接上有序地传输数据。这是会话，也是建立同步(SYN)功能一:建立、管理、终止会话功能二:使用校验点可使会话在通信失效时从校验点/同步点继续恢复通信，实现数据同步。  \n传输层：负责主机中两个进程的通信，即端到端的通信。传输单位是报文段或用户数据报。功能一:可靠传输(TCP)、不可靠传输(UTP)功能二:差错控制功能三:流量控制功能四:复用分用\n\n\n\n\n\n\n\n\n\n复用:多个应用层进程可同时使用下面运输层的服务。分用:运输层把收到的信息分别交付给上面应用层中相应的进程。\n网络层：主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务网络层传输单位是数据报。功能一:路由选择功能二:流量控制功能三:差错控制功能四:拥塞控制  \n\n\n\n\n\n\n\n\n\n若所有结点都来不及接受分组,而要丢弃大量分组的话，网络就处于拥塞状态。因此要采取一定措施,缓解这种拥塞。\n数据链路层：主要任务是把网络层传下来的数据报组装成帧。数据链路层/链路层的传输单位是帧。功能一:成帧（定义帧的开始和结束)功能二:差错控制(帧错和位错)功能三:流量控制功能四:控制对信道的访问\n物理层：主要任务是在物理媒体上实现比特流的透明传输。物理层传输单位是比特。透明传输:指不管所传数据是什么样的比特组合,都应当能够在链路上传送。功能一:定义接口特性功能二:定义传输模式(单工、半双工、双工)功能三:定义传输速率功能四:比特同步功能五:比特编码  \nTCP/IP和5层参考模型TCP/IP四层结构：  \n\n应用层  \n传输层  \n网际层  \n网络接口层\n\n五层结构：  \n\n应用层  \n传输层  \n网络层  \n数据链路层  \n物理层\n\n物理层基本概念物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层主要任务:确定与传输媒体接口有关的一些特性定义标准。机械特性定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况。电气特性规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制等。功能特性指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途。规程特性定义各条物理线路的工作规程和时序关系。\n数据通信基础通信的目的是传送消息。数据:传送信息的实体，通常是有意义的符号序列。信号:数据的电气/电磁的表现，是数据在传输过程中的存在形式。  \n\n数字信号:代表消息的参数取值是离散的。  \n模拟信号:代表消息的参数取值是连续的。\n\n信源:产生和发送数据的源头。信宿:接收数据的终点。信道:信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。  \n通信方式：  \n\n单工通信只有一个方向的通信而没有反方向的交互，仅需要一条信道。  \n半双工通信通信的双方都可以发送或接收信息，但任何一方都不能同时发送和接收，需要两条信道  \n全双工通信通信双方可以同时发送和接受信息，也需要两条信道。\n\n数据传输方式：  \n\n串行传输：速度慢，费用低，适合远距离  \n并行传输：速度快，费用高，适合近距离\n\n码元、波特、速率、带宽码元是指用一个固定时长的信号波形（数字脉冲），代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，而该时长称为码元宽度。当码元的离散状态有M个时(M大于2)，此时码元为M进制码元。1个码元可以携带多个比特的信息量。例如，在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态。速率也叫数据率，是指数据的传输速率，表示单位时间内传输的数据量。可以用码元传输速率和信息传输速率表示。码元传输速率别名码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数(也可称为脉冲个数或信号变化的次数)，单位是 波特（Baud） 。1波特表示数字通信系统每秒传输一个码元。这里的码元可以是多进制的，也可以是二进制的，但码元速率与进制数无关。信息传输速率别名信息速率、比特率等，表示单位时间内数字通信系统传输的二进制码元个数（即比特数)单位是比特/秒(b/s) 。带宽表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”，常用来表示网络的通信线路所能传输数据的能力。单位是b/s。\n奈氐准则和香农定理码间串扰:接收端收到的信号波形失去了码元之间清晰界限的现象。奈氏准则:在理想低通（无噪声，带宽受限)条件下，为了避免码间串扰，极限码元传输速率为2W Baud，W是信道带宽，单位是Hz。\n\n\n\n\n\n\n\n\n\n在任何信道中，码元传输的速率是有上限的。若传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能。信道的频带越宽(即能通过的信号高频分量越多)，就可以用更高的速率进行码元的有效传输。奈氏准则给出了码元传输速率的限制，但并没有对信息传输速率给出限制。由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多个比特的信息量，这就需要采用多元制的调制方法。\n噪声存在于所有的电子设备和通信信道中。由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但是噪声的影响是相对的，若信号较强，那么噪声影响相对较小。因此，信噪比就很重要。信噪比=信号的平均功率/噪声的平均功率，常记为S/N，并用分贝（dB）作为度量单位，即:信噪比香农定理:在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。信道的极限数据传输速率(b/s)\n\n\n\n\n\n\n\n\n\n信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了。只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现无差错的传输。香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少。从香农定理可以看出，若信道带宽W或信噪比S/N没有上限(不可能)，那么信道的极限信息传输速率也就没有上限。\n编码和调制基带信号将数字信号1和0直接用两种不同的电压表示，再送到数字信道上去传输（基带传输）。来自信源的信号，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的直接表达了要传输的信息的信号，比如我们说话的声波就是基带信号。宽带信号将基带信号进行调制后形成的频分复用模拟信号，再传送到模拟信道上去传输（宽带传输）把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。\n\n\n\n\n\n\n\n\n\n在传输距离较近时，计算机网络采用基带传输方式(近距离衰减小，从而信号内容不易发生变化)在传输距离较远时，计算机网络采用宽带传输方式(远距离衰减大，即使信号变化大也能最后过滤出来基带信号)\n数字数据编码为数据信号非归零编码【NRZ】：高1低0，编码容易实现，但没有检错功能，且无法判断一个码元的开始和结束，以至于收发双方难以保持同步。归零编码【RZ】：信号电平在一个码元之内都要恢复到零的这种编码成编码方式。反向不归零编码【NRZ1】：信号电平翻转表示o，信号电平不变表示1。曼彻斯特编码将一个码元分成两个相等的间隔,前一个间隔为低电平后一个间隔为高电平表示码元1;码元0则正好相反。也可以采用相反的规定。该编码的特点是在每一个码元的中间出现电平跳变，位中间的跳变既作时钟信号（可用于同步）,又作数据信号,但它所占的频带宽度是原始的基带宽度的两倍。每一个码元都被调成两个电平,所以数据传输速率只有调制速率的1/2。差分曼彻斯特编码同1异0常用于局域网传输，其规则是:若码元为1，则前半个码元的电平与上一个码元的后半个码元的电平相同，若为0，则相反。该编码的特点是，在每个码元的中间,都有一次电平的跳转，可以实现自同步，且抗干扰性强于曼彻斯特编码。4B/5B编码：比特流中插入额外的比特以打破一连串的0或1，就是用5个比特来编码4个比特的数据，之后再传给接收方，因此称为4B/5B。编码效率为80%。\n数字数据调制为模拟信号调幅、调频、调相、调幅+调相。\n模拟数据编码为数字信号最典型的例子就是对音频信号进行编码的脉码调制(PCM)，在计算机应用中，能够达到最高保真水平的就是PCM编码，被广泛用于素材保存及音乐欣赏，CD、DVD以及我们常见的WAV文件中均有应用。它主要包括三步:抽样、量化、编码。采样频率最高频率\n","slug":"计算机网络(一)","date":"2022-05-05T02:13:00.000Z","categories_index":"网络","tags_index":"网络,网络体系结构,物理层","author_index":"Ac-Accelerator"},{"id":"71d1afeec993a23db80ca1627d2eb461","title":"网页浮动布局","content":"多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动\n浮动先用标准流的父元素排列上下位置,之后内部子元素采取浮动排列左右位置。\nfloat属性定义浮动。属性值有left和right。\n浮动特性\n脱离标准普通流的控制，移动到指定位置(俗称脱标)  \n浮动的盒子不再保留原先的位置\n如果多个盒子都设置了浮动，则它们会按照属性值一行内显示并且顶端对齐排列。\n浮动的元素是互相不会有缝隙，如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐。\n任何元素都可以浮动。不管原先是什么模式的元素，添加浮动之后具有行内块元素相似的特性。\n浮动的盒子只会影响浮动盒子后面的标准流不会影响前面的标准流。\n\n清除浮动使用clear属性清除浮动，属性值有left、right、both(常用)。\n由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为0时，就会影响下面的标准流盒子。\n清除浮动的本质是清除浮动元素造成的影响。如果父盒子本身有高度，则不需要清除浮动。清除浮动之后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了。\n清除浮动常用策略：\n\n额外标签法会在浮动元素末尾添加一个空的块级元素标签。例如&lt; divstyle=” clear:both” &gt; &lt; /div &gt;，或者其他标签(如&lt; br /&gt;等)缺点是结构性较差。  \n给父级元素添加overflow:hidden属性，缺点是无法显示溢出部分。  \n对父元素使用类选择器添加如下CSS样式\n\ncss.clearfix:after {\n    content : \"\";\n    display : block;\n    height: 0;\n    clear : both;\n    visibility: hidden;\n}\n.clearfix {\n    *zoom : 1;\n}对父元素使用类选择器添加如下CSS样式\ncss.clearfix:before, \n.clearfix:after {\n    content : \" \";\n    display: table;\n}\n.clearfix:after {\n    clear: both;\n}\n.clearfix {\n    zoom: 1;\n}","slug":"CSS网页浮动布局","date":"2022-04-04T16:57:37.000Z","categories_index":"前端","tags_index":"CSS","author_index":"Ac-Accelerator"},{"id":"2cd531c7170c2dbe47cea834debb4679","title":"CSS网页标准布局和美化","content":"&gt;网页布局就是利用CSS摆盒子。\n布局盒子边框border：&lt;line-width&gt; || &lt;line-style&gt; || &lt;color&gt;\n第一个是盒子边框的粗细，有thin、medium、thick等预设值，还可以是带单位的数值第二个是盒子边框的样式none、hidden、dotted、dashed、solid、double、groove、ridge、inset、outset。第三个是颜色。\ncss.test {\n    border: 5px solid #000;\n}\n.test2 {\n    margin-top: 10px;\n    border: 5px solid;\n    color: #f00;\n}相关的标签还有border-top、border-right、border-bottom、border-left，属性都是一样的。\n另外，border-collapse属性可以用来合并相邻表格的边框，以至于不会太粗。属性值为collapse。\n加了边框会可能增加盒子的实际大小，要根据具体情况缩小盒子的大小。\n盒子内边距padding属性修改内边距。属性值是具体的数值或百分比。  \npadding可以有一到四个属性值：只有一个值，代表所有方向上的内边距。有两个值，前一个代表上下，后一个代表左右。三个值，前一个代表上边距，中间代表左右，后一个代表下边距。四个值，分别代表上、右、下、左四个方向。  \n相关的标签还有padding-top、padding-right、padding-bottom、padding-left。\n加了内边距会可能增加盒子的实际大小，要根据具体情况缩小盒子的大小。\n盒子外边距margin属性修改内边距。属性值是具体的数值或百分比，也可以是预设的auto。margin可以有一到四个属性值,具体和padding一样。\n其他的相关属性还有margin-top、margin-right、margin-bottom、margin-left。\n常用做使块级盒子水平居中。但是盒子的宽度width必须指定，左右外边距都设置为auto。\n注意：父元素和子元素同时存在上外边距的时候，父元素会坍塌较大的外边距值。这种情况叫做嵌套块元素垂直外边距的塌陷。解决办法：为父元素定义上边框或上内边框，或添加overflow:hidden属性。\n清除内外边距在实际开发过程中，经常使用如下CSS样式,使原本HTML标签自带的属性消失，从而更好的自定义元素的显示样式。\ncss* {\n    margin: 0;\n    padding: 0;\n}美化圆角边框border-radius属性可以为盒子设置圆角边框。属性值是圆的半径，可以是具体的值或者百分比。\n传入一个值的时候，四个角圆的半径都是一样的。传入四个值的时候，可以分别给左上、右上、右下、左下角定义圆的半径。\n其他相关属性有分开写: border-top-left-radius、border-top-right-radius、border-bottom-right-radius、border-bottom-left-radius。\n盒子阴影box-shadow属性定义阴影。box-shadow: &lt;h-shadow&gt; || &lt;v-shadow&gt; || &lt;blur&gt; || &lt;spread&gt; || &lt;color&gt; || &lt;inset&gt;。\n前两个属性必须写，分别代表水平阴影，垂直阴影。其他可选的分别代表阴影模糊，阴影大小，阴影颜色，内外阴影(值为空时，是外阴影)。\n过渡使用transition属性进行过渡。transition：&lt;single-transition-property&gt; || &lt;time&gt; || &lt;single-transition-timing-function&gt; || &lt;delay-time&gt; ,[else…]。第一个属性是对象中的参与过渡的属性(可以是all，全部属性)、第二个属性是持续的时间、第三个属性是过渡的动画类型(linear、ease、ease-in、ease-out、ease-in-out、step-start、step-end)、动画延时。\n当有多个属性需要过渡时，使用逗号来分隔。\n","slug":"CSS网页标准布局和美化","date":"2022-04-04T02:57:00.000Z","categories_index":"前端","tags_index":"CSS","author_index":"Ac-Accelerator"},{"id":"2d84197b69c87d393530863c6fed2f9f","title":"深度学习的模型训练","content":"兄弟们，看了二十来天的人工智能概述还有实现方法，我终于搞懂了。\n一个有关人工智能的pytorch程序应该包含数据集废话，没数据怎么玩啊，这里以FashionMNIST数据集举个例子。\npythonimport torch\nfrom torch import nn\nimport torchvision\nimport torchvision.transforms as transforms\n#首先是数据集的内容。\n#mnist_train代表要进行训练的数据集，root属性是其存放的位置，train属性代表这是用作训练的数据集，download属性为true表示无则下载，有则现用，transform属性代表将数据集转化为Tensor。\nmnist_train = torchvision.datasets.FashionMNIST(\n    root='./Datasets', train=True, download=True, transform=transforms.ToTensor())\n#mnist_train代表是对训练结果进行测试的数据集，属性意义和上面的几乎一致\nmnist_test = torchvision.datasets.FashionMNIST(\n    root='./Datasets', train=False, download=True, transform=transforms.ToTensor())\n\n#设置批大小，即迭代数据的时候每一批次样本的量\nbatch_size=256\n\n#train_iter代表对训练数据集迭代的迭代器，shuffle代表随机打乱顺序，这样符合机器学习的原理，num_workers为载入数据时使用处理器的数量，win下一般为0。\ntrain_iter = torch.utils.data.DataLoader(\n    mnist_train, batch_size=batch_size, shuffle=True, num_workers=0)\n#test_iter的shuffle为false不必打乱。\ntest_iter = torch.utils.data.DataLoader(\n    mnist_test, batch_size=batch_size, shuffle=False, num_workers=0)模型有了数据，那我们该采取哪种方式处理呢？那么就需要模型了。\n自定义不带参数的层：python#CenteredLayer类通过继承Module类自定义了一个将输入减掉均值后输出的层，并将层的计算定义在了forward函数里。这个层不含模型参数。\nclass CenteredLayer(nn.Module):\n    def __init__(self, **kwargs):\n        super(CenteredLayer, self).__init__(**kwargs)\n    def forward(self, x):\n        return x - x.mean()\n\n#FlattenLayer类通过继承Module类自定义了一个将输入X的维度降低为2维，第一维是数据的量，第二维是数据的内容\nclass FlattenLayer(nn.Module):\n    def __init__(self):\n        super(FlattenLayer, self).__init__()\n    def forward(self, x):  # x shape: (batch, *, *, ...)\n        return x.view(x.shape[0], -1)自定义带参数的层：python#这里的例子是定义了一个按列表顺序向前传播的层\nclass MyDense(nn.Module):\n    def __init__(self):\n        super(MyDense, self).__init__()\n        self.params = nn.ParameterList([nn.Parameter(torch.randn(4, 4)) for i in range(3)])\n        self.params.append(nn.Parameter(torch.randn(4, 1)))\n\n    def forward(self, x):\n        for i in range(len(self.params)):\n            x = torch.mm(x, self.params[i])\n        return x这是自定义的模型样本，我来解释一下。\n定义模型并生成模型实例python#一般情况下自定义的模型都以类的形式声明，继承自nn.Module类\n#这里是一个自定义的多层感知机\nclass MLP(nn.Module):\n    def __init__(self):\n        super(MLP, self).__init__()# 调用MLP父类Module的构造函数来进行必要的初始化。\n        self.flat=FlattenLayer()#自定义的层\n        self.hidden1 = nn.Linear(784, 512) # 全连接隐藏层1\n        self.hidden2 = nn.Linear(512, 256)# 全连接隐藏层2\n        self.output = nn.Linear(256, 10)  # 全连接输出层\n        self.act = nn.ReLU() #激活函数\n        #注意，在使用Linear或其他相关函数定义层的时候，就已经了自带的权重参数。\n\n    # 需要定义模型的向前传播算法，即如何根据输入x计算返回所需要的模型输出。\n    def forward(self, x):\n        #在调用的时候将以这种方式向前传播\n        return self.output(self.act(self.hidden2(self.act(self.hidden1(self.flat(x))))))\n\nnet=MLP()\t#生成对象实例使用Module类自带的子类Sequential类可以更加方便的进行模型构造，但是不能构造复杂的模型。类似于这样的使用\npython#比如这个例子，它的向前传播算法是这样的\nnet = nn.Sequential(\n    nn.Linear(num_inputs, num_hiddens),#第一步，计算隐藏层1\n    nn.ReLU(),#对隐藏层1的结果使用激活函数\n    nn.Dropout(0.1),#对隐藏层的结果使用丢弃法，丢弃概率为0.1\n    nn.Linear(num_hiddens,256),#计算隐藏层2\n    nn.ReLU(),#对隐藏层2的结果使用激活函数\n    nn.Dropout(0.2),#对隐藏层的结果使用丢弃法，丢弃概率为0.2\n    nn.Linear(256, num_outputs),#计算输出层\n)可以看到Sequential类的特点就是按顺序进行向前传播。非常直观。Sequential内的模块需要按照顺序排列，要保证相邻层的输入输出大小相匹配，内部forward功能已经实现。其他的还有ModuleList和ModuleDict，但是它们的forward方法需要自己去定义，个人觉得一般般（任何事物都有其存在的价值，可能是我才疏学浅吧）。\n访问模型中的参数：python#net是一个实例化的模型对象，使用named_parameters可以访问&lt;名称，参数&gt;键值对。\n#name是个str,param是一个Parameter对象。\nfor name, param in net.named_parameters():\n    #在这里什么也不干，单纯就打印出来\n    print(name, param.size())初始化模型中的参数：python#nn.Module的模块参数都采取了较为合理的初始化策略，但是我们有时候依然希望自定义模型中的参数\n#使用init方法对权重进行初始化，除了normal_外还有其他的初始化函数。\nfor name, param in net.named_parameters():\n    if 'weight' in name:\n        init.normal_(param, mean=0, std=0.01)\n        print(name, param.data)模型参数可以共用，只要向前传播的时候调用的是同一个模型参数即可。\n读写和保存对Tensor：\npythonx = torch.ones(3)\n\n#将tensor x 保存到x.pt文件里面\ntorch.save(x, 'x.pt')\n\n#将tensor x 从x.pt文件里面读取到x2\nx2 = torch.load('x.pt')\n\n#还可以将x,x2形成列表储存进xx2.pt，\ntorch.save([x, x2], 'xx2.pt')\n\n#再读取到xx2_list里\nxx2_list = torch.load('xx2.pt')\n\n#字典同理对模型呢：\npython#这里使用之前定义的MLP模型来举例\n\n#只保存和加载模型参数的方法\n# 注意，使用state_dict方法时一定要先有一个实例化的对象\nmodel=MLP()\n#使用state_dict()方法保存和加载模型参数，这里的model是一个实例化的模型对象，PATH是要保存的路径还有文件名\ntorch.save(model.state_dict(), PATH) # 推荐的文件后缀名是pt或pth\n#在载入的时候也要有一个实例对象，这里就命名为model2吧\nmodel2=MLP()\n#载入！\nmodel.load_state_dict(torch.load(PATH))\n\n#保存和加载整个模型的方法\ntorch.save(model, PATH)\nmodel = torch.load(PATH)损失函数可以自己写，也可以使用自带的。例如使用自带的CrossEntropyLoss()交叉熵损失函数。\npythonloss = torch.nn.CrossEntropyLoss()其他的还有\npythontorch.nn.L1Loss()#绝对值损失\ntorch.nn.MSELoss()#均方差损失\ntorch.nn.KLDivLoss()#散度损失\ntorch.nn.BCELos()#二进制交叉熵损失\ntorch.nn.BCEWithLogitsLoss()# 带Sigmoid层的二进制交叉熵损失\ntorch.nn.MarginRankingLoss()\ntorch.nn.HingeEmbeddingLoss()\ntorch.nn.MultiLabelMarginLoss#多标签分类损失\ntorch.nn.SmoothL1Loss()#平滑版绝对值损失\ntorch.nn.SoftMarginLoss()#2分类的logistic损失\ntorch.nn.MultiLabelSoftMarginLoss()#多标签 one-versus-all 损失\ntorch.nn.CosineEmbeddingLoss()#cosine损失\ntorch.nn.MultiMarginLoss()#多类别分类的hinge损失参见博客\n优化函数可以自己写，也可以使用自带的。例如使用自带的SGD函数。\npython#这里可以设置，lr学习率，weight_decay权重衰减\noptimizer = torch.optim.SGD(net.parameters(), lr=0.4,weight_decay=0.0005)其他的还有\npythontorch.optim.SGD()#随机梯度下降算法\ntorch.optim.ASGD()#异步随机梯度下降法\ntorch.optim.Rprop()#弹性反向传播算法\ntorch.optim.Adagrad()#自适应学习率优化算法\ntorch.optim.Adadelta()#改进版自适应学习率优化算法\ntorch.optim.RMSprop()#均方根反向传播算法\ntorch.optim.Adam()\ntorch.optim.Adamax()\ntorch.optim.SparseAdam()\ntorch.optim.LBFGS()#拟牛顿法正确率评估函数(可选)这个非必须，主要是给人看模型训练的正确率的，一般都要有例如这个：\npythondef evaluate_accuracy(data_iter, net):\n    acc_sum, n = 0.0, 0\n    for X, y in data_iter:\n        acc_sum += (net(X).argmax(dim=1) == y).float().sum().item()\n        n += y.shape[0]\n    return acc_sum / n训练方法告诉python怎么使用数据和模型进行计算\npythondef train_ch3(net, train_iter, test_iter, loss, num_epochs, batch_size,\n              params=None, lr=None, optimizer=None):\n    for epoch in range(num_epochs):#首先对每个周期来说，要执行以下操作：\n        train_l_sum, train_acc_sum, n = 0.0, 0.0, 0\n        for X, y in train_iter:#对每个样本\n            y_hat = net(X)#根据模型向前传播算出对应的标签值\n            l = loss(y_hat, y).sum()#计算该样本的损失并使用sum方法并加起来\n\n            # 对优化器记得梯度清零\n            optimizer.zero_grad()\n\n            l.backward() #使用backward对损失函数进行反向传播\n            optimizer.step()  #使用SGD算法进行优化\n\n            #统计正确数和总数(非必须)\n            train_l_sum += l.item()\n            train_acc_sum += (y_hat.argmax(dim=1) == y).sum().item()#计算当前的正确率\n            n += y.shape[0]#已训练的样本数量要加上当前批次的训练数量\n\n        #计算正确率(非必须)\n        test_acc = evaluate_accuracy(test_iter, net)#使用评估函数对随机样本进行评估\n        print('epoch %d, loss %.4f, train acc %.3f, test acc %.3f' % (epoch + 1, train_l_sum / n, train_acc_sum / n, test_acc))#输出","slug":"人工智能学习笔记","date":"2022-04-04T02:28:00.000Z","categories_index":"人工智能","tags_index":"Pytorch","author_index":"Ac-Accelerator"},{"id":"e8e899a32442557ba38f16b4d4d99793","title":"CSS盒子和背景","content":"Emmet语法快速开发对于HTML标签:\n\n\n\n\n\n\n\n\n\n1．生成标签直接输入标签名按tab键即可比如div然后tab键，就可以生成&lt;div&gt;&lt;/div&gt;2．如果想要生成多个相同标签加上就可以了比如div*3就可以快速生成3个div3．如果有父子级关系的标签，可以用&gt;比如ul &gt; li就可以了4．如果有兄弟关系的标签，用＋就可以了比如div+p5．如果生成带有类名或者id名字的，直接写.demo或者#two tab键就可以了6．如果生成的div类名是有顺序的，可以用自增符号$7．如果想要在生成的标签内部写内容可以用{}表示\n对于CSS样式:\n\n\n\n\n\n\n\n\n\n1．比如w200按tab 可以生成width: 200px;2.比如lh26按tab 可以生成 line-height: 26px;\n元素的显示模式元素显示模式就是元素以什么方式显示，比如div自己占一行，一行可以放多个span。HTML元素一般分为块元素和行内元素两种。\n块元素块状元素的特点：\n\n\n\n\n\n\n\n\n\n1.独占一行2.高度、宽度、内边距和内边距都可以控置。3.宽度默认是父级宽度。4.块元素是一个容器，里面可以放行内或者块元素。\n注意：文字类的块元素内部不能放其他块元素。\n行内元素行内元素的特点：  \n\n\n\n\n\n\n\n\n\n1.相邻行内元素在一行上，一行可以显示多个。2.高、宽直接设置是无效的。3.默认宽度就是它本身内容的宽度。4.行内元素只能容纳文本或其他行内元素。\n注意：链接里面不能放链接，但是可以放块元素。\n行内块元素行内块元素的特点：\n\n\n\n\n\n\n\n\n\n1.和相邻行内元素(行内块)在一行上，但是他们之间会有空白缝隙。一行可以显示多个(行内元素特点)。2.默认宽度就是它本身内容的宽度(行内元素特点)。3.高度，行高、外边距以及内边距都可以控制(块级元素特点)。  \n元素显示模式的切换使用display属性进行转换。\n常用属性值有none(隐藏)、inline(行内元素)、block(块元素)、inline-block(行内块元素)。\nCSS背景背景颜色使用background-color来定义元素的背景。\n背景图片使用背景图片属性background-image描述。语法是 background-image: url()  在url那里填上图片的url。\n背景图片在背景颜色的上层。\n背景平铺使用background-repeat属性定义背景图片是否平铺。有no-repeat(不平铺),repeat-x(x方向上平铺),repeat-y(y方向上平铺),repeat(默认，x、y上平铺)。\n背景位置使用background-position属性定义背景图片的位置。\n参数是center、left、right、top、bottom和偏移量。\n如果提供两个参数，第一个用于横坐标，第二个用于纵坐标。\n如果只提供一个参数，该值将用于横坐标；纵坐标将默认为50%（即center）。 \n如果提供三或四个，每个偏移量前都必须跟着一个方位名词。\n背景附着使用background-attachment属性定义背景图片是否附着。\n参数有fixed(相对于窗体固定)、scroll(默认，相对于元素固定)、local(相对于元素内容固定)。\n背景属性缩写background属性，参数是各种背景属性的参数。\n","slug":"CSS盒子和背景","date":"2022-04-03T02:57:00.000Z","categories_index":"前端","tags_index":"CSS","author_index":"Ac-Accelerator"},{"id":"99ee2dab73c41d51a135362a1fafc76c","title":"CSS字体常用属性","content":"上一篇学习了CSS的选择器，这一篇就学习：\nCSS属性字体使用font-family属性对元素的字体定义样式，可以设置多种不同的字体(如果浏览器不支持当前字体则找下一个字体替换)，字体之间用逗号隔开。字体名称可以是中文名，但是最好写英文名。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;字体样式&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        body {\n            /* 页面基本属性 */\n            font-family: Arial, Helvetica, sans-serif,\"宋体\";\n            /* 字体类型 */\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;p&gt;定义字体类型&lt;/p&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;字号使用font-size属性对元素的文字大小定义样式，常用单位是px(像素)、em(以父辈字体大小为参考值设置大小)。\n标题标签要单独特别指定大小。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;字体样式&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        body {\n            /* 网页字体大小 */\n            font-size: 0.75em;\n            /* 约等于12像素 */\n        }\n\n        body,\n        div,\n        p {\n            font-size: 0.75em;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div id=\"content\"&gt;框架\n        &lt;div id=\"sub\"&gt;子框架\n            &lt;p&gt;段落文本&lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;字体粗细使用font-weight属性对元素的文字粗细定义样式，常用属性值有normal、bold、bolder、lighter等自带的属性值，也有数值属性值，一般normal=400。\n标题标签要单独特别指定粗细。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;字体样式&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        p {\n            font-weight: normal\n        }\n\n        /* 等于400 */\n        h1 {\n            font-weight: 700\n        }\n\n        /* 等于bold */\n        div {\n            font-weight: bolder\n        }\n\n        /* 可能为500 */\n        .bold {\n            /* 粗体样式类 */\n            font-weight: bold;\n            /* 加粗显示 */\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;p&gt;绊爱（キズナアイ）是YouTube上一个虚拟YouTuber，自称为世界第一个Virtual YouTuber，YouTube频道名为A.I.Channel。角色形象由森倉円设计，3D模型由Tomitake制作，Tda监督。2016年12月25日，免费公开自身3D模型素材，作为圣诞礼物。2018年成为推广日本旅游的Come to Japan的宣传大使，目前是Kizuna AI株式会社的虚拟YouTuber和音乐艺术家。声称是人工智能（AI）。\n    &lt;/p&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;字体倾斜这个属性最常用于把倾斜的字体变得不倾斜\n使用font-style属性对元素的文字粗细定义样式，属性值为normal、italic、oblique。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;字体样式&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        span {\n            font-style: normal;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;p&gt;&lt;i&gt;绊爱（キズナアイ）是&lt;span&gt;YouTuber&lt;/span&gt;上一个虚拟&lt;span&gt;YouTuber&lt;/span&gt;，自称为世界第一个&lt;span&gt;YouTuber&lt;/span&gt;，&lt;span&gt;YouTuber&lt;/span&gt;频道名为A.I.Channel。角色形象由森倉円设计，3D模型由Tomitake制作，Tda监督。2016年12月25日，免费公开自身3D模型素材，作为圣诞礼物[1]。2018年成为推广日本旅游的Come\n            to Japan的宣传大使，目前是Kizuna AI株式会社的虚拟&lt;span&gt;YouTuber&lt;/span&gt;和音乐艺术家。声称是人工智能（AI）。 &lt;/i&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;!-- 所有的YouTuber都归正了。 --&gt;\n\n&lt;/html&gt;行间距使用line-height属性对元素的文字行间距定义样式。\n常用单位px。\n字体复合属性使用font属性对字体设置样式。语法font: font-style | font-variant | font-weight | font-size | line-height | font-family属性值之间用空格分隔。至少设置字体大小和字体类型，且必须放在后面。各个属性值要严格遵循相应的顺序。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;字体样式&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        body {\n            /* 斜体样式类 */\n            font: bolder 24px \"隶书\";\n            /* 斜体 */\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;p&gt;绊爱（キズナアイ）是YouTuber上一个虚拟YouTuber，自称为世界第一个YouTuber，YouTuber频道名为A.I.Channel。目前是Kizuna\n        AI株式会社的虚拟YouTuber和音乐艺术家。声称是人工智能（AI）。&lt;/p&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;字体颜色使用color属性对元素的文字颜色定义样式。  \n可以使用预定义的颜色、十六进制颜色、RGB表示颜色。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;字体样式&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        body {\n            color: gray;\n        }\n\n        p {\n            color: #666666;\n        }\n\n        div {\n            color: rgb(120, 120, 120);\n        }\n\n        span {\n            color: rgb(50%, 50%, 50%);\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;p&gt;定义字体颜色&lt;/p&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;文本对齐使用text-align属性对元素的对齐定义样式。常用属性值有:left、right、center、justify、start、end、match-parent、justify-all。\n使用vertical-align属性对元素的垂直对齐定义样式。常用属性有：auto、baseline、sub、super、top、text-top、middle、bottom、text-bottom、length。\n文本装饰使用text-decoration属性定义字体的下划线效果。常用属性有：none、underline、blink、overline、line-through。\nlist-style属性可以控制文本的标记。list-style: &lt; list-style-type&gt; || &lt; list-style-position &gt; || &lt; list-style-image &gt;\n第一项是预设标记、有disc(实心圆) circle(空心圆) 、square(实心方块) 、decimal(阿拉伯数字) 、lower-roman(小写罗马数字) 、upper-roman(大写罗马数字) 、lower-alpha(小写英文字母) 、upper-alpha(大写英文字母) 、none(不使用项目符号) 、armenian(传统的亚美尼亚数字) 、cjk-ideographic(浅白的表意数字) 、georgian(传统的乔治数字) 、lower-greek(基本的希腊小写字母) 、hebrew(传统的希伯莱数字) 、hiragana(日文平假名字符) 、hiragana-iroha(日文平假名序号) 、katakana(日文片假名字符) 、katakana-iroha(日文片假名序号) 、lower-latin(小写拉丁字母) 、upper-latin(大写拉丁字母) 。\n第二项是作为对象的列表项标记如何根据文本排列，取outside和inside。\n第三项是图像的url。\n文本缩进使用text-indent属性对元素的缩进定义样式,可以是浮点数，可以是负数。常用单位是：em(字距)。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;文本样式&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        p {\n            text-indent: -2em;\n            padding-left: 2em;/* 左侧补白 */\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n\n    &lt;h1&gt;《人间词话》节选&lt;/h1&gt;\n    &lt;h2&gt;王国维&lt;/h2&gt;\n    &lt;p&gt;古今之成大事业、大学问者，必经过三种之境界：\"昨夜西风凋碧树。独上高楼，望断天涯路。\"此第一境也。\"衣带渐宽终不悔，为伊消得人憔悴。\"此第二境也。\"众里寻他千百度，蓦然回首，那人却在灯火阑珊处。\"此第三境也。此等语皆非大词人不能道。然遽以此意解释诸词，恐为晏欧诸公所不许也。\n    &lt;/p&gt;\n\n&lt;/body&gt;\n\n&lt;/html&gt;","slug":"CSS字体常用属性","date":"2022-04-02T08:19:00.000Z","categories_index":"前端","tags_index":"CSS","author_index":"Ac-Accelerator"},{"id":"a436d0c5ab40b72eca296c2bdd2e3201","title":"CSS伪类选择器","content":"伪类选择器伪选择器包括伪类和伪对象选择器,伪选择器以冒号’:’作为前缀标识。冒号 前面可以添加选择符,限定伪类应用的范围。冒号后面为伪类和伪对象名。冒号前后没有空格，否则将错认为类选择器。\n动态伪类动态伪类只有当用户与页面进行交互时才能体现出来。其中，动态伪类选择器分为\n锚点伪类有:link(链接没被激活时)、:visited(链接被激活过),常见于链接中。行为伪类有:hover(鼠标移动到上方时)、:active(对元素按下鼠标左键时)和:focus(表单元素成为焦点时)。  \n注意:为了确保生效，需要按照先后顺序：link-&gt;visited-&gt;hover-&gt;active。\ncssa:hover,\na:active {\n  outline: 0;\n}","slug":"CSS伪类选择器","date":"2022-04-01T12:11:00.000Z","categories_index":"前端","tags_index":"CSS","author_index":"Ac-Accelerator"},{"id":"77b2bb6af72e4872676c2271a80ae12d","title":"CSS基本选择器和组合选择器","content":"新一轮的学习又开始了！之前学完CSS的语法和使用。现在学习的是~~\nCSS选择器基本选择器基本选择器分为标签选择器、类选择器、ID选择器和通配选择器。\n层叠性:如果样式冲突，则采用最新的样式。继承性:子标签会继承父标签的某些样式。优先级:继承&lt;元素选择器&lt;类/伪类选择器&lt;I选择器&lt;行内样式&lt;!important。\n标签选择器标签选择器直接引用HTML标签的名称，控制页面标签的默认显示效果,快速为页面中同类型的标签设置统一样式。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        p {\n            font-size: 12px;\n            color: red;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;p&gt;我的低调不是你们装逼的资本&lt;/p&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n类选择器差异化选择不同的标签，或单独选一个或者几个标签。开发中最常使用的方法。\n需要在HTML标签中定义class属性。类选择器以一个”.”号开头，后面紧跟类名。\n一个标签可以有多个类名，不同类名之间用空格隔开，尽量使用纯英文做类名。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;我的低调不是你们装逼的资本&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        p {\n            font-size: 12px;\n            color: red;\n        }\n\n        .font18px {\n            font-size: 18px;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;p&gt;这里是来自2010年&lt;/p&gt;\n    &lt;p class=\"font18px\"&gt;我是MC石头，在这里给你们带来好听的歌曲&lt;/p&gt;\n    &lt;p&gt;请认准唯一联系QQ：337845818&lt;/p&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;ID选择器通过ID选择一个特定的元素。\n需要在HTML标签中定义id属性。类选择器以一个”#”号开头，后面紧跟对象id。\n此选择器常和JavaScript配合使用\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        div#box {\n            background: url(images/bg1.gif) center bottom;\n            height: 200px;\n            width: 400px;\n            border: solid 2px red;\n            padding: 20px;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div id=\"box\"&gt;这就是爱&lt;/div&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;通配选择器为所有标签打上样式。\n选择器就是一个*号。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;CSS基础&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        * {\n            margin: 0;\n            padding: 0;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div id=\"box\"&gt;我寄愁心与明月随风直到夜郎西。&lt;/div&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;组合选择器组合选择器包括包含选择器、子选择器、相邻选择器、兄弟选择器和分组选择器。\n注意，优先级有权重叠加的问题。\n包含选择器、子选择器包含选择器通过空格标识符来表示。前面一个选择器表示包含框对象的选择器。而后面的选择器表示被包含的选择器。\n子选择器是指定父元素所包含的子元素，使用”&gt;”表示。\n下面的例子注意区分子选择器和组合选择器的区别。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        #header&gt;p {/* 子选择器 */\n            font-size: 14px;\n        }\n        \n        #main p {/* 包含选择器 */\n            font-size: 12px;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div id=\"wrap\"&gt;\n        &lt;div id=\"header\"&gt;\n            &lt;h2&gt;\n                &lt;p&gt;头部区域第1段文本&lt;/p&gt;\n            &lt;/h2&gt;\n            &lt;p&gt;头部区域第2段文本&lt;/p&gt;\n            &lt;p&gt;头部区域第3段文本&lt;/p&gt;\n        &lt;/div&gt;\n        &lt;div id=\"main\"&gt;\n            &lt;div&gt;\n                &lt;p&gt;主体区域第1段文本&lt;/p&gt;\n                &lt;p&gt;主体区域第2段文本&lt;/p&gt;\n            &lt;/div&gt;\n            &lt;p&gt;主体区域第3段文本&lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;html&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        span {\n            font-size: 12px;\n        }\n\n        div&gt;span {\n            font-size: 16px;\n        }\n\n        div&gt;.font24px {\n            font-size: 20px;\n        }\n\n        #box&gt;.font24px {\n            font-size: 24px;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;h2&gt;&lt;span&gt;HTML文档树状结构&lt;/span&gt;&lt;/h2&gt;\n    &lt;div id=\"box\"&gt;&lt;span class=\"font24px\"&gt;问君能有几多愁，恰似一江春水向东流。&lt;/span&gt;&lt;/div&gt;\n    &lt;div&gt;&lt;span class=\"font24px\"&gt;问君能有几多愁，恰似一江春水向东流。&lt;/span&gt;&lt;/div&gt;\n    &lt;div&gt;&lt;span&gt;问君能有几多愁，恰似一江春水向东流。&lt;/span&gt;&lt;/div&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;相邻选择器通过(+)号分隔符进行定义，第一个选择器指定前面相邻元素，后面选择器指定相邻元素。前后选择符的关系是兄弟关系，即在HTML结构中，两个标签先为兄后为弟，否则样式无法使用。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;style type=\"text/css\"&gt;\n        h2,\n        p,\n        h3 {\n            margin: 0;\n            padding: 0;\n            height: 30px;\n        }\n\n        p+h3 {\n            background-color: #0099FF;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div class=\"header\"&gt;\n        &lt;h2&gt;情况一：&lt;/h2&gt;\n        &lt;p&gt;子选择器控制p标签，能控制我吗&lt;/p&gt;\n        &lt;h3&gt;子选择器控制p标签&lt;/h3&gt;\n        &lt;h2&gt;情况二：&lt;/h2&gt;\n        &lt;div&gt;我隔开段落和h3直接&lt;/div&gt;\n        &lt;p&gt;子选择器控制p标签，能控制我吗&lt;/p&gt;\n        &lt;h3&gt;相邻选择器&lt;/h3&gt;\n        &lt;h2&gt;情况三：&lt;/h2&gt;\n        &lt;h3&gt;相邻选择器&lt;/h3&gt;\n        &lt;p&gt;子选择器控制p标签，能控制我吗&lt;/p&gt;\n        &lt;div&gt;\n            &lt;h2&gt;情况四：&lt;/h2&gt;\n            &lt;p&gt;子选择器控制p标签，能控制我吗&lt;/p&gt;\n            &lt;h3&gt;相邻选择器&lt;/h3&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;兄弟选择器通过”~”分隔符进行定义。第一个选择器指定同级前置元素，后面的选择器指定其后同级所有匹配元素，前后选择符的关系是兄弟关系，即在HTML结构中，两个标签先为兄后为弟，否则样式无法使用。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;style type=\"text/css\"&gt;\n        h2,\n        p,\n        h3 {\n            margin: 0;\n            padding: 0;\n            height: 30px;\n        }\n\n        p~h3 {\n            background-color: #0099FF;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div class=\"header\"&gt;\n        &lt;h2&gt;情况一：&lt;/h2&gt;\n        &lt;p&gt;子选择器控制p标签，能控制我吗&lt;/p&gt;\n        &lt;h3&gt;子选择器控制p标签&lt;/h3&gt;\n        &lt;h2&gt;情况二：&lt;/h2&gt;\n        &lt;div&gt;我隔开段落和h3直接&lt;/div&gt;\n        &lt;p&gt;子选择器控制p标签，能控制我吗&lt;/p&gt;\n        &lt;h3&gt;相邻选择器&lt;/h3&gt;\n        &lt;h2&gt;情况三：&lt;/h2&gt;\n        &lt;h3&gt;相邻选择器&lt;/h3&gt;\n        &lt;p&gt;子选择器控制p标签，能控制我吗&lt;/p&gt;\n        &lt;div&gt;\n            &lt;h2&gt;情况四：&lt;/h2&gt;\n            &lt;p&gt;子选择器控制p标签，能控制我吗&lt;/p&gt;\n            &lt;h3&gt;相邻选择器&lt;/h3&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;分组选择器分组选择器就是用逗号隔开不同的选择器啦。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;script type=\"text/javascript\" src=\"IE8.js\"&gt;&lt;/script&gt;\n    &lt;style type=\"text/css\"&gt;\n        h1,\n        h2,\n        h3,\n        h4,\n        h5,\n        h5,\n        h6 {\n            background-color: #99CC33;\n            /* 设置背景色 */\n            margin: 0;\n            /* 清除标题的默认外边距 */\n            margin-bottom: 10px;\n            /* 使用下边距拉开各个标题之间的距离 */\n        }\n\n        h1+h2,\n        h2+h3,\n        h4+h5 {\n            color: #0099FF;\n            /* 兄弟关系 设置字体的颜色 */\n        }\n\n        body&gt;h6,\n        h1&gt;span,\n        h4&gt;span {\n            font-size: 20px;\n            /* 子选择器 设置字体的大小 */\n        }\n\n        h2 span,\n        h3 span {\n            padding: 0 20px;\n            /* &lt;span&gt;标签的左右间距 */\n        }\n\n        h5 span[class],\n        h6 span[class] {\n            background-color: #CC0033;\n            /* h5、h6标题中含有class属性的span标签设置背景色 */\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;h1&gt;h1元素&lt;span&gt;这里是span元素&lt;/span&gt;&lt;/h1&gt;\n    &lt;h2&gt;h2元素&lt;span&gt;这里是span元素&lt;/span&gt;&lt;/h2&gt;\n    &lt;h3&gt;h3元素&lt;span&gt;这里是span元素&lt;/span&gt;&lt;/h3&gt;\n    &lt;h4&gt;h4元素&lt;span&gt;这里是span元素&lt;/span&gt;&lt;/h4&gt;\n    &lt;h5&gt;h5元素&lt;span class=\"S1\"&gt;这里是span元素&lt;/span&gt;&lt;/h5&gt;\n    &lt;h6&gt;h6元素&lt;span class=\"S2\"&gt;这里是span元素&lt;/span&gt;&lt;/h6&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;结束学习了CSS的基本选择器，组合选择器。其实还有属性选择器、伪类选择器。\n","slug":"CSS基本选择器和组合选择器","date":"2022-03-30T12:11:00.000Z","categories_index":"前端","tags_index":"CSS","author_index":"Ac-Accelerator"},{"id":"06cb31f739141f028e7d96fc342e06c9","title":"CSS语法初探以及使用","content":"CSS语法CSS规则由两个主要的部分构成：选择器，以及一条或多条声明\n选择器通常是您需要改变样式的对象，这些对象可以是某个标签、所有网页对象、指定Class或ID值等。每条声明由一个属性和一个值组成。属性是CSS提供的设置好的样式选项。每个属性有一个值。属性和值被冒号分隔开。属性值是用来显示属性效果的参数。它包括数值和单位，或者关键字。CSS声明总是以分号 ; 结束，声明总以大括号 {} 括起来\n例如：\ncssbody\n{\n  front-size: 12px;\n  color: #333;\n}在这个例子中，body就是选择器，表示&lt;body&gt;这个标签。\nfront-size:12px;和color:#333;就是该条CSS的两个声明。\n在声明中，冒号前面的是属性，后面的是属性值。\n一般在属性值和前面的冒号之间放一个空格，会更加美观。字母最好全部小写。\nCSS应用CSS样式代码必须保存在.css文件中(链接式、导入式)，或者放在网页内style标签中(内嵌式)，或者插在网页标签的style属性值中(行内样式)。\n行内样式：html&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;p style=\"background-color: #999900\"&gt;行内元素，控制段落-1&lt;/p&gt;\n    &lt;h2 style=\"background-color: #FF6633\"&gt;行内元素，h2标题元素&lt;/h2&gt;\n    &lt;p style=\"background-color: #999900\"&gt;行内元素，控制段落-2&lt;/p&gt;\n    &lt;strong style=\"font-size: 30px;\"&gt;行内元素，strong比em效果要强&lt;/strong&gt;\n    &lt;div style=\"background-color: #66CC99; color: #993300;height: 30px; line-height: 30px;\"&gt;行内元素，div块级元素&lt;/div&gt;\n    &lt;em style=\"font-size: 2em;\"&gt;行内元素，em强调&lt;/em&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;直接将CSS的声明作为style的属性值。多个声明之间用分号间隔。只能操作当前一个元素，优先级最高。\n内嵌式html&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        p {\n            text-align: left;\n            /* 文本左对齐 */\n            font-size: 18px;\n            /* 字体大小18像素 */\n            line-height: 25px;\n            /* 行高25像素 */\n            width: 500px;\n            /* 段落宽度500像素 */\n            margin: 0 auto;\n            /* 浏览器下居中 */\n            margin-bottom: 20px;\n            /* 段落下边距20像素 */\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;p&gt;某个地方有个正在旅行的魔女，&lt;br /&gt;她的名字是伊蕾娜。&lt;br /&gt;身为旅人，&lt;br /&gt;在很长很长的旅途中，&lt;br /&gt;她与形形色色的国家与人们邂逅。&lt;/p&gt;\n    &lt;p&gt;只允许魔法师入境的国家、&lt;br /&gt;最喜欢肌肉的壮汉、&lt;br /&gt;在死亡深渊等待恋人归来的青年、&lt;br /&gt;独自留守国家早已灭亡的公主…&lt;/p&gt;\n    &lt;p&gt;最后，还有她身为魔女的至今为止与从今以后。&lt;br /&gt;和莫名其妙、滑稽可笑的人们相遇，&lt;br /&gt;接触某人美丽的日常生活，&lt;br /&gt;魔女日复一日编织出相逢与离别的故事。&lt;/p&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;将CSS的内容直接写入网页源文件的&lt;style&gt;标签内部，只能控制当前一个页面，一般情况下&lt;style&gt;标签位于&lt;head&gt;内，但实际上&lt;style&gt;标签也可放在其他地方。\n注意，&lt;style&gt;不仅可以定义CSS样式，还可以定义JavaScript脚本。常用属性为type(类型)、title(样式名称)。其中，type的属性值有text/css和test/javascript。\n一个网页可以有多个CSS样式表，一个网页文档中有多个&lt;style&gt;标签，就有多个样式表。通过title属性可以做到在多种样式直接切换。\n例如：\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;style type=\"text/css\" title=\"字体14号\"&gt;\n        p {\n            text-align: left;\n            /* 文本左对齐 */\n            font-size: 14px;\n            /* 字体大小14像素 */\n            line-height: 25px;\n            /* 行高25像素 */\n            width: 500px;\n            /* 段落宽度500像素 */\n            margin: 0 auto;\n            /* 浏览器下居中 */\n        }\n    &lt;/style&gt;\n    &lt;style type=\"text/css\" title=\"字体18号\"&gt;\n        p {\n            text-align: left;\n            /* 文本左对齐 */\n            font-size: 18px;\n            /* 字体大小18像素 */\n            line-height: 25px;\n            /* 行高25像素 */\n            width: 500px;\n            /* 段落宽度500像素 */\n            margin: 0 auto;\n            /* 浏览器下居中 */\n        }\n\n        p {\n            color: #6699FF;\n            /* 字体颜色的改变 */\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;p&gt;精灵，存在于邻界，被指定为特殊灾害的生命体。&lt;br /&gt;（精霊、隣界に存在する特殊災害指定生命体。）&lt;br /&gt;\n        处置方法1，以武力歼灭精灵。&lt;br /&gt;（対処法１、武力を以てこれを殲滅する。）&lt;br /&gt;\n        处置方法2，与精灵约会，使其娇羞。&lt;br /&gt;（対処法２、デートして、デレさせる。） ”\n    &lt;/p&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;链接式：链接式就是通过&lt;link /&gt;标签将外部样式表文件链接到HTML文档中。这是网络上网站应用最多的方式，同时也是最实用的方式。增强网页结构的拓展性和CSS样式的可维护性。例如：lianjie.css文件：\ncss/* CSS Document */\nh3{font-weight: normal; background-color: #66CC99;height: 50px; line-height: 50px;}\nspan{ color: #FF0000; font-weight: bold; }lianjie-2.css文件：\ncss/* CSS Document */\np{color: #FF3333; font-weight: bold; border-bottom:3px dashed #009933; line-height: 30px;}HTML文件:\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;link href=\"lianjie.css\" type=\"text/css\" rel=\"stylesheet\" /&gt;\n    &lt;link href=\"lianjie-2.css\" type=\"text/css\" rel=\"stylesheet\" /&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;p&gt;我是被lianjie-2.css文件控制的，楼下的你呢？？&lt;/p&gt;\n    &lt;h3&gt;楼上的,&lt;span&gt;lianjie.css&lt;/span&gt;文件给我穿的花衣服。&lt;/h3&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;&lt;link /&gt; 标签定义文档与外部资源的关系。常用属性有href(链接目标)、type(链接文档的类型)、rel(链接外部文件的关联类型)、title(样式表标题)。\n其中rel属性的属性值有alternate、author、help、icon、licence、next、pingback、prefetch、prev、search、sidebar、stylesheet、tag。\n链接到CSS时，type选择text/css，rel选择stylesheet。\n通过title属性可以做到在多种样式直接切换。\ntitle属性和rel属性存在联系，来的网页文档会使用多个&lt;link /&gt;元素导入不同的外部文件。如样式文件，脚本文件，主题文件，甚至可以包括个人自定义的其他补充文件。导入这么多不同类型、名称各异的文件后，可以使用title属性进行选择。这时，属性的作用就显现出来了。它可以指定网页文件初始显示时应用的导入文件类型。目前只能关联样式表类型。  \n外部样式是CSS应用最佳方案，一个样式表文件可以被多个网页文件引用，同时一个网页文件可以导入多个样式表，方法是重复使用&lt;link /&gt;元素导入不同的样式表文件。\n导入样式使用@import命令导入外部样式表。daoru.css文件：\ncss/* CSS Document */\n@import url(\"lianjie-2.css\");\np{text-indent:3em;}HTML文件：\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        @import url(lianjie.css);\n        @import url(daoru.css);\n\n        body {\n            background-color: #e4e929;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div&gt;\n        &lt;p&gt;我是被lianjie-2.css文件控制的，楼下的你呢？？&lt;/p&gt;\n        &lt;h3&gt;楼上的,&lt;span&gt;lianjie.css&lt;/span&gt;文件给我穿的花衣服。&lt;/h3&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;注意在&lt;style&gt;中@import语句必须写标签中靠前的位置，后接CSS样式，否则可能导致样式失效。在CSS文件中使用@import也应该如此。\n&lt;link /&gt;和@import导入样式表的区别：  \n\n\n\n\n\n\n\n\n\nlink属于HTML标签，而@import是CSS提供的。link和页面同时加载，@import引用的CSS会等页面被加载完再加载。link兼容性更好。link的优先级更高。  \n结束学习了CSS基本语法和如何在HTML文件中使用CSS，接下来学习CSS选择器方面的知识。\n","slug":"CSS语法初探以及使用","date":"2022-03-30T02:44:00.000Z","categories_index":"前端","tags_index":"CSS","author_index":"Ac-Accelerator"},{"id":"a6e203121c86bba787d1ff23e359b97c","title":"HTML更多常用标签","content":"继续学习HTML5的相关标签。\n无序列表html&lt;ul&gt;\n  &lt;li&gt;列表项1&lt;/li&gt;\n  &lt;li&gt;列表项2&lt;/li&gt;\n  ...\n  &lt;li&gt;列表项n&lt;/li&gt;\n&lt;/ul&gt;&lt;ul&gt;标签中只能嵌套&lt;li&gt;，不能输入其他标签和文字；&lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有元素。可以使用css设置无序列表的样式属性。\n有序列表html&lt;ol&gt;\n  &lt;li&gt;列表项1&lt;/li&gt;\n  &lt;li&gt;列表项2&lt;/li&gt;\n  ...\n  &lt;li&gt;列表项n&lt;/li&gt;\n&lt;/ol&gt;大致和无序列表相似，但是是有强制的顺序。\n自定义列表html&lt;dl&gt;\n  &lt;dt&gt;名称&lt;/dt&gt;\n  &lt;dd&gt;列表项1&lt;/dd&gt;\n  &lt;dd&gt;列表项2&lt;/dd&gt;\n  &lt;dd&gt;...&lt;/dd&gt;\n  &lt;dd&gt;列表项n&lt;/dd&gt;\n&lt;/dl&gt;&lt;dl&gt;内只能包含&lt;dt&gt;和&lt;dd&gt;。不一定只有一个&lt;dt&gt;,&lt;dt&gt;也不一定放在&lt;dd&gt;的前面。&lt;dt&gt;和&lt;dd&gt;没有个数限制。\n表单html&lt;form &gt;\n  &lt;label&gt;元素&lt;/label&gt;\n  提示信息1\n  &lt;input /&gt;\n  &lt;select&gt;\n    &lt;option&gt;选项1&lt;/option&gt;\n    &lt;option&gt;选项2&lt;/option&gt;\n    &lt;option&gt;...&lt;/option&gt;\n    &lt;option&gt;选项n&lt;/option&gt;\n  &lt;/select&gt;\n  &lt;textarea&gt;请输入~&lt;/textarea&gt;\n&lt;/form&gt;表单由表单域、表单元素、提示信息组成。&lt;form&gt;构成表单域，属性有action(处理表单信息的程序)、method(提交方式)、name(表单名称)。其中，method属性有get和post两种。\n提示信息就是表单域内的文字。\n&lt;input /&gt;表示输入信息的表单元素，是单标签。常用属性为type(表单类型)、name(表单名称)、value(默认值)、checked(默认勾选)、maxlength(字符最大长度)。  \n其中type属性属性值包括button、checkbox、color、date、datetime、datetime-local、email、file、hidden、image、month、number、password、radio、range、reset、search、submit、tel、text、time、url、week。  \n其中checked属性属性值为checked。\n其中单选按钮和复选框的name属性值要一致。\n &lt;label&gt;表示给&lt;input /&gt;定义标注，即点击该标签相当于点击对应&lt;input /&gt;标签。常用属性为for(绑定&lt;input /&gt;标签的id属性值)。被绑定的&lt;input /&gt;标签必须有id属性。\n&lt;selcet&gt;是选择下拉列表的标签，&lt;option&gt;是该标签下的选项。其中：&lt;selcet&gt;中至少包含一个选项。&lt;option&gt;的常用属性有selected(默认选中),属性值有selected和””。\n&lt;textarea&gt;用于定义多行文本输入。若要预先显示内容，则输入文本元素。常用属性有cols(每行输入的字符数)、rows(显示的行数)。但通常使用css来改变大小。\n结束：基本上完成了对常用的HTML5标签的学习，更多标签可等日后要用的时候上网搜索，可能以后阅历丰富了会出一个其他HTML5标签和特性介绍的博客。\n由此HTML5便告一段落，迎接CSS3的学习吧！\n","slug":"HTML更多常用标签","date":"2022-03-29T12:37:00.000Z","categories_index":"前端","tags_index":"HTML","author_index":"Ac-Accelerator"},{"id":"04af9c93be90c311478eb160a4d5a3e4","title":"HTML语法和常用标签","content":"我终于开始学习前端知识了。网站是由一个个网页组成，网页就是浏览器打开的HTML文件。HTML文档是由一个又一个标签组成的。 \n基本语法：\n\n\n\n\n\n\n\n\n1.代码的第一行使用DOCTYPE声明文档类型。2.&lt;html&gt;标签应该设置文档名字空间。3.所有标签都包含在 “&lt;”和”&gt; “起止标识符中，构成一个标签。4.绝大多数元素都有起始标签和结束标签，在起始标签和结束标签之间包含的是元素主体。5.起始标签包含元素的名称以及可选属性。  6.元素的属性包含属性名称和属性值两部分。7.少数元素的属性也可能不包含属性值，仅包含一个属性名称。8.一般属性值应该包含在引号内。9.属性是可选的。10.标签可以互相嵌套，形成文档结构。嵌套必须匹配。合法的嵌套，应该是包含或被包含的关系。11.文档所有信息都必须包含在&lt;html&gt;标签中。所有文档元信息应该包含在&lt;head&gt;子标签中。传递信息和网页显示内容应包含在&lt;body&gt;子标签中。\n网页模板：下面是网页的一个基本模板。\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=\"zh-CN\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    \n&lt;/body&gt;\n&lt;/html&gt;&lt;!DOCTYPE html&gt;声明这是一个HTML5文档。&lt;html&gt;告诉浏览器这是中文文档。&lt;meta charset=”UTF-8”&gt;告诉浏览器这是使用UTF-8进行编码&lt;title&gt;Document&lt;/title&gt;指明这篇文章的标题是Document。\n标签学习：大部分标签都有三个核心属性class(所属类名)、id(元素的唯一标识)、style(元素样式声明)\n大部分标签还有语言属性lang(元素的语言代码和编码)、dir(定义文本方向，有ltr和rtl两个属性)。\n还有定义元素键盘访问方法的键盘属性accesskey(定义访问某元素的快捷键，按下Alt+该键来访问指定URL)、tabindex(定义tab键访问的顺序)\n还有定义元素包含内容的附加信息的内容属性alt(定义元素的替换文本)、title(定义元素提示文本)、longdesc(长描述信息)、cite(定义引用信息)、datetime(定义时间)。\n其他属性如：rel(当前页面和其他页面的关系)、rev(从目标文档到源文档的关系)。\n剩下就是所有标签都有的全局属性！：contentEditable(是否允许用户在线编辑元素中的内容，true和false)、contextmenu(用于定义&lt;div&gt;元素的右键菜单，属性值和要打开的&lt;menu&gt;元素的id值保持一致)、data-*(用于储存页面或web应用私有的自定义数据，用于JavaScript)、draggable(元素是否能拖动，true和false)、dropzone(在元素上拖动数据时，是否复制、移动或链接被拖动数据，copy、move和link)、hidden(元素是否可见，true和false)、spellcheck(是否对元素进行拼写语法检查，true和false)、translate(是否翻译元素内容，yes和no)。\n标题标签：html&lt;h1&gt;这是一个标题&lt;/h1&gt;\n&lt;h2&gt;这是一个标题&lt;/h2&gt;\n···\n&lt;h6&gt;这是一个标题&lt;/h6&gt;分为1~6级标题，一级标题是最大的，六级是最小的。标题标签独占一行。\n段落标签：html&lt;p&gt;这是一个段落。&lt;/p&gt;\n&lt;p&gt;这是另外一个段落。&lt;/p&gt;不同段落在放不同的段落标签中。段落与段落之间有一定的间距。段落内自动换行，自动排版。\n换行标签：html&lt;br/&gt;这是位数不多的几个单标签之一。如果希望某段文本强制换行显示，就需要使用换行标签。\n水平线：html&lt;hr/&gt;这是位数不多的几个单标签之一。产生水平分隔线。   \n \n\n包含框标签：html&lt;div&gt;包含框&lt;/div&gt;\n&lt;span&gt;行内包含框&lt;/span&gt;前者独占一行，后者将一行分割成许多部分。\n修饰标签：html&lt;b&gt;粗体&lt;/b&gt;\n&lt;i&gt;斜体&lt;/i&gt;\n&lt;u&gt;下划线&lt;/u&gt;\n&lt;s&gt;删除线&lt;/s&gt;粗体斜体下划线删除线\n图像标签：html&lt;img /&gt;这是位数不多的几个单标签之一。必选参数为src，即图片地址。常用可选参数有alt(替换文本)、title(提示文本)、width(宽度)、height(高度)和border(边框粗细)。一般高度和宽度任选其一来保证长宽比与原图一致。\n超链接标签：html&lt;a &gt;超链接元素&lt;/a&gt;常用属性有href(跳转的目标)、target(打开方式)  \n如果跳转目标指向网页，则跳转至该网页；指向文件，则下载该文件。  \n若跳转目标暂时未定，则传入参数”#”，表示空链接。\n若是锚点链接，则href传入参数”#example”,其中example是某个元素的id属性的参数，单击此链接将跳转至该元素。\ntarget的默认值是_self，即切换当前界面至目标。可修改为_blank,新建标签页打开目标。\n表格标签：html&lt;table &gt;\n    &lt;thead&gt;\n        &lt;tr&gt; &lt;th&gt;1,1&lt;/th&gt; &lt;th&gt;1,2&lt;/th&gt;&lt;th&gt;...&lt;/th&gt;&lt;th&gt;1,n&lt;/th&gt; &lt;/tr&gt;\n    &lt;/thead&gt;\n    &lt;tbody&gt;\n        &lt;tr&gt; &lt;td&gt;2,1&lt;/td&gt; &lt;td&gt;2,2&lt;/td&gt;&lt;td&gt;...&lt;/td&gt;&lt;td&gt;2,n&lt;/td&gt; &lt;/tr&gt;\n        &lt;tr&gt; &lt;th&gt;3,1&lt;/th&gt; &lt;td&gt;3,2&lt;/td&gt;&lt;td&gt;...&lt;/td&gt;&lt;td&gt;3,n&lt;/td&gt; &lt;/tr&gt;\n        &lt;tr&gt; &lt;td&gt;...&lt;/td&gt; &lt;td&gt;...&lt;/td&gt; &lt;td&gt;...&lt;/td&gt; &lt;td&gt;...&lt;/td&gt;&lt;/tr&gt;\n        &lt;tr&gt; &lt;td&gt;m,1&lt;/td&gt; &lt;td&gt;m,2&lt;/td&gt;&lt;td&gt;...&lt;/td&gt;&lt;td&gt;m,n&lt;/td&gt; &lt;/tr&gt;\n    &lt;/tbody&gt;\n&lt;/table&gt;用于展示数据。可使用&lt;thead&gt;和&lt;tbody&gt;划分表格的表头部分和主体部分(只是为了方便管理而已)，值得注意的是&lt;thead&gt;里面必须包含&lt;tr&gt;标签;&lt;tr&gt;代表行；&lt;td&gt;代表一行中的每个元素(单元格)；&lt;th&gt;表示表头，其实它可以用于表中任何位置如(3,1)，第一行也不一定非要是表头，可以说是&lt;td&gt;带了强调效果(居中加粗),？\n\n    \n         1,1 1,2...1,n \n    \n    \n         2,1 2,2...2,n \n         3,1 3,2...3,n \n         ... ... ... ...\n         m,1 m,2...m,n \n    \n\n常用属性有align(对齐)、border(有无边框)、cellpadding(单元边缘与内容的间隙),cellspacing(单元格之间的间隙),width(表格的宽度),height(表格的高度)。\n\nalign的参数有left，center，right。border的参数有1，0。\nwidth,height的参数可以说像素和百分比。  \n单元格合并的属性的使用：  \n\n\n\n\n\n\n\n\n\n跨行向下合并：rowspan=”合并单元格的个数”跨列向右合并：colspan=”合并单元格的个数”找到合并的起点单元格，向该单元格添加上述属性。删除被合并的单元格。\n一般使用css3进行表格的布局渲染，很少使用表格的属性。\n结束学习了HTML5的相关知识，重点是标签，标签种类以及其属性复杂繁多，应该多加运用才能准确记忆。\n","slug":"HTML语法和常用标签","date":"2022-03-29T07:01:00.000Z","categories_index":"前端","tags_index":"HTML","author_index":"Ac-Accelerator"},{"id":"82bb5c4aa6675d3807368598b5169a90","title":"高等数学上册复习纲要","content":"重新复习高等数学，记下纲要以备查看右键在新标签页中可放大查看。","slug":"高等数学上册复习纲要","date":"2022-03-25T08:40:00.000Z","categories_index":"数学","tags_index":"微积分","author_index":"Ac-Accelerator"},{"id":"c680c055c2c55942f701ddf0f0509a08","title":"Linux系统的常用命令(1)","content":"文件管理说到操作系统，那就不得不提文件管理了。文件管理是使用计算机的基础，是最频繁的操作。学会linux下的文件管理是非常重要的。更多说明可以通过指令\ntxtinfo [指令名称]来查看官方详细文档\nls:列出文件ls为英语单词list的缩写。列出指定文件夹下的内容及其相关属性信息。默认状态下，ls命令会列出当前文件夹的内容。\n格式：ls [参数] [文件夹]\n常用参数：（区分大小写）   \n\n\n\n\n\n\n\n\n\n-a或 --all 显示所有文件及文件夹 (包括以“.”开头的隐藏文件)  -l或--format=long使用长格式列出文件及文件夹信息  -r或--reverse将文件以相反次序显示(默认依英文字母次序)-t或--sort=time根据最后的修改时间排序-A或--almost-all同 -a ，但不列出 “.” (当前文件夹) 及 “..” (父文件夹)-S或--sort=size根据文件大小排序-R或--recursive递归列出所有子文件夹  \n实例:列出当前文件夹下的所有文件和文件夹的详细信息 :\ntxtls -l递归列出 /etc 文件夹下的所有文件夹及文件的详细信息 :\ntxtls -lR /etc列出当前文件夹所有名称是 “a” 开头的文件 :\ntxtls a*列出当前文件夹下所有名称是 “gz” 结尾的文件并按时间排序 :\ntxtls -t *gzmkdir:创建文件夹mkdir命令是make directories的缩写。  \n默认状态下，如果要创建的文件夹已经存在，则提示已存在，而不会继续创建文件夹。 所以在创建文件夹时，应保证新建的文件夹与它所在文件夹下的文件没有重名。 mkdir命令还可以同时创建多个文件夹\n格式:mkdir [参数] [文件夹]  \n常用参数:（区分大小写） \n\n\n\n\n\n\n\n\n\n-p\t递归创建多级文件夹-m\t建立文件夹的同时设置文件夹的权限-z\t设置安全上下文-v\t显示文件夹的创建过程  \n实例在当前文件夹下，建立一个名为 dir 的子文件夹:\ntxtmkdir dir在文件夹/usr/linuxcool下建立子文件夹dir，并且设置文件属主有读、写和执行权限，其他人无权访问\ntxtmkdir -m 700 /usr/linuxcool/dir同时创建子文件夹dir1，dir2，dir3：\ntxtmkdir dir1 dir2 dir3递归创建文件夹：\ntxtmkdir -p linuxcool/dircp:复制cp命令是copy的缩写。  \ncp命令可以将多个文件复制到一个具体的文件名或一个已经存在的文件夹下，也可以同时复制多个文件到一个指定的文件夹中。\n格式:cp [参数] [文件夹]  \n常用参数:（区分大小写）  \n\n\n\n\n\n\n\n\n\n-f或--force若目标文件已存在，则会直接覆盖原文件-i或--interactive若目标文件已存在，则会询问是否覆盖-p或--preserve保留源文件或文件夹的所有属性-r或-R或--recursive递归复制文件和文件夹-d\t当复制符号连接时，把目标文件或文件夹也建立为符号连接，并指向与源文件或文件夹连接的原始文件或文件夹-l或--link对源文件建立硬连接，而非复制文件-s或--symbolic-link对源文件建立符号连接，而非复制文件-b或--backup覆盖已存在的文件目标前将目标文件备份-v或--verbose详细显示cp命令执行的操作过程-a或--archive等价于“dpr”选项  \n实例复制文件夹dir1到dir2下：\ntxtcp -r dir1 dir2将文件f1改名为f2：  \ntxtcp -f f1 f2复制file1,file2,file3到dir下：\ntxtcp -r file1 file2 file3 dir交互式地将文件夹 /usr/linuxcool 中的所有.c文件复制到文件夹 dir 中：\ntxtcp -r /usr/linuxcool/*.c dirpwd:显示当前路径pwd命令是print working directory缩写。显示当前工作文件夹的绝对路径。  \n格式:pwd [参数]\n常用参数:(区分大小写)  \n\n\n\n\n\n\n\n\n\n-L或--logical显示逻辑路径-P或--physica显示物理路径 \nmv:移动或改名文件mv命令是move单词的缩写，可以移动文件或对其改名。  \n格式:mv [参数]\n常用参数:(区分大小写)  \n\n\n\n\n\n\n\n\n\n-i或--interactive若存在同名文件，则向用户询问是否覆盖-f或--force覆盖已有文件时，不进行任何提示-b或--backup当文件存在时，覆盖前为其创建一个备份-u或--update当源文件比目标文件新，或者目标文件不存在时，才执行移动此操作  \n实例将文件file_1重命名为file_2：\ntxtmv file_1 file_2将文件file移动到文件夹dir中 ：\ntxtmv file /dir将文件夹dir1移动文件夹dir2中（前提是文件夹dir2已存在，若不存在则改名)：\ntxtmv /dir1 /dir2将文件夹dir1下的文件移动到当前文件夹下：\ntxtmv /dir1/* ./touch:创建文件pwd命令是print working directory缩写。显示当前工作文件夹的绝对路径。  \n格式:touch [参数] [文件]\n常用参数:  \n\n\n\n\n\n\n\n\n\n-a或--time=access改变档案的读取时间记录-m或--time=modify改变档案的修改时间记录-r或--reference=FILE使用参考档的时间记录，与 –file 的效果一样-c或--no-create不创建新文件-d或--date==TIME设定时间与日期，可以使用各种不同的格式-t\t设定档案的时间记录，格式与 date 命令相同--no-create\t不创建新文件--help\t显示帮助信息--version\t列出版本讯息  \n实例创建空文件file.txt：\ntxttouch file.txt批量创建文件，在当前文件夹生成file1.txt file2.txt file3.txt file4.txt file5.txt 五个文件：\ntxttouch file{1..5}.txt 修改文件的access(访问)时间：\ntxttouch -a file.txtuserdel:删除用户userdel英文全称user delete,用于删除指定的用户及与该用户相关的文件。其实userdel命令实际上是修改了系统的用户账号文件 /etc/passwd、/etc/shadow以及/etc/group文件。如果有该要删除用户相关的进程正在运行，userdel命令通常不会删除一个用户账号。如果确实必须要删除，可以先终止用户进程，然后再执行userdel命令进行删除。但是userdel命令也提供了一个面对该种情况的参数，即”-f”选项。\n格式:userdel [参数] [用户名]\n常用参数:(区分大小写)  \n\n\n\n\n\n\n\n\n\n-f或--force强制删除用户账号-r或--remove删除用户主文件夹及其中的任何文件-h或--help显示命令的帮助信息\n实例删除用户，但不删除其home文件夹及文件：\ntxtuserdel [username]删除用户，并将其家文件夹及文件一并删除：\ntxtuserdel -r [username]强制删除用户：\ntxtuserdel -f [username]ln:创建链接ln英文全称是link，即链接的意思，它的功能是为某一个文件在另外一个位置建立一个同步的链接。 一种是hard link，又称为硬链接，另一种是symbolic link，又称为符号链接。  \n可以把硬链接当成源文件的副本，他和源文件一样的大小，但是事实上却不占任何空间。符号链接可以理解为类似windows一样的快捷方式。  \n\n\n\n\n\n\n\n\n\n符号链接：1.符号链接以路径的形式存在，类似于Windows操作系统中的快捷方式。2.符号链接可以跨文件系统 ，硬链接不可以。3.符号链接可以对一个不存在的文件名进行链接，硬链接不可以。4.符号链接可以对文件夹进行链接，硬链接不可以。  \n\n\n\n\n\n\n\n\n\n硬链接：1.硬链接以文件副本的形式存在，但不占用实际空间。2.硬链接不允许给文件夹创建硬链接。3.硬链接只有在同一个文件系统中才能创建。  \n格式:ln [参数] [源文件或文件夹] [目标文件或文件夹]\n常用参数:(区分大小写) \n\n\n\n\n\n\n\n\n\n-b或--backup为每个已存在的目标文件创建备份文件-d或--directory或-F此选项允许“root”用户建立文件夹的硬链接-f或--force强制创建链接，即使目标文件已经存在-n或--no-dereference把指向文件夹的符号链接视为一个普通文件-i或--interactive交互模式，若目标文件已经存在，则提示用户确认进行覆盖-s或--symbolic对源文件建立符号链接，而非硬链接-v或--verbose详细信息模式，输出指令的详细执行过程 \n实例为源文件file.txt创建硬链接file_1：\ntxtln /root/dir/file.txt ./file_1使用ln命令的“-s”参数来创建文件夹的符号链接，并使用ls命令来查看链接文件的详细信息：\ntxtln -s dir file使用ln命令的“-b”命令来创建目标文件的备份文件:\ntxtln -b /root/dir/file.txt ./file_1chattr:更改文件属性chattr指令可改变linux文件系统的文件属性，通用格式为：+-=[aAcCdDeijsStTu]“ aAcCdDeijsStTu ” 表示可以赋予文件的新属性，这些属性共有以下几种模式 。 \n\n\n\n\n\n\n\n\n\na：让文件或文件夹仅供附加用途；A：当一个具有“A”属性的文件被访问时，它的atime记录不会被修改；c：将文件或文件夹压缩后存放；d：将文件或文件夹排除在倾倒操作之外；i：不得任意更动文件或文件夹；j：如果文件系统安装有“data=order”或“data=writeback”选项，则具有“j”属性的文件在写入文件本身之前将其所有数据写入ext 3日志；s：当删除具有“s”属性集的文件时，其块将被归零并写回磁盘；S：当修改具有“S”属性集的文件时，更改将同步写入磁盘；这相当于应用于文件子集的“同步”挂载选项；u：当删除具有‘u’属性集的文件时，它的内容将被保存。  \n格式chattr [参数] [文件]\n常用参数（区分大小写）  \n\n\n\n\n\n\n\n\n\n-R\t递归处理文件夹下的所有文件-v\t设置文件或文件夹版本-V\t显示指令执行过程+\t开启文件或文件夹的该项属性--\t关闭文件或文件夹的该项属性=\t指定文件或文件夹的该项属性  \n实例用chattr命令防止系统中某个关键文件被修改(加锁)：\ntxtchattr +i /etc/resolv.conf解锁：\ntxtchattr -i /home/omd/h.txt 让某个文件只能往里面追加数据，但不能删除，适用于各种日志文件：\ntxtchattr +a /var/log/messagescd:切换文件夹cd是change directory的缩写，功能是从当前文件夹切换到指定文件夹。其中文件夹的路径可分为绝对路径和相对路径。若文件夹名称省略，则切换至使用者的用户文件夹(也就是刚登录时所在的文件夹)。另外，“~”也表示为用户文件夹的意思，“.”则是表示目前所在的文件夹，”..”则表示当前文件夹位置的上一级文件夹。  \n格式cd [参数] [文件夹名]\n常用参数：  \n\n\n\n\n\n\n\n\n\n-P\t如果切换的目标文件夹是一个符号链接，则直接切换到符号链接指向的目标文件夹-L\t如果切换的目标文件夹是一个符号链接，则直接切换到符号链接名所在的文件夹--\t仅使用”-“选项时，当前文件夹将被切换到环境变量”OLDPWD”对应值的文件夹~\t切换至当前用户文件夹..\t切换至当前文件夹位置的上一级文件夹  \n实例将当前工作文件夹切换到dir文件夹：\ntxtcd dir返回上两级文件夹：\ntxtcd ../..返回上一次所在文件夹：\ntxtcd --locate:快速查找文件locate命令其实是find -name的另一种写法，但是要比后者快得多，原因在于它不搜索具体文件夹，而是搜索一个数据库/var/lib/locatedb，值得注意的是：版本不同，会有所不同。有的版本位置是 /var/lib/mlocate/mlocatedb ，还有的是/var/lib/slocate/slocate.db ，这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。\n格式locate [参数] [文件]\n常用参数  \n\n\n\n\n\n\n\n\n\n-d&lt;文件夹&gt;或--database=&lt;文件夹&gt;\t指定数据库所在的文件夹--help\t显示帮助--version\t显示版本信息  \n实例搜索/etc文件夹下所有以sh开头的文件：\ntxtlocate /etc/sh查找和pwd相关的所有文件：\ntxtlocate pwdwget:文件下载wget命令用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。wget支持HTTP，HTTPS和FTP协议，可以使用HTTP代理。所谓的自动下载是指，wget可以在用户退出系统的之后在后台执行。这意味这你可以登录系统，启动一个wget下载任务，然后退出系统，wget将在后台执行直到任务完成，相对于其它大部分浏览器在下载大量数据时需要用户一直的参与，这省去了极大的麻烦。\n格式：wget [参数]\n常用参数：(区分大小写)  \n\n\n\n\n\n\n\n\n\n-V或–-version 显示wget的版本后退出-O或--output-document=FILE 保存为-h或–-help 打印语法帮助-b或–-background 启动后转入后台执行-e或–-execute=COMMAND   作为wgetrc的一部分执行命令  \n实例使用wget下载单个文件:\ntxtwget https://ac-accelerator.github.io/testfile.zip下载并以不同的文件名保存：\ntxtwget -O test.zip https://ac-accelerator.github.io/testfile.zip使用wget断点续传：\ntxtwget -c https://ac-accelerator.github.io/test.zip使用wget后台下载：\ntxtwget -b https://ac-accelerator.github.io/test.ziptar:打包和备份的归档工具tar命令可以为linux的文件和文件夹创建档案。利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。利用tar命令，可以把一大堆的文件和文件夹全部打包成一个文件。\n格式：tar [参数] [文件或文件夹]\n常用参数：（区分大小写） \n\n\n\n\n\n\n\n\n\n-A\t新增文件到以存在的备份文件-B\t设置区块大小-c\t建立新的备份文件-C &lt;文件夹&gt;\t切换工作文件夹，先进入指定文件夹再执行压缩/解压缩操作，可用于仅压缩特定文件夹里的内容或解压缩到特定文件夹-d\t记录文件的差别-x\t从归档文件中提取文件-t\t列出备份文件的内容-z\t通过gzip指令压缩/解压缩文件，文件名最好为*.tar.gz-Z\t通过compress指令处理备份文件-f &lt;备份文件&gt;\t指定备份文件-v\t显示指令执行过程-r\t添加文件到已经压缩的文件-u\t添加改变了和现有的文件到已经存在的压缩文件-j\t通过bzip2指令压缩/解压缩文件，文件名最好为*.tar.bz2-v\t显示操作过程-l\t文件系统边界设置-k\t保留原有文件不覆盖-m\t保留文件不被覆盖-w\t确认压缩文件的正确性-p\t保留原来的文件权限与属性-P\t使用文件名的绝对路径，不移除文件名称前的“/”号-N &lt;日期格式&gt;\t只将较指定日期更新的文件保存到备份文件里-- -exclude=&lt;范本样式&gt;\t排除符合范本样式的文件-- -remove-files\t归档/压缩之后删除源文件  \n实例将所有.jpg的文件打成一个名为jpg.tar的包：\ntxttar -cf jpg.tar *.jpg打包文件之后删除源文件：\ntxttar -cvf file.tar file --remove-files打包文件以后，以 gzip 压缩：\ntxttar -zcvf log.tar.gz file.log解压缩file.tar.gz：\ntxttar -zxvf file.tar.gz结束至此，linux系统常用命令第一弹到此结束了，相信掌握了上述命令，对linux系统常用的文件操作应该是不陌生了，其实本文的许多内容都来自LinuxCool，一个非常好的学linux的网站，不会的都可以进行参考。\n","slug":"Linux系统的常用命令-1","date":"2022-03-06T02:30:00.000Z","categories_index":"Linux","tags_index":"Linux,文件操作","author_index":"Ac-Accelerator"},{"id":"0b8c5b2ddab35fde5457c41855fd8f40","title":"图的相关算法","content":"打算把图的相关算法都复习记录一遍。以相关题目为主，代码并非最优解。\n图的创建和删除边请编写程序对给定的有向图删除若干条边。有向图中包含n个顶点，编号为0至n-1。输入格式:输入第一行为两个正整数n和e，分别表示图的顶点数和边数，其中n不超过20000，e不超过1000。接下来e行表示每条边的信息，每行为3个非负整数a、b、c，其中a和b表示该边的端点编号，c表示权值。各边并非按端点编号顺序排列。随后一行为一个整数k，表示删除的边的条数，接下来k行，每行为2个非负整数a、b，表示待删除的边为a-&gt;b。保证删除的边一定在原图中。  输出格式:输出执行删边操作之后的图。每行表示一个顶点引出的所有边，格式为a:(a,b,w)……，表示有向边a-&gt;b的权值为w，a引出的多条边按编号b的递增序排列。若某顶点没有引出边，则不输出。输入样例:  \ntxt7 7\n0 1 5\n0 3 7\n0 6 6\n1 2 4\n2 5 1\n3 5 3\n6 5 4\n2\n2 5\n0 1输出样例:  \ntxt0:(0,3,7)(0,6,6)\n1:(1,2,4)\n3:(3,5,3)\n6:(6,5,4)代码:  \ncpp#include &lt;iostream&gt;\n#include &lt;map&gt;\nusing namespace std;\nclass Node\n{\npublic:\n    int value;//节点下标\n    map&lt;int, int&gt; connection; //first:连接的节点的下标，second：对应边的权值\n};\nmain()\n{\n    int n, e;\n    cin &gt;&gt; n &gt;&gt; e;\n    Node list[n];\n    for (int i = 0; i &lt; e; i++)\n    {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        list[a].value = a;\n        list[a].connection[b] = c;\n    }\n    int x;\n    cin &gt;&gt; x;\n    for (int i = 0; i &lt; x; i++)//删边\n    {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        list[a].connection.erase(b);\n    }\n    for (int i = 0; i &lt; n; i++)//按格式输出\n    {\n        if (!list[i].connection.empty())\n        {\n            cout &lt;&lt; i &lt;&lt; ':';\n            for (auto j = list[i].connection.begin(); j != list[i].connection.end(); j++)\n            {\n                cout &lt;&lt; '(' &lt;&lt; i &lt;&lt; ',' &lt;&lt; j-&gt;first &lt;&lt; ',' &lt;&lt; j-&gt;second &lt;&lt; ')';\n            }\n            cout &lt;&lt; endl;\n        }\n    }\n}岛屿数量：深度优先遍历给你一个由 1（陆地）和 0（水）组成的n*m的二维网格，请你计算网格中岛屿的数量num。\n岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。例如\n\n\n\n例\n例\n例\n\n\n\n0\n0\n0\n\n\n0\n1\n0\n\n\n0\n0\n1\n\n\n此为两个岛屿\n此外，你可以假设该网格的四条边均被水包围。1&lt;=n,m&lt;=100输入格式:第一行中给出网格长宽n,m 接下来的n行表示网格情况输出格式:岛屿个数num输入样例:  \ntxt4 5\n1 1 0 0 0\n1 1 0 0 0\n0 0 1 0 0\n0 0 0 1 1输出样例:  \ntxt3代码:  \ncpp#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nstruct node\n{\n    int num = 0;//该点的值\n    bool done = 0;//是否被搜索过\n};\nnode nodes[2002][2002];//图\nvoid dfs(int, int);//选定算法：深度优先遍历\nint sum=0;\nmain()\n{\n    int m, n;\n    cin &gt;&gt; m &gt;&gt; n;\n    for (int i = 1; i &lt;= m;i++)//建图\n        for (int j = 1; j &lt;=n;j++)\n            cin &gt;&gt; nodes[i][j].num;\n    for (int i = 1; i &lt;= m;i++)\n        for (int j = 1; j &lt;=n;j++)\n            if((!nodes[i][j].done)&amp;&amp;nodes[i][j].num==1)//遍历每个点，如果是陆地且没有被走过，则深度优先遍历和它相连的陆地\n            {\n                dfs(i, j);\n                sum++;//岛屿的数量增加\n            }\n    cout &lt;&lt; sum;\n}\nvoid dfs(int i ,int j)\n{\n    if (nodes[i][j].done==1)//被走过，return\n        return;  \n    nodes[i][j].done = 1;//没被走过，进行标记\n    if(nodes[i+1][j].num==1)   //遍历搜索\n        dfs(i + 1, j);  \n    if(nodes[i-1][j].num==1)   \n        dfs(i - 1, j);   \n    if(nodes[i][j+1].num==1)   \n        dfs(i, j+1);\n    if(nodes[i][j-1].num==1) \n        dfs(i , j-1);\n}繁忙的都市：最小生成树城市 C 是一个非常繁忙的大都市，城市中的道路十分的拥挤，于是市长决定对其中的道路进行改造。城市 C 的道路是这样分布的：城市中有 n 个交叉路口，有些交叉路口之间有道路相连，两个交叉路口之间最多有一条道路相连接。这些道路是双向的，且把所有的交叉路口直接或间接的连接起来了。每条道路都有一个分值，分值越小表示这个道路越繁忙，越需要进行改造。但是市政府的资金有限，市长希望进行改造的道路越少越好，于是他提出下面的要求：\n改造的那些道路能够把所有的交叉路口直接或间接的连通起来。\n在满足要求 (1) 的情况下，改造的道路尽量少。\n在满足要求 (1)、(2) 的情况下，改造的那些道路中分值最大的道路分值尽量小。\n任务：作为市规划局的你，应当作出最佳的决策，选择那些道路应当被修建。输入格式:第一行有两个整数 n,m 表示城市有 n 个交叉路口，m 条道路。\n接下来 m 行是对每条道路的描述，u,v,c 表示交叉路口 u 和 v 之间有道路相连，分值为 c 。  1≤n≤300,1≤c≤10000输出格式:两个整数 s,max，表示你选出了几条道路，分值最大的那条道路的分值是多少。输入样例:  \ntxt4 5\n1 2 3\n1 4 5\n2 4 7\n2 3 6\n3 4 8输出样例:  \ntxt3 6代码:  \ncpp#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nclass Node //路径类\n{\npublic:\n    int a, b, c; //节点1，节点2，权\n} list[10000];\nint sign[10000];//用于归类，下标是路径，数值是路径对应的类的编号\nint find(int);//用于找到路径属于哪一类\nbool compare(Node, Node);\nmain()\n{\n    int n, m, maxx=0, num=0;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1; i &lt;= n; i++)//初始化sign数组，每个路基都属于不同类\n        sign[i] = i;\n    for (int i = 1; i &lt;= m; i++)//建图\n        cin &gt;&gt; list[i].a &gt;&gt; list[i].b &gt;&gt; list[i].c;\n    sort(list + 1, list + 1 + m, compare); //对路径按权进行排序\n    for (int i = 1; i &lt;= m; i++)           //遍历所有路径\n    {\n        int u = list[i].a, v = list[i].b;\n        if (find(u) == find(v)) //左节点和右节点属于一类，则已经被连接，说明此路径不是两个节点的最短路径\n            continue;\n        num++;\n        sign[find(u)] = find(v); //连接左节点和右节点，即两个节点归属一类\n        maxx = max(maxx, list[i].c); //更新最大分值\n    }\n    cout &lt;&lt; num &lt;&lt; ' ' &lt;&lt; maxx;\n}\nbool compare(Node a, Node b)\n{\n    return a.c &lt; b.c;\n}\nint find(int x)//难点\n{\n    if (sign[x] != x)//如果不是初始化时的值\n        sign[x] = find(sign[x]);//则更新自己的值\n    return sign[x];\n}排列论文:拓扑排序给定编号为1至n的n篇论文，以及m个形如d, u (1≤d,u≤n,d=u)的引用关系，表示论文论文d中定义的一个名词在论文u中被引用。现在要对这n篇论文重新排列，排列方案须满足如下要求：一篇论文引用的名词必须在排在他前面的论文中被定义过。\n请编写程序粗略计算都有多少种满足要求的方案，如果无满足要求的方案则输出0，如果有唯一方案则输出1，如果有多种方案则输出2。输入格式:输入包含多组数据，每组数据第一行为两个正整数n和m，分别表示论文篇数和引用关系数，均不超过100。接下来m行表示论文引用关系，每行为空格间隔的2个正整数d和u，表示论文论文d中定义的一个名词在论文u中被引用。输出格式:对于每组数据输出一个整数：无满足要求的排列方案则输出0，如果有唯一方案则输出1，如果有多种方案则输出2。输入样例:  \ntxt5 4\n1 5\n5 2\n3 2\n4 3\n5 4\n3 1\n4 2\n1 5\n5 4输出样例:  \ntxt2\n1代码:  \ncpp#include &lt;cstring&gt;\n#include &lt;deque&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nint howMuchBefore[1000];\ndeque&lt;int&gt; dict[1000];//节点名称对子节点的索引\ndeque&lt;int&gt; outcome; //保存结果\ndeque&lt;int&gt; list;   //队列\nmain()\n{\n    int n, m;\n    while (cin &gt;&gt; n &gt;&gt; m)\n    {\n        bool sign = 0; //是否有多种结果\n        int num = 0;  // 起点的数量\n        for (int i = 1; i &lt;= m; i++)\n        {\n            int d, u;\n            cin &gt;&gt; d &gt;&gt; u;\n            dict[d].push_back(u); //给节点d添加一个子节点u\n            howMuchBefore[u]++;     //在u前面的论文个数增加\n        }\n        for (int i = 1; i &lt;= n; i++)\n        {\n            if (howMuchBefore[i] == 0)//拓扑排序，先找出所有起点\n            {              \n                list.push_back(i); //找到就加入队列\n                num++;\n            }\n        }\n        if (num &gt; 1) //起点太多，排序肯定不唯一\n            sign = 1;\n        while (!list.empty())\n        {\n            int p = list.front();//取队列中最前面的元素为p\n            list.pop_front();//删去队列中最前的元素\n            outcome.push_back(p);//添加到排序队列中去\n            for (int i = 0; i &lt; dict[p].size(); i++)//遍历p的子节点\n            {\n                int y = dict[p][i];\n                howMuchBefore[y]--;//告诉这些子节点，在你们之前的元素减少一个\n                if (!howMuchBefore[y])//如果y的前面没有元素了，只能直接将y放入队列\n                {\n                    list.push_back(y);\n                }\n            }\n        }\n        if (outcome.size() == n) //可以进行拓扑排序\n        {\n            if (!sign)\n                cout &lt;&lt; \"1\" &lt;&lt; endl;\n            else\n                cout &lt;&lt; \"2\" &lt;&lt; endl;\n        }\n        else\n            cout &lt;&lt; \"0\" &lt;&lt; endl;    //不能拓扑排序\n        for (int i = 0; i &lt; m; i++) //清空操作\n            dict[i].clear();\n        outcome.clear();\n        while (!list.empty())\n            list.pop_front();\n        memset(howMuchBefore, 0, sizeof(howMuchBefore));\n    }\n}双十一:最短路径算法Floyd双十一期间，某著名电商平台“东东”为应对销售高峰，准备在n个城市中再增加一个自营仓库，其要求是该仓库设在n个城市中的某个城市，且距离其他所有城市的最短距离之和最小。请编写程序帮助“东东”找出设立仓库的地点。假定n个城市编号为0至n-1，它们之间至少有一个城市与其他所有城市可及。输入格式:输入包含多组数据。每组数据第一行为两个正整数n和e，均不超过100。n表示城市数。接下来e行表示两个城市间的距离信息，每行为3个非负整数a、b、c，其中a和b表示两个城市编号，c表示城市间的距离。\n提示：可使用EOF判断输入结束。输出格式:输出为一个整数，表示建立仓库的城市编号，如多个城市满足要求，则输出编号最小者。输入样例:  \ntxt6 5\n0 1 1\n0 2 1\n0 3 1\n0 4 1\n0 5 1\n4 5\n0 1 1\n0 2 5\n1 2 2\n1 3 4\n2 3 1输出样例:  \ntxt0\n1代码:  \ncpp#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\nint map[200][200];//邻接矩阵，出发点到目标的距离=map[出发点][目标];距离为0视为无限大\nmain()\n{\n    int v, e;\n    while (cin &gt;&gt; v &gt;&gt; e)\n    {\n        memset(map, 0, sizeof(map));//初始化为无限大\n        for (int t = 0; t &lt; e; t++)//建图\n        {\n            int i, j;\n            cin &gt;&gt; i &gt;&gt; j &gt;&gt; map[i][j];\n            map[j][i] = map[i][j];\n        }\n        for (int k = 0; k &lt; v; k++)\t\t//Floyd算法找最短路\n            for (int j = 0; j &lt; v; j++)\t\n                for (int i = 0; i &lt; v; i++)\n                    if ((map[i][j] &gt; map[i][k] + map[k][j] || map[i][j] == 0) &amp;&amp; map[i][k] != 0 &amp;&amp; map[k][j] != 0)\n                        map[i][j] = map[i][k] + map[k][j];\n        int sum = 0;\n        int minsum = 99999;\n        int minn = 0;\n        for (int i = 0; i &lt; v; i++)//遍历所有起点找到最短的距离之和\n        {\n            for (int j = 0; j &lt; v; j++)\n            {\n                sum += map[i][j];\n            }\n            if (minsum &gt; sum)\n            {\n                minsum = sum;\n                minn = i;\n            }\n            sum = 0;\n        }\n        cout &lt;&lt; minn&lt;&lt;endl;\n    }\n}最短路径之Dijkstra算法、广度优先搜索本题目要求通过读入无向网的边的信息（省略了各顶点的信息，仅用顶点编号来表示），构造图，并利用Dijkstra算法，求出指定源点到其它各点的最短路径。输入格式:第一行，两个整数，顶点数vN和边数eN。 以后若干行，是相关边的信息，无向图的边是对称的，只输入一半的边（小编号到大编号的，间以空格），最后两行各一个整数，前一个指定源点，后一个指定的查询的终到点。 （注意，示例中34条边，只输入了17条边的信息）输出格式:在一行中输出从源点到指定终点的短路径及代价，注意：所有符号均为西文符号。输入样例:  \ntxt10 34\n0 1 2\n0 3 5\n1 2 5\n1 3 2\n2 4 8\n2 5 4\n3 5 4\n3 6 2\n4 7 5\n4 5 2\n5 6 3\n5 7 9\n5 8 7\n6 8 7\n7 8 3\n7 9 4\n8 9 8\n0\n8输出样例:  \ntxt0--&gt;1--&gt;3--&gt;6--&gt;8:13这里献上B站UP 从0开始数 的算法视频！\n \n\n代码:  \ncpp#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;deque&gt;\nusing namespace std;\nclass Node\n{\npublic:\n    int value;\n    int front;\n    int length = 99999;\n    map&lt;int, int&gt; connect; // first:子节点下标，second:到该子节点的路径权重\n} list[20];//采用邻接表\nbool sign[20];\nint v, e;\nvoid dij(int);\nvoid findpath(int, int);\nmain()\n{\n    cin &gt;&gt; v &gt;&gt; e;\n    for (int i = 0; i &lt; e / 2; i++)//建无向图\n    {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        list[a].value = a;\n        list[b].value = b;\n        list[a].connect[b] = c;\n        list[b].connect[a] = c;\n    }\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    if (n == m)\n        cout &lt;&lt; n &lt;&lt; \"--&gt;\" &lt;&lt; m &lt;&lt; ':' &lt;&lt; 0;\n    else\n    {\n        dij(n);//从n开始进行迪杰斯塔拉\n        findpath(n, m);\n        cout &lt;&lt; m &lt;&lt; ':' &lt;&lt; list[m].length;\n    }\n}\nvoid dij(int s)\n{\n    int minn = 0;//保存目前找到的 离s最近 的节点\n    int num = 0;//保存最小的路径长度\n    list[s].length = 0;//对起点长度先标记为0\n    sign[s] = 1;//不进行比较的标记\n    deque&lt;int&gt; que;//类似于广搜的队列\n    que.push_back(s);\n    while (que.size() != 0)//类广度优先搜索\n    {\n        int min = 99999;\n        for (auto i = list[*que.begin()].connect.begin(); i != list[*que.begin()].connect.end(); i++)//对当前 离s最近 的节点进行子节点遍历\n        {\n            if (sign[list[i-&gt;first].value])//如果已经被标记为不进行比较\n                continue;\n            if (list[i-&gt;first].length &gt; list[*que.begin()].length + i-&gt;second)//还可以更小\n            {\n                list[i-&gt;first].length = list[*que.begin()].length + i-&gt;second; //计算路程\n                list[i-&gt;first].front = list[*que.begin()].value;\t\t\t   //记录下标\n            }\n        }\n        for (int i = 0; i &lt; v; i++)//找到 离s最近 的节点\n            if (list[i].length &lt; min &amp;&amp; sign[i] != 1)\n            {\n                min = list[i].length;\n                minn = i;\n            }\n        sign[minn] = 1;//标记\n        num++;\n        que.pop_back();//删除队首元素\n        if (num &lt; v)//还没搜完\n            que.push_back(minn);//加入此节点\n    }\n}\nvoid findpath(int start, int target)//递归找路\n{\n    if (target == start)\n        return;\n    findpath(start, list[target].front);\n    cout &lt;&lt; list[target].front &lt;&lt; \"--&gt;\";\n}最长路题目描述:设 G 为有 n 个顶点的带权有向无环图，G 中各顶点的编号为 1 到 n，请设计算法，计算图 G 中 1,n 间的最长路径。输入格式:输入的第一行有两个整数，分别代表图的点数 n 和边数m。\n第 22 到第 行，每行 3 个整数 u, v, w（u &lt; v），代表存在一条从 u 到 v 边权为 w 的边。输出格式输出一行一个整数，代表 1 到 n 的最长路。\n若 1 与 n 不连通，请输出 -1。输入  \ntxt2 1\n1 2 1输出\ntxt1代码\ncpp#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cmath&gt;\n#define INF 0x7fffffff   \nusing namespace std;\nint n,m,x,y,z,map[1501][1501];    //邻接矩阵\nint main()\n{\n    cin&gt;&gt;n&gt;&gt;m;   //输入点数和边数\n    for(int i=0;i&lt;n;i++)\n        for(int j=0;j&lt;n;j++)\n            if(i==j) \n                map[i][j]=0;    //邻接矩阵赋初值\n            else map[i][j]=INF;    \n    for(int i=0;i&lt;m;i++)\n    {\n        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;\n        x--,y--;   //编号从1~n，注意处理数组越界问题\n        map[x][y]=min(map[x][y],-z);   //当两个点有多条路时取最长的那条\n    }\n    for(int k=0;k&lt;n;k++)   //Floyd\n        for(int i=0;i&lt;n;i++)\n            for(int j=0;j&lt;n;j++)\n                if(map[i][k]!=INF&amp;&amp;map[k][j]!=INF)\n                    map[i][j]=min(map[i][j],map[i][k]+map[k][j]);\n    if(map[0][n-1]==INF) \n        cout&lt;&lt;-1;   //判断两个点是否连通\n    else \n        cout&lt;&lt;-map[0][n-1];  //相当于map[0][n-1]*-1\n}愿天下有情人都是失散多年的兄妹: 深度有限搜索题目描述:呵呵。大家都知道五服以内不得通婚，即两个人最近的共同祖先如果在五代以内（即本人、父母、祖父母、曾祖父母、高祖父母）则不可通婚。本题就请你帮助一对有情人判断一下，他们究竟是否可以成婚？输入格式:输入第一行给出一个正整数N（2 ≤ N ≤104 ），随后N行，每行按以下格式给出一个人的信息：\ntxt本人ID 性别 父亲ID 母亲ID其中ID是5位数字，每人不同；性别M代表男性、F代表女性。如果某人的父亲或母亲已经不可考，则相应的ID位置上标记为-1。接下来给出一个正整数K，随后K行，每行给出一对有情人的ID，其间以空格分隔。注意：题目保证两个人是同辈，每人只有一个性别，并且血缘关系网中没有乱伦或隔辈成婚的情况。\n输出格式对每一对有情人，判断他们的关系是否可以通婚：如果两人是同性，输出Never Mind；如果是异性并且关系出了五服，输出Yes；如果异性关系未出五服，输出No。输入样例:  \ntxt24\n00001 M 01111 -1\n00002 F 02222 03333\n00003 M 02222 03333\n00004 F 04444 03333\n00005 M 04444 05555\n00006 F 04444 05555\n00007 F 06666 07777\n00008 M 06666 07777\n00009 M 00001 00002\n00010 M 00003 00006\n00011 F 00005 00007\n00012 F 00008 08888\n00013 F 00009 00011\n00014 M 00010 09999\n00015 M 00010 09999\n00016 M 10000 00012\n00017 F -1 00012\n00018 F 11000 00013\n00019 F 11100 00018\n00020 F 00015 11110\n00021 M 11100 00020\n00022 M 00016 -1\n00023 M 10012 00017\n00024 M 00022 10013\n9\n00021 00024\n00019 00024\n00011 00012\n00022 00018\n00001 00004\n00013 00016\n00017 00015\n00019 00021\n00010 00011输出样例：  \ntxtNever Mind\nYes\nNever Mind\nNo\nYes\nNo\nYes\nNo\nNo代码  \ncpp#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;//要深度遍历两个人，所以要两个缓存区\nint path1[100] = {0};//深度遍历的缓存，储存遍历数据\nint path2[100] = {0};\nint depth1 = 0, deep1 = 0;//分别是深度遍历缓存的指针、深度遍历的层数\nint depth2 = 0, deep2 = 0;\nvoid dls(int, int);\nstruct people\n{\n    char sex;\n    int fid = -1;\n    int mid = -1;\n};\npeople guy[100000];\nmain()\n{\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; i++)\n    {\n        int id;\n        cin &gt;&gt; id;\n        cin &gt;&gt; guy[id].sex &gt;&gt; guy[id].fid &gt;&gt; guy[id].mid;\n        if (guy[id].fid != -1)//这里最好给父母亲标好性别，有的人只存在ID\n            guy[guy[id].fid].sex = 'M';\n        if(guy[id].mid!=-1)\n            guy[guy[id].mid].sex = 'F';\n    }\n    cin &gt;&gt; n;\n    int i;\n    for (i = 0; i &lt; n; i++)\n    {\n        depth1 = 0, depth2 = 0;//归零开始新一轮的工作\n        int g1, g2;\n        cin &gt;&gt; g1 &gt;&gt; g2;\n        if (guy[g1].sex == guy[g2].sex)//同性恋\n        {\n            cout &lt;&lt; \"Never Mind\" &lt;&lt; endl;\n            continue;\n        }\n        dls(g1, 1), dls(g2, 2);//对双方分别遍历\n        deep1 = 0, deep2 = 0;//归零以备下次调用\n        bool done = 0;          //优化，用于跳出循环节省时间\n        for (int k = 0; k &lt; depth1; k++)//找是否有共同祖先\n        {\n            for (int l = 0; l &lt; depth2; l++)\n                if (path1[k] == path2[l])\n                {\n                    done = 1;//优化\n                    break;\n                }\n            if (done == 1)//优化\n                break;\n        }\n        if (i != n - 1)//对输出格式的调整\n        {\n            if (done == 1)       \n                cout &lt;&lt; \"No\" &lt;&lt; endl;            \n            else\n                cout &lt;&lt; \"Yes\" &lt;&lt; endl;\n        }\n        else\n        {\n            if (done == 1)           \n                cout &lt;&lt; \"No\";            \n            else\n                cout &lt;&lt; \"Yes\";\n        }\n    }\n}\nvoid dls(int s, int j)\n{\n    if (s == -1)\n        return;//此人无法考证，返回    \n    if ((deep1 == 5 &amp;&amp; j == 1) || (deep2 == 5 &amp;&amp; j == 2))\n        return;//超过5层，停止搜索，返回\n    if (j == 1)\n    {\n        path1[depth1++] = s;//记录在缓存中\n        deep1++;//遍历前，层数增加\n        dls(guy[s].fid, 1);//对父母遍历\n        dls(guy[s].mid, 1);\n        deep1--;//关键，层数回退\n    }\n    else        //同理\n    {\n        path2[depth2++] = s;\n        deep2++;\n        dls(guy[s].fid, 2);\n        dls(guy[s].mid, 2);\n        deep2--;\n    }\n}生化危机:深度优先搜索人类正在经历一场生化危机，许多城市已经被病毒侵袭，这些城市中的人们为了避免感染病毒，计划开车逃往其他没有被病毒入侵的城市（安全城市）。有些城市之间有公路直达，有些没有。虽然他们知道哪些城市是安全的，但是不知道有没有一条安全路径能够到达安全城市（只有该路径上经过的所有城市都是安全的，该路径才是安全路径）。请你编写一个程序帮助他们判断。输入格式:输入第一行为三个正整数，分别表示所有城市个数m（m&lt;=100）、安全城市个数n（m&lt;=50）、公路个数k（k&lt;=100）。随后一行给出n个安全城市的编号。随后k行，每一行给出两个整数，表示连接一条公路的两个城市编号。最后一行输入两个整数，分别表示当前所在城市s、目标城市d。每行整数之间都用空格分隔。\n输出格式:若目标城市已被病毒入侵（非安全城市），输出”The city i is not safe!”；若目标城市为安全城市且从当前所在城市能够经过一条安全路径到达目标城市，输出”The city can arrive safely！”；若目标城市为安全城市但是从当前所在城市没有一条安全路径到达目标城市，输出”The city can not arrive safely！”，i为目标城市编号。\n输入样例1:\ntxt5 2 5\n3 4\n0 1\n0 2\n0 4\n1 2\n2 4\n0 4输出样例1:\ntxtThe city 4 can arrive safely!输入样例2:\ntxt5 2 5\n3 4\n0 1\n0 2\n0 4\n1 2\n2 4\n0 3输出样例2:\ntxtThe city 3 can not arrive safely!输入样例3:\ntxt5 2 5\n3 4\n0 1\n0 2\n0 4\n1 2\n2 4\n0 1输出样例3:\ntxtThe city 1 is not safe!代码\ncpp#include &lt;iostream&gt;\nusing namespace std;\nstruct city//城市类\n{\n    bool done = 0;//是否被搜索过\n    bool safe = 0;//是否安全\n    int conect[101] = {0};//连接的城市\n    int conectnum = 0;//连接城市的数量\n};\nbool dfs(city a[], int start, int end);\nmain()\n{\n    int m, n, k;\n    cin &gt;&gt; m &gt;&gt; n &gt;&gt; k;\n    city a[m];\n    for (int i = 0; i &lt; n; i++)//建图\n    {\n        int no;\n        cin &gt;&gt; no;\n        a[no].safe = 1;\n    }\n    for (int i = 0; i &lt; k; i++)\n    {\n        int d, b;\n        cin &gt;&gt; d &gt;&gt; b;\n        a[d].conect[a[d].conectnum] = b;\n        a[d].conectnum++;\n        a[b].conect[a[b].conectnum] = d;\n        a[b].conectnum++;\n    }\n    int there, that;\n    cin &gt;&gt; there &gt;&gt; that;\n    if (!(a[that].safe))\n    {\n        cout &lt;&lt; \"The city \" &lt;&lt; that &lt;&lt; \" is not safe!\";\n        return 0;\n    }\n    if (dfs(a, there, that))\n        cout &lt;&lt; \"The city \" &lt;&lt; that &lt;&lt; \" can arrive safely!\";\n    else\n        cout &lt;&lt; \"The city \" &lt;&lt; that &lt;&lt; \" can not arrive safely!\";\n}\nbool dfs(city a[], int start, int end)//传入保存城市的数组，开始节点，结束节点\n{\n    if (start == end)//找到\n        return true;\n    if (a[start].done)//被搜索过\n        return false;\n    a[start].done = 1;//标记为被搜索过\n    for (int i = 0; i &lt; a[start].conectnum; i++)//对相连的城市进行深度优先搜索\n        if (dfs(a, a[start].conect[i], end))\n            return true;\n    return false;\n}","slug":"图的相关算法","date":"2022-03-04T04:29:00.000Z","categories_index":"竞赛","tags_index":"C++,算法,图论","author_index":"Ac-Accelerator"},{"id":"39fc6ddd2165079a9fa7e53c3022af95","title":"关于Aurora主题代码高亮的问题","content":"起因这几天兴致勃勃的搞了一个博客，换了几款主题，最后还是选定了极富科技感的Aurora主题。按照官方文档，折腾配置了很久，终于能够使用了。可是最最最最最蛋疼的就是这个代码块的语法高亮。我本人是C++语言的代码（不知道其他语言表现得怎么样），括号颜色极淡，其他的代码颜色也很单一，这就使我很难受。我在官方文档里找不到如何调节这种语法高亮，甚至我把prismjs的文档也看了一遍。还是fail了。\n发现问题可能是源于我前端知识的不足，我过了好久才想明白，任何网页上的元素都可以通过浏览器的F12进行查看和调试。到最后，我通过浏览器的调试功能（F12）找到了根源：post.9f951a60.css\n解决问题使用win自带的文件查找功能，在目录\\node_modules\\hexo-theme-aurora\\source\\static\\css下成功找到此文件。进去一看，乖乖，密密麻麻写的什么玩意儿。介于vscode是我的主力编辑器，我在安装了JS-CSS-HTML Formatter插件后Ctrl + Alt+F成功格式化CSS代码，这看上去不清晰得多？\n修改案例\n找到目标！！  \nCtrl+F搜索这个，\n```css\n.language-markup .token.punctuation,\n```\n你就可以看到一个：\n```css\n.language-css .token.punctuation,\n.language-html .token.punctuation,\n.language-markup .token.punctuation,\n.token.punctuation {\n    color: var(--subs);\n}\n```\n这个 var(--subs)就是造成你括号暗淡的罪魁祸首。\n\n法一：你可以搜索:root,并到–subs这里进行修改。\n法二：直接吧var(--subs)修改为其他颜色如#33ff00。\n关于其他问题都可以通过浏览器的F12功能来找到问题，然后对应修改\n","slug":"关于Aurora主题代码高亮的问题","date":"2022-03-03T11:28:00.000Z","categories_index":"前端","tags_index":"CSS,前端","author_index":"Ac-Accelerator"},{"id":"8d834d6f39e88bf7e2572d42a71885db","title":"字符串匹配算法","content":"1.暴力匹配：设三个指针，第一个用来指向原字符串，表示当前位置。剩下两个分别用来指向当前正在进行匹配的字符。  这是最简单的字符串匹配，其效率比较低，在算法竞赛中最好不要使用。\n2.KMP算法：找第一个匹配的下标\ncppvoid get_Next(string &amp;target, size_t tl, size_t *Next) //求出Next数组\n{                                                      // Next数组是从 target[0到i-1]前子串 的前缀后缀最大值\n    size_t point1 = 0, point2;\n    Next[0] = point2 = ULLONG_MAX;                                    // next数组首位默认为ULLONG_MAX\n    while (point1 &lt; tl)                                               //边界条件\n        if (point2 == ULLONG_MAX || target[point1] == target[point2]) //类似于KMP的匹配\n            Next[++point1] = ++point2;\n        else\n            point2 = Next[point2]; //失配\n}\nsize_t KMP(string &amp;origin, string &amp;target, size_t ol, size_t tl)\n{\n    size_t Next[tl];\n    get_Next(target, tl, Next);    //获得next数组\n    size_t point1 = 0, point2 = 0; //从0位开始匹配\n    while (point1 &lt; ol)            //临界值\n    {\n        if (point2 == ULLONG_MAX || origin[point1] == target[point2]) //相应字符匹配成功，继续\n        {\n            point2++, point1++;\n            if (point2 == tl)\n                return point1 - tl;\n        }\n        else\n            point2 = Next[point2]; //失配\n    }\n    return ol; //返回\n}计算包含多少个子串\ncppvoid get_Next(string &amp;target, size_t tl, size_t *Next) //求出Next数组\n{                                                      // Next数组是从 target[0到i-1]前子串 的前缀后缀最大值\n    size_t point1 = 0, point2;\n    Next[0] = point2 = ULLONG_MAX;                                    // next数组首位默认为ULLONG_MAX\n    while (point1 &lt; tl)                                               //边界条件\n        if (point2 == ULLONG_MAX || target[point1] == target[point2]) //类似于KMP的匹配\n            Next[++point1] = ++point2;\n        else\n            point2 = Next[point2]; //失配\n}\nsize_t KMP(string &amp;origin, string &amp;target, size_t ol, size_t tl)\n{\n    size_t Next[tl], sum = 0;\n    get_Next(target, tl, Next);    //获得next数组\n    size_t point1 = 0, point2 = 0; //从0位开始匹配\n    while (point1 &lt; ol)            //临界值\n    {\n        if (point2 == ULLONG_MAX || origin[point1] == target[point2]) //相应字符匹配成功，继续\n            point2++, point1++;\n        else\n            point2 = Next[point2]; //失配\n        if (point2 == tl)\n            sum++, point2 = Next[point2];\n    }\n    return sum; //返回\n}Sunday算法：找第一个匹配的下标\ncpp#define MAX_CHAR 256\nvoid GetNext(string &amp;p, size_t ot, size_t *Next);\nsize_t Sunday(string &amp;origin, size_t ol, string &amp;target, size_t tl);\nvoid GetNext(string &amp;p, size_t ot, size_t *Next) //标记各个字符所在的最大位置\n{\n    for (size_t i = 1; i &lt;= ot; ++i) //标记\n        Next[static_cast&lt;size_t&gt;(p[i - 1])] = i;\n}\nsize_t Sunday(string &amp;origin, size_t ol, string &amp;target, size_t tl)\n{\n    size_t Next[MAX_CHAR]{}; //声明next数组，用于存放字符位移量\n    GetNext(target, tl, Next);\n    size_t j = 0, k = 0; // origin 的下标 . target 的下标\n    size_t i = 0;\n    while (i &lt;= ol - tl) //走到尾部退出循环\n    {\n        j = i, k = 0;                                      // origin的下标指向最新的位置，target的下标重置，指向首位\n        while (j &lt; ol &amp;&amp; k &lt; tl &amp;&amp; origin[j] == target[k]) //如果相同，且未越界，则进行下一个字符的比对\n        {\n            j++, k++;\n        }\n        if (k == tl) //如果比对成功，则有k= target的长度，可进行操作\n            return j - tl;\n        if (i + tl &lt; ol)                               //如果在范围内，则重新将i定义为\n            i += (tl - Next[static_cast&lt;size_t&gt;(origin[i + tl])] + 1); ////////****算法核心****////////\n        /*  origin[i+tl]  指的是原字符串下一个字符，next[]是储存该字符位移量的数组。\n            如果target里有该字符，则进行指定长度的位移，没有则位移 (target的长度 +1)   */\n        else\n            break; //优化\n    }\n    return ol;\n}计算包含多少个子串\ncpp#define MAX_CHAR 256\nvoid GetNext(string &amp;p, size_t ot, size_t *Next);\nsize_t Sunday(string &amp;origin, size_t ol, string &amp;target, size_t tl);\nvoid GetNext(string &amp;p, size_t ot, size_t *Next) //标记各个字符所在的最大位置\n{\n    for (size_t i = 1; i &lt;= ot; ++i) //标记\n        Next[static_cast&lt;size_t&gt;(p[i - 1])] = i;\n}\nsize_t Sunday(string &amp;origin, size_t ol, string &amp;target, size_t tl)\n{\n    size_t Next[MAX_CHAR]{}, sum = 0; //声明next数组，用于存放字符位移量\n    GetNext(target, tl, Next);\n    size_t j = 0, k = 0; // origin 的下标 . target 的下标\n    size_t i = 0;\n    while (i &lt;= ol - tl) //走到尾部退出循环\n    {\n        j = i, k = 0;                                      // origin的下标指向最新的位置，target的下标重置，指向首位\n        while (j &lt; ol &amp;&amp; k &lt; tl &amp;&amp; origin[j] == target[k]) //如果相同，且未越界，则进行下一个字符的比对\n            ++j, ++k;\n        if (k == tl) //如果比对成功，则有k= target的长度，可进行操作\n            ++sum;\n        if (i + tl &lt; ol)                                               //如果在范围内，则重新将i定义为\n            i += (tl - Next[static_cast&lt;size_t&gt;(origin[i + tl])] + 1); ////////****算法核心****////////\n        /*  origin[i+tl]  指的是原字符串下一个字符，next[]是储存该字符位移量的数组。\n            如果target里有该字符，则进行指定长度的位移，没有则位移 (target的长度 +1)   */\n        else\n            break; //优化\n    }\n    return sum;\n}上述两种算法都是比较快速的算法，都是通过初始化Next数组，来实现对比位置的快速跳转。其中KMP属于时间复杂度稳定的算法，在ACM竞赛中经常使用，由此来避免特殊的字符串。而Sunday算法属于时间复杂度不稳定的算法，偏向实用，在实际工程中的效率KMP算法高。\n","slug":"字符串匹配算法","date":"2022-03-02T16:02:00.000Z","categories_index":"竞赛","tags_index":"C++,算法,字符串","author_index":"Ac-Accelerator"},{"id":"bdc46d1d5c3047d25f1a097055d8e321","title":"第十一届蓝桥杯省赛C++ A组题解","content":"出于能力和精力问题，有一部分题目暂无题解，见谅\n试题A 门牌制作小蓝要为一条街的住户制作门牌号这条街一共有 2020 位住户，门牌号从 1 到 2020 编号。小蓝制作门牌的方法是先制作 0 到 9 这几个数字字符，最后根据需要将字符粘贴到门牌上，例如门牌 1017 需要依次粘贴字符 1、0、1、7，即需要 1 个字符 0，2 个字符 1，1 个字符 7。请问要制作所有的 1 到 2020 号门牌，总共需要多少个字符 2?\ncpp#include &lt;iostream&gt;\nusing namespace std;\nint sum = 0;\nvoid find2(int a)\n&#123;\n    while (a != 0)\n    &#123;\n        if (a % 10 == 2)\n            sum++;\n        a /= 10;\n    &#125;\n&#125;\nint main()\n&#123;\n    for (int i = 0; i &lt;= 2020; i++)\n        find2(i);\n    cout &lt;&lt; sum;\n&#125;试题B 既约分数如果一个分数的分子和分母的最大公约数是1，这个分数称为既约分数。例如，$3&#x2F;4$ ， $5&#x2F;2$ ， $1&#x2F;8$  ， $7&#x2F;1$ 都是既约分数。请问，有多少个既约分数，分子和分母都是1 到2020 之间的整数（包括1和2020）？\ncpp#include &lt;iostream&gt;\nusing namespace std;\nint GreatestCommonDivisor(int a, int b)\n&#123;\n    if (a == 0 || b == 0)\n        return 1;\n    int tmp;\n    while (a % b != 0)\n    &#123;\n        tmp = a;\n        a = b;\n        b = tmp % b;\n    &#125;\n    return b;\n&#125;\nint main()\n&#123;\n    int sum = 0;\n    for (int i = 1; i &lt; 2021; i++)\n        for (int j = 1; j &lt; 2021; j++)\n            if (GreatestCommonDivisor(i, j) == 1)\n                sum++;\n    cout &lt;&lt; sum;\n&#125;试题C 蛇形填数如下图所示，小明用从 1 开始的正整数“蛇形”填充无限大的矩阵。1 2 6 7 15 …3 5 8 14 …4 9 13 …10 12 …11 ……求20行第20列的数字观察规律可得第i行第i列公式为 $2i^2-2i+1$求出答案为761\n试题D 七段码有127中情况，用用二进制可以表示哪个灯亮了哪个灯没亮；建图，然后就深度优先遍历看看亮的灯是否联通\n试题F 平面分割20 个圆和20 条直线最多能把平面分成多少个部分？\ncpp#include&lt;iostream&gt;\nusing namespace std;\nint main()\n&#123;\n    int n=20;\n    int m=20;\n    int ans=1+(n*(n+1))/2+(m*(2*n+2*n+2*(m-1)))/2;\n    cout&lt;&lt;ans&lt;&lt;endl;\n    return 0;\n&#125;试题F 成绩分析小蓝给学生们组织了一场考试，卷面总分为100分，每个学生的得分都是一个0到100的整数。请计算这次考试的最高分、最低分和平均分\ncpp#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nint main()\n&#123;\n    int n;\n    cin &gt;&gt; n;\n    int list[n];\n    double sum = 0;\n    for (int i = 0; i &lt; n;i++)\n    &#123;\n        cin &gt;&gt; list[i];\n        sum += list[i];\n    &#125;\n    sort(list, list + n);\n    cout &lt;&lt; list[n - 1] &lt;&lt; endl\n         &lt;&lt; list[0] &lt;&lt; endl\n         &lt;&lt; sum / n;\n&#125;试题G 回文日期2020 年春节期间，有一个特殊的日期引起了大家的注意：2020 年 2 月 2日。因为如果将这个日期按 “yyyymmdd” 的格式写成一个 8 位数是 20200202，恰好是一个回文数。我们称这样的日期是回文日期。有人表示 20200202 是 “千年一遇” 的特殊日子。对此小明很不认同，因为不到 2 年之后就是下一个回文日期：20211202 即 2021 年 12 月 2 日。也有人表示 20200202 并不仅仅是一个回文日期，还是一个 ABABBABA型的回文日期。对此小明也不认同，因为大约 100 年后就能遇到下一个ABABBABA 型的回文日期：21211212 即 2121 年 12 月 12 日。算不上 “千年一遇”，顶多算 “千年两遇”。给定一个 8 位数的日期，请你计算该日期之后下一个回文日期和下一个ABABBABA 型的回文日期各是哪一天。   \n解：一共约366种回文日期，用sort排序然后与输入对比，找到之后就输出。\ncpp#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nstring turn(int a)//转化为标准格式输出\n&#123;\n    string ans;\n    for (int i = 0; i &lt; 8;i++)\n    &#123;\n        ans = char(a % 10 + &#39;0&#39;) + ans;\n        a /= 10;\n    &#125;\n    return ans;\n&#125;\nint rev(int a)//对 （月/日） 进行回文获得年份\n&#123;\n    int ans = 0;\n    for (int i = 0; i &lt; 4;i++)\n    &#123;\n        ans = ans * 10 + a % 10;\n        a /= 10;\n    &#125;\n    return ans;\n&#125;\nint main()\n&#123;\n    int lists[370], p = 0;//所有回文\n    int abab[14], l = 0;//abab形回文\n    int month[] = &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;//十二个月\n    for (int i = 1; i &lt;= 12; i++)\n    &#123;\n        for (int j = 1; j &lt;= month[i]; j++)\n        &#123;\n            int k = i * 100 + j;\n            k = rev(k) * 10000 + k;\n            lists[p++] = k;\n            if (i == j &amp;&amp; i / 10 != i % 10)//判断abab形回文\n            &#123;\n                abab[l++] = k;\n            &#125;\n        &#125;\n    &#125;\n    lists[p++] = 92200229;//闰年\n    sort(lists, lists + p);\n    sort(abab, abab + l);\n    int stds;\n    cin &gt;&gt; stds;\n    for (int i = 0; i &lt; p; i++)\n    &#123;\n        if (lists[i] &gt; stds)\n        &#123;\n            cout &lt;&lt; turn(lists[i]);\n            break;\n        &#125;   \n    &#125;\n    cout &lt;&lt; endl;\n    for (int i = 0; i &lt; l; i++)\n    &#123;\n        if (abab[i] &gt; stds)\n        &#123;\n            cout &lt;&lt; turn(abab[i]);\n            break;\n        &#125;   \n    &#125;\n&#125;","slug":"第十一届蓝桥杯省赛C-A组题解","date":"2022-03-02T12:30:00.000Z","categories_index":"竞赛","tags_index":"C++,算法,蓝桥杯","author_index":"Ac-Accelerator"},{"id":"30bb43ff3003d537e8635ebe0ad2a3db","title":"第十届蓝桥杯省赛C++ A组题解","content":"出于能力和精力问题，有一部分题目暂无题解，见谅\n试题A 平方和小明对数位中含有2、0、1、9的数字很感兴趣，在1到40中这样的数包括1、2、9、10至32、39和40，共28个，他们的和是574，平方和是14362。注意，平方和是指将每个数分别平方后求和。请问，在1到2019中，所有这样的数的平方和是多少?\ncpp#include &lt;iostream&gt;\nusing namespace std;\nbool find(int a)\n{\n    while (a != 0)\n    {\n        int t = a % 10;\n        if (t == 0 || t == 9 || t == 1 || t == 2)\n            return true;\n        a /= 10;\n    }\n    return false;\n}\nint main()\n{\n    unsigned long long a = 0;\n    for (int i = 1; i &lt; 2020; i++)\n        if (find(i))\n            a += i * i;\n    cout &lt;&lt; a;\n}试题B 数列求值给定数列1,1,1,3,5,9,17…，从第4项开始，每项都是前3项的和。求第20190324项的最后4位数字。\ncpp#include &lt;iostream&gt;\n#include &lt;cmath&gt;    \nusing namespace std;\nint cal(int a)\n{\n    int ans = 0;\n    for (int i = 0; i &lt; 4&amp;&amp;a!=0; i++)\n    {\n        ans = (a % 10) * pow(10,i)+ans;\n        a /= 10;\n    }\n    return ans;\n}\nint list[20190325] = {0, 1, 1, 1};\nint main()\n{\n    for (int i = 4; i &lt; 20190325;i++)\n    {\n        list[i] = cal(list[i - 1] + list[i - 2] + list[i - 3]);\n    }\n    cout &lt;&lt; list[20190324];\n}试题C 最大降雨量由于沙之国长年干旱，法师小明准备施展自己的一个神秘法术来求雨。这个法术需要用到他手中的49张法术符，上面分别写着1至49这49个数字。法术一共持续7周，每天小明都要使用一张法术符，法术符不能重复使用。每周，小明施展法术产生的能量为这周7张法术符上数字的中位数。法术施展完7周后，求雨将获得成功，降雨量为7周能量的中位数。由于干旱太久，小明希望这次求雨的降雨量尽可能大，请大最大值是多少?\n解：贪心算法，尽量取每周都取到能取得最大的中位数，然后加起来。\n\n\n\n第一周\n第二周\n第三周\n…\n\n\n\n46\n42\n38\n…\n\n\n得到结果：238\n试题D 迷宫下图给出了一个迷宫的平面图，其中标记为 1 的为障碍，标记为 0 的为可以通行的地方。010000000100001001110000迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这个它的上、下、左、右四个方向之一。对于上面的迷宫，从入口开始，可以按DRRURRDDDR 的顺序通过迷宫，一共 10 步。其中 D、U、L、R 分别表示向下、向上、向左、向右走。对于下面这个更复杂的迷宫（30 行 50 列），请找出一种通过迷宫的方式，其使用的步数最少，在步数最少的前提下，请找出字典序最小的一个作为答案。请注意在字典序中D &lt; L &lt; R &lt; U。（如果你把以下文字复制到文本文件中，请务必检查复制的内容是否与文档中的一致。在试题目录下有一个文件 maze.txt，内容与下面的文本相同）\ntxt01010101001011001001010110010110100100001000101010\n00001000100000101010010000100000001001100110100101\n01111011010010001000001101001011100011000000010000\n01000000001010100011010000101000001010101011001011\n00011111000000101000010010100010100000101100000000\n11001000110101000010101100011010011010101011110111\n00011011010101001001001010000001000101001110000000\n10100000101000100110101010111110011000010000111010\n00111000001010100001100010000001000101001100001001\n11000110100001110010001001010101010101010001101000\n00010000100100000101001010101110100010101010000101\n11100100101001001000010000010101010100100100010100\n00000010000000101011001111010001100000101010100011\n10101010011100001000011000010110011110110100001000\n10101010100001101010100101000010100000111011101001\n10000000101100010000101100101101001011100000000100\n10101001000000010100100001000100000100011110101001\n00101001010101101001010100011010101101110000110101\n11001010000100001100000010100101000001000111000010\n00001000110000110101101000000100101001001000011101\n10100101000101000000001110110010110101101010100001\n00101000010000110101010000100010001001000100010101\n10100001000110010001000010101001010101011111010010\n00000100101000000110010100101001000001000000000010\n11010000001001110111001001000011101001011011101000\n00000110100010001000100000001000011101000000110011\n10101000101000100010001111100010101001010000001000\n10000010100101001010110000000100101010001011101000\n00111100001000010000000110111000000001000000001011\n10000001100111010111010001000110111010101101111000解：广度优先搜索\ncpp#include &lt;iostream&gt;\n#include &lt;deque&gt;\nusing namespace std;\n\nbool notout(int x, int y)\n{\n    return x &gt;= 0 &amp;&amp; x &lt; 30 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; 50;\n}\nstruct point\n{\n    int x, y;\n    char front;\n    bool done = 0;\n};\nint main()\n{\n    point map[30][50];\n    for (int i = 0; i &lt; 30; i++)\n    {\n        for (int j = 0; j &lt; 50; j++)\n        {\n            char t;\n            cin &gt;&gt; t;\n            map[i][j].x = i, map[i][j].y = j;\n            if (t - '0' == 1)\n            {\n                map[i][j].done = 1;\n            }\n        }\n    }\n    deque&lt;point&gt; list;\n    point start;\n    start.x = 0, start.y = 0;\n    list.push_back(start);\n    map[0][0].done = 1;\n    while (!list.empty())\n    {\n        if (notout(list.begin()-&gt;x, list.begin()-&gt;y + 1) &amp;&amp; !map[list.begin()-&gt;x][list.begin()-&gt;y + 1].done)\n        {\n            map[list.begin()-&gt;x][list.begin()-&gt;y + 1].done = 1;\n            list.push_back(map[list.begin()-&gt;x][list.begin()-&gt;y + 1]);\n            map[list.begin()-&gt;x][list.begin()-&gt;y + 1].front = 'R';\n        }\n        if (notout(list.begin()-&gt;x - 1, list.begin()-&gt;y) &amp;&amp; !map[list.begin()-&gt;x - 1][list.begin()-&gt;y].done)\n        {\n            map[list.begin()-&gt;x - 1][list.begin()-&gt;y].done = 1;\n            list.push_back(map[list.begin()-&gt;x - 1][list.begin()-&gt;y]);\n            map[list.begin()-&gt;x - 1][list.begin()-&gt;y].front = 'U';\n        }\n        if (notout(list.begin()-&gt;x + 1, list.begin()-&gt;y) &amp;&amp; !map[list.begin()-&gt;x + 1][list.begin()-&gt;y].done)\n        {\n            map[list.begin()-&gt;x + 1][list.begin()-&gt;y].done = 1;\n            list.push_back(map[list.begin()-&gt;x + 1][list.begin()-&gt;y]);\n            map[list.begin()-&gt;x + 1][list.begin()-&gt;y].front = 'D';\n        }\n        if (notout(list.begin()-&gt;x, list.begin()-&gt;y - 1) &amp;&amp; !map[list.begin()-&gt;x][list.begin()-&gt;y - 1].done)\n        {\n            map[list.begin()-&gt;x][list.begin()-&gt;y - 1].done = 1;\n            list.push_back(map[list.begin()-&gt;x][list.begin()-&gt;y - 1]);\n            map[list.begin()-&gt;x][list.begin()-&gt;y - 1].front = 'L';\n        }\n        list.pop_front();\n    }\n    start.x = 29, start.y = 49;\n    string ans;\n    while (!(start.x == 0 &amp;&amp; start.y == 0))\n    {\n        ans = map[start.x][start.y].front + ans;\n        if (map[start.x][start.y].front == 'U')\n            start.x += 1;\n        else if (map[start.x][start.y].front == 'D')\n            start.x -= 1;\n        else if (map[start.x][start.y].front == 'R')\n            start.y -= 1;\n        else if (map[start.x][start.y].front == 'L')\n            start.y += 1;\n    }\n    cout &lt;&lt; ans;\n}试题F 完全二叉树的权值现在小明要把相同深度的节点的权值加在- - 起，他想知道哪个深度的节点权值之和最大?如果有多个深度的权值和同为最大，请你输出其中最小的深度。注:根的深度是1。\ncpp#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nusing namespace std;\nint main()\n{\n    int n;\n    cin &gt;&gt;n;\n    int list[n];\n    for (int i = 0; i &lt; n;i++)\n        cin &gt;&gt; list[i];\n    int p=0;\n    int ma = 0;\n    int c = 0;\n    for (int i = 0; i &lt; log(n+1)/log(2);i++)\n    {\n        int sum = 0;\n        for (int j = 0; j &lt; pow(2, i);j++)\n            sum += list[p++];\n        if(ma&lt;sum)\n        {\n            ma = sum;\n            c = i + 1;\n        }\n    }\n    cout &lt;&lt; c;\n}试题G 外卖店优先级cpp#include&lt;bits/stdc++.h&gt;\n#define ll long long\nusing namespace std;\nint mon[2][13]=&lt;!--swig￼0--&gt;;\nint n;\nbool isleap(int x);\nbool islegaldate(int x);\nbool ishui(int x);\nbool isab(int x);\nint main(){\n    cin &gt;&gt; n;\n    int t = n;\n    int i = 0,j = 0;\n    while(!i){\n        t++;\n        if(islegaldate(t)){\n            if(ishui(t)){\n                i = t;\n            }\n        }\n    }\n    t = i-1;\n    while(!j){\n        t++;\n        if(islegaldate(t))\n        {\n            if(ishui(t))\n            {\n                if(isab(t))\n                j = t;\n            }\n        }\n    }\n    cout &lt;&lt; i &lt;&lt; endl &lt;&lt; j &lt;&lt; endl;\n    return 0;\n}\n\nbool isleap(int x){\n    if((x%4==0 &amp;&amp; x%100!=0)||(x%400==0)){\n        return 1;\n    }\n    return 0;\n}\n\nbool islegaldate(int x){\n    int y=x/10000;\n    int m=(x/100)%100;\n    int d=x%100;\n    if(y&gt;0 &amp;&amp; m&gt;0 &amp;&amp; m&lt;=12){\n        if(d&lt;mon[isleap(y)][m])\n            return 1;\n    }\n    return 0;\n}\n\nbool ishui(int x){\n    int t=x,r=0;\n    while(x){\n        r=r*10+x%10;\n        x/=10;\n    }\n    if(t==r){\n        return 1;\n    }\n    return 0;\n}\n\nbool isab(int x){\n    int y=x/10000;\n    int m=(x/100)%100;\n    int d=x%100;\n    int k=y/100;\n    int n=y%100;\n    if(k==n &amp;&amp; m==d){\n        return 1;\n    }\n    return 0;\n}\n","slug":"第十届蓝桥杯省赛C-A组题解","date":"2022-03-02T12:27:00.000Z","categories_index":"竞赛","tags_index":"C++,算法,蓝桥杯","author_index":"Ac-Accelerator"},{"id":"4f751f81a9110dfd7e708061eb5ee903","title":"第十二届蓝桥杯省赛C++ A组题解","content":"出于能力和精力问题，有一部分题目暂无题解，见谅\n试题A 卡片小蓝有很多数字卡片，每张卡片上都是数字0到9。小蓝准备用这些卡片来拼一些数，他想从1开始拼出正整数，每拼一个，就保存起来，卡片就不能用来拼其它数了。小蓝想知道自己能从1拼到多少。例如，当小蓝有30张卡片，其中0到9各3张，则小蓝可以拼出1到10,但是拼11时卡片1已经只有一张了，不够拼出11。现在小蓝手里有0到9的卡片各2021张，共20210 张，请问小蓝可以从1拼到多少?\ncpp#include &lt;iostream&gt;\nusing namespace std;\nint list[10];\nint find(int a)\n{\n    while (a != 0)\n    {\n        if (list[a % 10] == 0)\n        {\n            return 0;\n        }\n        list[a % 10]--;\n        a /= 10;\n    }\n    return 1;\n}\nint main()\n{\n    for (int i = 0; i &lt; 10; i++)\n    {\n        list[i] = 2021;\n    }\n    for (int i = 1; i &lt; 999999; i++)\n    {\n        if (find(i) == 0)\n        {\n            cout &lt;&lt; i - 1;\n            break;\n        }\n    }\n}试题B 直线在平面直角坐标系中，两点可以确定一条直线。如果有多点在一条直线上，那么这些点中任意两点确定的直线是同一条。给定平面上2×3个整点{(x,y)|0≤x&lt;2,0≤y&lt;3,x∈Z,y∈Z}，即横坐标是0到1(包含0和1)之间的整数、纵坐标是О到2(包含О和2)之间的整数的点。这些点一共确定了11条不同的直线。给定平面上20×21个整点{(x,y)[0 ≤x &lt;20,0 ≤ y &lt; 21,x ∈ ‘Z,y ∈Z)，即横坐标是О到19(包含0和 19)之间的整数、纵坐标是О到20(包含О和20)之间的整数的点。请问这些点一共确定了多少条不同的直线。\ncpp#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;vector&gt;\n#include &lt;cmath&gt;\nusing namespace std;\ntypedef pair&lt;int, int&gt; PII;//二维\ntypedef pair&lt;PII, int&gt; PIII;//三维\nset&lt;PIII&gt; line;//线的参数\nvector&lt;PII&gt; point;//点\nint gcd(int a, int b)//最大公约数\n{\n    if (b == 0)\n        return a;\n    return gcd(b, a % b);\n}\nint main()\n{\n    for (int i = 0; i &lt; 20; i++)\n        for (int j = 0; j &lt; 21; j++)\n            point.push_back({i, j});//记录点的坐标\n    for (int i = 0; i &lt; point.size(); i++)\n    {\n        for (int j = i + 1; j &lt; point.size(); j++)\n        {\n            int x1 = point[i].first, y1 = point[i].second;\n            int x2 = point[j].first, y2 = point[j].second;\n            int A = x2 - x1, B = y1 - y2, C = x1 * y2 - x2 * y1;\n            int gcdd = gcd(gcd(A, B), C);//约分前的工作\n            line.insert(","slug":"第十二届蓝桥杯省赛C-A组题解","date":"2022-03-02T12:19:00.000Z","categories_index":"竞赛","tags_index":"C++,算法,蓝桥杯","author_index":"Ac-Accelerator"},{"id":"03e1cda0baa3a649921c8af01fed4d68","title":"我的第一篇博客","content":"博客的开始经过了一天的努力，我参照了很多帖子，终于在github平台上搭建起了自己的博客。以后我会尝试在这上面分享我的生活和学习。包括很多的算法和计算机知识也会在这里分享。由于本人才疏学浅，所理解的知识难免存在不够好的地方，欢迎指正和交流！\n写博客的理由在我初学计算机的时候，我曾经也是个P都不懂的小白。经常进行各种傻逼操作，我和我的电脑都累坏了。看了很多大佬的博客还有帖子，我才找到正确的路。于是，我也想成为学弟学妹的领路人。总之就是这种情况。还有就是我其实是一个非常健忘的people。所以我想把我学到的算法，学到的知识记录下来，管他有没有人看，我自己看。在浏览器里看总比在doc里面看养眼多了吧。\n结语加油，先更他个一百篇！\n","slug":"我的第一篇博客-1","date":"2022-03-02T10:29:00.000Z","categories_index":"生活","tags_index":"","author_index":"Ac-Accelerator"}]