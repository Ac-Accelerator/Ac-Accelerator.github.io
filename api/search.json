[{"id":"3255a3c7fdb01a732e78ce23940a0d52","title":"STM32入门（八）：定时器","content":"有时会在单片机中需要等待一段时间再执行的命令。我们有两种方式实现，一种是让CPU空转，另一种是使用定时器。空转的方式会浪费CPU资源，且时间准确度很低（由于ARM使用流水线的原因），而定时器则不会。本文主要介绍定时器的使用。\n定时器的基本原理基本上就是一个带有自动重装载的16位累加计数器，计数器的时钟通过一个预分频器得到。当计数器的值达到设定值时，就会加载重装载值到计数器，并触发相应操作。\n定时器的分类一共有三个大类：常规定时器、专用定时器和内核定时器。\n\n常规定时器\n基本定时器\n通用定时器\n高级定时器\n\n\n专用定时器\n窗口看门狗\n独立看门狗\n实时时钟（RTC）\n低功耗定时器\n\n\n内核定时器\n系统定时器（SysTick）\n\n\n\n本文介绍常规定时器。\n定时器计数模式向上计数模式在向上计数模式中，计数器从0计数到自动加载值(TIMx_ARR计数器的内容)，然后重新从0开始计数并且产生一个计数器溢出事件。每次计数器溢出时可以产生更新事件（也可以不产生哦）。\n向下计数模式在向下模式中，计数器从自动装入的值(TIMx_ARR计数器的值)开始向下计数到0，然后从自动装入的值重新开始并且产生一个计数器向下溢出事件。每次计数器溢出时可以产生更新事件（也可以不产生哦）。\n中央对齐模式（向上/向下计数模式）\n\n\n\n\n\n\n\n\n在这个模式，不能写入TIMx_CR1中的DIR方向位。它由硬件更新并指示当前的计数方向。\n在中央对齐模式，计数器从0开始计数到自动加载的值(TIMx_ARR寄存器)−1，产生一个计数器溢出事件，然后向下计数到1并且产生一个计数器下溢事件；然后再从0开始重新计数。可以在每次计数上溢和每次计数下溢时产生更新事件（也可以不产生哦）；\n\n\n\n\n\n\n\n\n\n关于更新事件： 当发生一次更新事件时，所有寄存器会被更新：\n\n传送预装载值(TIMx_PSC寄存器的内容)至预分频器的缓冲区\n自动重装载影子寄存器被更新为预装载值(TIMx_ARR)。\n\n(通过软件或使用从模式控制器)设置TIMx_EGR寄存器的UG位也可以产生更新事件。设置TIMx_CR1中的UDIS位可以禁止产生更新事件。\n关于中断/DMA请求：配置中断使能寄存器(TIMx_DIER)UDE位后，每次更新事件会产生一个DMA请求。配置UIE位后，每次更新事件会产生一个更新中断。另外，如果设置了TIMx_CR1寄存器中的URS(选择更新请求)（用来决定UG位产生的更新事件对中断/DMA请求有没有用的），设置UG位可以产生一次更新事件UEV，但不设置UIF标志(即没有中断或DMA请求)，此时上溢下溢仍然会设置UIF标志哦。\n常规定时器不同的芯片的定时器个数等等都不一样，但是基本原理都是一样的。这里以STM32F103为例。\n常规定时器的共同点包括：\n\n都支持16位的计数器位数\n都支持向上计数\n分频系数都是1~65535\n\n溢出时间计算\n\n其中  是TIMxCLK的时钟间隔，单位为ms。\n基本定时器TIM6、TIM7\n用途：没有输入输出通道，常用做定时功能。\n主要特性\n是一个16位的递增计数器\n16位的预分频器\n可用于触发DAC（数字模拟转换器）的转换\n在更新事件时产生中断/DMA请求\n挂载在APB1总线上\n\n\n\n寄存器：\n\nTIMx_CNT：计数器寄存器\nTIMx_PSC：预分频器寄存器\nTIMx_ARR：自动重装载寄存器\nTIMx_CR1：控制寄存器1(包含计数器使能位CEN、自动重装载预加载使能位ARPE、更新请求源位URS、禁止更新位UDIS)\nTIMx_CR2：控制寄存器2(MMS主模式选择)\nTIMx_DIER：DMA/中断使能寄存器\nTIMx_SR：状态寄存器(UIF中断状态)\nTIMx_EGR：事件生成寄存器(UG位用于产生更新事件)\n\n计数模式仅仅支持向上计数模式。\n自动重装载寄存器是预加载的，每次读写自动重装载寄存器时，实际上是通过读写预加载寄存器实现。根据TIMx_CR1寄存器中的自动重装载预加载使能位(ARPE)（用来指示预加载寄存器内容是否立刻生效的啦），写入预加载寄存器的内容能够立即或在每次更新事件时，传送到它的影子寄存器。计数器由预分频输出CK_CNT驱动，设置TIMx_CR1寄存器中的计数器使能位(CEN)使能计数器计数。\n预分频可以以系数介于1至65536之间的任意数值对计数器时钟分频。它是通过一个16位寄存器(TIMx_PSC)的计数实现分频。因为TIMx_PSC控制寄存器具有缓冲，可以在运行过程中改变它的数值，新的预分频数值将在下一个更新事件时起作用。\nTIMxCLK频率：由于其挂载在APB1总线上，所以其时钟（TIMxCLK）频率与APB1总线的时钟频率相关。具体频率需要查看时钟树的相关设置HAL_StatusTypeDef Stm32_Clock_Init(); 。\n基本定时器配置步骤\n配置定时器基础工作参数：HAL_TIM_Base_Init()\n定时器基础MSP初始化：HAL_TIM_Base_MspInit()，配置NVIC和时钟\n使能更新中断并启动计数器：HAL_TIM_Base_Start_IT()\n设置优先级使能中断：HAL_NVIC_SetPriority()和HAL_NVIC_EnableIRQ()\n编写中断服务函数：TIMx_IRQHandler()→HAL_TIM_IRQHandler()\n编写定时器更新中断服务函数：HAL_TIM_PeriodElapsedCallback()\n\n基本定时器的应用:延时HAL_StatusTypeDef Stm32_Clock_Init();void LED_Init();\ncpp#include &lt;stm32f1xx_hal.h&gt;\n\nHAL_StatusTypeDef Stm32_Clock_Init();\nvoid LED_Init();\n\nvoid BaseTim_Init(uint32_t arr, uint32_t psc);//基本定时器初始化函数\nstatic TIM_HandleTypeDef g_timx_handle;//定时器句柄\n\nint main()\n{\n    HAL_Init();                     // 初始化HAL库\n    Stm32_Clock_Init(RCC_PLL_MUL9); // 初始化时钟\n    LED_Init();                     // 初始化LED外设\n    BaseTim_Init(7199, 4999);       // 初始化基本定时器，定时时间为500ms\n    while (1)\n    {\n        LED1_OFF();\n    }\n}\n\n\nvoid BaseTim_Init(uint32_t arr, uint32_t psc)\n{\n    g_timx_handle.Instance = TIM6;      // 指定定时器为TIM6\n    g_timx_handle.Init.Prescaler = psc; // 设置预分频系数\n    // g_timx_handle.Init.CounterMode = TIM_COUNTERMODE_UP;//该项在基本定时器中无用，如果设置最好设置为TIM_COUNTERMODE_UP\n    g_timx_handle.Init.Period = arr;       // 设置自动重装载寄存器周期的值\n    HAL_TIM_Base_Init(&amp;g_timx_handle);     // 初始化定时器\n    HAL_TIM_Base_Start_IT(&amp;g_timx_handle); // 开启定时器中断并且启动定时器\n}\n\nvoid HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim) // 定时器硬件初始化：配置NVIC和时钟\n{\n    if (htim-&gt;Instance == TIM6) /// 定时器判断，如果有多个定时器，这个判断很有必要\n    {\n        __HAL_RCC_TIM6_CLK_ENABLE();           // 使能TIM6时钟\n        HAL_NVIC_SetPriority(TIM6_IRQn, 4, 0); // 设置TIM6中断优先级\n        HAL_NVIC_EnableIRQ(TIM6_IRQn);         // 开启TIM6中断\n    }\n}\n\nvoid TIM6_IRQHandler(void) // 定时器中断服务函数\n{\n    HAL_TIM_IRQHandler(&amp;g_timx_handle); // 调用HAL库中断处理公用函数\n}\n\nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) // 被HAL_TIM_IRQHandler()调用\n{\n    if (htim-&gt;Instance == TIM6) // 定时器判断，如果有多个定时器，这个判断很有必要\n    {\n        LED0_TOGGLE(); // 一些功能\n    }\n}通用定时器TIM2、TIM3、TIM4、TIM5\n用途：有输入输出通道，可用于输入捕获、输出比较。也可用作定时。\n主要特性\n是一个16位的递增、递减、中心对齐计数器\n16位的预分频器\n有4个独立的通道，可用于输入捕获、输出比较、PWM输出、单脉冲模式输出\n可用于触发ADC（模数转换器）/DAC（数字模拟转换器）的转换\n在更新事件、触发事件、捕获/比较事件时产生中断/DMA请求\n使用外部信号定时器且可实现多个定时器互联的同步电路（级联）\n支持编码器和霍尔传感器电路\n挂载在APB1总线上\n\n\n\n寄存器：\n\nTIMx_CNT：计数器寄存器\nTIMx_PSC：预分频器寄存器\nTIMx_ARR：自动重装载寄存器\nTIMx_CR1：控制寄存器1(包含计数器使能位CEN、自动重装载预加载使能位ARPE、更新请求源位URS、禁止更新位UDIS、方向位DIR、中央对齐模式选择位CMS、单脉冲模式选择位OPM)\nTIMx_CR2：控制寄存器2(MMS主模式选择)\nTIMx_SMCR：从模式控制寄存器\nTIMx_DIER：DMA/中断使能寄存器\nTIMx_SR：状态寄存器(UIF中断状态)\nTIMx_EGR：事件生成寄存器(UG位用于产生更新事件)\nTIMx_CCMRx：捕获/比较模式寄存器\nTIMx_CCER：捕获/比较使能寄存器\nTIMx_CCRx：捕获/比较寄存器\nTIMx_DCR：DMA控制寄存器\nTIMx_DMAR：连续模式的DMA地址\n\n计数模式支持向上计数模式、向下计数模式、中央对齐模式。\n自动重装载寄存器是预加载的，每次读写自动重装载寄存器时，实际上是通过读写预加载寄存器实现。根据TIMx_CR1寄存器中的自动重装载预加载使能位(ARPE)（用来指示预加载寄存器内容是否立刻生效的啦），写入预加载寄存器的内容能够立即或在每次更新事件时，传送到它的影子寄存器。计数器由预分频输出CK_CNT驱动，设置TIMx_CR1寄存器中的计数器使能位(CEN)使能计数器计数。\n预分频可以以系数介于1至65536之间的任意数值对计数器时钟分频。它是通过一个16位寄存器(TIMx_PSC)的计数实现分频。因为TIMx_PSC控制寄存器具有缓冲，可以在运行过程中改变它的数值，新的预分频数值将在下一个更新事件时起作用。\nTIMxCLK频率：由于其挂载在APB1总线上，所以其时钟（TIMxCLK）频率与APB1总线的时钟频率相关。具体频率需要查看时钟树的相关设置HAL_StatusTypeDef Stm32_Clock_Init(); 。\n时钟选择计数器时钟可由下列时钟源提供：\n\n内部时钟(CK_INT)\n外部时钟模式1：外部输入脚(TIx)\n外部时钟模式2：外部触发输入(ETR)\n内部触发输入(ITRx)：使用一个定时器作为另一个定时器的预分频器，如可以配置一个定时器Timer1而作为另一个定时器Timer2的预分频器。\n\n内部时钟：预分频器的时钟就由内部时钟CK_INT提供。(TIMx_SMCR寄存器的SMS=000,ECE=0)\n外部时钟模式1：计数器可以在选定输入端的每个上升沿或下降沿计数。(TIMx_SMCR寄存器的SMS=111)\n\n\n外部时钟模式2：计数器能够在外部触发ETR的每一个上升沿或下降沿计数。(TIMx_SMCR寄存器中的ECE=1)\n\n\n内部触发输入：\n\n\n\n输入捕获模式在输入捕获模式下，当检测到ICx信号上相应的边沿后，计数器的当前值被锁存到捕获/比较寄存器(TIMx_CCRx)中。当捕获事件发生时，相应的CCxIF标志(TIMx_SR寄存器)被置’1’，如果使能了中断或者DMA操作，则将产生中断或者DMA操作。如果捕获事件发生时CCxIF标志已经为高，那么重复捕获标志CCxOF(TIMx_SR寄存器)被置’1’。写CCxIF=0可清除CCxIF，或读取存储在TIMx_CCRx寄存器中的捕获数据也可清除CCxIF。写CCxOF=0可清除CCxOF。\n\n\n\n以下例子说明如何在TI1输入的上升沿时捕获计数器的值到TIMx_CCR1寄存器中，步骤如下：\n\n选择有效输入端：TIMx_CCR1必须连接到TI1输入，所以写入TIMx_CCR1寄存器中的CC1S=01，只要CC1S不为’00’，通道被配置为输入，并且TM1_CCR1寄存器变为只读。\n根据输入信号的特点，配置输入滤波器为所需的带宽(即输入为TIx时，输入滤波器控制位是TIMx_CCMRx寄存器中的ICxF位)。假设输入信号在最多5个内部时钟周期的时间内抖动，我们须配置滤波器的带宽长于5个时钟周期。因此我们可以(以fDTS频率)连续采样8次，以确认在TI1上一次真实的边沿变换，即在TIMx_CCMR1寄存器中写入IC1F=0011。\n选择TI1通道的有效转换边沿，在TIMx_CCER寄存器中写入CC1P=0(上升沿)。\n配置输入预分频器。在本例中，我们希望捕获发生在每一个有效的电平转换时刻，因此预分频器被禁止(写TIMx_CCMR1寄存器的IC1PS=00)。\n设置TIMx_CCER寄存器的CC1E=1，允许捕获计数器的值到捕获寄存器中。\n如果需要，通过设置TIMx_DIER寄存器中的CC1IE位允许相关中断请求，通过设置TIMx_DIER寄存器中的CC1DE位允许DMA请求。\n\n当发生一个输入捕获时：\n\n产生有效的电平转换时，计数器的值被传送到TIMx_CCR1寄存器。\nCC1IF标志被设置(中断标志)。当发生至少2个连续的捕获时，而CC1IF未曾被清除，CC1OF也被置’1’。\n如设置了CC1IE位，则会产生一个中断。\n如设置了CC1DE位，则还会产生一个DMA请求。\n\n为了处理捕获溢出，建议在读出捕获溢出标志之前读取数据，这是为了避免丢失在读出捕获溢出标志之后和读取数据之前可能产生的捕获溢出信息。\n输入捕获模式配置步骤：\n\n配置定时器基础工作参数：HAL_TIM_IC_Init()\n定时器输入捕获MSP初始化：HAL_TIM_IC_MspInit()，配置NVIC和时钟、GPIO\n配置输入通道映射、捕获边沿等：HAL_TIM_IC_ConfigChannel()\n设置优先级使能中断：HAL_NVIC_SetPriority()和HAL_NVIC_EnableIRQ()\n使能定时器更新中断：__HAL_TIM_ENABLE_IT()\n使能捕获、捕获中断以及计数器：HAL_TIM_IC_START_IT()\n编写中断服务函数：TIMx_IRQHandler()→HAL_TIM_IRQHandler()\n编写更新中断和捕获回调函数：HAL_TIM_PeriodElapsedCallback()和HAL_TIM_IC_CaptureCallback()\n\n测量脉冲宽度：\nHAL_StatusTypeDef Stm32_Clock_Init();void LED_Init();void LED0_TOGGLE();void UART_Init(uint32_t bound);void print(char *str);void printn(char *str, uint32_t n);\ncpp#include &lt;stm32f1xx_hal.h&gt;\n\nHAL_StatusTypeDef Stm32_Clock_Init();\nvoid UART_Init(uint32_t bound);\nvoid LED_Init();\nvoid print(char *str);\nvoid printn(char *str, uint32_t n);\nvoid LED0_TOGGLE();\n\n\nextern TIM_HandleTypeDef htimx;\nextern uint16_t capture;\nextern uint32_t status ;\nvoid GeneralTim_Init(uint32_t arr, uint32_t psc);//通用定时器初始化函数\n\nint main()\n{\n    HAL_Init();                     // 初始化HAL库\n    Stm32_Clock_Init(RCC_PLL_MUL9); // 初始化时钟\n    LED_Init();                     // 初始化LED\n    UART_Init(115200);              // 初始化串口波特率为115200\n    GeneralTim_Init(0XFFFF, 71);    // 初始化定时器5，自动重装值为0XFFFF，预分频系数为71\n    uint32_t time = 0;\n    while (1)\n    {\n        if (status &amp; (1U &lt;&lt; 31U))\n        {\n            print(\"capture:\");\n            uint32_t temp = (status &amp; 0X3FFFFFFF) * 0XFFFF + capture;\n            char str[16];\n            uint8_t i = 0;\n            while (temp)\n            {\n                str[i] = temp % 10 + '0';\n                ++i;\n                temp /= 10;\n            }\n            while (i)\n            {\n                --i;\n                printn(&amp;str[i], 1);\n            }\n            print(\"\\r\\n\");\n            status = 0;\n        }\n        time++;\n        if (time % 20 == 0)\n        {\n            LED0_TOGGLE();\n        }\n        if (time % 500 == 0)\n        {\n            print(\"Hello World!\\r\\n\");\n        }\n        HAL_Delay(10);\n    }\n}\n\n\nTIM_HandleTypeDef htimx;//定时器句柄\n\nuint16_t capture = 0; // 捕获值\nuint32_t status = 0;  // 捕获状态,bit31:捕获完成标志，bit30:捕获到高电平标志\n\nvoid GeneralTim_Init(uint32_t arr, uint32_t psc) // arr为自动重装值，psc为预分频值\n{\n    htimx.Instance = TIM5;                       // 定时器5\n    htimx.Init.Prescaler = psc;                  // 预分频值\n    htimx.Init.Period = arr;                     // 自动重装值\n    htimx.Init.CounterMode = TIM_COUNTERMODE_UP; // 向上计数\n    HAL_TIM_IC_Init(&amp;htimx);                     // 初始化输入捕获\n\n    TIM_IC_InitTypeDef sConfigIC = {0};                          // 定义输入捕获初始化结构体\n    sConfigIC.ICPolarity = TIM_ICPOLARITY_RISING;                // 上升沿捕获\n    sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;            // 映射到TI1上\n    sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;                      // 不分频\n    sConfigIC.ICFilter = 0;                                      // 不滤波\n    HAL_TIM_IC_ConfigChannel(&amp;htimx, &amp;sConfigIC, TIM_CHANNEL_1); // 配置通道1\n\n    __HAL_TIM_ENABLE_IT(&amp;htimx, TIM_IT_UPDATE); // 使能更新中断\n    HAL_TIM_IC_Start_IT(&amp;htimx, TIM_CHANNEL_1); // 开启输入捕获中断\n}\n\nvoid HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)\n{\n    if (htim-&gt;Instance == TIM5) // TIM5\n    {\n        GPIO_InitTypeDef GPIO_InitStruct = {0};       // 定义GPIO初始化结构体\n        GPIO_InitStruct.Pin = GPIO_PIN_0;             // PA0\n        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;       // 复用推挽输出\n        GPIO_InitStruct.Pull = GPIO_PULLDOWN;         // 下拉\n        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; // 速度可以不设置\n        __HAL_RCC_GPIOA_CLK_ENABLE();                 // 使能GPIOA时钟\n        __HAL_RCC_TIM5_CLK_ENABLE();                  // 使能TIM5时钟\n        HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);       // 初始化GPIOA0\n        HAL_NVIC_SetPriority(TIM5_IRQn, 4, 0);        // 设置TIM5中断优先级，注意要比SysTick_IRQn的优先级高\n        HAL_NVIC_EnableIRQ(TIM5_IRQn);                // 开启TIM5中断\n    }\n}\n\nvoid TIM5_IRQHandler(void)\n{\n    HAL_TIM_IRQHandler(&amp;htimx); // 调用HAL库TIM中断处理公用函数\n}\n\nvoid HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)\n{\n\n    if (htim-&gt;Instance == TIM5) // TIM5\n    {\n        if (htim-&gt;Channel == HAL_TIM_ACTIVE_CHANNEL_1) // 通道1\n        {\n            if (status &amp; (1U &lt;&lt; 31U))\n            {\n            }\n            else\n            {\n                if (status &amp; (1U &lt;&lt; 30U)) // 捕获过上升沿，捕获到了下降沿\n                {\n                    status |= (1U &lt;&lt; 31U);                                               // 标记成功捕获到下降沿\n                    capture = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);            // 读取捕获值\n                    TIM_RESET_CAPTUREPOLARITY(htim, TIM_CHANNEL_1);                      // 重置捕获极性\n                    TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_1, TIM_ICPOLARITY_RISING); // 设置为上升沿捕获\n                }\n                else // 首次捕获上升沿\n                {\n                    status = (1U &lt;&lt; 30U);\n                    capture = 0;\n                    __HAL_TIM_DISABLE(htim);                                              // 关闭定时器\n                    __HAL_TIM_SET_COUNTER(htim, 0);                                       // 计数器清零\n                    TIM_RESET_CAPTUREPOLARITY(htim, TIM_CHANNEL_1);                       // 重置捕获极性\n                    TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_1, TIM_ICPOLARITY_FALLING); // 设置为下降沿捕获\n                    __HAL_TIM_ENABLE(htim);                                               // 使能定时器\n                    //其实这样写有一个问题，从捕获到上升沿到重新启动定时器，这段时间内的脉宽会被忽略，可以采用更好的方式解决，在这里就不做更改了。\n                }\n            }\n        }\n    }\n}\n\nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)\n{\n    if (htim-&gt;Instance == TIM5) // TIM5\n    {\n        if (status &amp; (1U &lt;&lt; 31U))\n            ;\n        else\n        {\n            status++;\n        }\n    }\n}输出比较模式此项功能是用来控制一个输出波形，或者指示一段给定的的时间已经到时。\n\n\n当计数器与捕获/比较寄存器的内容相同时，输出比较功能做如下操作：\n\n将输出比较模式(TIMx_CCMRx寄存器中的OCxM位)和输出极性(TIMx_CCER寄存器中的CCxP位)定义的值输出到对应的引脚上。在比较匹配时，输出引脚可以保持它的电平(OCxM=000)、被设置成有效电平(OCxM=001)、被设置成无效电平(OCxM=010)或进行翻转(OCxM=011)。\n设置中断状态寄存器中的标志位(TIMx_SR寄存器中的CCxIF位)。\n若设置了相应的中断屏蔽(TIMx_DIER寄存器中的CCxIE位)，则产生一个中断。\n若设置了相应的使能位(TIMx_DIER寄存器中的CCxDE位，TIMx_CR2寄存器中的CCDS位选择DMA请求功能)，则产生一个DMA请求。\n\nTIMx_CCMRx中的OCxPE位选择TIMx_CCRx寄存器是否需要使用预装载寄存器。在输出比较模式下，更新事件UEV对OCxREF和OCx输出没有影响。同步的精度可以达到计数器的一个计数周期。输出比较模式(在单脉冲模式下)也能用来输出一个单脉冲。\n输出比较模式的配置步骤：\n\n选择计数器时钟(内部，外部，预分频器)\n将相应的数据写入TIMx_ARR和TIMx_CCRx寄存器中\n如果要产生一个中断请求和/或一个DMA请求，设置CCxIE位和/或CCxDE位。\n选择输出模式，例如当计数器CNT与CCRx匹配时翻转OCx的输出引脚，CCRx预装载未用，开启OCx输出且高电平有效，则必须设置OCxM=’011’、OCxPE=’0’、CCxP=’0’和CCxE=’1’。\n设置TIMx_CR1寄存器的CEN位启动计数器TIMx_CCRx寄存器能够在任何时候通过软件进行更新以控制输出波形，条件是未使用预装载寄存器(OCxPE=’0’，否则TIMx_CCRx影子寄存器只能在发生下一次更新事件时被更新)。\n\nPWM输出模式在TIMx_CCMRx寄存器中的OCxM位写入’110’(PWM模式1)或’111’(PWM模式2)，能够独立地设置每个OCx输出通道产生一路PWM。必须设置TIMx_CCMRx寄存器OCxPE位以使能相应的预装载寄存器，最后还要设置TIMx_CR1寄存器的ARPE位，(在向上计数或中心对称模式中)使能自动重装载的预装载寄存器。\nOCx的极性可以通过软件在TIMx_CCER寄存器中的CCxP位设置，它可以设置为高电平有效或低电平有效。TIMx_CCER寄存器中的CCxE位控制OCx输出使能。详见TIMx_CCERx寄存器的描述。\nPWM输出模式配置步骤：\n\n配置定时器基础工作参数：HAL_TIM_PWM_Init()\n定时器基础MSP初始化：HAL_TIM_PWM_MspInit()，配置NVIC和时钟、GPIO\n配置PWM模式/比较值：HAL_TIM_PWM_ConfigChannel()\n使能更新中断并启动计数器：HAL_TIM_PWM_Start()\n配置修改占空比（可选）： __HAL_TIM_SET_COMPARE()\n使能通道预装载（可选）：__HAL_TIM_ENABLE_OCx_PRELOAD()\n\n呼吸灯\nHAL_StatusTypeDef Stm32_Clock_Init();\ncpp#include &lt;stm32f1xx_hal.h&gt;\nHAL_StatusTypeDef Stm32_Clock_Init();\n\nextern TIM_HandleTypeDef htimx;//通用定时器句柄\nvoid GeneralTim_Init(uint32_t arr, uint32_t psc);//通用定时器初始化函数\n\nint main()\n{\n    HAL_Init();                     // 初始化HAL库\n    Stm32_Clock_Init(RCC_PLL_MUL9); // 初始化时钟\n    GeneralTim_Init(499, 71);       // 初始化通用定时器，周期为0.5ms\n    _Bool flag = 1;\n    unsigned int pwmval = 0;\n    while (1)\n    {\n        HAL_Delay(10);\n        if (flag)\n            pwmval++;\n        else\n            pwmval--;\n        if (pwmval == 0)\n            flag = 1;\n        else if (pwmval == 300)\n            flag = 0;\n        __HAL_TIM_SET_COMPARE(&amp;htimx, TIM_CHANNEL_2, pwmval);\n    }\n}\n\nTIM_HandleTypeDef htimx;\n\nvoid GeneralTim_Init(uint32_t arr, uint32_t psc) // arr为自动重装值，psc为预分频值\n{\n    TIM_OC_InitTypeDef sConfigOC = {0};                           // 定义输出比较结构体\n    htimx.Instance = TIM3;                                        // 定时器3\n    htimx.Init.Prescaler = psc;                                   // 预分频值\n    htimx.Init.Period = arr;                                      // 自动重装值\n    htimx.Init.CounterMode = TIM_COUNTERMODE_UP;                  // 向上计数\n    HAL_TIM_PWM_Init(&amp;htimx);                                     // 初始化PWM，调用HAL_TIM_PWM_MspInit()\n    sConfigOC.OCMode = TIM_OCMODE_PWM1;                           // PWM模式1，即向上计数时TIMx_CNT&lt;TIMx_CCRx时输出有效电平\n    sConfigOC.Pulse = arr / 2;                                    // 占空比为50%，之后可用__HAL_TIM_SET_COMPARE()修改\n    sConfigOC.OCPolarity = TIM_OCPOLARITY_LOW;                    // 配置CC1P为1，即有效电平为低电平\n    HAL_TIM_PWM_ConfigChannel(&amp;htimx, &amp;sConfigOC, TIM_CHANNEL_2); // 配置PWM通道\n    HAL_TIM_PWM_Start(&amp;htimx, TIM_CHANNEL_2);                     // 开启PWM\n}\n\nvoid HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)//通用定时器硬件初始化：配置NVIC和时钟、GPIO\n{\n    if (htim-&gt;Instance == TIM3) // TIM3\n    {\n        // 因为TIM3_CH2可通过重映射连接到LED所在的PB5，所以配置GPIOB5重映射为TIM3_CH2\n        GPIO_InitTypeDef GPIO_InitStruct = {0};       // 定义GPIO初始化结构体\n        GPIO_InitStruct.Pin = GPIO_PIN_5;             // PB5\n        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;       // 推挽复用功能\n        GPIO_InitStruct.Pull = GPIO_PULLUP;           // 上拉\n        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; // 高速\n        __HAL_RCC_GPIOB_CLK_ENABLE();                 // 使能GPIOB时钟\n        __HAL_RCC_TIM3_CLK_ENABLE();                  // 使能TIM3时钟\n        HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);       // 初始化GPIOB5\n        __HAL_RCC_AFIO_CLK_ENABLE();                  // 使能AFIO时钟\n        __HAL_AFIO_REMAP_TIM3_PARTIAL();              // 重映射TIM3_CH2到PB5\n    }\n}计时基本定时功能：和基本定时器的配置步骤类似，可以参考基本定时器的配置步骤。不同在于通用定时器的句柄（依然是 TIM_HandleType）可配置性更强，可配置的参数（可实现的功能）更多。\n由于通用定时器的时钟源可以来自内部也可以来自外部，因此比基本定时器的功能稍多，如果要使用外部时钟，还需要配置外部时钟源。如果不使用外部时钟，那么通用定时器的配置步骤和基本定时器的配置步骤是一样的（仅仅是名称里的数字如TIM2、TIM6这样的差别）。\n如果使用的是外部时钟模式：\n\n配置定时器基础工作参数：HAL_TIM_IC_Init()\n定时器输入捕获MSP初始化：HAL_TIM_IC_MspInit()，配置NVIC和时钟、GPIO\n配置定时器从模式：HAL_TIM_SlaveConfigSynchro()\n使能输入捕获并启动计数器：HAL_TIM_IC_Start()\n获取计数器值：__HAL_TIM_GET_COUNTER()\n设置计数器值：__HAL_TIM_SET_COUNTER()\n\ncppvoid GeneralTim_Init(uint32_t arr, uint32_t psc)\n{\n    htimx.Instance = TIM2;                       // 定时器2\n    htimx.Init.Prescaler = psc;                  // 预分频系数\n    htimx.Init.CounterMode = TIM_COUNTERMODE_UP; // 向上计数\n    htimx.Init.Period = arr;                     // 自动重装载值\n    HAL_TIM_IC_Init(&amp;htimx);                     // 初始化定时器\n\n    TIM_SlaveConfigTypeDef sSlaveConfig = {0};\n    sSlaveConfig.SlaveMode = TIM_SLAVEMODE_EXTERNAL1;          // 选择外部时钟模式\n    sSlaveConfig.InputTrigger = TIM_TS_TI1FP1;                 // 选择TI1FP1作为输入触发源\n    sSlaveConfig.TriggerPolarity = TIM_TRIGGERPOLARITY_RISING; // 选择上升沿触发\n    sSlaveConfig.TriggerFilter = 0;                            // 不滤波\n    HAL_TIM_SlaveConfigSynchronization(&amp;htimx, &amp;sSlaveConfig); // 配置定时器2为从模式\n\n    HAL_TIM_IC_Start(&amp;htimx, TIM_CHANNEL_1); // 开启通道1的输入捕获\n}\n\nvoid HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)\n{\n    if (htim-&gt;Instance == TIM2) // 如果是定时器2\n    {\n        __HAL_RCC_TIM2_CLK_ENABLE();  // 使能定时器2时钟\n        __HAL_RCC_GPIOA_CLK_ENABLE(); // 使能GPIOA时钟\n        GPIO_InitTypeDef GPIO_InitStruct = {0};\n        GPIO_InitStruct.Pin = GPIO_PIN_0;             // 指定要初始化的引脚\n        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;       // 指定引脚模式为复用推挽输出\n        GPIO_InitStruct.Pull = GPIO_PULLDOWN;         // 指定引脚上下拉为下拉\n        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; // 指定引脚速度为高速\n        HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);       // 初始化PA0引脚\n    }\n}\n高级定时器TIM1、TIM8\n用途：有输入输出通道，可用于输入捕获、输出比较。可用于带死区控制的互补信号输出、刹车输入。也可用于定时。（电机控制、数字电源控制）\n主要特性\n是一个16位的递增、递减、中心对齐计数器\n16位的预分频器\n有4个独立的通道，可用于输入捕获、输出比较、PWM输出、单脉冲模式输出\n可用于触发ADC（模数转换器）/DAC（数字模拟转换器）的转换\n在更新事件、触发事件、捕获/比较事件时产生中断/DMA请求\n使用外部信号定时器且可实现多个定时器互联的同步电路（级联）\n支持编码器和霍尔传感器电路\n挂载在APB2总线上\n带有重复计数器\n死区时间带可编程的互补输出\n断路输入，用于将定时器的输出信号置于用户可选的安全配置中。\n\n\n\n\n\n\n寄存器：\n\nTIMx_CNT：计数器寄存器\nTIMx_PSC：预分频器寄存器 \nTIMx_ARR：自动装载寄存器 \nTIMx_RCR：重复次数寄存器 \nTIMx_CR1：控制寄存器1\nTIMx_CR2：控制寄存器2\nTIMx_SMCR：从模式控制寄存器\nTIMx_DIER：DMA/中断使能寄存器\nTIMx_SR：状态寄存器\nTIMx_EGR：事件生成寄存器\nTIMx_CCMR1：通道1和通道2的捕获/比较模式寄存器\nTIMx_CCMR2：通道3和通道4的捕获/比较模式寄存器\nTIMx_CCER：捕获/比较使能寄存器\nTIMx_CCR1：捕获/比较寄存器1\nTIMx_CCR2：捕获/比较寄存器2\nTIMx_CCR3：捕获/比较寄存器3\nTIMx_CCR4：捕获/比较寄存器4\nTIMx_BDTR：断路器寄存器\nTIMx_DCR：DMA控制寄存器\nTIMx_DMAR：DMA地址寄存器\n\n计数模式支持向上计数模式、向下计数模式、中央对齐模式。\n自动重装载寄存器是预加载的，每次读写自动重装载寄存器时，实际上是通过读写预加载寄存器实现。根据TIMx_CR1寄存器中的自动重装载预加载使能位(ARPE)（用来指示预加载寄存器内容是否立刻生效的啦），写入预加载寄存器的内容能够立即或在每次更新事件时，传送到它的影子寄存器。计数器由预分频输出CK_CNT驱动，设置TIMx_CR1寄存器中的计数器使能位(CEN)使能计数器计数。\n预分频可以以系数介于1至65536之间的任意数值对计数器时钟分频。它是通过一个16位寄存器(TIMx_PSC)的计数实现分频。因为TIMx_PSC控制寄存器具有缓冲，可以在运行过程中改变它的数值，新的预分频数值将在下一个更新事件时起作用。\n在高级计数器中，计数器上溢/下溢时更新事件(UEV)只能在重复计数达到0的时候产生。重复计数器在下述任一条件成立时递减：\n\n向上计数模式下每次计数器溢出时 \n向下计数模式下每次计数器下溢时\n中央对齐模式下每次上溢和每次下溢时。虽然这样限制了PWM的最大循环周期为128，但它能够在每个PWM周期2次更新占空比。在中央对齐模式下，因为波形是对称的，如果每个PWM周期中仅刷新一次比较寄存器，则最大的分辨率为2xTck。\n\n重复计数器是自动加载的，重复速率是由TIMx_RCR寄存器的值定义。当更新事件由软件产生(通过设置TIMx_EGR 中的UG位)或者通过硬件的从模式控制器产生，则无论重复计数器的值是多少，立即发生更新事件，并且TIMx_RCR寄存器中的内容被重载入到重复计数器。\nTIMxCLK频率：由于其挂载在APB2总线上，所以其时钟（TIMxCLK）频率与APB1总线的时钟频率相关。具体频率需要查看时钟树的相关设置HAL_StatusTypeDef Stm32_Clock_Init();。\n高级定时器输出指定个数PWM波形的配置步骤：\n\n配置定时器基础工作参数：HAL_TIM_PWM_Init()\n定时器基础MSP初始化：HAL_TIM_PWM_MspInit()，配置NVIC和时钟、GPIO\n配置PWM模式/比较值：HAL_TIM_PWM_ConfigChannel()\n设置优先级使能中断：HAL_NVIC_SetPriority()和HAL_NVIC_EnableIRQ()\n使能定时器更新中断：__HAL_TIM_ENABLE_IT()\n使能输出、主输出和计数器：HAL_TIM_PWM_Start()\n编写中断服务函数：TIMx_IRQHandler()→HAL_TIM_IRQHandler()\n编写更新中断函数：HAL_TIM_PeriodElapsedCallback()\n\n\n\n\n\n\n\n\n\n\n高级定时器输出必须把MOE位设置为1，否则无法输出。\nHAL_StatusTypeDef Stm32_Clock_Init();void KEY_Init();\nc#include &lt;stm32f1xx_hal.h&gt;\n\nHAL_StatusTypeDef Stm32_Clock_Init();\nvoid KEY_Init();\nvoid AdvancedTim_Init(uint32_t arr, uint32_t psc);\nvoid update_pwm_num(uint8_t num);\n\nint main()\n{\n    HAL_Init();                   // 初始化HAL库\n    Stm32_Clock_Init();           // 初始化时钟\n    KEY_Init();                   // 初始化按键\n    AdvancedTim_Init(4999, 7199); // 初始化定时器8，自动重装值为4999，预分频系数为7199\n\n    // 配置PE5为输入引脚，避免冲突\n    GPIO_InitTypeDef GPIO_InitStruct = {0};\n    GPIO_InitStruct.Pin = GPIO_PIN_5;       // 指定要初始化的引脚\n    GPIO_InitStruct.Pull = GPIO_PULLUP;     // 上拉输入\n    GPIO_InitStruct.Mode = GPIO_MODE_INPUT; // 指定引脚模式为推挽输出\n    __HAL_RCC_GPIOE_CLK_ENABLE();           // 使能GPIOE时钟\n    HAL_GPIO_Init(GPIOE, &amp;GPIO_InitStruct); // 初始化PE5引脚\n\n    while (1)\n    {\n        HAL_Delay(10);\n    }\n}\n\nTIM_HandleTypeDef htimx;\n\nuint8_t num_pwm = 0;\n\nvoid AdvancedTim_Init(uint32_t arr, uint32_t psc)\n{\n    htimx.Instance = TIM8; // TIM8\n    htimx.Init.Prescaler = psc;//\n    htimx.Init.CounterMode = TIM_COUNTERMODE_UP;\n    htimx.Init.Period = arr;\n    htimx.Init.RepetitionCounter = 0;\n    HAL_TIM_PWM_Init(&amp;htimx);\n\n    TIM_OC_InitTypeDef TIM_OCInitStructure;\n    TIM_OCInitStructure.OCMode = TIM_OCMODE_PWM1;\n    TIM_OCInitStructure.Pulse = arr / 2;\n    TIM_OCInitStructure.OCPolarity = TIM_OCPOLARITY_HIGH;\n    HAL_TIM_PWM_ConfigChannel(&amp;htimx, &amp;TIM_OCInitStructure, TIM_CHANNEL_1);\n    __HAL_TIM_ENABLE_IT(&amp;htimx, TIM_IT_UPDATE);\n    HAL_TIM_PWM_Start(&amp;htimx, TIM_CHANNEL_1);\n}\n\nvoid HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)\n{\n    if (htim-&gt;Instance == TIM8)\n    {\n        GPIO_InitTypeDef GPIO_Initure;\n        __HAL_RCC_TIM8_CLK_ENABLE();  // 使能TIM8时钟\n        __HAL_RCC_GPIOC_CLK_ENABLE(); // 开启GPIOC时钟\n\n        GPIO_Initure.Pin = GPIO_PIN_6;        // PC6\n        GPIO_Initure.Mode = GPIO_MODE_AF_PP;  // 复用推挽输出\n        GPIO_Initure.Pull = GPIO_PULLUP;      // 上拉\n        GPIO_Initure.Speed = GPIO_SPEED_HIGH; // 高速\n        HAL_GPIO_Init(GPIOC, &amp;GPIO_Initure);\n\n        HAL_NVIC_SetPriority(TIM8_UP_IRQn, 4, 0); // 设置中断优先级，抢占优先级4，子优先级0\n        HAL_NVIC_EnableIRQ(TIM8_UP_IRQn);         // 开启TIM8_UP_IRQn中断\n    }\n}\n\nvoid update_pwm_num(uint8_t num)\n{\n    if (num == 0)\n        return;\n    num_pwm = num;\n    HAL_TIM_GenerateEvent(&amp;htimx, TIM_EVENTSOURCE_UPDATE);\n    __HAL_TIM_ENABLE(&amp;htimx);\n}\n\nvoid TIM8_UP_IRQHandler(void)\n{\n    HAL_TIM_IRQHandler(&amp;htimx);\n}\n\nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)\n{\n    if (htim-&gt;Instance == TIM8)\n    {\n        if (num_pwm)\n        {\n            TIM8-&gt;RCR = num_pwm - 1;\n            HAL_TIM_GenerateEvent(&amp;htimx, TIM_EVENTSOURCE_UPDATE);\n            __HAL_TIM_ENABLE(&amp;htimx);\n            num_pwm = 0;\n        }\n        else\n        {\n            // __HAL_TIM_DISABLE(&amp;htimx);\n            TIM8-&gt;CR1 &amp;= ~(TIM_CR1_CEN);\n        }\n    }\n}\n\n\n\n\n\n\n\n\n记一个奇怪的问题：我本来想使用串口通信来实现改变PWM波形个数，但是发现串口通信会导致定时器不能输出PWM。具体原因完全没有找到。以下是具体情况：\n\n上述代码在正常情况下：复位后仅仅输出一个PWM波形就会被关闭，按下按键后会开启并输出指定数量的PWM波形后关闭。不输出PWM的时候引脚为高电平。\n如果删除KEY_Init();，即不初始化按键，则复位后不会输出PWM波形，引脚为低电平❓。\n如果添加UART_Init(115200);，即初始化串口通信，则复位后不会输出PWM波形，引脚为低电平，按下按键也不会有任何反应❓。\n如果在删除KEY_Init();的情况下，添加UART_Init(115200);，则复位后不会输出PWM波形，引脚为低电平❓。\n在KEY_Init()函数中，如果仅仅初始化PE3一个引脚，设置对应中断，则复位后仅仅输出一个PWM波形就会被关闭，在按下与PE3相连的按键时会产生对应数量的PWM波形，不输出PWM的时候引脚为高电平。\n在KEY_Init()函数中，如果仅仅初始化PA0一个引脚，不设置任何中断，则复位后不会输出PWM波形，引脚为低电平❓。\n在KEY_Init()函数中，如果仅仅初始化PE3一个引脚，不设置任何中断，则复位后仅仅输出一个PWM波形就会被关闭，不输出PWM的时候引脚为高电平。\n\n目前仍未找到原因。\n死区控制死区时间是指在两个互补输出之间的时间间隔。死区时间的作用是防止两个互补输出同时处于有效状态，从而导致电流短路。死区时间的大小由TIMx_BDTR寄存器中的DTG[7:0]位和LOCK[1:0]位决定。死区时间的计算公式如下：\n\n其中，TIMxCLK是定时器的时钟频率，DeadTime是死区时间。死区时间的最大值为255个TIMxCLK周期。死区时间的最小值由LOCK[1:0]位决定.\n死区控制通常用于控制电机的驱动，防止电机的两个相同时刻都处于有效状态，导致电流短路。\n断路输入断路输入可以使得定时器的输出信号置于用户可选的安全配置中。断路输入的作用是在定时器输出信号的有效期间，当断路输入信号有效时，立即将定时器输出信号置为无效。断路输入信号可以是外部信号或者内部信号。外部信号可以是TIMx_ETR引脚上的信号或者TIMx_CHx引脚上的信号。内部信号可以是TIMx_TRGO引脚上的信号或者TIMx_ITRy引脚上的信号。\n","slug":"STM32入门（八）：定时器","date":"2023-09-17T09:22:52.000Z","categories_index":"嵌入式","tags_index":"STM32,单片机","author_index":"Ac-Accelerator"},{"id":"66ba1c7d8be31c9521741b1f3e971a8c","title":"STM32入门（七）：IWDG&WWDG","content":"单片机在运行过程中，由于受到外界干扰或者程序出现错误，导致程序陷入死循环，这时候就需要复位单片机，使其重新运行。单片机复位的方式有多种，比如手动复位、软件复位、看门狗复位等。本文主要介绍看门狗复位。\nIWDGIWDG（Independent Watchdog）独立看门狗，它是一个能产生复位信号的计数器，当计数器达到给定的超时值时，产生系统复位。独立看门狗(IWDG)由专用的低速时钟(LSI)驱动，即使主时钟发生故障它也仍然有效。IWDG最适合应用于那些需要看门狗作为一个在主程序之外，能够完全独立工作，并且对时间精度要求较低的场合。\n系统复位条件：\n\n外部复位NRST引脚低电平\n独立看门狗复位\n窗口看门狗复位\n软件复位\n低功耗管理复位\n\n目前介绍的是独立看门狗复位。\nIWDG特性\n自由运行的递减计数器\n时钟由独立的RC振荡器提供(可在停止和待机模式下工作)\n看门狗被激活后，则在计数器计数至0x000时产生复位\n\n因此，为了防止复位，必须在看门狗复位之前重载计数器。俗称喂狗。\n\n\n看门狗功能处于VDD供电区，即在停机和待机模式时仍能正常工作。\nIWDG溢出时间计算\n其中，为LSI的周期，为分频系数，为重装载值。\nIWDG寄存器配置步骤寄存器包括：\n\nIWDG_KR：键值寄存器\nIWDG_PR：预分频寄存器\nIWDG_RLR：重装载寄存器\nIWDG_SR：状态寄存器\n\n\n在IWDG_KR中写入0XCCCC，开启IWDG\n在IWDG_KR中写入0X5555，使能寄存器访问\n在IWDG_PR中写入分频系数\n对IWDG_RLR写入重装载值\n等待寄存器更新IWDG_SR=0X0000\n刷新计数器的值为IWDG_RLR的值（IWDG_KR=0XAAAA）\n\nIWDG配置步骤\nIWDG工作参数初始化:HAL_IWDG_Init()\n喂狗:HAL_IWDG_Refresh()\n\nHAL库应用HAL_StatusTypeDef Stm32_Clock_Init();void LED_Init();void UART_Init(uint32_t bound);void print(char *str);  \ncpp#include &lt;stm32f1xx_hal.h&gt;\n#include &lt;usart.h&gt; //STM32入门（六）：串口通信所需头文件\n\nHAL_StatusTypeDef Stm32_Clock_Init();\nvoid LED_Init();\nvoid UART_Init(uint32_t bound);\nvoid print(char *str);\n\nstatic IWDG_HandleTypeDef IWDG_Handler; // 独立看门狗句柄\nvoid IWDG_Init(uint32_t time_ms);\nvoid IWDG_Feed(void);\n\nint main()\n{\n    /*\n    HAL_Init()中，调用HAL_NVIC_SetPriorityGrouping设置中断优先级分组为NVIC_PRIORITYGROUP_4\n    即4位抢占优先级，0位响应优先级，并且用HAL_NVIC_SetPriority将SysTick_IRQn设置为15即最低优先级\n    */\n    HAL_Init();                     // 初始化HAL库\n    Stm32_Clock_Init(RCC_PLL_MUL9); // 初始化时钟\n    LED_Init();                     // 初始化LED外设\n    UART_Init(115200); // 初始化串口，波特率为115200\n    IWDG_Init(10000);  // 初始化独立看门狗，溢出时间为10000ms\n    HAL_Delay(1000);\n    HAL_GPIO_WritePin(GPIOE, GPIO_PIN_5, GPIO_PIN_SET);\n    while (1)\n    {\n        if (USART_RX_STA &amp; 0x8000) // 接收完成标志为1\n        {\n            IWDG_Feed(); // 喂狗\n            USART_RX_STA = 0;  // 接收完成标志清零\n        }\n        HAL_Delay(1000);\n        print(\"如果不发送数据，系统将重启\\r\\n\");\n    }\n}\n\nvoid IWDG_Init(uint32_t time_ms)\n{\n    uint32_t Prescaler = 4;// 分频系数\n    uint32_t Prescaler_Sta = 0;// 分频系数状态\n    for (; Prescaler_Sta &lt; 7; Prescaler_Sta++)//找到一个合适的分频系数和重装载值\n    {\n        if (time_ms * 40 / Prescaler &lt;= 0xFFF)\n            break;\n        Prescaler &lt;&lt;= 1;\n    }\n    IWDG_Handler.Instance = IWDG; // 独立看门狗\n    //设置分频系数和重装载值\n    if (Prescaler_Sta != 7)\n    {\n        IWDG_Handler.Init.Prescaler = Prescaler_Sta;\n        IWDG_Handler.Init.Reload = time_ms * 40 / Prescaler;\n    }\n    else{\n        IWDG_Handler.Init.Prescaler = IWDG_PRESCALER_256;\n        IWDG_Handler.Init.Reload = 0xFFF;\n    }\n    HAL_IWDG_Init(&amp;IWDG_Handler); // 初始化独立看门狗\n}\n\nvoid IWDG_Feed(void)// 喂狗\n{\n    HAL_IWDG_Refresh(&amp;IWDG_Handler); \n}\nWWDG窗口看门狗(Window Watchdog)通常被用来监测，由外部干扰或不可预见的逻辑条件造成的应用程序背离正常的运行序列而产生的软件故障。除非递减计数器的值在T6位变成0前被刷新，看门狗电路在达到预置的时间周期时，会产生一个MCU复位。在递减计数器达到窗口寄存器数值之前，如果7位的递减计数器数值(在控制寄存器中)被刷新， 那么也将产生一个MCU复位。这表明递减计数器需要在一个有限的时间窗口中被刷新。\n一般来说，硬件错误使用独立看门狗，软件错误使用窗口看门狗。\nWWDG特性\n可编程的自由运行递减计数器\n条件复位\n当递减计数器的值小于0x40，(若看门狗被启动)则产生复位。\n当递减计数器在窗口外被重新装载，(若看门狗被启动)则产生复位。\n\n\n如果启动了看门狗并且允许中断，当递减计数器等于0x40时产生早期唤醒中断(EWI)，它可以被用于重装载计数器以避免WWDG复位。\n\n当微控制器进入调试模式时(Cortex-M3核心停止)，根据调试模块中的DBG_WWDG_STOP 配置位的状态，WWDG的计数器能够继续工作或停止。\n\n\n\n\nWWDG溢出时间计算\n其中  是APB1以ms为单位的时钟间隔\nWWDG配置步骤\nWWDG工作参数初始化:HAL_WWDG_Init()\nWWDG MSP初始化:HAL_WWDG_MspInit(),配置NVIC和时钟\n设置优先级使能中断:HAL_NVIC_SetPriority()和HAL_NVIC_EnableIRQ()\n编写中断服务函数WWDG_IRQHandler()\n重定义提前唤醒中断服务函数HAL_WWDG_EarlyWakeupCallback()\n在窗口期内喂狗HAL_WWDG_Refresh()\n\nHAL_StatusTypeDef Stm32_Clock_Init();void LED_Init();void UART_Init(uint32_t bound);void print(char *str);  \ncpp#include &lt;stm32f1xx_hal.h&gt;\n\nHAL_StatusTypeDef Stm32_Clock_Init();\nvoid LED_Init();\nvoid UART_Init(uint32_t bound);\nvoid print(char *str);\n\nstatic WWDG_HandleTypeDef WWDG_Handler; // 窗口看门狗句柄\nvoid WWDG_Init(uint8_t tr, uint8_t wr, uint32_t fprer);\nvoid WWDG_Feed(void);\n\nint main()\n{\n    /*\n    HAL_Init()中，调用HAL_NVIC_SetPriorityGrouping设置中断优先级分组为NVIC_PRIORITYGROUP_4\n    即4位抢占优先级，0位响应优先级，并且用HAL_NVIC_SetPriority将SysTick_IRQn设置为15即最低优先级\n    */\n    HAL_Init();                     // 初始化HAL库\n    Stm32_Clock_Init(RCC_PLL_MUL9); // 初始化时钟\n    LED_Init();                     // 初始化LED外设\n    LED0_ON();                      // 点亮LED0\n    HAL_Delay(300);\n    WWDG_Init(0X7F,0X5F,WWDG_PRESCALER_8);  // 初始化窗口看门狗\n    while (1)\n    {\n        LED0_OFF(); // 关闭LED0\n    }\n}\n\nvoid WWDG_Init(uint8_t tr, uint8_t wr, uint32_t fprer)\n{\n    WWDG_Handler.Instance = WWDG;\n    WWDG_Handler.Init.Prescaler = fprer;         // 设置分频系数\n    WWDG_Handler.Init.Counter = tr;              // 设置计数器值\n    WWDG_Handler.Init.Window = wr;               // 设置窗口值\n    WWDG_Handler.Init.EWIMode = WWDG_EWI_ENABLE; // 使能早期唤醒中断\n    HAL_WWDG_Init(&amp;WWDG_Handler);                // 初始化窗口看门狗\n}\n\nvoid HAL_WWDG_MspInit(WWDG_HandleTypeDef *hwwdg)\n{\n    __HAL_RCC_WWDG_CLK_ENABLE();            // 使能窗口看门狗时钟\n    HAL_NVIC_SetPriority(WWDG_IRQn, 15, 0); // 设置窗口看门狗中断优先级\n    HAL_NVIC_EnableIRQ(WWDG_IRQn);          // 使能窗口看门狗中断，递减计数器等于0x40时产生早期唤醒中断\n}\n\n//递减计数器等于0x40时产生早期唤醒中断\nvoid WWDG_IRQHandler(void)\n{\n    HAL_WWDG_IRQHandler(&amp;WWDG_Handler); // 调用HAL库中断处理公用函数\n}\n\nvoid WWDG_Feed(void)\n{\n    HAL_WWDG_Refresh(&amp;WWDG_Handler); // 喂狗\n}\n\n//此函数会被HAL_WWDG_IRQHandler()调用\nvoid HAL_WWDG_EarlyWakeupCallback(WWDG_HandleTypeDef *hwwdg)//定义提前唤醒中断服务函数\n{\n    WWDG_Feed(); // 喂狗\n    LED1_TOGGLE(); // LED1翻转\n}\n特别注意，在中断内喂狗一定要快，否则当看门狗计数器值减到0X3F时将产生复位！\n","slug":"STM32入门（七）：IWDG&WWDG","date":"2023-07-20T10:24:54.000Z","categories_index":"嵌入式","tags_index":"STM32,单片机","author_index":"Ac-Accelerator"},{"id":"a08aadec6f6b3fd60392df174980aebb","title":"STM32入门（六）：串口通信","content":"通信基本概念串行/并行通信串行通信：数据逐位传输，一个单位时间只能发送一个bit。并行通信：数据同时通过多条线路传输，一次可以发送多个bit\n单工/半双工/全双工通信单工通信：数据只能单向传输，不能双向传输。半双工通信：数据可以双向传输，但是不能同时传输。全双工通信：数据可以双向传输，且可以同时传输。\n同步/异步通信同步通信：发送端和接收端的时钟信号是同步的，发送端和接收端的时钟信号是同一个时钟信号。异步通信：没有时钟信号，通过在数据的起始和终止位置添加特殊的标志位来实现同步。\n波特率/比特率比特率：单位时间内传输的bit数，单位为bit/s。波特率：单位时间内传送的码元个数，单位为Baud。码元与比特：信号在被编码调制后，一个码元可以代表多个比特。\n常见的串口通信协议\n\n\n通信协议\n接口引脚\n数据同步方式\n数据传输方向\n\n\n\nUART\nTXD、RXD、GND\n异步\n全双工\n\n\nSPI\nMOSI、MISO、SCLK、CS、GND\n同步\n全双工\n\n\nI2C\nSDA、SCL、GND\n同步\n半双工\n\n\n1-Wire\nDQ、GND\n异步\n半双工\n\n\n串口按位发送或接收的接口，如RS-232、RS-485、RS-422等。\nRS-232(USB)RS-232是一种串行通信接口标准，它是由美国电子工业协会联合贝尔系统公司、调制解调器厂家及计算机终端生产厂家于1970年共同制定，其全名是“数据终端设备和数据通信设备之间串行二进制数据交换接口技术标准”\n常用的RS-232串口使用方法：USB通过串口连接电脑等设备，USB信号通过USB转串口模块CH340，将USB电平转换为TTL/CMOS电平。\n和USART的关系USART是一种集成电路，它能够以同步或异步的方式进行数据传输。而RS-232是一种串行通信接口标准，它定义了电气特性、机械特性和功能特性等方面的规范。\nUSART可以通过RS-232接口与其他设备进行通信。在这种情况下，USART负责数据的发送和接收，而RS-232负责定义数据传输的电气特性和其他规范。因此，USART和RS-232可以协同工作，实现串行通信。\nUSART通用同步异步收发器(Universal Synchronous Asynchronous Receiver Transmitter)提供了一种灵活的方法与使用工业标准NRZ异步串行数据格式的外部设备之间进行全双工数据交换。USART利用分数波特率发生器提供宽范围的波特率选择。它支持同步单向通信和半双工单线通信，也支持LIN(局部互连网)，智能卡协议和IrDA(红外数据组织)SIR ENDEC规范，以及调制解调器(CTS/RTS)操作。它还允许多处理器通信。使用多缓冲器配置的DMA方式，可以实现高速数据通信。\nUART(Universal Asynchronous Receiver Transmitter)异步收发器是没有同步收发功能的USART\nUART和USART都可以使用RS-232串口作为物理层。\n通过STM32选型手册可以得知，STM32F103ZET6有3个USART，两个UART。因此有5个串口。\nUART：\n\n\n\n串口号\nTX\nRX\n\n\n\nUART4\nPC10\nPC11\n\n\nUART5\nPC12\nPD2\n\n\nUSART：\n\n\n\n串口号\nTX\nRX\nCTS\nRTS\nCK\n\n\n\nUSART1\nPA9\nPA10\nPA11\nPA12\nPA8\n\n\nUSART2\nPA2\nPA3\nPA0\nPA1\nPA4\n\n\nUSART3\nPB10\nPB11\nPB13\nPB14\nPB12\n\n\n\n\n\nSW_RX： 数据接收引脚，只用于单线和智能卡模式，属于内部引脚，没有具体外部引脚。\n\nRX：接收数据串行输。通过过采样技术来区别数据和噪音，从而恢复数据。\n\nTX：发送数据输出。当发送器被禁止时，输出引脚恢复到它的I/O端口配置。当发送器被激活，并且不发送数据时，TX引脚处于高电平。在单线和智能卡模式里，此I/O口被同时用于数据的发送和接收。\n\n\n\n\n\n\n\n\n\n\n\n\n总线在发送或接收前应处于空闲状态\n一个起始位\n一个数据字(8或9位)，最低有效位在前\n0.5，1.5，2个的停止位，由此表明数据帧的结束\n使用分数波特率发生器 —— 12位整数和4位小数的表示方法。\n一个状态寄存器(USART_SR)\n数据寄存器(USART_DR)\n一个波特率寄存器(USART_BRR)，12位的整数和4位小数\n一个智能卡模式下的保护时间寄存器(USART_GTPR)\n\n上面这两个USART引脚对应着RS-232串口的RXD和TXD。\n在同步模式中需要以下引脚：\n\nSCLK： 时钟信号，用于同步数据传输。\n\n在IrDA模式里需要下列引脚：\n\nIrDA_RDI: IrDA模式下的数据输入。\nIrDA_TDO: IrDA模式下的数据输出。\n\n在硬件流控模式中需要以下引脚：\n\nnCTS: 清除发送，若是高电平，在当前数据传输结束时阻断下一次的数据发送。\nnRTS: 发送请求，若是低电平，表明USART准备好接收数据。\n\nUSART寄存器介绍USART_SR：状态寄存器USART_DR：数据寄存器USART_BRR：波特率寄存器USART_CR1：控制寄存器1USART_CR2：控制寄存器2USART_CR3：控制寄存器3\n详细功能见参考手册。\n设置USART波特率依据USART的框图，可以得知波特率的计算公式：\n\n而USARTDIV由USART_BRR（波特比率寄存器）的低16位DIV_Mantissa和DIV_Fraction共同决定，其中DIV_Mantissa是整数部分，DIV_Fraction是小数部分。所以只需要设置这两个寄存器就可以设置USARTDIV，进而设置波特率。\nUSART分频的计算公式：\n\n通过以上两个公式，可以由USART_BRR的值推出波特率，也可以由波特率推出USART_BRR的值。\n\n\n\n\n\n\n\n\n\n要注意的是，USART1的时钟是PCLK2（因为挂载在APB2总线上），而其他的串口的时钟是PCLK1（因为挂载在APB1总线上）。详情参考芯片手册。\nHAL库回调机制外设初始化MSP回调机制：\nMSP的全称是MCU Support Package。它是为了方便ST不同芯片平台移植而产生的。\nHAL_PPP_Init()函数会调用HAL_PPP_MspInit()回调函数（PPP代表外设名字），其中HAL_PPP_MspInit()是个__weak类型函数，因此用户可以重写这个函数，实现外设的初始化。\n中断回调机制：\nHAL_PPP_IRQHandler()函数会调用HAL_PPP_xxx_Callback()回调函数（PPP代表外设名字，xxx代表中断类型），其中HAL_PPP_xxxCallback()是个__weak类型函数，因此用户可以重写这个函数，实现中断的处理。\n例子\nIO引脚复用功能通用： IO引脚由GPIO外设控制复用： IO引脚由非GPIO的其他外设控制\n参考芯片数据手册可以得知IO引脚分别支持哪些复用，如果遇到复用功能冲突，则可以使用重映射来实现。\nUSART/UART异步通信配置\n配置串口工作参数\n串口底层初始化，配置NVIC,GPIO,Clock等\n开启串口异步接收中断\n设置优先级，使能中断\n编写中断服务函数\n串口数据发送接收\n\nHAL库程序代码：接收什么发送什么HAL_StatusTypeDef Stm32_Clock_Init();void LED_Init();\ncpp#include &lt;stm32f1xx_hal.h&gt;\nHAL_StatusTypeDef Stm32_Clock_Init();\n\nvoid LED_Init();\nvoid UART_Init(uint32_t bound);\nvoid print(char *str);\nvoid printn(char *str, uint32_t n);\n\nuint8_t aRxBuffer[1];             // 数据缓冲区\nUART_HandleTypeDef UART1_Handler; // 句柄\nuint16_t USART_RX_STA=0;        // 串口接收到数据标志\nuint8_t USART_RX_BUF[256];        // 串口接收缓冲区\n\nint main()\n{\n    /*\n    HAL_Init()中，调用HAL_NVIC_SetPriorityGrouping设置中断优先级分组为NVIC_PRIORITYGROUP_4\n    即4位抢占优先级，0位响应优先级，并且用HAL_NVIC_SetPriority将SysTick_IRQn设置为15即最低优先级\n    */\n    HAL_Init();                     // 初始化HAL库\n    Stm32_Clock_Init(RCC_PLL_MUL9); // 初始化时钟\n    LED_Init();                     // 初始化LED外设\n    UART_Init(115200);              // 初始化串口，波特率为115200\n    HAL_GPIO_WritePin(GPIOE, GPIO_PIN_5, GPIO_PIN_SET);//灭灯，意义不大\n\n    int len = 0;\n    unsigned int times = 0;\n    while (1)\n    {\n        if (USART_RX_STA &amp; 0x8000) // 接收完成标志为1\n        {\n            len = USART_RX_STA &amp; 0x3fff; // 得到此次接收到的数据长度\n            print(\"\\r\\n您发送的消息为:\\r\\n\");\n\n            HAL_UART_Transmit(&amp;UART1_Handler, (uint8_t *)USART_RX_BUF, len, 1000); // 发送接收到的数据\n            while (__HAL_UART_GET_FLAG(&amp;UART1_Handler, UART_FLAG_TC) != SET)\n                ;              // 等待发送结束\n            print(\"\\r\\n\\r\\n\"); // 插入换行\n            USART_RX_STA = 0; // 接收完成标志清零\n        }\n        else\n        {\n            times++;\n            if (times % 1000 == 0)\n                print(\"请输入数据,以回车键结束\\r\\n\");\n            if (times % 300 == 0)\n                HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_5);\n            HAL_Delay(10);\n        }\n    }\n}\n\nvoid UART_Init(uint32_t bound)\n{\n    // UART 初始化设置\n    UART1_Handler.Instance = USART1;                              // 配置的目的串口是USART1\n    UART1_Handler.Init.BaudRate = bound;                          // 设置串口波特率\n    UART1_Handler.Init.WordLength = UART_WORDLENGTH_8B;           // 设置字长为8位数据格式\n    UART1_Handler.Init.StopBits = UART_STOPBITS_1;                // 设置停止位数为1\n    UART1_Handler.Init.Parity = UART_PARITY_NONE;                 // 奇偶校验位为无\n    UART1_Handler.Init.HwFlowCtl = UART_HWCONTROL_NONE;           // 硬件流控为无\n    UART1_Handler.Init.Mode = UART_MODE_TX_RX;                    // 串口模式为收发模式\n    HAL_UART_Init(&amp;UART1_Handler);                                // HAL_UART_Init()会调用HAL_UART_MspInit使能UART1\n    HAL_UART_Receive_IT(&amp;UART1_Handler, (uint8_t *)aRxBuffer, 1); // 该函数会开启接收中断：标志位UART_IT_RXNE，并且设置接收缓冲以及接收缓冲接收最大数据量\n}\n\nvoid HAL_UART_MspInit(UART_HandleTypeDef *huart) // 定义HAL_UART_MspInit\n{\n    GPIO_InitTypeDef GPIO_Initure; // GPIO端口配置结构体\n\n    if (huart-&gt;Instance == USART1) // 如果是串口1，进行串口1 MSP初始化\n    {\n        __HAL_RCC_USART1_CLK_ENABLE(); // 使能USART1时钟\n        __HAL_RCC_GPIOA_CLK_ENABLE();  // 因为USART1都在GPIOA的引脚上，所以使能GPIOA时钟\n        __HAL_RCC_AFIO_CLK_ENABLE();   // 使能AFIO时钟\n\n        GPIO_Initure.Pin = GPIO_PIN_9;             // PA9\n        GPIO_Initure.Mode = GPIO_MODE_AF_PP;       // TX引脚，因此选择复用推挽输出\n        GPIO_Initure.Speed = GPIO_SPEED_FREQ_HIGH; // 高速\n        HAL_GPIO_Init(GPIOA, &amp;GPIO_Initure);       // 初始化PA9\n\n        GPIO_Initure.Pin = GPIO_PIN_10;         // PA10\n        GPIO_Initure.Pull = GPIO_PULLUP;        // 空闲时高电平，因此选择上拉\n        GPIO_Initure.Mode = GPIO_MODE_AF_INPUT; // DX引脚，选择复用输入模式\n        HAL_GPIO_Init(GPIOA, &amp;GPIO_Initure);    // 初始化PA10\n\n        HAL_NVIC_EnableIRQ(USART1_IRQn);           // 使能USART1中断通道\n        HAL_NVIC_SetPriority(USART1_IRQn, 14, 0U); // 设置中断优先级\n    }\n}\n\nvoid USART1_IRQHandler(void)\n{\n    uint32_t timeout = 0;\n\n    HAL_UART_IRQHandler(&amp;UART1_Handler); // HAL库中断处理公共函数会调用HAL_UART_RxCpltCallback\n\n    timeout = 0;\n    while (HAL_UART_GetState(&amp;UART1_Handler) != HAL_UART_STATE_READY) // 等待就绪\n    {\n        timeout++; ////超时处理\n        if (timeout &gt; HAL_MAX_DELAY)\n            break;\n    }\n\n    timeout = 0;\n    while (HAL_UART_Receive_IT(&amp;UART1_Handler, (uint8_t *)aRxBuffer, 1) != HAL_OK) // 一次处理完成之后，重新开启中断并设置RxXferCount为1\n    {\n        timeout++; // 超时处理\n        if (timeout &gt; HAL_MAX_DELAY)\n            break;\n    }\n}\n\nvoid HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)\n{\n    if (huart-&gt;Instance == USART1) // 如果是串口1\n    {\n        if ((USART_RX_STA &amp; 0x8000) == 0) // 接收未完成\n        {\n            if (USART_RX_STA &amp; 0x4000) // 已经接收到了'/r'，但是还没接收到'/n'\n            {\n                if (aRxBuffer[0] != 0x0a) // 检查是不是'/n'\n                    USART_RX_STA = 0;     // 接收错误,清零\n                else\n                    USART_RX_STA |= 0x8000; // 接收完成标记\n            }\n            else // 还没收到'/r'\n            {\n                if (aRxBuffer[0] == 0x0d)   // 检查是不是'/r'\n                    USART_RX_STA |= 0x4000; // 标记接收到了'/r'\n                else                        // 记录在缓冲区\n                {\n                    USART_RX_BUF[USART_RX_STA &amp; 0X3FFF] = aRxBuffer[0];\n                    USART_RX_STA++;\n                    if (USART_RX_STA &gt; (256 - 1))\n                        USART_RX_STA = 0; // 接收数据错误,重新开始接收\n                }\n            }\n        }\n    }\n}\n\nvoid print(char *str)\n{\n    char *p = str;\n    while (*p != '\\0')\n    {\n        while (__HAL_UART_GET_FLAG(&amp;UART1_Handler, UART_FLAG_TC) != SET)\n            ; // 等待发送结束\n        HAL_UART_Transmit(&amp;UART1_Handler, (uint8_t *)p++, 1, 1000);\n    }\n}\n\nvoid printn(char *str, uint32_t n)\n{\n    char *p = str;\n    while (*p != '\\0' &amp;&amp; n--)\n    {\n        while (__HAL_UART_GET_FLAG(&amp;UART1_Handler, UART_FLAG_TC) != SET)\n            ; // 等待发送结束\n        HAL_UART_Transmit(&amp;UART1_Handler, (uint8_t *)p++, 1, 1000);\n    }\n}\n在platformio.ini中添加:\ninimonitor_speed = 115200使得其和上面的设置的波特率一致。\n","slug":"STM32入门（六）：串口通信","date":"2023-07-16T06:40:29.000Z","categories_index":"嵌入式","tags_index":"STM32,单片机","author_index":"Ac-Accelerator"},{"id":"216a2da9fe9c97a8ed131bdb8a83b703","title":"STM32入门（五）：中断","content":"中断概念中断是指计算机在正常处理程序的过程中，当发现某种异常事件或某种外部请求时，处理器会暂停执行当前程序转而执行异常事件处理或外部事件处理。在计算机科学中，中断是指处理器接收到来自硬件或软件的信号，提示发生了某个事件，应该被注意，这种情况就称为中断。通常，在接收到来自外围硬件（相对于中央处理器和内存）的异步信号，或来自软件的同步信号之后，处理器将会进行相应的硬件/软件处理。发出这样的信号称为进行中断请求（interrupt request，IRQ）。硬件中断导致处理器通过一个执行资讯切换（context switch）来保存执行状态（以程序计数器和程序状态字等寄存器信息为主）；软件中断则通常作为CPU指令集中的一个指令，以可编程的方式直接指示这种执行资讯切换，并将处理导向一段中断处理代码。\n在STM32中，一个中断的流程如下：\n\n\n中断优先级中断优先级是为了判断当多个中断同时发生时，哪个中断先执行而产生的概念。\n中断优先级分为：\n\n抢占优先级\n响应优先级\n自然优先级（中断向量表的优先级）\n\n抢占优先级高的会打断抢占优先级低的中断。当中断的抢占优先级相同时，响应优先级高的会先执行，但是不能互相打断。当中断的抢占优先级和响应优先级都相同时，自然优先级高的会先执行，但是不能互相打断。  \n中断优先级数值越小，优先级越高。\n在STM32中，有4个位来表示抢占优先级以及响应优先级，而中断优先级分组决定了这4个位中抢占优先级以及响应优先级位数的分配。\nNVIC嵌套向量中断控制器（Nested Vectored Interrupt Controller）\n\n68个可屏蔽中断通道(不包含16个Cortex™-M3的中断线)；\n16个可编程的优先等级(使用了4位中断优先级)；\n低延迟的异常和中断处理；\n电源管理控制；\n系统控制寄存器的实现；\n\n嵌套向量中断控制器(NVIC)和处理器核的接口紧密相连，可以实现低延迟的中断处理和高效地处理晚到的中断。\n\n\n**ISER(Interrupt Set-Enable Register)**：中断使能寄存器：此寄存器用于启用中断，并显示哪些中断已启用。**ISCR(Interrupt Clear-Enable Register)**：中断失能寄存器：此寄存器用于禁用中断，并显示哪些中断已启用。AIRCR(Application Interrupt and Reset Control Register):应用程序中断和复位控制寄存器此寄存器提供了数据访问的端序状态和系统的复位控制。（和中断优先级分组有关）SHPR(System Handler Priority Registers):系统处理器优先级寄存器：这些寄存器设置异常处理程序的优先级级别。**IPR(Interrupt Priority Registers)**：中断优先级寄存器：这些寄存器为每个中断提供一个4位优先级字段。  \nEXTI外部中断/事件控制器（External Interrupt）\n对于互联型产品，外部中断/事件控制器由20个产生事件/中断请求的边沿检测器组成，对于其它产品，则有19个能产生事件/中断请求的边沿检测器。每个输入线可以独立地配置输入类型(脉冲或挂起)和对应的触发事件(上升沿或下降沿或者双边沿都触发)。每个输入线都可以独立地被屏蔽。挂起寄存器保持着状态线的中断请求。\nEXTI控制器的主要特性如下：\n\n每个中断/事件都有独立的触发和屏蔽\n每个中断线都有专用的状态位\n支持多达20个软件的中断/事件请求\n检测脉冲宽度低于APB2时钟宽度的外部信号。\n\n\n\n\nIMR：Interrupt Mask Register，中断屏蔽寄存器。\nEMR：Event Mask Register，事件屏蔽寄存器。\nRTSR：Rising Trigger Selection Register，上升沿触发选择寄存器。\nFTSR：Falling Trigger Selection Register，下降沿触发选择寄存器。\nSWIER：Software Interrupt Event Register，软件中断事件寄存器。\nPR：Pending Register，挂起寄存器。\n\n要产生中断，必须先配置好并使能中断线。根据需要的边沿检测设置2个触发寄存器，同时在中断屏蔽寄存器的相应位写’1’允许中断请求。当外部中断线上发生了期待的边沿时，将产生一个中断请求，对应的挂起位也随之被置’1’。在挂起寄存器的对应位写’1’，将清除该中断请求。如果需要产生事件，必须先配置好并使能事件线。根据需要的边沿检测通过设置2个触发寄存器，同时在事件屏蔽寄存器的相应位写’1’允许事件请求。当事件线上发生了需要的边沿时，将产生一个事件请求脉冲，对应的挂起位不被置’1’。通过在软件中断/事件寄存器写’1’，也可以通过软件产生中断/事件请求。\nGPIO外部中断\n\n另外四个EXTI线的连接方式如下：\n\nEXTI线16连接到PVD输出\nEXTI线17连接到RTC闹钟事件\nEXTI线18连接到USB唤醒事件\nEXTI线19连接到以太网唤醒事件(只适用于互联型产品)\n\nGPIO外部中断配置方式\n使能GPIO时钟\n设置GPIO模式为输入\n使能AFIO/SYSCFG时钟\n设置EXTI和GPIO的映射关系\n设置EXTI触发方式\n设置NVIC\n定义中断服务函数\n\n\n\n依据上述回调机制，我们需要在自己定义的中断服务函数中调用HAL库中断处理公共函数，即HAL_GPIO_EXTI_IRQHandler，该函数会清除中断挂起寄存器PR，并调用回调函数HAL_GPIO_EXTI_Callback。HAL_GPIO_EXTI_Callback函数是个__weak类型的函数，可以重写该函数，这样就可以在中断服务函数里面实现具体的功能了。\nGPIO硬件中断代码例子制作一个会改变闪烁频率的LED灯\nHAL_StatusTypeDef Stm32_Clock_Init();void LED_Init();\ncpp#include &lt;stm32f1xx_hal.h&gt;\n\nHAL_StatusTypeDef Stm32_Clock_Init();\nvoid LED_Init();\nvoid KEY_Init();\nuint32_t time = 1000;\n\nint main()\n{\n    /*\n    HAL_Init()中，调用HAL_NVIC_SetPriorityGrouping设置中断优先级分组为NVIC_PRIORITYGROUP_4\n    即4位抢占优先级，0位响应优先级\n    并且用HAL_NVIC_SetPriority将SysTick_IRQn设置为15即最低优先级\n    */\n    HAL_Init();                     // 初始化HAL库\n    Stm32_Clock_Init(RCC_PLL_MUL9); // 初始化时钟\n    LED_Init();                     // 初始化LED外设\n    KEY_Init();                     // 初始化KEY外设\n    HAL_NVIC_SetPriority(SysTick_IRQn, 1, 0U);//由于我们要在中断里面使用HAL_Delay()函数消除抖动，所以要设置SysTick_IRQn的抢占优先级比EXTI3_IRQn和EXTI0_IRQn高。\n    while (1)                       // 交替闪烁\n    {\n        HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_RESET); // PB5输出低电平\n        HAL_GPIO_WritePin(GPIOE, GPIO_PIN_5, GPIO_PIN_SET);   // PE5输出高电平\n        HAL_Delay(time);\n\n        HAL_GPIO_WritePin(GPIOE, GPIO_PIN_5, GPIO_PIN_RESET); // PE5输出低电平\n        HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_SET);   // PB5输出高电平\n        HAL_Delay(time);\n    }\n}\n\nvoid KEY_Init()\n{\n    // 第1步，在使用GPIO之前，需要使能GPIO时钟\n    __HAL_RCC_GPIOA_CLK_ENABLE(); // 使能GPIOA时钟\n    __HAL_RCC_GPIOE_CLK_ENABLE(); // 使能GPIOE时钟\n\n    //第2步到第5步\n    GPIO_InitTypeDef GPIO_InitStruct = {0};\n\n    GPIO_InitStruct.Pin = GPIO_PIN_3;       // 指定要初始化的引脚\n    GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING; // 指定引脚模式为输入\n    GPIO_InitStruct.Pull = GPIO_PULLUP;     // 指定引脚上拉\n    HAL_GPIO_Init(GPIOE, &amp;GPIO_InitStruct);// 初始化PE3引脚\n\n    GPIO_InitStruct.Pin = GPIO_PIN_0; // 指定要初始化的引脚\n    GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;// 指定引脚模式为中断上升沿触发\n    GPIO_InitStruct.Pull = GPIO_PULLDOWN;// 指定引脚下拉\n    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);// 初始化PA0引脚\n\n    //第6步，设置NVIC\n    HAL_NVIC_SetPriority(EXTI0_IRQn, 15, 0);// 设置中断优先级15，抢占优先级0\n    HAL_NVIC_EnableIRQ(EXTI0_IRQn);// 使能中断线0\n\n    HAL_NVIC_SetPriority(EXTI3_IRQn, 15, 0);// 设置中断优先级15，抢占优先级0\n    HAL_NVIC_EnableIRQ(EXTI3_IRQn);// 使能中断线3\n}\n\nvoid EXTI0_IRQHandler()// 中断服务函数，当EXTI0发生中断时会自动调用该函数\n{   \n    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0);//调用HAL库中断处理公共函数\n}\n\nvoid EXTI3_IRQHandler()// 中断服务函数，当EXTI3发生中断时会自动调用该函数\n{   \n    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_3);//调用HAL库中断处理公共函数\n}\n\nvoid HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)// 重写回调函数，实现具体功能\n{\n    HAL_Delay(10);// 消除抖动\n    if (GPIO_Pin == GPIO_PIN_0)\n    {\n        if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_SET)\n        {\n            time /= (time==1?1:2);// 防止time为0\n        }\n    }\n    else if (GPIO_Pin == GPIO_PIN_3)\n    {\n        if (HAL_GPIO_ReadPin(GPIOE, GPIO_PIN_3) == GPIO_PIN_RESET)\n        {\n            time *= 2;\n        }\n    }\n}\n\nvoid SysTick_Handler()// SysTick中断服务函数\n{\n    HAL_IncTick();\n}","slug":"STM32入门（五）：中断","date":"2023-07-15T04:16:04.000Z","categories_index":"嵌入式","tags_index":"STM32,单片机","author_index":"Ac-Accelerator"},{"id":"68d21eb3a7189bac765001dce9d152b5","title":"STM32入门（四）：GPIO","content":"什么是GPIOGPIO（General-Purpose Input/Output，通用输入输出）是指集成电路或电子电路（例如MCU/MPU）板上的一个未提交的数字信号引脚，它可以用作输入或输出，或两者兼而有之，并且可以通过软件控制。GPIO没有预定义的目的，且默认情况下未使用。\nGPIO的用途非常广泛，它可以用来操作自定义电子设备。例如，您可以使用GPIO来构建自己的机器人臂或DIY气象站。GPIO接口可以让您自定义信号，以便正确操作您的设备。\n每个GPI/O端口有两个32位配置寄存器(GPIOx_CRL，GPIOx_CRH)，两个32位数据寄存器(GPIOx_IDR和GPIOx_ODR)，一个32位置位/复位寄存器(GPIOx_BSRR)，一个16位复位寄存器(GPIOx_BRR)和一个32位锁定寄存器(GPIOx_LCKR)。根据数据手册中列出的每个I/O端口的特定硬件特征， GPIO端口的每个位可以由软件分别配置成多种模式。\n\n输入浮空\n输入上拉\n输入下拉\n模拟输入\n开漏输出\n推挽式输出\n推挽式复用功能\n开漏复用功能\n\n每个I/O端口位可以自由编程，然而I/0端口寄存器必须按32位字被访问(不允许半字或字节访问)。GPIOx_BSRR和GPIOx_BRR寄存器允许对任何GPIO寄存器的读/更改的独立访问；这样，在读和更改访问之间产生IRQ时不会发生危险。\n\n\nGPIO模式输入浮空输入浮空模式是指逻辑器件与引脚既不接高电平，也不接低电平。由于逻辑器件的内部结构，当它输入引脚悬空时，相当于该引脚接了高电平。一般实际运用时，引脚不建议悬空，易受干扰。通俗讲就是浮空就是浮在空中，就相当于此端口在默认情况下什么都不接，呈高阻态，这种设置在数据传输时用的比较多。浮空最大的特点就是电压的不确定性，它可能是0V，页可能是VCC，还可能是介于两者之间的某个值（最有可能）\n输入上拉输入上拉模式是一种常用的输入模式，它可以用来检测外部信号，例如接地的按键等，在按键没有导通的时候端口状态为1。在输入上拉模式中，微控制器将开启引脚的内部上拉电阻，实现上拉输入功能。这种模式可以确保输入信号稳定，避免输入信号受到干扰。\n输入下拉输入下拉模式是一种常用的输入模式，它可以用来检测外部信号，例如接高电平的按键等，在按键没有导通的时候端口状态为0。在输入下拉模式中，微控制器将开启引脚的内部下拉电阻，实现下拉输入功能。这种模式可以确保输入信号稳定，避免输入信号受到干扰\n模拟输入模拟输入是指对连续变化的信号进行量化，将模拟信号通过模数转换器（ADC）转换成数字量，并将数据上传到计算机的功能。这种功能在数据采集卡中使用最为广泛。例如，当您需要测量温度、压力或电压等物理量时，可以使用模拟输入来读取传感器的输出信号，并将其转换为数字量以便计算机处理。\n开漏输出开漏输出（Open Drain Output）是一种常用的输出模式，它可以用来连接不同电平的器件，匹配电平。因为开漏引脚不连接外部的上拉电阻时，只能输出低电平，如果需要同时具备输出高电平的功能，则需要接上拉电阻。这样，通过改变上拉电源的电压，便可以改变传输电平。\n开漏输出还可以用于通信接口，例如I2C总线。在这种情况下，多个设备可以同时挂在同一条总线上。当内部信号输入高电平时，NMOS管导通，输出被拉低到低电平状态；当内部信号输入低电平时，NMOS管截至，输出高阻态。此时可以在外部接一个上拉电阻来实现输出高电平。\n推挽输出推挽输出（Push-Pull Output）是一种常用的输出模式，它可以用来直接控制数字电路。可以直接控制一些数字芯片，如ADC、DAC、触发器、锁存器、三极管控制引脚等等。推挽输出电路通常用于驱动负载电流较大的应用，例如音频放大器或电机驱动器等\n推挽复用功能推挽复用输出（Push-Pull Alternate Function Output），复用功能是指单片机的引脚既可以做普通GPIO使用，也可以作为内部外设控制器的引脚来使用。例如，STM32F103xx单片机的PA5引脚，它可以做为普通GPIO来使用；其次，如果作为外设的引脚，它可以作为SPI1的时钟（SPI1_SCK）、DAC的输出通道1（DAC_OUT1）或者ADC的输入通道5（ADC12_IN5）。\n开漏复用功能开漏式复用输出（Open Drain Alternate Function Output）是一种常用的输出模式，它可以用来连接片内外设功能，例如I2C的SCL和SDA。\nGPIO模式对应的状态输入\n输出缓冲器被禁止\n施密特触发输入被激活\n根据输入配置(上拉，下拉或浮动)的不同，弱上拉和下拉电阻被连接\n出现在I/O脚上的数据在每个APB2时钟被采样到输入数据寄存器\n对输入数据寄存器的读访问可得到I/O状态\n\n输出\n输出缓冲器被激活\n开漏模式：输出寄存器上的’0’激活N-MOS，而输出寄存器上的’1’将端口置于高阻状态(P-MOS从不被激活)。\n推挽模式：输出寄存器上的’0’激活N-MOS，而输出寄存器上的’1’将激活P-MOS。\n\n\n施密特触发输入被激活\n弱上拉和下拉电阻被禁止\n出现在I/O脚上的数据在每个APB2时钟被采样到输入数据寄存器\n在开漏模式时，对输入数据寄存器的读访问可得到I/O状态\n在推挽式模式时，对输出数据寄存器的读访问得到最后一次写的值。\n\n复用\n在开漏或推挽式配置中，输出缓冲器被打开\n内置外设的信号驱动输出缓冲器(复用功能输出)\n施密特触发输入被激活\n弱上拉和下拉电阻被禁止\n在每个APB2时钟周期，出现在I/O脚上的数据被采样到输入数据寄存器\n开漏模式时，读输入数据寄存器时可得到I/O口状态\n在推挽模式时，读输出数据寄存器时可得到最后一次写的值\n\n模拟\n输出缓冲器被禁止；\n禁止施密特触发输入，实现了每个模拟I/O引脚上的零消耗。施密特触发输出值被强置为’0’；\n弱上拉和下拉电阻被禁止；\n读取输入数据寄存器时数值为’0’。\n\nGPIO使用（控制LED闪烁）查看开发板电路图，看到两个LED的引脚分别是PB5和PE5，因此我们需要对这两个引脚进行初始化，使其成为输出引脚。\nGPIO初始化cpp#include &lt;stm32f1xx_hal.h&gt;\nvoid LED_Init()\n{\n    //在使用GPIO之前，需要使能GPIO时钟\n    __HAL_RCC_GPIOB_CLK_ENABLE();   // 使能GPIOB时钟\n    __HAL_RCC_GPIOE_CLK_ENABLE();   // 使能GPIOE时钟\n    GPIO_InitTypeDef GPIO_InitStruct = {0};\n    GPIO_InitStruct.Pin = GPIO_PIN_5;             // 指定要初始化的引脚\n    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; // 指定引脚模式为推挽输出\n    GPIO_InitStruct.Speed = GPIO_SPEED_LOW;    // 指定引脚速度为低速（在控制led的例子中这一项没那么重要）\n    // GPIO_InitStruct.Pull = GPIO_NOPULL;     // 输出模式上下拉没什么意义\n    HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);// 初始化PB5引脚\n    HAL_GPIO_Init(GPIOE, &amp;GPIO_InitStruct);// 初始化PE5引脚\n}\nGPIO使用HAL_StatusTypeDef Stm32_Clock_Init();\ncpp#include &lt;stm32f1xx_hal.h&gt;\nHAL_StatusTypeDef Stm32_Clock_Init();\nvoid LED_Init();\n\nvoid LED0_TOGGLE();\nvoid LED0_ON();\nvoid LED0_OFF();\n\nvoid LED1_TOGGLE();\nvoid LED1_ON();\nvoid LED1_OFF();\n\nint main()\n{\n    HAL_Init();                     // 初始化HAL库\n    Stm32_Clock_Init(RCC_PLL_MUL9); // 初始化时钟\n    LED_Init();                     // 初始化LED外设\n    while (1)//交替闪烁\n    {\n        HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_RESET);//PB5输出低电平\n        HAL_GPIO_WritePin(GPIOE, GPIO_PIN_5, GPIO_PIN_SET);//PE5输出高电平\n        HAL_Delay(500);\n\n        HAL_GPIO_WritePin(GPIOE, GPIO_PIN_5, GPIO_PIN_RESET);//PE5输出低电平\n        HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_SET);//PB5输出高电平\n        HAL_Delay(500);\n    }\n}\n\nvoid SysTick_Handler()//系统计时器中断处理程序（重要⚠️如果没定义则无法处理系统定时器的中断）\n{\n    HAL_IncTick();//系统嘀嗒计时器加1（如果不调用这个函数，无法使用HAL_Delay函数，需要自己实现其他方法）\n}\n\nvoid LED0_ON()\n{\n    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_RESET); // 点亮LED0\n}\n\nvoid LED0_OFF()\n{\n    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_SET); // 关闭LED0\n}\n\nvoid LED0_TOGGLE()\n{\n    HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_5); // 翻转LED0\n}\n\nvoid LED1_ON()\n{\n    HAL_GPIO_WritePin(GPIOE, GPIO_PIN_5, GPIO_PIN_RESET); // 点亮LED1\n}\n\nvoid LED1_OFF()\n{\n    HAL_GPIO_WritePin(GPIOE, GPIO_PIN_5, GPIO_PIN_SET); // 关闭LED1\n}\n\nvoid LED1_TOGGLE()\n{\n    HAL_GPIO_TogglePin(GPIOE, GPIO_PIN_5); // 翻转LED1\n}\n\n\n\n\n\n\n\n\n\n记得定义SysTick_Handler，否则时间延迟函数HAL_Delay()会进入死循环。\n其他的函数还有HAL_GPIO_ReadPin()、HAL_GPIO_TogglePin()等，可以自行查看。\n","slug":"STM32入门（四）：GPIO","date":"2023-07-14T14:36:30.000Z","categories_index":"嵌入式","tags_index":"STM32,单片机","author_index":"Ac-Accelerator"},{"id":"4ec857b23ce5e6dcd3e699fe4235ea27","title":"STM32入门（三）：时钟配置","content":"基本上所有的单片机功能都离不开时钟的帮助啦！所以时钟的配置是非常重要的。基本上是单片机开发的第一步呢！\n时钟系统初始化\n\ncpp#include &lt;stm32f1xx_hal.h&gt; //要使用hal库，必须使用这个头文件\nHAL_StatusTypeDef Stm32_Clock_Init();//时钟初始化函数\nint main()\n{\n    /*\n    首先初始化HAL库\n    这个函数首先会设置中断优先级分组\n    然后使用HSI作为默认时钟，设置1ms触发一个系统定时器的中断,中断优先级默认设置为15。\n    最后会初始化底层硬件\n    */\n    HAL_Init(); \n\n    Stm32_Clock_Init()；//时钟初始化\n}\nHAL_StatusTypeDef Stm32_Clock_Init()\n{\n    HAL_StatusTypeDef ret = HAL_OK;\n    RCC_OscInitTypeDef RCC_OscInitStructure;//晶震初始化结构体\n    RCC_ClkInitTypeDef RCC_ClkInitStructure;//时钟初始化结构体\n\n    RCC_OscInitStructure.OscillatorType = RCC_OSCILLATORTYPE_HSE; // 该结构体配置的目标是HSE\n    RCC_OscInitStructure.HSEState = RCC_HSE_ON;                   // 设置HSE的状态为打开\n    RCC_OscInitStructure.HSEPredivValue = RCC_HSE_PREDIV_DIV1;    // 时钟信号经过PLLXTPRE(PREDIV1)时不分频\n    RCC_OscInitStructure.PLL.PLLState = RCC_PLL_ON;               // 设置PLL状态为打开\n    RCC_OscInitStructure.PLL.PLLSource = RCC_PLLSOURCE_HSE;       // 选择HSE为PLL时钟源(PLLSRC)\n    RCC_OscInitStructure.PLL.PLLMUL = RCC_PLL_MUL9;               // 主PLL倍频因子(PLLMUL)，9倍频，得到72M\n    ret = HAL_RCC_OscConfig(&amp;RCC_OscInitStructure);               // 初始化\n\n    if (ret != HAL_OK)\n        return ret;\n\n    RCC_ClkInitStructure.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);// 选择配置SYSCLK、HCLK,PCLK1和PCLK2\n    RCC_ClkInitStructure.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;       // 设置SYSCLK为PLL\n    RCC_ClkInitStructure.AHBCLKDivider = RCC_SYSCLK_DIV1;              // AHB分频系数为1\n    RCC_ClkInitStructure.APB1CLKDivider = RCC_HCLK_DIV2;               // APB1分频系数为2\n    RCC_ClkInitStructure.APB2CLKDivider = RCC_HCLK_DIV1;               // APB2分频系数为1\n    /* 同时设置FLASH延时周期为2WS，也就是3个CPU周期。这是因为CPU比flash速度快，例如flash最快24MHz，如果CPU频率超过这个频率，就必须加入等待时间，比如一般用72MHz主频，那么flash等待周期必须设置为2*/\n    ret = HAL_RCC_ClockConfig(&amp;RCC_ClkInitStructure, FLASH_LATENCY_2); \n\n    if (ret != HAL_OK)\n        return ret;\n    return HAL_OK;\n}\n\nvoid SysTick_Handler()//系统计时器中断处理程序（重要⚠️如果没定义则无法处理系统定时器的中断）\n{\n    HAL_IncTick();//系统嘀嗒计时器加1（如果不调用这个函数，无法使用HAL_Delay函数，需要自己实现其他方法）\n}\n\n\n\n\n\n\n\n\n\nSysTick_Handler是系统定时器的中断处理程序。在HAL_Init中，设置系统定时器中断触发时间为1ms，因此这个函数1ms触发一次。在这个函数中，调用了HAL_IncTick()函数，这个函数的作用是将系统嘀嗒计时器的计数值加1。系统嘀嗒计时器的计数值是一个全局变量，它的值会在每次中断时加1，所以这个变量的值就是系统运行的时间，单位是ms。这个变量的值可以通过调用HAL_GetTick()函数获得。可以通过在该中断处理程序中完成一些周期性的工作。\n至此，系统时钟以及系统计时器配置完成。\nsystick配置cppHAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);将系统嘀嗒计时器的时钟源设置为HCLK，也就是72MHz。\n在HAL_Init函数中，默认是将系统嘀嗒计时器的时钟源设置为HCLK，所以这一步可以省略。\n时间延迟功能cppHAL_Delay(1000);上述函数的作用是延迟1000ms，也就是1s。\n如果要做到微秒级的延时控制，可以通过软件实现，但是精准度不高，所以一般使用硬件定时器（TIM）来实现。\n软件实现：\ncppvoid delay_us(u32 nus)  //软件控制微秒级延时\n{\n    u32 ticks;\n    u32 told, tnow, tcnt = 0;\n    u32 reload = SysTick-&gt;LOAD; // LOAD的值\n    ticks = nus * 72;       // 需要的节拍数\n    told = SysTick-&gt;VAL;        // 刚进入时的计数器值\n    while (1)\n    {\n        tnow = SysTick-&gt;VAL;\n        if (tnow != told)\n        {\n            if (tnow &lt; told)\n                tcnt += told - tnow; // SYSTICK是一个递减的计数器就可以了.\n            else\n                tcnt += reload - tnow + told;\n            told = tnow;\n            if (tcnt &gt;= ticks)\n                break; // 时间超过/等于要延迟的时间,则退出.\n        }\n    };\n}","slug":"STM32入门（三）：时钟配置","date":"2023-07-14T09:04:28.000Z","categories_index":"嵌入式","tags_index":"STM32,单片机","author_index":"Ac-Accelerator"},{"id":"38fc18eebdbdaec5f989594360c2293b","title":"STM32入门（二）：开发环境配置","content":"操作系统环境Ubuntu 22.04.2 LTS\n开发软件配置Visual Studio Code\n安装插件\nC/C++\nPlatformIO IDE\n\n新建PlatformIO工程配置PlatformIO在PlatformIO主页面中选择platform页面，安装一个嵌入式平台，选择ST STM32。\n在PlatformIO主页面中选择Project页面，点击New Project按钮，选择STM32F103ZE作为开发板，该芯片支持很多框架，这里选择STM32Cube，点击Finish按钮，即可新建一个PlatformIO工程。\n可以看到配置文件如下所示，由于我使用的是正点原子的F1精英开发板以及stlink下载器，所以添加最后两行用于指定上传和调试工具，避免其使用默认的工具导致出现错误。\nini[env:genericSTM32F103ZE]\nplatform = ststm32\nboard = genericSTM32F103ZE\nframework = stm32cube\n;添加如下两行\nupload_protocol = stlink ; 上传工具\ndebug_tool = stlink      ; 调试工具如果需要指定更多配置，可以参考官方文档。\n文件夹介绍可以看到PlatformIO自动为我们生成了一个简单的工程，其中有很多文件夹，各个文件夹的用途写在了对应的readme文件中。\nlib该目录适用于项目特定的（私有）库。PlatformIO 将它们编译为静态库并链接到可执行文件。\n每个库的源代码应该放在自己单独的目录中（“lib/your_library_name/[这里是源文件]”）。\n例如，以下两个库“Foo”和“Bar”的结构：\ntxt|--lib\n|  |\n|  |--Bar\n|  |  |--docs\n|  |  |--examples\n|  |  |--src\n|  |     |- Bar.c\n|  |     |- Bar.h\n|  |  |- library.json (optional, custom build options, etc) https://docs.platformio.org/page/librarymanager/config.html\n|  |\n|  |--Foo\n|  |  |- Foo.c\n|  |  |- Foo.h\n|\n|- platformio.ini\n|--src\n   |- main.c在源文件中，您可以使用以下方式包含库头文件：\ncpp#include &lt;Foo.h&gt;\n#include &lt;Bar.h&gt;\n\nint main (void)\n{\n  ...\n}src、include在src里面编写的源文件可以使用include目录下的头文件。\ntest单元测试文件夹,具体用法如下\n基础\n在嵌入式设备上运行\n持续集成和远程测试\nSTM32Cube库文件\n\n目录~/.platformio/packages/framework-stm32cubef1下的文件如上图所示。\n其中~/.platformio/packages/framework-stm32cubef1/Drivers/STM32F1xx_HAL_Driver 文件夹就是HAL库和LL库所在的位置。\n","slug":"STM32入门（二）：开发环境配置","date":"2023-07-14T06:13:00.000Z","categories_index":"嵌入式","tags_index":"STM32,单片机","author_index":"Ac-Accelerator"},{"id":"d680335def93df41c247e0c4f534ee20","title":"STM32入门（一）：认识STM32","content":"产品类型STM32分为小容量、中容量、大容量和互联型产品。\n\n小容量产品是指闪存存储器容量在16K至32K字节之间的STM32F101xx、STM32F102xx和STM32F103xx微控制器。  \n中容量产品是指闪存存储器容量在64K至128K字节之间的STM32F101xx、STM32F102xx和STM32F103xx微控制器。  \n大容量产品是指闪存存储器容量在256K至512K字节之间的STM32F101xx和STM32F103xx微控制器。  \n互联型产品是STM32F105xx和STM32F107xx微控制器。\n\n系统构架在小容量、中容量和 大容量产品中，主系统由4个驱动单元和4个被动单元组成。\n\n驱动单元：  \n\nDCode总线(D-bus)：一条基于AHB-Lite总线协议的32位总线，负责在0x0000_0000 – 0x1FFF_FFFF之间的数据访问操作。它的作用是对数据读写访问，只和数据有关。\n系统总线(S-bus)：一条基于AHB-Lite总线协议的32位总线，负责在0x2000_0000 – 0xDFFF_FFFF之间的数据访问操作1。它的作用是对数据读写访问，只和数据有关。\n通用DMA1：直接存储器访问（Direct Memory Access）控制器的第一个实例。它可以在不占用处理器资源的情况下，直接在内存和外设之间传输数据。在Cortex-M3内核中，DMA控制器通过与Cortex-M3内核共享系统总线来执行直接存储器传输。当CPU和DMA目标相同时（内存或外设），DMA请求可能会在一些总线周期内停止CPU对系统总线的访问\n通用DMA2：和DMA1一样，只是它是第二个实例。\n\n\n被动单元：  \n\n内部SRAM：静态随机存储器（Static Random Access Memory，简称SRAM）。它是一种内存类型，用于在芯片内部存储数据。与动态随机存储器（Dynamic Random Access Memory，简称DRAM）不同，SRAM不需要定期刷新来保持数据。这意味着它可以更快地访问数据，但也意味着它的成本更高，且集成度较低。\n内部闪存存储器：FLASH\nFSMC：灵活的静态存储器控制器（Flexible Static Memory Controller）是STM32中一个很有特色的外设，通过FSMC，STM32可以与SRAM、ROM、PSRAM、Nor Flash和NandFlash存储器的引脚相连，从而进行数据的交换。FSMC可以连接异步或同步存储器或16位PC存储卡，主要用途有：将AHB数据通信事务转换为适当的外部器件协议，满足外部器件的访问时序要求。\nAHB到APB的桥(AHB2APBx)，它连接所有的APB设备。\n\n\n\n\n\n\n\n\n\n\n\n\nCortex™-M3内核的DCode总线(D-bus)和系统总线(S-bus)都是基于AHB-Lite总线协议的32位总线，负责数据访问操作。它们的主要区别在于它们所负责的数据访问范围不同。DCode总线(D-bus)负责在0x0000_0000 – 0x1FFF_FFFF之间的数据访问操作，而系统总线(S-bus)负责在0x2000_0000 – 0xDFFF_FFFF之间的数据访问操作。尽管CM3支持非对齐访问，但你绝不会在该总线上看到任何非对齐的地址，这是因为处理器的总线接口会把非对齐的数据传送都转换成对齐的数据传送。因此，连接到D-Code总线上的任何设备都只需支持AHB-Lite的对齐访问，不需要支持非对齐访问\n\n\n\n\n\n\n\n\n\n高级高性能总线AHB（Advanced High-performance Bus）和高级外设总线APB（Advanced Peripheral Bus）都属于ARM公司的AMBA（Advanced Microcontroller Bus Architecture，高级微控制器总线架构）规范的一部分。它们之间的主要区别在于它们的速度和预期用途。AHB被设计用于需要快速数据传输速率和低延迟通信的高性能应用，而APB则被设计用于不需要高速数据传输的较慢外设。AHB使用全双工并行通信，而APB则使用大量的内存I/O访问。AHB通常用于芯片上不同组件之间的高速通信，而APB则用于处理器和其他外设之间的低速通信。AHB是一个同步协议，而APB是一个异步协议。\n\n\n\n指令总线(ICode bus)用于传输指令。该总线将Cortex™-M3内核的指令总线与闪存指令接口相连接。指令预取在此总线上完成。 \nSDIO是Secure Digital Input Output的缩写，它是一种安全数字卡接口，可以用作输入或输出设备的接口1。SDIO接口通常用于连接各种外设，如Wi-Fi、蓝牙、GPS等，以扩展设备的功能。  \nRCC是Reset and Clock Control（复位和时钟控制）的缩写。它是一个用于管理系统时钟和复位的模块。在Cortex-M3内核中，RCC模块负责管理系统时钟源，包括内部和外部时钟源，以及为外设提供时钟信号。此外，RCC模块还负责管理系统复位，包括软件复位、硬件复位和电源复位等。\nDMA总线将DMA的AHB主控接口与总线矩阵相联，总线矩阵协调着CPU的DCode和DMA到SRAM、闪存和外设的访问。\n总线矩阵协调内核系统总线和DMA主控总线之间的访问仲裁，仲裁利用轮换算法。\n\n启动配置在STM32F10xxx里，可以通过BOOT[1:0]引脚选择三种不同启动模式。\n\n\n\nBOOT0\nBOOT1\n启动模式\n\n\n\nX\n0\n主存储器启动模式\n\n\n0\n1\n系统存储器启动模式\n\n\n1\n1\nSRAM启动模式\n\n\n闪存存储器有主存储块和信息块组成。\n从主闪存存储器启动：主闪存存储器被映射到启动空间(0x0000 0000)，但仍然能够在它原有的地址(0x0800 0000)访问它，即闪存存储器的内容可以在两个地址区域访问，0x0000 0000或0x0800 0000。\n从系统存储器启动：系统存储器被映射到启动空间(0x0000 0000)，但仍然能够在它原有的地址(互联型产品原有地址为0x1FFF B000，其它产品原有地址为0x1FFF F000)访问它。\n从内置SRAM启动：只能在0x2000 0000开始的地址区访问SRAM。\n\n\n\n\n\n\n\n\n\n注意： 当从内置SRAM启动，在应用程序的初始化代码中，必须使用NVIC的异常表和偏移寄存器，从新映射向量表之SRAM中。\n复位STM32F10xxx支持三种复位形式，分别为系统复位、上电复位和备份区域复位。\n系统复位除了时钟控制器的RCC_CSR寄存器中的复位标志位和备份区域中的寄存器(见图4)以外，系统复位将复位所有寄存器至它们的复位状态。\n当发生以下任一事件时，产生一个系统复位：\n\nNRST引脚上的低电平(外部复位)\n窗口看门狗计数终止(WWDG复位)\n独立看门狗计数终止(IWDG复位)\n软件复位(SW复位)\n低功耗管理复位\n\n可通过查看RCC_CSR控制状态寄存器中的复位状态标志位识别复位事件来源。\n通过将Cortex™-M3中断应用和复位控制寄存器中的SYSRESETREQ位置’1’，可实现软件复位。\n在以下两种情况下可产生低功耗管理复位：\n\n在进入待机模式时产生低功耗管理复位：通过将用户选择字节中的nRST_STDBY位置’1’将使能该复位。这时，即使执行了进入待机模式的过程，系统将被复位而不是进入待机模式。\n在进入停止模式时产生低功耗管理复位：通过将用户选择字节中的nRST_STOP位置’1’将使能该复位。这时，即使执行了进入停机模式的过程，系统将被复位而不是进入停机模式。\n\n电源复位当以下事件中之一发生时，产生电源复位：\n\n上电/掉电复位(POR/PDR复位)\n从待机模式中返回\n\n电源复位将复位除了备份区域外的所有寄存器。\n\n\n图中复位源将最终作用于RESET引脚，并在复位过程中保持低电平。复位入口矢量被固定在地址0x0000 0004。芯片内部的复位信号会在NRST引脚上输出，脉冲发生器保证每一个(外部或内部)复位源都能有至少20μs的脉冲延时；当NRST引脚被拉低产生外部复位时，它将产生复位脉冲。\n备份区域复位拥有两个专门的复位，它们只影响备份区域。当以下事件中之一发生时，产生备份区域复位。\n\n软件复位，备份区域复位可由设置备份域控制寄存器(RCC_BDCR)中的BDRST位产生。\n在和两者掉电的前提下，或上电将引发备份区域复位。\n\n时钟概况三种不同的时钟源可被用来驱动系统时钟(SYSCLK)\n\nHSI振荡器时钟：高速内部振荡器（High-Speed Internal Oscillator）\nHSE振荡器时钟：高速外部振荡器（High-Speed External Oscillator）\nPLL时钟：锁相环（Phase-Locked Loop）用来倍频HSI RC的输出时钟或HSE晶体输出时钟。\n\n\n\n\n\n\n\n\n\n\nPLL的设置(选择HIS振荡器除2或HSE振荡器为PLL的输入时钟，和选择倍频因子)必须在其被激活前完成。一旦PLL被激活，这些参数就不能被改动。如果PLL中断在时钟中断寄存器里被允许，当PLL准备就绪时，可产生中断申请。如果需要在应用中使用USB接口，PLL必须被设置为输出48或72MHZ时钟，用于提供48MHz的USBCLK时钟。\n\n\n用户可通过多个预分频器配置AHB、高速APB(APB2)和低速APB(APB1)域的频率。AHB和APB2域的最大频率是72MHz。APB1域的最大允许频率是36MHz。SDIO接口的时钟频率固定为HCLK/2。\nRCC通过AHB时钟(HCLK)8分频后作为Cortex系统定时器(SysTick)的外部时钟。通过对SysTick控制与状态寄存器的设置，可选择上述时钟或Cortex(HCLK)时钟作为SysTick时钟。ADC时钟由高速APB2时钟经2、4、6或8分频后获得。\n定时器时钟频率分配由硬件按以下2种情况自动设置：\n\n如果相应的APB预分频系数是1，定时器的时钟频率与所在APB总线频率一致。\n否则，定时器的时钟频率被设为与其相连的APB总线频率的2倍。\n\nLSE晶体通过在备份域控制寄存器(RCC_BDCR)里的LSEON位启动和关闭。\nLSI RC可以通过控制/状态寄存器(RCC_CSR)里的LSION位来启动或关闭。\n时钟启动系统复位后，HSI振荡器被选为系统时钟。当时钟源被直接或通过PLL间接作为系统时钟时，它将不能被停止。\n只有当目标时钟源准备就绪了(经过启动稳定阶段的延迟或PLL稳定)，从一个时钟源到另一个时钟源的切换才会发生。在被选择时钟源没有就绪时，系统时钟的切换不会发生。直至目标时钟源就绪，才发生切换。\n时钟输出微控制器允许输出时钟信号到外部MCO引脚。\n相应的GPIO端口寄存器必须被配置为相应功能。以下四个时钟信号可被选作MCO时钟：\n\nSYSCLK\nHSI\nHSE\n除2的PLL时钟\n\n时钟的选择由时钟配置寄存器(RCC_CFGR)中的MCO[2:0]位控制。\n","slug":"STM32入门（一）：认识STM32","date":"2023-07-13T08:31:43.000Z","categories_index":"嵌入式","tags_index":"STM32,单片机","author_index":"Ac-Accelerator"},{"id":"59fff721b35c430dcc2003c20536d30b","title":"8086微机汇编语言","content":"在学校学习了汇编语言一课程，但是由于汇编指令繁多，而且在互联网上没有找到满足我要求的资料。同时书上的知识也比较分散，不好索引。所以我打算自己整理一份资料，方便自己以后查阅。同时也希望能帮助到其他人。\n寄存器分类通用寄存器\n\n\n寄存器符号\n全称\n\n用途\n\n\n\nAX\nAccumulator\n累加寄存器\n通用寄存器，主要作为累加器使用，是算数运算的主要寄存器\n\n\nBX\nBase\n基址寄存器\n通用寄存器，一般用于存放基址\n\n\nCX\nCount\n计数寄存器\n通用寄存器，一般用于存放循环次数的寄存器\n\n\nDX\nData\n数据寄存器\n通用寄存器，一般用于存储数据，在双精度算术运算中，和AX配合使用存放双字操作数，DX是高位寄存器，AX是低位寄存器\n\n\n地址寄存器\n\n\n寄存器符号\n全称\n\n用途\n\n\n\nSI\nSource Index\n源变址寄存器\n可作为源变址寄存器使用，是存放源变址的寄存器\n\n\nDI\nDestination Index\n目的变址寄存器\n可用于存放目的缓冲区的偏移地址\n\n\nSP\nStack Pointer\n堆栈指针寄存器\n用于指出堆栈顶端的偏移地址\n\n\nBP\nBase Pointer\n基址指针寄存器\n用于指出堆栈区某个单元的偏移地址\n\n\n段寄存器\n\n\n寄存器符号\n全称\n\n用途\n\n\n\nCS\nCode Segment\n代码段寄存器\n用于指出代码段的偏移地址\n\n\nDS\nData Segment\n数据段寄存器\n用于指出数据段的偏移地址\n\n\nSS\nStack Segment\n堆栈段寄存器\n用于指出堆栈段的偏移地址\n\n\nES\nExtra Segment\n附加段寄存器\n用于指出附加段的偏移地址\n\n\n控制寄存器\n\n\n寄存器符号\n全称\n\n用途\n\n\n\nIP\nInstruction Pointer\n指令指针寄存器\n用于指出下一条指令的偏移地址\n\n\nFLAGS\nFLAGS\n标志寄存器\n用于存放各种标志位\n\n\n\n\n\n标志码\n标志\n含义\n条件\n\n\n\nCF\nCarry Flag\n进位标志\n当指令的执行结果的最高位向前进位时，CF=1，否则CF=0\n\n\nSF\nSign Flag\n符号标志\n当指令的执行结果的最高位（符号位）为负数时，SF=1，否则SF=0\n\n\nZF\nZero Flag\n零标志\n当指令的执行结果为0时，ZF=1，否则ZF=0\n\n\nOF\nOverflow Flag\n溢出标志\n当指令的执行结果有溢出时（超出了表示的范围），OF=1，否则OF=0\n\n\nDF\nDirection Flag\n方向标志\n执行串操作时，若设置DF=1，储存单元地址自动减小，若设置DF=0时，储存单元地址自动增大\n\n\nIF\nInterrupt Flag\n中断标志\nIF=1时，允许CPU响应可屏蔽中断，IF=0时，禁止CPU响应中断请求\n\n\nPF\nParity Flag\n奇偶标志\n当指令的执行结果的二进制数中1的个数为偶数时，PF=1，否则PF=0\n\n\nTF\nTrap Flag\n陷阱标志\nDebug时，若设置TF=1，执行单步调试指令，进入陷阱，TF=0时，正常执行指令\n\n\nAF\nAuxiliary Carry Flag\n辅助进位标志\n当指令的执行结果的第三位（半字节）向前进位时，AF=1，否则AF=0\n\n\n8086标志位缩写形式\n\n\n\n标志名称\n标志\n值为1\n值为0\n\n\n\n进位标志\nCF\nCY\nNC\n\n\n符号标志\nSF\nNG\nPL\n\n\n零标志\nZF\nZR\nNZ\n\n\n溢出标志\nOF\nOV\nNV\n\n\n方向标志\nDF\nDN\nUP\n\n\n中断标志\nIF\nEI\nDI\n\n\n奇偶标志\nPF\nPE\nPO\n\n\n辅助进位标志\nAF\nAC\nNA\n\n\n指令分类DOS功能调用DOS功能调用采用中断指令INT 21H，功能号存放在AH寄存器，在其他的寄存器和存储单元中提供必须得参数和缓冲区地址，执行后系统在AL中放入返回参数。通常的DOS功能有5个：\n\n\n\n功能号\n功能\n说明\n示例\n\n\n\n1H\n键盘输入一个字符\n将键盘输入的字符放入AL中\nMOV AH,1HINT 21H\n\n\n8H\n键盘输入但不显示\n将键盘输入的字符放入AL中，不反映到在屏幕上\nMOV AH,8HINT 21H\n\n\n2H\n显示一个字符\n将DL中的字符显示在屏幕上，并且将AL的值改为DL的值\nMOV AH,2HINT 21H\n\n\n5H\n打印输出一个字符\n将DL中的字符发送到打印机，并且将AL的值改为DL的值\nMOV AH,5HINT 21H\n\n\n9H\n显示字符串\n将DS:DX中的字符串显示在屏幕上，AL的值被修改为24H\nMOV AH,9HLEA DX,STRINT 21H\n\n\n0AH\n键盘输入一个字符串\n将键盘输入的字符串放入DS:DX中\nMOV AH,0AHLEA DX,BUFFINT 21H\n\n\n4CH\n结束程序\n结束程序\nMOV AH,4CHINT 21H\n\n\n数据传送指令\n\n\n指令\n格式\n作用\n说明\n举例\n注意\n\n\n\n传输指令\nMOV DST,SRC\n(DST)←(SRC)\n将源操作数转移到目的操作数\nMOV AX, BX\n1.操作数类型要匹配2.目的操作数不能是立即数3.两个操作数不能同时是储存单元4.目的操作数属性要确定5.CS段寄存器不能作为目的操作数6.段寄存器不能用立即数赋值\n\n\n数据交换指令\nXCHG OPR1,OPR2\n(OPR1)↔(OPR2)\n将两个操作数互换\nXCHG AX, BX\n1.操作数类型要匹配2.两个操作数必须有一个是寄存器3.操作数不能是立即数\n\n\n进栈指令\nPUSH SRC\n((SP+1),(SP))←(SRC)\n先将堆栈指针减2，再将操作数SRC入栈\nPUSH AX\nSRC必须是字\n\n\n出栈指令\nPOP DST\n(DST)←((SP+1),(SP))\n将栈顶指针所指向的字单元的内容弹出到操作数DST中，再将SP加2\nPOP AX\n\n\n\n查表转换指令\nXLAT\nAL←(DS:BX+AL)\n将DS:BX+AL的内容送入AL,即把AL中位移量换成对应内容\nXLAT\n\n\n\n有效地址传送指令\nLEA 寄存器,储存单元\n寄存器←储存单元\n将储存单元的有效地址传送给寄存器\nLEA BX TABLE\n\n\n\n数据段地址传送指令\nLDS 寄存器,双字储存单元\nDS:寄存器←储存单元\n将双字单元的低字送入寄存器，高字传送给DS数据段寄存器\nLDS BX TABLE\n\n\n\n附加段地址传送指令\nLES 寄存器,双字储存单元\nES:寄存器←储存单元有效地址\n将双字单元的低字送入寄存器，高字传送给ES附加段寄存器\nLES BX TABLE\n\n\n\n字节拓展为字指令\nCBW\nAX←sign-extend(AL)\n将AL拓展到AX。如果AL的符号位为0，则AH为0，如果AL的符号位为1，则AH为FFH\nCBW\n\n\n\n字拓展为双字指令\nCWD\nDX:AX←sign-extend(AX)\n将AX拓展到DX。如果AX的符号位为0，则DX为0，如果AX的符号位为1，则DX为FFFFH\nCWD\n\n\n\n算术运算指令\n\n\n指令\n格式\n作用\n说明\n举例\n注意\n\n\n\n加法指令\nADD DST,SRC\n(DST)←(DST)+(SRC)\nSRC和DST相加，结果放入DST\nADD AX, BX\n\n\n\n带进位加法指令\nADC DST,SRC\n(DST)←(DST)+(SRC)+CF\n将SRC加到DST再加上进位标志CF，结果放入DST\nADC AX, BX\n一般用在双精度加法中，当低字相加后，两个高字相加时要考虑来自低字的进位\n\n\n加1指令\nINC OPR\n(OPR)←(OPR)+1\n将OPR加1，结果放入OPR\nINC AX\n\n\n\n减法指令\nSUB DST,SRC\n(DST)←(DST)-(SRC)\nSRC减去DST，结果放入DST\nSUB AX, BX\n\n\n\n带借位减法指令\nSBB DST,SRC\n(DST)←(DST)-(SRC)-CF\n将DST减去SRC再减去借位标志CF，结果放入DST\nSBB AX, BX\n一般用在双精度减法中，当低字相减后，两个高字相减时要考虑来自低字的借位\n\n\n减1指令\nDEC OPR\n(OPR)←(OPR)-1\n将OPR减1，结果放入OPR\nDEC AX\n\n\n\n求补指令\nNEG OPR\n(OPR)←0-(OPR)\n将OPR求补，结果放入OPR\nNEG AX\n\n\n\n比较指令\nCMP OPR1，OPR2\n(OPR1)-(OPR2)\n将OPR1减去OPR2，但不保存结果,改变标志位\nCMP AX, BX\n一般用于比较两个操作数的大小，不改变操作数的值\n\n\n无符号数乘法指令\nMUL SRC\nDX:AX←(AX) * (SRC)\n将AX乘以SRC（字），结果放入AX和DX\nMUL AX\n字节乘法是将AL乘以SRC（字节），结果放入AX\n\n\n带符号数乘法指令\nIMUL SRC\nDX:AX←(AX) * (SRC)\n将AX乘以SRC（字），结果放入AX和DX\nIMUL AX\n字节乘法是将AL乘以SRC（字节），结果放入AX\n\n\n无符号数除法指令\nDIV SRC\nAX←(DX:AX)/(SRC),DX←(DX:AX)%(SRC)\n将DX:AX除以SRC（字），结果放入AX，余数放入DX\nDIV AX\n字节除法是将AX除以SRC（字节），结果放入AL，余数放入AH\n\n\n带符号数除法指令\nIDIV SRC\nAX←(DX:AX)/(SRC),DX←(DX:AX)%(SRC)\n将DX:AX除以SRC（字），结果放入AX，余数放入DX\nIDIV AX\n字节除法是将AX除以SRC（字节），结果放入AL，余数放入AH\n\n\n压缩的BCD码加法调整\nDAA\n如果AL的低4位大于9，则将AL加6，并将AF置1，如果AL的高4位大于9（或等于9时AF为1），则将AL加60H，并将CF置1\n\nDAA\n\n\n\n压缩的BCD码减法调整\nDAS\n如果AF为1（AC），则将AL减6,AF置1。如果AL的高4位大于9，将AL减60H，并将CF置1\n\nDAS\n\n\n\n非压缩的BCD码加法调整\nAAA\n如果AL的低4位大于9，则将AL加6，AH加1，AL的高4位置0，CF和AF置1\n\nAAA\n\n\n\n非压缩的BCD码减法调整\nAAS\n如果AF为1（AC），则将AL减6，AH减1，AL高4位置0，CF置1\n\nAAS\n\n\n\n非压缩的BCD码乘法调整\nAAM\nAL除以0AH，得到的商送往AH，余数送往AL\n将乘积调整为两个非压缩的BCD码。\nAAM\n\n\n\n非压缩的BCD码除法调整\nAAD\nAL+AH×0AH，结果送往AL，AH清零\n在做除法之前，将被除数AX中的两个非压缩的BCD码调整为二进制数\nAAD\n\n\n\n算数左移\nSAL OPR,CNT\n(OPR)←(OPR)×2^(CNT)\n将OPR左移CNT位，结果放入OPR\nSAL AX, 1\n超过1位必须用CL寄存器指出位移位数\n\n\n算数右移\nSAR OPR,CNT\n(OPR)←(OPR)/2^(CNT)\n将OPR右移CNT位，结果放入OPR\nSAR AX, 1\n超过1位必须用CL寄存器指出位移位数\n\n\n循环左移\nROL OPR,CNT\n\nOPR左移，最高位进CF同时进最低位\nROL AX, 1\n超过1位必须用CL寄存器指出位移位数\n\n\n循环右移\nROR OPR,CNT\n\nOPR右移，最低位进CF同时进最高位\nROR AX, 1\n超过1位必须用CL寄存器指出位移位数\n\n\n带进位循环左移\nRCL OPR,CNT\n\nOPR左移，CF移入最低位，最高位进CF\nRCL AX, 1\n超过1位必须用CL寄存器指出位移位数\n\n\n带进位循环右移\nRCR OPR,CNT\n\nOPR右移，CF移入最高位，最低位进CF\nRCR AX, 1\n超过1位必须用CL寄存器指出位移位数\n\n\n逻辑运算指令\n\n\n指令\n格式\n作用\n说明\n举例\n注意\n\n\n\n逻辑与\nAND DST,SRC\n(DST)←(DST) AND (SRC)\nSRC和DST进行逻辑与，结果放入DST\nAND AX, BX\n自身相与结果不变但是改变标志位\n\n\n逻辑或\nOR DST,SRC\n(DST)←(DST) OR (SRC)\nSRC和DST进行逻辑或，结果放入DST\nOR AX, BX\n\n\n\n逻辑非\nNOT OPR\n(OPR)←NOT (OPR)\n将OPR求逻辑非，结果放入OPR\nNOT AX\n\n\n\n逻辑异或\nXOR DST,SRC\n(DST)←(DST) XOR (SRC)\nSRC和DST进行逻辑异或，结果放入DST\nXOR AX, BX\n\n\n\n测试指令\nTEST DST,SRC\n(DST) AND (SRC)\nSRC和DST进行逻辑与，结果不放入DST，只改变标志位\nTEST AX, BX\n\n\n\n逻辑左移\nSHL OPR,CNT\n(OPR)←(OPR)×2^(CNT)\n将OPR左移CNT位，结果放入OPR\nSHL AX, 1\n超过1位必须用CL寄存器指出位移位数\n\n\n逻辑右移\nSHR OPR,CNT\n(OPR)←(OPR)/2^(CNT)\n将OPR右移CNT位，结果放入OPR\nSHR AX, 1\n超过1位必须用CL寄存器指出位移位数\n\n\n串操作指令\n\n\n串处理指令\n格式\n作用\n说明\n举例\n\n\n\n串传送\nMOVS/MOVSB/MOVSW DST,SRC\nREP连用，以字或字节的形式重复传送，直到CX=0为止,源串偏移地址由SI指出，目的串的偏移地址由DI指出，传送次数由CX指出\n第一种格式的双操作数要显式地指出源和目的操作数的地址属性；后两种格式隐式地指出源和目的串的地址和属性，即指令中没有操作数只有操作码\nREP MOVS BYTE PTR ES:[SI],DS:[DI]REP MOVSB\n\n\n串比较\nCMPS/CMPSB/CMPSW DST,SRC\n和REPZ等指令连用，以字或字节的形式重复比较，直到CX=0为止，并改变标志位,源串偏移地址由SI指出，目的串的偏移地址由DI指出，比较次数由CX指出\n第一种格式的双操作数要显式地指出源和目的操作数的地址属性；后两种格式隐式地指出源和目的串的地址和属性，即指令中没有操作数只有操作码\nREPNE CMPSW\n\n\n串扫描\nSCAS/SCASB/SCASW DST\n和REPZ等指令连用，在目的串中查找与AL或AX相等的字或字节，直到CX=0为止，并改变标志位,目的串在附加段中，偏移地址由DI指出，扫描次数由CX指出\n第一种格式的单操作数要显式地指出目的操作数的地址和属性；后两种格式隐式地指出目的串的地址和属性，即指令中没有操作数只有操作码\nREPNZ SCASB\n\n\n串获取\nLODS/LODSB/LODSW SRC\n从源串中取出一个字或字节放入AL或AX中,源串在数据段定义，源串偏移地址由SI指出。如果与REP连用则直到CX=0为止，取出次数由CX指出\n第一种格式的单操作数要显式地指出源操作数的地址和属性；后两种格式隐式地指出源串的地址和属性，即指令中没有操作数只有操作码\nREP LODSW\n\n\n串存入\nSTOS/STOSB/STOSW DST\n将AL或AX中的字或字节存入目的串中,目的串在附加段定义，目的串偏移地址由DI指出。如果与REP连用则直到CX=0为止，存入次数由CX指出\n第一种格式的单操作数要显式地指出目的操作数的地址和属性；后两种格式隐式地指出目的串的地址和属性，即指令中没有操作数只有操作码\nREP STOSB\n\n\n控制与转移指令\n\n\n无条件转移指令\n用法\n说明\n举例\n\n\n\n段内直接短转移\nJMP SHORT OPR\n(IP)←(IP)+8位位移量OPR\nJMP SHORT HELLO\n\n\n段内直接近转移\nJMP NEAR OPR\n(IP)←(IP)+16位偏移量OPR\nJMP NEAR HELLO\n\n\n段内间接转移\nJMP WORD PTR OPR\n(IP)←(EA)\nJMP WORD PTR [BX+SI]\n\n\n段间直接转移\nJMP FAR OPR\n(CS):(IP)←(OPR)\nJMP FAR PTR HELLO\n\n\n段间间接转移\nJMP DWORD PTR OPR\n(IP)←(EA),(CS)←(EA+2)\nJMP DWORD PTR [BX]\n\n\n\n\n\n条件标志转移指令\n转移条件\n说明\n\n\n\nJZ/JE\nZF=1\n结果为0则转移\n\n\nJNZ/JNE\nZF=0\n结果不为0则转移\n\n\nJC\nCF=1\n进位标志为1则转移\n\n\nJNC\nCF=0\n进位标志为0则转移\n\n\nJS\nSF=1\n符号标志为1则转移\n\n\nJNS\nSF=0\n符号标志为0则转移\n\n\nJO\nOF=1\n溢出标志为1则转移\n\n\nJNO\nOF=0\n溢出标志为0则转移\n\n\nJP\nPF=1\n奇偶标志为1则转移\n\n\nJNP\nPF=0\n奇偶标志为0则转移\n\n\n\n\n\n无符号数比较转移指令\n转移条件\n说明\n\n\n\nJB/JNAE\nCF=1 AND ZF=0\n小于则转移\n\n\nJBE/JNA\nCF=1 OR ZF=1\n小于等于则转移\n\n\nJA/JNBE\nCF=0 AND ZF=0\n大于则转移\n\n\nJAE/JNB\nCF=0 OR ZF=1\n大于等于则转移\n\n\n\n\n\n带符号数比较转移指令\n转移条件\n说明\n\n\n\nJL/JNGE\nSF≠OF AND ZF=0\n小于则转移\n\n\nJLE/JNG\nZF=1 OR SF≠OF\n小于等于则转移\n\n\nJG/JNLE\nZF=0 AND SF=OF\n大于则转移\n\n\nJGE/JNL\nSF=OF OR ZF=1\n大于等于则转移\n\n\n\n\n\nCX转移\n转移条件\n说明\n\n\n\nJCSZ\nCX=0\nCX为0则转移\n\n\n\n\n\n循环指令\n格式\n作用\n举例\n\n\n\n循环\nLOOP OPR\n(CX)←(CX)-1,若CX≠0，跳转到标号OPR处循环执行，若CX=0，退出循环并执行LOOP的下一条指令\nLOOP SS1\n\n\n循环\nLOOPZ/LOOPE OPR\n(CX)←(CX)-1,若CX≠0且ZF=1，跳转到标号OPR处循环执行，若CX=0或ZF=0，则执行LOOPZ的下一条指令\nLOOPZ SS1\n\n\n循环\nLOOPNZ/LOOPNE OPR\n(CX)←(CX)-1,若CX≠0且ZF=0，跳转到标号OPR处循环执行，若CX=0或ZF=1，则执行LOOPNZ的下一条指令\nLOOPNZ SS1\n\n\n处理机控制指令\n\n\n指令\n作用\n说明\n\n\n\nCLC\nCF=0\n清除进位标志\n\n\nSTC\nCF=1\n设置进位标志\n\n\nCMC\nCF=NOT CF\n进位标志取反\n\n\nCLD\nDF=0\n清除方向标志\n\n\nSTD\nDF=1\n设置方向标志\n\n\nCLI\nIF=0\n清除中断标志\n\n\nSTI\nIF=1\n设置中断标志\n\n\nHLT\n停机\n停机\n\n\nNOP\n无操作\n占3个时钟周期\n\n\n","slug":"8086微机汇编语言","date":"2023-04-16T10:25:35.000Z","categories_index":"汇编","tags_index":"汇编","author_index":"Ac-Accelerator"},{"id":"77e095561161043d7bcb5f0fd932479f","title":"数据库系统原理（二）","content":"数据的定义与操作SQL概述关系数据库的标准语言是 Structured Query Language，全称的翻译成中文就是结构化查询语言，简称SQL。虽然SQL字面含义是“查询语言”，但是其功能却包括了数据定义、数据查询、数据修改和保护等许多内容。伴随着数据库技术的发展和应用，国际标准化组织先后发布了SQL语言的多个版本的标准。实际中，各种不同数据库管理系统 在SQL语言的实现上存在一些小的差异。\nSQL语言的核心是SELECT语句，基本Select语句的一般形式中，第一个子句是SELECT，SELECT后面是ALL或者DISTINCT，或ALL和DISTINCT两个都不出现的默认的声明，再后面是一个或多个&lt;目标列表达式&gt;，每个&lt; 目标列表达式 &gt;还可以起个[ 别名 ]跟在后面；第二个子句是FROM FROM后面可以是一个&lt; 表名 &gt;或者是一个[&lt; 连接表达式 &gt;]；第三个子句是WHERE，WHERE后面是一个&lt; 条件表达式 &gt;；第四个子句是GROUP BY，GROUP BY后面是一个或多个 &lt; 列名 &gt; ；第五个子句是HAVING，HAVING后面是一个&lt; 条件表达式 &gt;；第六个子句是ORDER BY，ORDER BY后面是一个或多个 &lt; 列名 &gt; 以及相应的ASC或DESC，或两者都不出现的默认声明。ASC表示按升序排列，DESC表示按降序排列。如果指定了多个排序列，那么仅在前面的表达式排序相等的情况下，才使用后面的表达式做进一步排序；第七个子句是LIMIT，后面是一个表示输出行数的数值，再后面是offset 后面跟一个表示偏移量的数值，这就是基本Select语句的一般形式。\nsqlSELECT [ALL|DISTINCT]\n    &lt;目标列表达式&gt; [别名][,&lt;目标列表达式&gt; [别名]]...\n[FROM &lt;表名&gt;[别名] [&lt;连接表达式&gt;]...]\n[WHERE &lt;条件表达式&gt;]\n[GROUP BY &lt;列名&gt; [&lt;列名&gt;]\n[HAVING &lt;条件表达式&gt;]]\n[ORDER BY &lt;列名&gt; [ASC|DESC] [&lt;列名&gt; [ASC|DESC]]\n[LIMIT &lt;行数&gt; [&lt;OFFSET偏移量&gt;]]];整个语句的执行过程:（在实际执行时数据库管理系统会为了尽可能快地获得等价查询结果而采取完全不同的执行步骤）\n\n如果仅有SELECT子句，按SELECT子句中给出的列名或列表达式求值，否则继续执行(2) ;\nFROM: 从FROM子句获得表;\n取满足WHERE子句所给出条件表达式的行;\n按GROUP BY子句中指定列的值分组;\n提取满足HAVING子句中组条件表达式的那些组;\n按SELECT子句中给出的列名或列表达式求值;\nORDER BY子句对输出的目标表进行排序，ASC:升序，DESC:降序;\n按照LIMIT子句的偏移量和行数确定输出元组;\n\nWHERE与HAVING的区别：WHERE子句是作用于FROM子句中关系的属性上的谓词，从FROM子句结果关系中选择满足条件的行，WHERE子句必须跟在FROM子句后面，没FROM子句就不能有WHERE子句;HAVING子句作用于GROUP BY子句的结果组，从中选择满足条件的组，HAVING子句必须跟在GROUP BY子句后面，没有GROUP BY子句就不能有HAVING子句。\nSQL语言是大小写不敏感的，PG建议SQL的保留字用大写 表名，字段名等所有数据库对象名全部使用小写，除非从定义到使用始终都加双引号，否则系统把所有对象名自动转化为小写，PG用单引号做字符串常量的标识，只有引号里面的字符才区分大小写。\n数据的定义以及修改表的定义包括表模式的创建、修改和删除\n数据修改包括给表里添加数据、更新数据以及删除数据\n创建表：\nsqlCREATE TABLE&lt;表名&gt;\n  (&lt;列名&gt;&lt;数据类型&gt;,\n  &lt;列名&gt;&lt;数据类型&gt;,\n  ...\n  );可以看到表的每个列都要指定数据类型，具体数据类型查看此表\n更改表的名字：\nsqlALTER TABLE &lt;表名&gt; RENAME TO &lt;新表名&gt;;删除表：\nsqlDROP TABLE &lt;表名&gt;修改表：\nsqlALTER TABLE&lt;表名&gt;\n[ADD COLUMN &lt;新列名&gt; &lt;数据类型&gt;]\n[ADD [完整性约束(&lt;列名&gt;)] ]\n[RENAME COLUMN &lt;旧列名&gt; TO &lt;新列名&gt;]\n[ALTER COLUMN &lt;列名&gt; TYPE &lt;数据类型&gt;]\n[DROP COLUMN &lt;列名&gt;];插入元组：插入元组的分量个数必须是正确的，插入元组的属性值必须在属性域中，元组值对应的属性排列顺序必须与定义时的顺序一致，否则必须在INSERT语句中明确指明属性顺序。在插入的常量元组中非主键属性可以使用空值null。\nsqlINSERT INTO &lt;表名&gt; [(&lt;属性1&gt;[,&lt;属性2&gt;,...])]VALUES (&lt;常量1&gt;[,&lt;常量2&gt;]... )插入查询结果：\nsqlINSERT INTO &lt;表名&gt; [(&lt;列名序列&gt;)]\n&lt;SELECT查询语句&gt;插入表：\nsqlINSERT INTO &lt;表名1&gt; [(&lt;列名序列&gt;)]\nTABLE &lt;表名2&gt;删除元组：如果没有任何条件限制，将删除所有元组\nsqlDELETE FROM &lt;表名&gt; [WHERE &lt;条件表达式&gt;]更新表中元组的某些列值：如果没有任何条件限制，将更新所有元组\nsqlUPDATE &lt;表名&gt;\nSET &lt;列名&gt;=&lt;表达式&gt;[,&lt;列名&gt;=&lt;表达式&gt;]...\n[WHERE &lt;条件&gt;]简单查询单表查询：包括投影、选择和聚集查询。\n投影查询包括基本投影和广义投影，基本投影是指选取表中的某些列的列值；广义投影是指在选取属性列时，允许进行一些适当的运算。例如，从student表中查找全部的学生id以及学生名字，输出每一行的id以及stu_name：\nsqlSELECT id , stu_name\nFROM student一般可以用*号代表全部列。\nsqlSELECT *\nFROM student广义投影（SELECT后面跟表达式）：查询所有id以及与100分的差值\nsqlSELECT id,100-grade\nFROM student用ORDER BY对结果进行排序，查询全体学生，按成绩升序，按年龄降序。\nsqlSELECT *\nFROM student\nORDER BY grade ASC,age DESC投影结果中可能出现所有列值均相等的重复行，但从数据库管理系统实现的角度看，投影过程会对每个新产生的结果行进行标识，即系统能区分每个行，也就是说，由于去重是一项耗时的工作，DBMS采取惰性原则:除非在SELECT后跟DISTINCT明确指出要求去重，否则，默认情况下、或者SELECT后跟ALL时都保留重复。\n选择查询：选择所有年龄大于20的学生的行\nsqlSELECT *\nFROM student\nWHERE age&gt;20;数据库用于选择查询的的关系运算符：\n聚集查询：从多个输入行中计算出一个结果。如sum等。还可以使用GROUP BY使得所有给出列上取值相同的行被分在一个组，将聚集函数作用在组上。\nsqlSELECT department, AVG(age) AS avgage\nFROM student\nGROUP BY department\nORDER BY avgage;这里AS的意思是给AVG(age)起了个avgage别名。还可以使用HAVING对分组进行筛选，HAVING子句给出的条件只针对GROUP BY子句形成的分组起作用，也可以使用聚集函数。\n联接查询如果查询的数据涉及两个或多个表，可以使用联接操作，称为联接查询。\n联接条件决定了两个表中哪些行是匹配的，以联接结果中出现哪些列\n联接类型是按照对悬浮行的不同处理方式来分的，即内联接，左外联接，右外联接，全外联接。\n在写多表联接查询语句的时候，如果查询涉及多个表，最简单直接的方法就是在FROM后面依次写上这些表名，并以逗号或CROSS JOIN分隔。FROM子句的结果表就是这些表的笛卡尔积，结果表包含所有这些表的所有列。如果两个表中有同名列，在列名前加上表名作前缀，表明该列的来源表。根据查询需要，还可通过WHERE子句对笛卡尔积结果表施加选择操作，以撷取那些符合查询条件的行。\n如果是自然联接，则用NATURAL JOIN来分割表名。\n如果是属性联接，用到的是JOIN USING语法\nsqlSELECT *\nFROM math_exam JOIN english_exam USING(id);如果是条件联接，用到的是JOIN ON语法\nsqlSELECT *\nFROM math_exam JOIN english_exam ON math_exam.id=english_exam.id;内联接用INNER而外联接用OUTER默认为INNERLEFT、RIGHT、FULL均隐含外联接  \n嵌套查询一个SELECT-FROM-WHERE语句称为一个查询块，将一个查询块嵌套在另一个查询块的SELECT FROM、WHERE、GROUP BY、HAVING、ORDER BY、LIMIT、OFFSET或WITH子句中的查询称为嵌套查询。\n表式嵌套：嵌套查询的结果是一个表，可以在外层查询中使用。\nsqlWITH avgach(eeid,avgachieve)AS(\n  SELECT eeid,AVG(achieve)FROM eeexam\n  GROUP BY eeid\n  )\nSELECT COUNT(*)\nFROM avgach\nWHERE avgachieve&gt;=80;sqlSELECT COUNT(*)\nFROM ( SELECT eeid,avg(achieve)\n  FROM eeexam\n  GROUP BY eeid\n  )AS avgach (eeid,avgachieve)\nWHERE avgachieve&gt;=80;\n注意：WITH子句只在包含它自己的查询语句中有效,WITH子句中的AS不能省略。\n\n\n\n\n\n\n\n\n\n相关嵌套查询：嵌套查询的结果是一个表，可以在外层查询中使用。外层查询中的表达式中包含内层查询的结果。\n集合嵌套：嵌套查询的结果是一个集合，可以在外层查询中使用。\nsqlSELECT eid,ename\nFROM exampaper\nWHERE eid IN\n  (SELECT eid\n  FROM eeexam\n  WHERE eeid='218811011013');sqlSELECT *\nFROM examinee\nWHERE EXISTS\n  (SELECT*\n  FROM eeexam\n  WHERE eeid=examinee.eeid AND eid= '0205000002');\n\n\n\n\n\n\n\n\n不相关嵌套查询：嵌套查询的结果是一个集合，可以在外层查询中使用。外层查询中的表达式中不包含内层查询的结果。\n标量式嵌套：嵌套查询的结果是一个标量，可以在外层查询中使用。\nsqlSELECT dname,\n  (SELECT COUNT(*)\n  FROM examiner\n  WHERE examiner.erdepa=department.dname)\nFROM department;sqlSELECT eeid，eename\nFROM examineeWHERE eedepa =\n  (SELECT eedepa\n  FROM examinee\n  WHERE eeid='218811011028');sqlSELECT (\n  SELECT eedepa\n  FROM examinee\n  WHERE eeexam.eeid=examinee.eeid) ,\n  avg(achieve)\nFROM eeexam\nGROUP BY(\n  SELECT eedepa\n  FROM examinee\n  WHERE eeexam.eeid=examinee.eeid);\n\n\n\n\n\n\n\n\n查询块可以出现在任何表名可以出现的地方，也可以出现在集合可以出现的地方，如果能确定查询块只返回单行单列的单个值，查询块可以出现在单个属性名、单个表达式、单个常量 可以出现的地方。\n","slug":"数据库系统原理（二）","date":"2023-03-29T08:37:00.000Z","categories_index":"数据库","tags_index":"数据库,学习笔记","author_index":"Ac-Accelerator"},{"id":"13bf866f8a267e47702ed2383b6aca22","title":"数据库系统原理（一）","content":"绪论数据库是什么广义定义：指包含关于某单位、机构、部门，或是某领域、业务主题，或是某对象的信息、互相关联的大量数据的集合。\n狭义定义：特指用专门通用软件管理，长期储存在计算机内、有组织、可共享的大量数据的集合。\n数据库管理系统定义：英语是 Database Management System ，缩写为DBMS.DBMS是位于用户与操作系统之间的一层软件，它是一个大型的复杂的系统软件。领先的著名数据库管理系统DBMS有PostgreSQL、IBM DB2、Oracle、Microsoft SQL Server等。\n模式和实例：数据库模式相对稳定，很少需要修改。实例是其对应模式的一个具体值，反映的是某一时刻数据库的状态。同一个模式可以有很多实例，实例的值随数据库中数据的更新而不断变化。\n基本功能：数据库管理系统最基本的功能就是允许用户逻辑地使用数据而无需关注这些数据在计算机中是如何存放如何处理的。\n数据抽象的层次对现实世界事物的状态进行选择、加工、组织，形成人对全部用户数据需求在大脑当中的认识，就是概念层。概念层数据模型通常使用实体-联系模型（E-R模型），一般用E-R图来表示。\n又数据库管理系统提供，通过便于人理解的相对简单的结构来描述数据库当中存储的数据以及这些数据之间存在的联系，这是逻辑层，逻辑层描述全部用户数据的整体结构。\n数据库一般有多个用户，一个用户不一定要使用所有数据，视图层从某个或某类用户角度出发，只描述与其相关的那一部分数据。\n物理层描述数据实际上是怎样在磁盘设备上组织的，典型的物理层数据模型是B+树\n\n\n\n逻辑层的数据模式也称为模式。视图层的数据模式也称为外模式。物理层的数据模式也称为内模式。\n有了外模式后，应用程序员不必关心逻辑模式。只与外模式发生联系。\n逻辑独立性：当模式改变时，由数据库管理员DBA对各外模式/模式映射作相应的改变，外模式保持不变。应用程序完全无需修改。\n物理独立性：如果数据库的内模式改变，只要对模式/内模式映射作相应的修改，可以使模式保持不变。外模式无需修改。\n三层模式两级映射：数据库管理系统的三层模式及两级映射，既为简单、安全地共享数据提供支持，又为应用系统易于扩展来适应应用需求的变化奠定了基础。\nSQL语言SQL包括数据定义、数据操作和数据保护三个部分\nSQL语言非常接近自然语言，易学易用。\n\n\n用户查询时，经由外模式-模式的映射转换到模式上的操作，然后在统计数据的帮助下找出尽可能好的执行计划，最后翻译成存储管理模块能够执行的形式，存储管理模块利用数据字典、数据索引，从磁盘上取到查询的目标数据。以上两个模块总是在保护管理模块下运行。保护管理模块负责检查用户权限，数据合法性。并以一种称为“事务”的方式在日志信息的帮助下维护多用户并发访问以及故障情况下的数据一致性\n数据库管理技术发展趋势关系数据库：关系数据库管理系统针对简单、高效和安全地共享数据这个中心目标已经发展出诸多极具特色的关键技术。\n关系数据库管理系统使用非常简单的关系模型，使得数据库设计和访问都像面对的是日常生活中广泛使用的最简单形式的表格。\n独立性、安全性、共享性是数据库中数据的特征。\n\n\n允许事务并发执行虽能带来性能上的好处，但需要对并发进行管控以保证数据完整性。\n并发控制机制保证并发情况下的数据完整性。恢复机制能保障故障情况下的数据完整性。\n随着大数据现象的出现，数据管理技术正面临基础架构变化带来的深刻变革。NoSQL系统利用计算机集群这种新架构来存储和处理大数据。当前的NoSQL系统强调可扩展性和高性能。在这种形势下，传统关系型数据库面临着巨大的挑战。\n关系模型关系结构和约束关系表：关系数据库使用一个或多个表来存储数据。数学上把一系列域上的笛卡尔积的子集称为关系。\n每个表有多个行，每个行有多个列，每个行列单元都是不能再分的原子值，同一表中各行相异，不允许重复出现完全相同的行。同一表中的行次序、列次序均无关紧要。考虑到表的实际应用，数据库中通常给每个列指定一个唯一的名字，也称作属性或字段。每个属性有一个允许值的集合，称为该属性的域或取值范围。给定一个关系表，习惯上把关系模式写成表名后面跟一对圆括号，里面罗列出一个个列名，例如：stu_info=(id,name,sex,class)。\n数据库保存现实世界的状态，并服务现实世界的应用，数据库中的数据应该与现实世界时时保持一致才有意义。理想情况下，系统能够判断数据库中的各个数据项值是否与现实世界一致，也就是数据是不是真实正确。然而，这个目标是没有办法实现的。退而求其次，可以在系统中定义一些正确数据应该满足的约束，系统自动检查数据库中的数据是否满足这些约束条件，并且只允许满足这些约束条件的数据进入数据库。也就是说，软件系统无法保证数据的真实正确性，可以保证数据符合可明确定义的约束。这种约束通常称为完整性约束，它是数据安全性的一部分。\n常见的简单约束有两种形式，一种是对属性取值范围的限定，比如性别只有男、女两种取值；另一种是对属性值之间相互关系的限定，最典型的就是关系模型里面键的概念，包括：超键、候选键、主键、外键。\n超键：在给定关系模式中，能唯一标识出各个元组的属性集合，被称为该关系模式的超键。超键中可能包含无关紧要的属性，也就是说超键的真子集也可能是超键。比如：(id)是stu_info的一个超键，(id,name)、(id,name,sex)、(id,name,sex,class)也都是stu_info的超键。\n候选键：在给定关系模式中，能够唯一标识出各个元组的属性集合，并且不含多余属性，就称这个属性集合是该关系模式的候选键。从概念我们可以看到说候选键是超键，但超键不一定是候选键，只有其任何真子集都不是超键的超键才是候选键。比如stu_info只有一个候选键，即(id)。\n主键：一个关系当中可能有多个候选键，通常指定其中一个，并且只一个，用来标识元组，就把这个候选键称为主键。由于主键具有唯一性，所以主键是候选键，但候选键不一定是主键。\n外键：如果关系表S1的一个属性子集A，必须匹配另外一个关系表S2中出现的数值，我们就把A称为是关系表S1的外键。其中，S1称为引用关系，S2称为被引用关系。外键的值，或与被引用关系中出现的数值对应，或者为空值。\n基本关系代数运算可以用代数、逻辑等方法描述关系操作，最基本最常用的是代数方法，也就是关系代数。\n通常，通常一门代数总是包括一些运算符和一些运算数，关系代数也是一门代数，关系代数包括一个运算集合，这些运算以一个或两个关系作为运算数，产生一个新的关系作为结果。\n关系运算的运算参数是关系，运算结果也是关系，这样，一个关系运算的结果可以作为另一个关系运算的参数，从而可以把多个关系代数运算组合在一起，形成复杂的关系代数表达式。\n\n\n关系代数运算分基本关系代数运算、附加关系代数运算和扩展关系代数运算。其中基本关系代数运算包括选择、投影 并、差、笛卡尔积以及更名运算。\n选择运算是选出满足给定谓词(条件)的元组，结果关系和原关系有着相同的模式。选择运算用希腊字母σ来表示，将谓词写作σ的右下标，并在σ后面的括号中给出作为参数的关系名。\n男\n投影运算用来从给定关系产生一个只有其部分列的新关系。投影运算用希腊字母 π 表示，所有希望在结果关系中出现的属性作为 π 的右下标，而作为参数的关系名紧跟在 π 后的括号中。结果关系的模式是 π 的下标中所有列出的所有属性，并按 π 下标中列出的顺序出现。需要注意的是，由于关系代数把表看作元组集合，既然是集合，就不包括重复元组。\n\n关系并运算：参与运算的关系必须是相容的。即两个关系必须是同元的，两个关系对应属性的域必须相同或者相容。\n关系差运算：是用来查询在一个关系中 而不在另一个关系中的那些元组 和并运算一样，差运算只能在相容的关系间进行。\n关系的笛卡尔积运算：结果关系的模式是参与运算的两个关系的模式的串接，在属性名称前加上来自的关系名，中间用小数点分隔。但对那些只在两个关系模式之一中出现的属性一般省略其关系名前缀，运算符左侧关系中的每一个元组与右侧关系的每一个元组拼接，形成结果关系中的一个元组。\n更名：更改关系名字。\n\n附加关系代数运算集合交运算：集合交运算的结果是由那些同时在参与运算关系中存在的元组组成，集合交运算只能在相容的关系间进行。\n自然联接运算：首先计算笛卡尔积，然后在笛卡尔积的结果上，基于两个关系模式中都出现的属性，即两个关系模式的所有同名属性进行属性值相等的选择运算，最后去除重复列。\n\n属性联接运算：首先计算笛卡尔积，然后在笛卡尔积的结果上，基于两个关系模式中都出现的属性，即按指定同名属性进行属性值相等的选择运算，最后去除重复列。属性联接与自然联接的区别在于，当参与联接运算的两个表有多个同名列时，自然联接的匹配条件是所有同名列全部取值相等，而属性联接的匹配条件是指定其中若干同名列取值相等。如果属性联接指定全部同名列来匹配，则等价于自然联接。\n\n条件联接运算：首先计算笛卡尔积，然后在笛卡尔积的结果上，选取满足给定条件的元组。\n\n赋值运算：赋值运算是将一右侧的表达式的结果赋给一左侧的关系变量，该关系变量可以在后续的表达式中使用。\n男\n扩展关系代数运算除了基本关系代数运算、附加关系代数运算，为了表达用户其他方面的查询需求，需要对关系代数运算做进一步的扩充。关系代数运算的进一步扩充，通常主要包括以下三个方面：广义投影——允许将算术运算作为投影的一部分、聚集——例如计算给定集合元素的总和、平均值等、外联接——使得关系代数表达式能够处理缺失信息。\n广义投影：允许在投影列表中使用算术表达式。形式如下：E是任意关系代数表达式，而F1,F2,…Fn中的每一个都是涉及E的属性的算术表达式，也可以仅仅是个属性或常量。\n\n聚集函数:sum、avg、count、max和min等,还可以对关系中的元组按某一条件进行分组，并对每个分组使用聚集函数。分组条件写在左下标，聚集函数写在右下标。\n\n外联接：有些元组不能跟另外关系的任何一个元组匹配，一些实际应用系统可能希望在结果中保留悬浮元组，这就有了外联接运算。相对于外连接，不考虑悬浮元组的自然联接、属性联接和条件联接都称为内联接。\n外联接有三种形式：左外联接、右外联接、全外联接首先计算内联接，然后加入左侧关系、右侧关系、两侧关系中的悬浮元组。运算符分别是在内联接运算符号的右上角加上L,R,F。\n\n","slug":"数据库系统原理（一）","date":"2023-03-28T10:56:00.000Z","categories_index":"数据库","tags_index":"数据库,学习笔记","author_index":"Ac-Accelerator"},{"id":"29c0bb26f17c8d5598125731d7dbd2bf","title":"C++多线程","content":"这是观看一位大佬双笙子佯谬的视频后写的笔记。\n时间标准库chrono（C++11）std::chrono定义于头文件&lt;chrono&gt;\n利用 C++ 强类型的特点，明确区分时间点与时间段，明确区分不同的时间单位。时间点类型：chrono::steady_clock::time_point 等时间段类型：chrono::milliseconds，chrono::seconds，chrono::minutes 等方便的运算符重载：时间点+时间段=时间点，时间点-时间点=时间段auto t0 = chrono::steady_clock::now(); //获取当前时间点auto t1 = t0 + chrono::seconds(30);// 当前时间点的30秒后auto dt = t1 - t0;// 获取两个时间点的差（时间段）int64_t sec = chrono::duration_cast&lt;chrono::seconds&gt;(dt).count();// 时间差的秒数  \n计算花费的时间ms。\ncppint main()\n{\n    auto t0 = std::chrono::steady_clock::now();\n    for (volatile int i = 0; i &lt; 10000000; i++)\n        ;\n    auto t1 = std::chrono::steady_clock::now();\n    auto dt = t1 - t0;\n    int64_t ms = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(dt).count();\n    std::cout &lt;&lt; \"time elapsed: \" &lt;&lt; ms &lt;&lt; \" ms\" &lt;&lt; std::endl;\n    return 0;\n}duration_cast 可以在任意的 duration 类型之间转换duration&lt;T, R&gt; 表示用 T 类型表示，且时间单位是 RR 省略不写就是秒，std::milli 就是毫秒，std::micro 就是微秒seconds 是 duration&lt;int64_t&gt; 的类型别名milliseconds 是 duration&lt;int64_t, std::milli&gt; 的类型别名  \n下面这样可以输出小数单位的时间段。\ncppint main()\n{\n    auto t0 = std::chrono::steady_clock::now();\n    for (volatile int i = 0; i &lt; 10000000; i++)\n        ;\n    auto t1 = std::chrono::steady_clock::now();\n    auto dt = t1 - t0;\n    double ms = std::chrono::duration_cast&lt;std::chrono::duration&lt;double, std::milli&gt;&gt;(dt).count();\n    std::cout &lt;&lt; \"time elapsed: \" &lt;&lt; ms &lt;&lt; \" ms\" &lt;&lt; std::endl;\n    return 0;\n}sleepstd::this_thread::sleep_for可以让当前线程休眠一段时间，然后继续。而且单位也可以自己指定，比如这里是 milliseconds 表示毫秒，也可以换成 microseconds 表示微秒，seconds 表示秒，chrono 的强类型让单位选择更自由。\ncpp\nint main()\n{\n    std::this_thread::sleep_for(std::chrono::milliseconds(400));\n    return 0;\n}std::this_thread::sleep_until让当前线程休眠直到某个时间点。\ncpp#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;chrono&gt;\nint main()\n{\n    auto t = std::chrono::steady_clock::now() + std::chrono::milliseconds(400);\n    std::this_thread::sleep_until(t);\n    return 0;\n}线程std::thread定义于头文件&lt;thread&gt;\nC++11 开始，为多线程提供了语言级别的支持。std::thread 这个类来表示线程。std::thread构造函数的参数可以是任意可调用对象。当那个线程启动时，就会执行这个可调用对象的内容。用 std::thread 类的成员函数 join() 来等待该进程结束。  \n作为一个 C++ 类，std::thread 同样遵循 RAII 思想和三五法则：因为管理着资源，它自定义了解构函数，删除了拷贝构造/赋值函数，但是提供了移动构造/赋值函数。\ncppvoid download(std::string file)//模拟的一个下载过程\n{\n    for (int i = 0; i &lt; 10; i++)\n    {\n        std::cout &lt;&lt; \"Downloading \" &lt;&lt; file\n                  &lt;&lt; \" (\" &lt;&lt; i * 10 &lt;&lt; \"%)...\" &lt;&lt; std::endl;\n        std::this_thread::sleep_for(std::chrono::milliseconds(400));\n    }\n    std::cout &lt;&lt; \"Download complete: \" &lt;&lt; file &lt;&lt; std::endl;\n}\nvoid interact()//模拟与用户交互的函数\n{\n    std::string name;\n    std::cin &gt;&gt; name;\n    std::cout &lt;&lt; \"Hi, \" &lt;&lt; name &lt;&lt; std::endl;\n}\nint main()\n{\n    std::thread t1([&amp;]\n                   { download(\"hello.zip\"); });//构造函数，会执行这个 lambda 里的内容。\n    interact();\n    std::cout &lt;&lt; \"Waiting for child thread...\" &lt;&lt; std::endl;\n    t1.join();//使用join()来等待线程t1结束。如果没有这一步，随着interact的结束，父线程立刻退出，它的子线程t1也会随之销毁，download就无法完成了。\n    std::cout &lt;&lt; \"Child thread exited!\" &lt;&lt; std::endl;\n    return 0;\n}std::thread的析构函数会销毁线程，因此，当某个std::thread对象生命周期结束的时候，就会调用析构函数，这会销毁线程。\ncppvoid myfunc()\n{\n    std::thread t1([&amp;]\n                   { download(\"hello.zip\"); });\n    // 退出函数体时，会销毁 t1 线程的句柄！\n}调用成员函数 detach() 分离该线程，意味着线程的生命周期不再由当前 std::thread 对象管理，而是在线程退出以后自动销毁自己。不过这样还是会在进程退出时候自动退出。\n但是 detach 的问题是进程退出时候不会等待所有子线程执行完毕。所以另一种解法是把std::thread对象移动到一个全局变量去，从而延长其生命周期。\ncppstd::vector&lt;std::thread&gt; pool;//全局线程池\nvoid myfunc()\n{\n    std::thread t1([&amp;]\n                   { download(\"hello.zip\"); });\n    // t1.detach();//分离该线程，线程将继续执行直至退出。\n    pool.push_back(std::move(t1));// 移交控制权到全局的线程池，以延长 t1 的生命周期\n}\nint main()\n{\n    myfunc();\n    interact();\n    for (auto &amp;t : pool)\n        t.join(); // 等待池里的线程全部执行完毕\n    return 0;\n}main 函数退出后自动 join 全部线程我们可以自定义一个类 ThreadPool，并用它创建一个全局变量tpool，其析构函数会在 main 退出后自动调用。\ncppclass ThreadPool\n{\n    std::vector&lt;std::thread&gt; m_pool;\npublic:\n    void push_back(std::thread thr)\n    {\n        m_pool.push_back(std::move(thr));\n    }\n    ~ThreadPool()// lmain函数退出后会自动调用\n    {\n        for (auto &amp;t : m_pool)\n            t.join();//等待池里的线程全部执行完毕\n    }\n} tpool;std::jthread(C++20)C++20 引入了 std::jthread 类，和 std::thread 不同在于：它的析构函数里会自动调用 join() 函数，从而保证 pool 析构时会自动等待全部线程执行完毕。\n异步std::async定义于头文件&lt;future&gt;  \nstd::async 接受一个带返回值的可调用对象，自身返回一个 std::future 对象。可调用对象将在另一个线程里执行。  \n等到要用到异步返回值的时候，就调用 future 的 get() 方法，如果此时异步线程还没结束，会等待其完成，并获取该可调用对象的返回值。  \ncppint main()\n{\n    std::future&lt;int&gt; fret = std::async([&amp;]\n                                       { return download(\"hello.zip\"); });\n    interact();\n    int ret = fret.get();\n    std::cout &lt;&lt; \"Download result: \" &lt;&lt; ret &lt;&lt; std::endl;\n    return 0;\n}除了 get() 会等待外，wait() 也可以等待，但是不会返回其值。  \n只要线程没有执行完，wait() 会无限等下去。而 wait_for() 则可以指定一个最长等待时间，用 std::chrono 里的类表示单位。它会返回一个 std::future_status 表示等待是否成功。如果超过这个时间线程还没有执行完毕，则放弃等待，返回 future_status::timeout。如果线程在指定的时间内执行完毕，则认为等待成功，返回 future_status::ready。  \n同理还有 wait_until() 其参数是一个时间点。\nstd::async的第一个参数可以设为 std::launch::deferred，这时不会创建一个线程来执行，它只会把可调用对象的运算推迟到 future 的 get() 被调用时。\ncppint main()\n{\n    std::future&lt;int&gt; fret = std::async(std::launch::deferred, [&amp;]\n                                       { return download(\"hello.zip\"); });\n    interact();\n    int ret = fret.get();//现在才开始运行\n    std::cout &lt;&lt; \"Download result: \" &lt;&lt; ret &lt;&lt; std::endl;\n    return 0;\n}std::promise如果不想让 std::async 帮你自动创建线程，想要手动创建线程，可以直接用 std::promise。然后在线程返回的时候，用 set_value() 设置返回值。在主线程里，用 get_future() 获取其 std::future 对象，进一步 get() 可以等待并获取线程返回值。\nfuture 为了三五法则，删除了拷贝构造/赋值函数。如果需要浅拷贝，实现共享同一个 future 对象，可以用std::shared_future。如果不需要返回值，std::async 里可调用对象的返回类型可以为 void， 这时 future 对象的类型为 std::future&lt;void&gt;。同理有 std::promise&lt;void&gt;，它的 set_value() 不接受参数，仅仅作为同步用，不传递任何实际的值。  \n互斥量vector 不是多线程安全（MT-safe）的容器。多个线程同时访问同一个 vector 会出现数据竞争（data-race）现象。\ncppint main()\n{\n    std::vector&lt;int&gt; arr;\n    std::thread t1([&amp;]\n                   {\n        for (int i = 0; i &lt; 1000; i++) \n            arr.push_back(1); });\n    std::thread t2([&amp;]\n                   {\n        for (int i = 0; i &lt; 1000; i++) \n            arr.push_back(2); });\n    t1.join();\n    t2.join();\n    return 0;\n}这样会导致vector的顺序是随机的。\nstd::mutex定义在头文件&lt;mutex&gt;\n防止多个线程同时进入某一代码段\n调用 std::mutex 的 lock() 时，会检测 mutex 是否已经上锁。如果没有锁定，则对 mutex 进行上锁。如果已经锁定，则陷入等待，直到 mutex 被另一个线程解锁后，才再次上锁。而调用 unlock() 则会进行解锁操作。这样，就可以保证 mtx.lock() 和 mtx.unlock() 之间的代码段，同一时间只有一个线程在执行，从而避免数据竞争。  \ncppint main()\n{\n    std::vector&lt;int&gt; arr;\n    std::mutex mtx;\n    std::thread t1([&amp;]\n                   {\n        for (int i = 0; i &lt; 1000; i++) {\n            mtx.lock();\n            arr.push_back(1);\n            mtx.unlock();\n        } });\n    std::thread t2([&amp;]\n                   {\n        for (int i = 0; i &lt; 1000; i++) {\n            mtx.lock();\n            arr.push_back(2);\n            mtx.unlock();\n        } });\n    t1.join();\n    t2.join();\n    return 0;\n}std::lock_guard符合 RAII 思想的上锁和解锁\n根据 RAII 思想，可将锁的持有视为资源，上锁视为锁的获取，解锁视为锁的释放。std::lock_guard 就是这样一个工具类，它的构造函数里会调用 lock()，解构函数会调用unlock()。从而退出函数作用域时能够自动解锁，避免程序员粗心不小心忘记解锁。  \nstd::unique_lock更自由的std::lock_guard\nstd::lock_guard 严格在解构时 unlock()，但是有时候我们会希望提前 unlock()。这时可以用 std::unique_lock，它额外存储了一个 flag 表示是否已经被释放。它会在解构检测这个 flag，如果没有释放，则调用 unlock()，否则不调用。然后可以直接调用 unique_lock 的 unlock() 函数来提前解锁，但是即使忘记解锁也没关系，退出作用域时候它还会自动检查一遍要不要解锁。\ncppint main()\n{\n    std::vector&lt;int&gt; arr;\n    std::mutex mtx;\n    std::thread t1([&amp;]\n                   {\n        for (int i = 0; i &lt; 1000; i++) {\n            std::unique_lock grd(mtx);\n            arr.push_back(1);\n        } });\n    std::thread t2([&amp;]\n                   {\n        for (int i = 0; i &lt; 1000; i++) {\n            std::unique_lock grd(mtx);\n            arr.push_back(2);\n            grd.unlock();\n            printf(\"outside of lock\\n\");\n            // grd.lock();  // 如果需要，还可以重新上锁\n        } });\n    t1.join();\n    t2.join();\n    return 0;\n}std::unique_lock：用 std::adopt_lock 做参数如果当前 mutex 已经上锁了，但是之后仍然希望用 RAII 思想在解构时候自动调用 unlock()，可以用 std::adopt_lock 作为 std::unique_lock 或 std::lock_guard 的第二个参数，这时它们会默认对象已经上锁。\n多个对象就每个对象各分配一把锁\n上锁失败不等待lock() 如果发现 mutex 已经上锁的话，会等待它直到它解锁。也可以用无阻塞的 **try_lock()**，它在上锁失败时不会陷入等待，而是直接返回 false；如果上锁成功，则会返回 true。比如下面这个例子，第一次上锁，因为还没有上锁，所以成功了，返回 true。第二次上锁，由于已经上锁，所以失败了，返回 false。\ncppstd::mutex mtx1;\nint main()\n{\n    if (mtx1.try_lock())\n        printf(\"succeed\\n\");\n    else\n        printf(\"failed\\n\");\n    if (mtx1.try_lock())\n        printf(\"succeed\\n\");\n    else\n        printf(\"failed\\n\");\n    mtx1.unlock();\n    return 0;\n}std::unique_lock：用 std::try_to_lock 做参数和无参数相比，它会调用 try_lock() 而不是 lock()。之后，可以用owns_lock() 判断是否上锁成功。\n上锁失败等待一段时间try_lock() 碰到已经上锁的情况，会立即返回 false。如果需要等待，但仅限一段时间，可以用 std::timed_mutex 的 try_lock_for() 函数，它的参数是最长等待时间，同样是由 chrono 指定时间单位。超过这个时间还没成功就会“不耐烦地”失败并返回 false；如果这个时间内上锁成功则返回 true。同理还有接受时间点的 **try_lock_until()**。\ncppstd::timed_mutex mtx1;\nint main()\n{\n    if (mtx1.try_lock_for(std::chrono::milliseconds(500)))\n        printf(\"succeed\\n\");\n    else\n        printf(\"failed\\n\");\n    if (mtx1.try_lock_for(std::chrono::milliseconds(500)))\n        printf(\"succeed\\n\");\n    else\n        printf(\"failed\\n\");\n    mtx1.unlock();\n    return 0;\n}unique_lock和mutex接口相同其实 std::unique_lock 具有 mutex 的所有成员函数：lock(), unlock(), try_lock(), try_lock_for() 等。除了它会在解构时按需自动调用 unlock()。因为 std::lock_guard 无非是调用其构造参数名为 lock() 的成员函数，所以 std::unique_lock 也可以作为 std::lock_guard 的构造参数！这种只要具有某些指定名字的成员函数，就判断一个类是否满足某些功能的思想，在 Python 称为鸭子类型，而 C++ 称为 concept（概念）。比起虚函数和动态多态的接口抽象，concept 使实现和接口更加解耦合且没有性能损失。 \n死锁两个锁互相锁由于同时执行的两个线程，它们中发生的指令不一定是同步的，因此有可能出现这种情况：t1 执行 mtx1.lock()。t2 执行 mtx2.lock()。t1 执行 mtx2.lock()：失败，陷入等待t2 执行 mtx1.lock()：失败，陷入等待双方都在等着对方释放锁，但是因为等待而无法释放锁，从而要无限制等下去。 \ncppint main()\n{\n    std::mutex mtx1;\n    std::mutex mtx2;\n\n    std::thread t1([&amp;]\n                   {\n        for (int i = 0; i &lt; 1000; i++) {\n            mtx1.lock();\n            mtx2.lock();\n            mtx2.unlock();\n            mtx1.unlock();\n        } });\n    std::thread t2([&amp;]\n                   {\n        for (int i = 0; i &lt; 1000; i++) {\n            mtx2.lock();\n            mtx1.lock();\n            mtx1.unlock();\n            mtx2.unlock();\n        } });\n    t1.join();\n    t2.join();\n    return 0;\n}这种现象称为死锁（dead-lock）。  \n解决1：永远不要同时持有两个锁最简单的方法，就是保证在一个线程中，得处于lock状态的锁不超过一个，即可以避免死锁。  \n解决2：保证两个锁双方上锁顺序一致比方有两个锁，mtx1和mtx2，每个运行的线程都保证先锁mtx1，再锁mtx2。这时，无论实际执行顺序是怎样，都不会出现一方等着对方的同时持有了对方等着的锁的情况。。\n解决3：用 std::lock 同时对多个上锁（更推荐）如果没办法保证上锁顺序一致，可以用标准库的 std::lock(mtx1, mtx2, …) 函数，一次性对多个 mutex 上锁。它接受任意多个 mutex 作为参数，并且它保证在无论任意线程中调用的顺序是否相同，都不会产生死锁问题。\nstd::lock 的 RAII 版本：std::scoped_lock和 std::lock_guard 相对应，std::lock 也有 RAII 的版本 std::scoped_lock。只不过他可以同时对多个 mutex 上锁。\n一个锁自己锁自己除了两个线程同时持有两个锁会造成死锁外，即使只有一个线程一个锁，如果 lock() 以后又调用 lock()，也会造成死锁。比如下面的 func 函数，上了锁之后，又调用了 other 函数，他也需要上锁。而 other 看到 mtx1 已经上锁，还以为是别的线程上的锁，于是陷入等待。殊不知是调用他的 func 上的锁，other 陷入等待后 func 里的 unlock() 永远得不到调用。\ncppstd::mutex mtx1;\nvoid other()\n{\n    mtx1.lock();\n    // do something\n    mtx1.unlock();\n}\nvoid func()\n{\n    mtx1.lock();\n    other();\n    mtx1.unlock();\n}\nint main()\n{\n    func();\n    return 0;\n}解决1：other 里不要再上锁把 other 里的 lock() 去掉，并在其文档中说明：“other 不是线程安全的，调用本函数之前需要保证某 mutex 已经上锁。”\n解决2：改用 std::recursive_mutex如果实在不能改的话，可以用 std::recursive_mutex。他会自动判断是不是同一个线程 lock() 了多次同一个锁，如果是则让计数器加1，之后 unlock() 会让计数器减1，减到0时才真正解锁。但是相比普通的std::mutex有一定性能损失。同理还有std::recursive_timed_mutex，如果你同时需要 try_lock_for()的话。\n数据结构std::vectorvector 不是多线程安全的容器。多个线程同时访问同一个 vector 会出现数据竞争（data-race）现象。我们可以封装一个线程安全的vector，类似下面的。\ncppclass MTVector\n{\n    std::vector&lt;int&gt; m_arr;\n    mutable std::mutex m_mtx;//设为mutable否则size()函数报错\npublic:\n    void push_back(int val)\n    {\n        m_mtx.lock();\n        m_arr.push_back(val);\n        m_mtx.unlock();\n    }\n    size_t size() const\n    {\n        m_mtx.lock();\n        size_t ret = m_arr.size();\n        m_mtx.unlock();\n        return ret;\n    }\n};在数据结构中：读可以共享，写必须独占，且写和读不能共存。那么在这种要求下，我们引入读写锁的概念。\nstd::shared_mutex上锁时，可以指定你的需求是写入还是读取，负责调度的读写锁会帮你判断要不要等待。如果需要写入数据，使用 lock() 和 unlock() 的组合。如果是要读取数据，使用 lock_shared() 和 unlock_shared() 的组合。\nstd::shared_lock在函数体退出时自动调用 unlock_shared()。\n访问者模式只需一次性上锁，且符合 RAII 思想\ncppclass MTVector\n{\n    std::vector&lt;int&gt; m_arr;\n    std::mutex m_mtx;\npublic:\n    class Accessor\n    {\n        MTVector &amp;m_that;\n        std::unique_lock&lt;std::mutex&gt; m_guard;\n    public:\n        Accessor(MTVector &amp;that)\n            : m_that(that), m_guard(that.m_mtx) {}\n        void push_back(int val) const { return m_that.m_arr.push_back(val); }\n        size_t size() const { return m_that.m_arr.size(); }\n    };\n    Accessor access() { return {*this}; }\n};\nint main()\n{\n    MTVector arr;\n    std::thread t1([&amp;]()\n                   {\n        auto axr = arr.access();\n        for (int i = 0; i &lt; 1000; i++) {\n            axr.push_back(i);\n        } });\n\n    std::thread t2([&amp;]()\n                   {\n        auto axr = arr.access();\n        for (int i = 0; i &lt; 1000; i++) {\n            axr.push_back(1000 + i);\n        } });\n    t1.join();\n    t2.join();\n    std::cout &lt;&lt; arr.access().size() &lt;&lt; std::endl;\n    return 0;\n}条件变量定义于头文件&lt;condition_variable&gt;\n等待被唤醒cppint main()\n{\n    std::condition_variable cv;\n    std::mutex mtx;\n    std::thread t1([&amp;]\n                   {\n        std::unique_lock lck(mtx);\n        cv.wait(lck);\n        std::cout &lt;&lt; \"t1 is awake\" &lt;&lt; std::endl; });\n    std::this_thread::sleep_for(std::chrono::milliseconds(400));\n    std::cout &lt;&lt; \"notifying...\" &lt;&lt; std::endl;\n    cv.notify_one(); // 唤醒t1\n    t1.join();\n\n    return 0;\n}cv.wait(lck) 将会让当前线程陷入等待。在其他线程中调用 cv.notify_one() 则会唤醒那个陷入等待的线程。可以发现 std::condition_variable 必须和 std::unique_lock&lt;std::mutex&gt; 一起用，稍后会解释原因。\n等待条件为true给成员函数wait额外指定一个参数，变成 wait(lock, expr) 的形式，其中 expr 是一个可调用对象，只有其返回值为 true 时才会真正唤醒，否则继续等待。\ncppint main()\n{\n    std::condition_variable cv;\n    std::mutex mtx;\n    bool ready = false;\n    std::thread t1([&amp;]\n                   {\n        std::unique_lock lck(mtx);\n        cv.wait(lck, [&amp;] { return ready; });\n        std::cout &lt;&lt; \"t1 is awake\" &lt;&lt; std::endl; });\n    std::cout &lt;&lt; \"notifying not ready\" &lt;&lt; std::endl;\n    cv.notify_one(); // 没用，因为ready为false\n    ready = true;\n    std::cout &lt;&lt; \"notifying ready\" &lt;&lt; std::endl;\n    cv.notify_one(); // t1被唤醒，因为ready为true\n    return 0;\n}多个等待者std::condition_variable成员函数notify_all() 唤醒全部等待中的线程。这就是为什么 wait() 需要一个 unique_lock 作为参数，因为要保证多个线程被唤醒时，只有一个能够被启动。如果不需要，在 wait() 返回后调用 unlock() 即可。wait() 的过程中会暂时 unlock() 这个锁。\ncppint main()\n{\n    std::condition_variable cv;\n    std::mutex mtx;\n    std::thread t1([&amp;]\n                   {\n        std::unique_lock lck(mtx);\n        cv.wait(lck);\n        std::cout &lt;&lt; \"t1 is awake\" &lt;&lt; std::endl; });\n    std::thread t2([&amp;]\n                   {\n        std::unique_lock lck(mtx);\n        cv.wait(lck);\n        std::cout &lt;&lt; \"t2 is awake\" &lt;&lt; std::endl; });\n    std::thread t3([&amp;]\n                   {\n        std::unique_lock lck(mtx);\n        cv.wait(lck);\n        std::cout &lt;&lt; \"t3 is awake\" &lt;&lt; std::endl; });\n    std::this_thread::sleep_for(std::chrono::milliseconds(400));\n    std::cout &lt;&lt; \"notifying one\" &lt;&lt; std::endl;\n    cv.notify_one(); // 仅仅唤醒t1\n    std::this_thread::sleep_for(std::chrono::milliseconds(400));\n    std::cout &lt;&lt; \"notifying all\" &lt;&lt; std::endl;\n    cv.notify_all(); // 唤醒剩下的t2和t3\n    t1.join();\n    t2.join();\n    t3.join();\n    return 0;\n}实现生产者-消费者模式cppint main()\n{\n    std::condition_variable cv;\n    std::mutex mtx;\n    std::vector&lt;int&gt; foods;\n    std::thread t1([&amp;]\n                   {\n        for (int i = 0; i &lt; 2; i++) {\n            std::unique_lock lck(mtx);\n            cv.wait(lck, [&amp;] {\n                return foods.size() != 0;\n            });\n            auto food = foods.back();\n            foods.pop_back();\n            lck.unlock();\n            std::cout &lt;&lt; \"t1 got food:\" &lt;&lt; food &lt;&lt; std::endl;\n        } });\n    std::thread t2([&amp;]\n                   {\n        for (int i = 0; i &lt; 2; i++) {\n            std::unique_lock lck(mtx);\n            cv.wait(lck, [&amp;] {\n                return foods.size() != 0;\n            });\n            auto food = foods.back();\n            foods.pop_back();\n            lck.unlock();\n            std::cout &lt;&lt; \"t2 got food:\" &lt;&lt; food &lt;&lt; std::endl;\n        } });\n    foods.push_back(42);\n    foods.push_back(233);\n    cv.notify_one();\n    foods.push_back(666);\n    foods.push_back(4399);\n    cv.notify_all();\n    t1.join();\n    t2.join();\n    return 0;\n}\n\n\n\n\n\n\n\n\nstd::condition_variable 仅仅支持 std::unique_lock&lt;std::mutex&gt; 作为 wait 的参数，如果需要用其他类型的 mutex 锁，可以用 std::condition_variable_any。他还有 wait_for() 和 wait_until() 函数，分别接受 chrono 时间段和时间点作为参数。\n原子操作定义于头文件&lt;atomic&gt;\n多个线程修改同一个计数器多个线程同时往一个 int 变量里累加，这样肯定会出错，因为 counter += i 在 CPU 看来会变成三个指令：读取 counter 变量到 rax 寄存器rax 寄存器的值加上 1把 rax 写入到 counter 变量即使编译器优化成 add [counter], 1 也没用，因为现代 CPU 为了高效，会把一条汇编指令拆分成很多微指令 (micro-ops)，具体是如何实现的跟硬件有很大的关系。  \n如果有多个线程同时运行，顺序是不确定的：t1：读取 counter 变量，到 rax 寄存器t2：读取 counter 变量，到 rax 寄存器t1：rax 寄存器的值加上 1t2：rax 寄存器的值加上 1t1：把 rax 写入到 counter 变量t2：把 rax 写入到 counter 变量如果是这种顺序，最后 t1 的写入就被 t2 覆盖了，从而 counter 只增加了 1，而没有像预期的那样增加 2。更不用说现代 CPU 还有高速缓存，乱序执行，指令级并行等优化策略，你根本不知道每条指令实际的先后顺序。  \n解决1：std::mutex 上锁防止多个线程同时修改 counter 变量，从而不会冲突。问题：mutex 太过重量级，他会让线程被挂起，从而需要通过系统调用，进入内核层，调度到其他线程执行，有很大的开销。\n解决2：std::atomic（推荐）因此可以用更轻量级的 atomic，对他的 += 等操作，会被编译器转换成专门的指令。CPU 识别到该指令时，会锁住内存总线，放弃乱序执行等优化策略（将该指令视为一个同步点，强制同步掉之前所有的内存操作），从而向你保证该操作是原子 (atomic) 的，不会加法加到一半另一个线程插一脚进来。对于程序员，只需把 int 改成 atomic&lt;int&gt; 即可，也不必像 mutex 那样需要手动上锁解锁，因此用起来也更直观。\n\n\n\n\n\n\n\n注意\n不过要注意了，这种写法：counter = counter + 1;  // 错，不能保证原子性counter += 1;                // OK，能保证原子性counter++;                    // OK，能保证原子性\n\n\n","slug":"C-多线程","date":"2022-11-08T17:02:00.000Z","categories_index":"C++","tags_index":"C++进阶,多线程","author_index":"Ac-Accelerator"},{"id":"654198c9751861f6164cbde797aab0ed","title":"编译器优化","content":"这是观看一位大佬双笙子佯谬的视频后写的笔记。\n汇编基础x64架构CPU寄存器模型\n\n汇编语言\n\ngcc编译器里函数的前6个参数：分别通过*di，*si，*dx，*cx，r8*，r9*传入,如果有六个以上的参数，则使用程序的堆栈将其他参数传递给该函数。  gcc编译器里的返回值：通过 eax 传出\n如何用编译器产生汇编语言？添加下面几个编译参数。第一个参数用于简化汇编代码，第二个参数用于在汇编代码旁边附带源码注释。第三个是告诉编译器生成目标是汇编语言。至于第四个是优化等级，有O0,O1,O2,O3等等，优化程度由低到高，可自行选择。\ntxt-fomit-frame-pointer -fverbose-asm -S -O2化简代数化简cppint func(int a, int b)\n{\n    int c = a + b;\n    int d = a - b;\n    return (c + d) / 2;//其实就是return a;\n}编译优化后\ntxt_Z4funcii:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:2: {\n    movl\t%ecx, %eax\t # tmp86, a\n # exam1.cpp:6: }\n    ret\t常量折叠示例1：\ncppint func() \n{\n    int a = 32;\n    int b = 10;\n    return a + b;\n}编译优化后\ntxt_Z4funcv:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:5: }\n    movl\t$42, %eax\t #,\n    ret\t示例2\ncppint func(int n)\n{\n    int ret = 0;\n    for (int i = 1; i &lt;= 100; i++) \n        ret += i;\n    return ret;\n}编译优化后\ntxt_Z4funci:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:6: }\n    movl\t$5050, %eax\t #,\n    ret\t但是像这种就会优化失败：\ncpp#include &lt;vector&gt;\nint func()\n{\n    std::vector&lt;int&gt; arr;\n    for (int i = 1; i &lt;= 100; i++)\n        arr.push_back(i);\n    return std::reduce(arr.begin(), arr.end());\n}\n\n\n\n\n\n\n\n\n结论：尽量避免代码复杂化，避免使用会造成内存分配在堆上的容器。简单的代码，比什么优化手段都强。\n存储在堆上（妨碍优化）：vector, map, set, string, function, anyunique_ptr, shared_ptr, weak_ptr。\n存储在栈上（利于优化）：array, bitset, glm::vec, string_viewpair, tuple, optional, variant\n那把vector改为array试试？\ncpp#include &lt;array&gt;\nint func()\n{\n    std::array&lt;int,100&gt; arr;\n    for (int i = 1; i &lt;= 100; i++)\n        arr[i-1]=i;\n    return std::reduce(arr.begin(), arr.end());\n}优化失败的。\n那再改用手写的reduce？\ncpp#include &lt;array&gt;\nint func() {\n    std::array&lt;int, 100&gt; arr;\n    for (int i = 1; i &lt;= 100; i++) \n        arr[i - 1] = i;\n    int ret = 0;\n    for (int i = 1; i &lt;= 100; i++) \n        ret += arr[i - 1];\n    return ret;\n}优化还是失败。把数字改小一点试试？\ncpp#include &lt;array&gt;\nint func() {\n    std::array&lt;int, 10&gt; arr;\n    for (int i = 1; i &lt;= 10; i++) \n        arr[i - 1] = i;\n    int ret = 0;\n    for (int i = 1; i &lt;= 10; i++) \n        ret += arr[i - 1];\n    return ret;\n}实测优化成功。\n\n\n\n\n\n\n\n\n\n结论：代码过于复杂，涉及的语句数量过多时，编译器会放弃优化！简单的代码，比什么优化手段都强。\nconstexpr：强迫编译器在编译期求值\ncpp#include &lt;vector&gt;\n#include &lt;numeric&gt;\nconstexpr int func1()\n{\n    std::vector&lt;int&gt; arr;\n    for (int i = 1; i &lt;= 100; i++)\n        arr.push_back(i);\n    return std::reduce(arr.begin(), arr.end());\n}\nint func2()\n{\n    constexpr int con = func1();\n    return con;\n}C++20实测可优化成功。C++20以下不支持对vector的优化，但是可以优化前面几个没优化成功的。\n过度依赖编译器c常量优化可能会导致编译速度变慢。\n内联编译器优化：call 变 jmp调用外部函数：call 指令\ncppint other(int a);\nint func()\n{\n    return other(233);\n}优化前：\ntxt_Z4funcv:\n.LFB0:\n    subq\t$40, %rsp\t #,\n    .seh_stackalloc\t40\n    .seh_endprologue\n # exam1.cpp:4:     return other(233);\n    movl\t$233, %ecx\t #,\n    call\t_Z5otheri\t #\n # exam1.cpp:5: }\n    addq\t$40, %rsp\t #,\n    ret\t优化后\ntxt_Z4funcv:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:4:     return other(233);\n    movl\t$233, %ecx\t #,\n # exam1.cpp:5: }\n # exam1.cpp:4:     return other(233);\n    jmp\t_Z5otheri\t #如果 _Z5otheri 定义在同一个文件中，编译器会直接调用，减轻了链接器的负担。\n内联化内联：当编译器看得到被调用函数（other）实现的时候，会直接把函数实现贴到调用他的函数（func）里。只有定义在同一个文件的函数可以被内联！否则编译器看不见函数体里的内容怎么内联呢？  \ncppint other(int a)\n{\n    return a;\n}\nint func()\n{\n    return other(233);\n}txt_Z4funcv:\n.LFB1:\n    .seh_endprologue\n # exam1.cpp:8: }\n    movl\t$233, %eax\t #,\n    ret\t为了效率我们可以尽量把常用函数定义在头文件里，然后声明为 static。这样调用他们的时候编译器看得到他们的函数体，从而有机会内联。 因为 static 声明表示不会暴露 other 给其他文件，而且 func 也已经内联了 other，所以编译器干脆不定义 other 了。\n指针看下面这个例子\ncppvoid func(int *a, int *b, int *c)\n{\n    *c = *a;\n    *c = *b;\n}txt_Z4funcPiS_S_:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:3:     *c = *a;\n    movl\t(%rcx), %eax\t # *a_4(D), _1\n # exam1.cpp:3:     *c = *a;\n    movl\t%eax, (%r8)\t # _1, *c_5(D)\n # exam1.cpp:4:     *c = *b;\n    movl\t(%rdx), %eax\t # *b_7(D), _2\n # exam1.cpp:4:     *c = *b;\n    movl\t%eax, (%r8)\t # _2, *c_5(D)\n # exam1.cpp:5: }\n    ret\t为什么编译器不优化掉 *c = *a？\n指针别名现象（pointer aliasing）如果b和c指向同一个变量，优化就会产生错误，编译器宁肯不优化也不肯出现错误！\n__restrict关键字优化如果用户能够向编译器保证这些指针之间不会重叠，就可以使用__restrict关键字，告诉编译器让它大胆优化。\ncppvoid func(int *__restrict a, int *__restrict b, int *__restrict c)\n{\n    *c = *a;\n    *c = *b;\n}txt_Z4funcPiS_S_:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:3:     *c = *b;\n    movl\t(%rdx), %eax\t # *b_5(D), *b_5(D)\n    movl\t%eax, (%r8)\t # *b_5(D), *c_4(D)\n # exam1.cpp:4: }\n    ret\t实际上，__restrict 只需要加在所有具有写入访问的指针（这里是 c）上，就可以优化成功。而我们可以用 const 禁止写入访问。  \n\n\n\n\n\n\n\n\n\n结论：所有非 const 的指针都可尝试声明 __restrict。 \n禁止优化：volatile\ncppint func(int volatile *a)\n{\n    *a = 42;\n    return *a;\n}txt_Z4funcPVi:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:3:     *a = 42;\n    movl\t$42, (%rcx)\t #, *a_2(D)\n # exam1.cpp:4:     return *a;\n    movl\t(%rcx), %eax\t # *a_2(D), &lt;retval&gt;\n # exam1.cpp:5: }\n    ret\t\n\n\n\n\n\n\n\n\n结论：加了 volatile 的对象，编译器会放弃优化对他的读写操作。做性能实验的时候非常有用。\n合并写入\ncppvoid func(int *a)\n{\n    a[0] = 123;\n    a[1] = 456;\n}将两个 int32 的写入合并为一个 int64 的写入。\ntxt_Z4funcPi:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:3:     a[0] = 123;\n    movq\t.LC0(%rip), %rax\t #, tmp83\n    movq\t%rax, (%rcx)\t # tmp83, MEM &lt;vector(2) int&gt; [(int *)a_2(D)]\n # exam1.cpp:5: }\n    ret\t\n    .seh_endproc\n    .section .rdata,\"dr\"\n    .align 8\n.LC0:\n    .long\t123\n    .long\t456但如果访问的两个元素地址间有跳跃，就不能合并了。\ncppvoid func(int *a)\n{\n    a[0] = 123;\n    a[2] = 456;\n}txt_Z4funcPi:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:3:     a[0] = 123;\n    movl\t$123, (%rcx)\t #, *a_2(D)\n # exam1.cpp:4:     a[2] = 456;\n    movl\t$456, 8(%rcx)\t #, MEM[(int *)a_2(D) + 8B]\n # exam1.cpp:5: }\n    ret\t矢量化SIMD更宽的合并写入：矢量化指令（SIMD）  两个 int32 可以合并为一个 int64四个 int32 可以合并为一个 __m128xmm0 由 SSE 引入，是个 128 位寄存器他可以一次存储 4 个 int，或 4 个 floatmovups：move unaligned packed singlemovaps：move aligned packed single  \ncppvoid func(int *a)\n{\n    a[0] = 111;\n    a[1] = 222;\n    a[2] = 333;\n    a[3] = 444;\n}txt_Z4funcPi:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:2:     a[0] = 111;\n    movdqu\t.LC0(%rip), %xmm0\t #, tmp83\n    movups\t%xmm0, (%rcx)\t # tmp83, MEM &lt;vector(4) int&gt; [(int *)a_2(D)]\n # exam1.cpp:6: }\n    ret\t\n    .seh_endproc\n    .section .rdata,\"dr\"\n    .align 16\n.LC0:\n    .long\t111\n    .long\t222\n    .long\t333\n    .long\t444能再宽一点吗？两个 int32 可以合并为一个 int64四个 int32 可以合并为一个 __m128八个 int32 可以合并为一个 __m256！  \ncppvoid func(int *a)\n{\n    a[0] = 111;\n    a[1] = 222;\n    a[2] = 333;\n    a[3] = 444;\n    a[4] = 555;\n    a[5] = 666;\n    a[6] = 777;\n    a[7] = 888;\n}但是编译器默认没有用256位的 ymm0而是用了两次xmm0,因为他不敢保证运行这个程序的电脑支持 AVX 指令集…… \ntxt_Z4funcPi:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:3:     a[0] = 111;\n    movdqu\t.LC0(%rip), %xmm0\t #, tmp83\n    movups\t%xmm0, (%rcx)\t # tmp83, MEM &lt;vector(4) int&gt; [(int *)a_2(D)]\n    movdqu\t.LC1(%rip), %xmm0\t #, tmp84\n    movups\t%xmm0, 16(%rcx)\t # tmp84, MEM &lt;vector(4) int&gt; [(int *)a_2(D) + 16B]\n # exam1.cpp:11: }\n    ret\t\n    .seh_endproc\n    .section .rdata,\"dr\"\n    .align 16\n.LC0:\n    .long\t111\n    .long\t222\n    .long\t333\n    .long\t444\n    .align 16\n.LC1:\n    .long\t555\n    .long\t666\n    .long\t777\n    .long\t888编译选项-march=native 让编译器自动判断当前硬件支持的指令。但是这会导致程序兼容性降低。\ntxt_Z4funcPi:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:3:     a[0] = 111;\n    vmovdqu\t.LC0(%rip), %ymm0\t #, tmp83\n    vmovdqu\t%ymm0, (%rcx)\t # tmp83, MEM &lt;vector(8) int&gt; [(int *)a_2(D)]\n    vzeroupper\n # exam1.cpp:11: }\n    ret\t\n    .seh_endproc\n    .section .rdata,\"dr\"\n    .align 32\n.LC0:\n    .long\t111\n    .long\t222\n    .long\t333\n    .long\t444\n    .long\t555\n    .long\t666\n    .long\t777\n    .long\t888成功使用了ymm0\n清零拷贝：自动调用标准库cppvoid func(int *a, int n)\n{\n    for (int i = 0; i &lt; n; i++)\n        a[i] = 0;\n}txt_Z4funcPii:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:2:     for (int i = 0; i &lt; n; i++) {\n    testl\t%edx, %edx\t # n\n    jle\t.L3\t #,\n # exam1.cpp:3:         a[i] = 0;\n    movl\t%edx, %edx\t # n, n\n    leaq\t0(,%rdx,4), %r8\t #,\n    xorl\t%edx, %edx\t #\n # exam1.cpp:5: }\n # exam1.cpp:3:         a[i] = 0;\n    jmp\tmemset\t #\n    .p2align 4\n    .p2align 3\n.L3:\n # exam1.cpp:5: }\n    ret\t\n    .seh_endproc\n    .ident\t\"GCC: (Rev2, Built by MSYS2 project) 12.1.0\"\n    .def\tmemset;\t.scl\t2;\t.type\t32;\t.endefmemcpy 同理，不必为了高效，手动改写成对 memcpy/memset 的调用，影响可读性。编译器会自动分析你是在做拷贝或是清零，并优化成对标准库这俩的调用。\n从0到1024填充：SIMD加速paddd：四个 int 的加法movdqa：加载四个 int  如果次数是4的倍数（如下面的1024）\ncppvoid func(int *a)\n{\n    for (int i = 0; i &lt; 1024; i++)\n        a[i] = i;\n}txt_Z4funcPi:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:2: {\n    movdqu\t.LC0(%rip), %xmm0\t #, vect_vec_iv_.4\n    movdqu\t.LC1(%rip), %xmm2\t #, tmp89\n    leaq\t4096(%rcx), %rax\t #, _9\n    .p2align 4,,10\n    .p2align 3\n.L2:\n    movdqa\t%xmm0, %xmm1\t # vect_vec_iv_.4, vect_vec_iv_.4\n    addq\t$16, %rcx\t #, ivtmp.10\n    paddd\t%xmm2, %xmm0\t # tmp89, vect_vec_iv_.4\n # exam1.cpp:5:         a[i] = i;\n    movups\t%xmm1, -16(%rcx)\t # vect_vec_iv_.4, MEM &lt;vector(4) int&gt; [(int *)_2]\n    cmpq\t%rcx, %rax\t # ivtmp.10, _9\n    jne\t.L2\t #,\n # exam1.cpp:7: }\n    ret\t\n    .seh_endproc\n    .section .rdata,\"dr\"\n    .align 16\n.LC0:\n    .long\t0\n    .long\t1\n    .long\t2\n    .long\t3\n    .align 16\n.LC1:\n    .long\t4\n    .long\t4\n    .long\t4\n    .long\t4一次写入 4 个 int，一次计算 4 个 int 的加法，从而更加高效但这样有个缺点，那就是数组的大小必须为 4 的整数倍，否则就会写入越界的地址！\n如果不一定是 4 的倍数？边界特判法  \ncppvoid func(int *a, int n)\n{\n    for (int i = 0; i &lt; n; i++)\n        a[i] = i;\n}假设 n = 1023：  先对前 1020 个元素用 SIMD 指令填入，每次处理 4 个剩下 3 个元素用传统的标量方式填入，每次处理 1 个思想：对边界特殊处理，而对大部分数据能够矢量化编译器做优化时会自动处理边界特判。如果你是自己手写 SIMD 指令的话就要考虑一下这个。  \nn总是4的倍数？避免边界特判  这样写\ncppvoid func(int *a, int n)\n{\n    n = n / 4 * 4;\n    for (int i = 0; i &lt; n; i++)\n        a[i] = i;\n}编译器会发现 n % 4 = 0，从而不会生成边界特判的分支。\n假定指针是 16 字节对齐的：assume_aligned如果能保证指针 a 总是对齐到 16 字节，这样写(C++20),对性能有微弱的提升。\ncppvoid func(int *a, int n)\n{\n    n = n / 4 * 4;\n    a = std::assume_aligned&lt;16&gt;(a);\n    for (int i = 0; i &lt; n; i++)\n        a[i] = i;\n}数组求和：reduction 的优化cppfloat func(float *a)\n{\n    float ret = 0;\n    for (int i = 0; i &lt; 1024; i++)\n        ret += a[i];\n    return ret;\n}txt_Z4funcPf:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:3:     float ret = 0;\n    pxor\t%xmm0, %xmm0\t # &lt;retval&gt;\n    leaq\t4096(%rcx), %rax\t #, _4\n    .p2align 4,,10\n    .p2align 3\n.L2:\n    addss\t(%rcx), %xmm0\t # BIT_FIELD_REF &lt;MEM &lt;vector(4) float&gt; [(float *)_3], 32, 0&gt;, stmp_ret_10.7\n    addq\t$16, %rcx\t #, ivtmp.13\n    addss\t-12(%rcx), %xmm0\t # BIT_FIELD_REF &lt;MEM &lt;vector(4) float&gt; [(float *)_3], 32, 32&gt;, stmp_ret_10.7\n # exam1.cpp:5:         ret += a[i];\n    addss\t-8(%rcx), %xmm0\t # BIT_FIELD_REF &lt;MEM &lt;vector(4) float&gt; [(float *)_3], 32, 64&gt;, stmp_ret_10.7\n    addss\t-4(%rcx), %xmm0\t # BIT_FIELD_REF &lt;MEM &lt;vector(4) float&gt; [(float *)_3], 32, 96&gt;, &lt;retval&gt;\n    cmpq\t%rcx, %rax\t # ivtmp.13, _4\n    jne\t.L2\t #,\n # exam1.cpp:7: }\n    ret\t循环循环中的矢量化cppvoid func(float *a, float *b) \n{\n    for (int i = 0; i &lt; 1024; i++)\n        a[i] = b[i] + 1;\n}考虑 func(a, a + 1) 的情况，那样会产生数据依赖链，没法 SIMD 化。为了优化而不失正确性，他索性生成两份代码：一份是 SIMD 的，一份是传统标量的他在运行时检测 a, b 指针的差是否超过 1024 来判断是否有重叠现象。如果没有重叠，则跳转到 SIMD 版本高效运行。如果重叠，则跳转到标量版本低效运行，但至少不会错。  \n可以通过使用__restrict,仅仅生成SIMD版本进行矢量化。\n循环中的if语句循环中的if语句会导致SIMD矢量化困难。\ncppvoid func(float *__restrict a, float *__restrict b, bool is_mul)\n{\n    for (int i = 0; i &lt; 1024; i++)\n        if (is_mul)\n            a[i] = a[i] * b[i];\n        else\n            a[i] = a[i] + b[i];\n}在这里，编译器的看到is_mul是常量，就会将条件判断提到前面，然后使用SIMD矢量化，下面这个代码和上面这个代码编译优化后是一样的。\ncppvoid func(float *__restrict a, float *__restrict b, bool is_mul) {\n    if (is_mul) \n        for (int i = 0; i &lt; 1024; i++) \n            a[i] = a[i] * b[i];\n    else \n        for (int i = 0; i &lt; 1024; i++) \n            a[i] = a[i] + b[i];\n}同样的，如果循环中有在循环期间不变的表达式，在优化的时候也会把它提到循环体外。\n循环体内调用函数下面这个代码无法优化。\ncppvoid other();\nfloat func(float *a)\n{\n    float ret = 0;\n    for (int i = 0; i &lt; 1024; i++)\n    {\n        ret += a[i];\n        other();\n    }\n    return ret;\n}因为编译器看不到那个文件的 other 函数里是什么，哪怕 other 在定义他的文件里是个空函数，他也不敢优化掉。   \n解决方案：把函数实现放在同一个文件里编译器看得到 other 的函数体，就可以内联化该函数\n\n\n\n\n\n\n\n\n\n结论：避免在 for 循环体里调用外部函数，或者把他们移到同一个文件里，或者放在头文件声明为 static 函数。\n下标随机访问矢量化失败\ncppvoid func(float *a, int *b)\n{\n    for (int i = 0; i &lt; 1024; i++)\n        a[b[i]] += 1;\n}下标跳跃访问矢量化部分成功，但是很艰难\ncppvoid func(float *a)\n{\n    for (int i = 0; i &lt; 1024; i++)\n        a[i * 2] += 1;\n}下标连续访问矢量化成功\ncppvoid func(float *a)\n{\n    for (int i = 0; i &lt; 1024; i++)\n        a[i] += 1;\n}\n\n\n\n\n\n\n\n\n结论：不管是编译器还是 CPU，都喜欢顺序的连续访问。\n循环展开cppvoid func(float *a)\n{\n#pragma GCC unroll 4\n    for (int i = 0; i &lt; 1024; i++)\n        a[i] = 1;\n}每次执行循环体 a[i] = 1后，都要进行一次判断 i &lt; 1024。导致一部分时间花在判断是否结束循环，而不是循环体里。如果循环体内容非常简单，那么相对的来说，判断的代价就会很高。所以要循环展开避免判断。\n对小的循环体进行 unroll 可能是划算的，但最好不要 unroll 大的循环体，否则会造成指令缓存的压力反而变慢！\n对于 GCC 编译器，可以用#pragma GCC unroll 4表示把循环体展开为4个  就像这样（但是不建议手动这样写，可能会妨碍编译器矢量化）\ncppvoid func(float *a)\n{\n    for (int i = 0; i &lt; 1024; i += 4)\n    {\n        a[i + 0] = 1;\n        a[i + 1] = 1;\n        a[i + 2] = 1;\n        a[i + 3] = 1;\n    }\n}结构体两个 float：对齐到 8 字节，成功矢量化。\ncppstruct MyVec\n{\n    float x;\n    float y;\n};\nMyVec a[1024];\nvoid func()\n{\n    for (int i = 0; i &lt; 1024; i++)\n        a[i].x *= a[i].y;\n}三个 float：对齐到 12 字节，矢量化失败。生成了标量的低效汇编代码\ncppstruct MyVec\n{\n    float x;\n    float y;\n    float z;\n};\nMyVec a[1024];\nvoid func()\n{\n    for (int i = 0; i &lt; 1024; i++)\n        a[i].x *= a[i].y;\n}添加一个辅助对齐的变量：对齐到 16 字节,追加了一个没有用的 4 字节变量，整个结构体变成 16 字节大小，矢量化成功\ncppstruct MyVec\n{\n    float x;\n    float y;\n    float z;\n    char padding[4];\n};\nMyVec a[1024];\nvoid func()\n{\n    for (int i = 0; i &lt; 1024; i++)\n        a[i].x *= a[i].y;\n}\n\n\n\n\n\n\n\n\n结论：计算机喜欢 2 的整数幂，2, 4, 8, 16, 32, 64, 128…结构体大小若不是 2 的整数幂，往往会导致 SIMD 优化失败。\n让编译器自动对齐 alignas（c++11）在 struct 后加上 alignas(要对齐到的字节数) 即可实现同样效果，就不需要手动写 padding 变量了。\ncppstruct alignas(16) MyVec\n{\n    float x;\n    float y;\n    float z;\n};\nMyVec a[1024];\nvoid func()\n{\n    for (int i = 0; i &lt; 1024; i++)\n        a[i].x *= a[i].y;\n}\n\n\n\n\n\n\n \nSIMD 和缓存行对齐只是性能优化的一个点，又不是全部。还要考虑结构体变大会导致内存带宽的占用，对缓存的占用等一系列连锁反应，总之，要根据实际情况选择优化方案。\n\n\n结构体的内存布局：AOS、SOA和AOSOA\nSTL容器std::vector也有指针别名问题。此时__restrict对于STL容器的指针或引用是无效的。解决方案：#pragma omp simd 或 #pragma GCC ivdep\nstd::vector也能实现 SOA！\n数学运算除法变为乘法计算机做乘法的速度比除法快两倍甚至三倍。\ncppfloat func(float a)\n{\n    return a / 2;\n}相当于变成了 a * 0.5f\ntxt_Z4funcf:\n.LFB0:\n    .seh_endprologue\n # exam1.cpp:3:     return a / 2;\n    mulss\t.LC0(%rip), %xmm0\t #, tmp84\n # exam1.cpp:4: }\n    ret\t\n    .seh_endproc\n    .section .rdata,\"dr\"\n    .align 4\n.LC0:\n    .long\t1056964608编译器放弃的优化：分离公共除数因为担心b=0,编译器放弃优化。\ncppvoid func(float *a, float b) \n{\n    for (int i = 0; i &lt; 1024; i++) \n        a[i] /= b;\n}解决方法1\ncppvoid func(float *a, float b) \n{\n    float inv_b = 1 / b;\n    for (int i = 0; i &lt; 1024; i++) \n        a[i] *= inv_b;\n}解决方法2编译参数-ffast-math选项让 GCC 更大胆地尝试浮点运算的优化，有时能带来 2 倍左右的提升。作为代价，他对 NaN 和无穷大的处理，可能会和 IEEE 标准（腐朽的）规定的不一致。如果你能保证，程序中永远不会出现 NaN 和无穷大，那么可以放心打开 -ffast-math。\n嵌套循环：直接累加，有指针别名问题编译器担心 c 和 a 可能会指向同一个地址，而判断多个指针是否有重合又过于复杂。编译器选择直接放弃矢量化。\ncppvoid func(float *a, float *b, float *c)\n{\n    for (int i = 0; i &lt; 1024; i++)\n        for (int j = 0; j &lt; 1024; j++)\n            c[i] += a[i] * b[j];\n}解决方法1先累加到初始为 0 的局部变量，再累加到 c\ncppvoid func(float *a, float *b, float *c)\n{\n    for (int i = 0; i &lt; 1024; i++)\n    {\n        float tmp = 0;\n        for (int j = 0; j &lt; 1024; j++)\n            tmp += a[i] * b[j];\n        c[i] += tmp;\n    }\n}总结\n函数尽量写在同一个文件内\n避免在 for 循环内调用外部函数\n非 const 指针加上 __restrict 修饰\n试着用 SOA 取代 AOS\n对齐到 16 或 64 字节\n简单的代码，不要复杂化\n试试看 #pragma omp simd\n循环中不变的常量挪到外面来\n对小循环体用 #pragma unroll\n-ffast-math 和 -march=native\n\n","slug":"编译器优化","date":"2022-11-08T09:13:00.000Z","categories_index":"C++","tags_index":"C++进阶,编译器优化","author_index":"Ac-Accelerator"},{"id":"182933b43edb5a2e2aab1a699c004ce0","title":"C++ RAII与智能指针","content":"这是观看一位大佬双笙子佯谬的视频后写的笔记。\nRAII（Resource Acquisition Is Initialization）资源获取视为初始化，反之，资源释放视为销毁C++ 除了用于初始化的构造函数（constructor）还包括了用于销毁的析构函数（destructor）\n传统内存管理\nc#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\nint main()\n{\n    size_t nv = 4;\n    int *v = (int *)malloc(nv * sizeof(int));//分配内存得到一个指针\n    v[0] = 4;\n    v[1] = 3;\n    v[2] = 2;\n    v[3] = 1;\n    int sum = 0;\n    for (size_t i = 0; i &lt; nv; i++)\n        sum += v[i];\n    printf(\"%d \\n\", sum);\n    free(v);//需要手动释放指针所对应的内存\n    return 0;\n}RAII的内存管理\ncpp#include &lt;iostream&gt;\n#include &lt;vector&gt;\nint main()\n{\n    std::vector&lt;int&gt; v(4);//调用构造函数获得对象的同时即可自动分配内存\n    v[0] = 4;\n    v[1] = 3;\n    v[2] = 2;\n    v[3] = 1;\n    int sum = 0;\n    for (size_t i = 0; i &lt; v.size(); i++)\n        sum += v[i];\n    std::cout &lt;&lt; sum;\n    return 0;\n}//离开大括号作用域时自动调用析构函数释放内存\n乍一看C语言的内存管理也只是有一点点不方便而已啊，只要留点心就好了啊。但是看下面这个例子，每个带有返回的分支都要手动释放所有之前的资源，如果分支很多很复杂，就很容易造成疏忽。\nc#include &lt;fstream&gt;\n#include &lt;vector&gt;\n#include &lt;cstdio&gt;\nint main()\n{\n    std::ifstream f1(\"1.txt\");\n    if (checkFileContent(f1))\n    {\n        printf(\"bad file 1!\\n\");\n        f1.close();\n        return 1;\n    }\n    std::ifstream f2(\"2.txt\");\n    if (checkFileContent(f2))\n    {\n        printf(\"bad file 2!\\n\");\n        f1.close();\n        f2.close();\n        return 1;\n    }\n    std::vector&lt;std::ifstream&gt; files;\n    files.push_back(std::ifstream(\"3.txt\"));\n    files.push_back(std::ifstream(\"4.txt\"));\n    files.push_back(std::ifstream(\"5.txt\"));\n    for (auto &amp;file : files)\n        file.close();\n    f1.close();\n    f2.close();\n    return 0;\n}可见RAII的思想可以帮助我们及时释放不再使用的内存，避免了手动内存管理可能导致的内存泄漏问题。\n与 Java，Python 等垃圾回收语言不同，C++ 的析构函数是显式的，离开作用域自动销毁，毫不含糊（有好处也有坏处，对高性能计算而言利大于弊）\n其次，C++ 标准保证当异常发生时，会调用已创建对象的析构函数。\n类设计规则：三五法则\n如果一个类定义了析构函数，那么您必须同时定义或删除拷贝构造函数和拷贝赋值运算符，否则出错。\n如果一个类定义了拷贝构造函数，那么您必须同时定义或删除拷贝赋值运算符，否则出错，删除可导致低效。\n如果一个类定义了移动构造函数，那么您必须同时定义或删除移动赋值运算符，否则出错，删除可导致低效。\n如果一个类定义了拷贝构造函数或拷贝赋值运算符，那么您必须最好同时定义移动构造函数或移动赋值运算符，否则低效。\n\n智能指针智能指针类重载了operator -&gt; ,使它的对象的行为看上去像是一个指针。\nunique_ptr:智能指针类unique_ptr，他的解构函数中会调用 delete，因此当对象生命周期结束的时候能够自动释放对象的内存，避免了这里 make_unique&lt;C&gt;(…) 可以理解为和之前的 new C(…) 等价，括号里也可以有其他构造函数的参数。\ncpp#include &lt;cstdio&gt;\n#include &lt;memory&gt;\nstruct C\n{\n    C() { std::printf(\"分配内存! \\n\"); };\n    ~C() { std::printf(\"释放内存! \\n\"); };\n};\nint main()\n{\n    std::unique_ptr&lt;C&gt; p = std::make_unique&lt;C&gt;();\n    if (1 + 1 == 2)\n    {\n        std::printf(\"出了点小状况.......n \");\n        return 1;\n        //  自动释放p\n    }\n    return 0;\n    // 自动释放p\n}在旧时代 C++ 里，常常听到这样的说法：“释放一个指针后，必须把这个指针设为 nullptr，防止空悬指针！”delete p;p = nullptr;unique_ptr 则把他们封装成一个操作：只需要p = nullptr;      // 等价于：p.reset()即可。将其设为空指针的同时释放资源，体现了面向对象“封装：不变性”的思想。\nunique_ptr禁止拷贝:这是因为 unique_ptr 删除了拷贝构造函数导致的。为什么他要删除拷贝构造函数？（unique指针不unique是吧）,原因还是三五法则，如果拷贝了指针，那么就会出现重复释放的问题。\n那么这个unique_ptr我们该怎么使用呢？看看下面这两个函数。\ncppvoid func1(C* p)\n{\n    p-&gt;do_something();\n}\nvoid func2(std::unique_ptr&lt;C&gt;p)\n{\n    p-&gt;do_something();\n}func1传入一个传统的指针，我们在调用的时候使用p.get()获得一个传统的指针，没有接过掌管对象生命周期的大权。\nfunc2传入一个智能指针对象，我们在调用的时候需要使用std::move(p)将智能指针转换为右值（因为没有拷贝构造函数，必须调用移动构造函数），于是原智能指针指向对象的生命周期将交给func中的智能指针对象管理。\n移交控制权后仍希望访问到 p 指向的对象怎么办？如果还是用 p 去访问的话，因为被移动构造函数转移了，p 已经变成空指针，从而出错。最简单的办法是，在移交控制权给 func2 前，提前通过 p.get() 获取原始指针raw_p;不过你得保证 raw_p 的存在时间不超过 p 的生命周期，否则会出现危险的空悬指针。\ncppint main()\n{\n    std::unique_ptr&lt;C&gt; p = std::make_unique&lt;C&gt;();\n    C *raw_p = p.get();\n    raw_p-&gt;do_something(); // 正常执行\n    func2(std::move(p));   // 随着func2的结束，对象生命周期结束。\n    raw_p-&gt;do_something(); //错误！raw_p已经是悬垂指针了。\n    return 0;\n}shared_ptrunique_ptr使用起来很困难的原因，在于 unique_ptr 解决重复释放的方式是禁止拷贝，这样虽然有效率高的优势，但导致使用困难，容易犯错等。相比之下， 牺牲效率换来自由度的 shared_ptr 则允许拷贝，他解决重复释放的方式是通过引用计数：当一个 shared_ptr 初始化时，将计数器设为1。当一个 shared_ptr 被拷贝时，计数器加1。当一个 shared_ptr 被解构时，计数器减1。减到0时，则自动销毁他指向的对象。从而可以保证，只要还有存在哪怕一个指针指向该对象，就不会被解构。  \n所以shared_ptr是可以被拷贝的。\nshared_ptr循环引用导致内存泄漏\ncpp#include &lt;memory&gt;\nstruct C\n{\n    std::shared_ptr&lt;C&gt; m_child;\n    std::shared_ptr&lt;C&gt; m_parent;\n};\nint main()\n{\n    auto parent = std::make_shared&lt;C&gt;();\n    auto child = std::make_shared&lt;C&gt;();\n    // 建立相互引用∶\n    parent-&gt;m_child = child;\n    child-&gt;m_parent = parent;\n    parent = nullptr; // parent不会被释放 !因为child还指向他 !\n    child = nullptr;  // child也不会被释放 !因为parent还指向他 !\n    return 0;\n}week_ptr的概念为了解决循环引用的问题，引入了week_ptr。\n有时候我们希望维护一个 shared_ptr 的弱引用 weak_ptr，即：弱引用的拷贝与解构不影响其引用计数器。之后有需要时，可以通过 lock() 随时产生一个新的 shared_ptr 作为强引用。但不 lock 的时候不影响计数。如果失效（计数器归零）则 expired() 会返回 false，且 lock() 也会返回 nullptr。\n可以把 C * 理解为 unique_ptr 的弱引用。weak_ptr 理解为 shared_ptr 的弱引用。但 weak_ptr 能提供失效检测，更安全。  \nweek_ptr示例：\ncpp#include &lt;memory&gt;\n#include &lt;vector&gt;\nstruct C\n{\n    std::shared_ptr&lt;C&gt; m_child;\n    std::shared_ptr&lt;C&gt; m_parent;\n};\nstd::vector&lt;std::shared_ptr&lt;C&gt;&gt; objlist;\nvoid func3(std::shared_ptr&lt;C&gt; p)\n{\n    p-&gt;do_something();\n    objlist.push_back(std::move(p));\n}\nint main()\n{\n    std::shared_ptr&lt;C&gt; p = std::make_shared&lt;C&gt;(); //引用计数初始化为1\n    printf(\"use count = %ld\\n\", p.use_count());   // 1\n    std::weak_ptr&lt;C&gt; weak_p = p;                  // 创建一个不影响计数器的弱引用\n    printf(\"use count = %ld\\n\", p.use_count());   // 1\n    func3(std::move(p));                          //控制权转移，p变为null，引用计数加不变\n    if (weak_p.expired())\n        printf(\"错误︰弱引用已失效! \");\n    else\n        weak_p.lock()-&gt;do_something(); //正常执行，p的生命周期仍被objlist延续着\n    objlist.clear();                   //刚刚p移交给func的生命周期结束了!引用计数减1，变成0了\n    if (weak_p.expired())              //因为shared_ptr指向的对象已释放，弱引用会失效\n        printf(\"错误︰弱引用已失效! \");\n    else\n        weak_p.lock()-&gt;do_something(); // 不会执行\n    return 0;                          //到这里最后一个弱引用weak_p也被释放，他指向的“管理块”被释放\n}循环引用：解决方案1 用week_ptr和shared_ptr只需要把其中逻辑上“不具有所属权”的那一个改成 weak_ptr 即可：因为父窗口“拥有”子窗口是天经地义的，而子窗口并不“拥有”父窗口。其实主要是一个父窗口可以有多个子窗口，只有规定子窗口从属于父窗口才能解决引用计数的问题……\ncpp#include &lt;memory&gt;\nstruct C\n{\n    std::shared_ptr&lt;C&gt; m_child;\n    std::week_ptr&lt;C&gt; m_parent;\n};\nint main()\n{\n    auto parent = std::make_shared&lt;C&gt;();\n    auto child = std::make_shared&lt;C&gt;();\n    // 建立相互引用∶\n    parent-&gt;m_child = child;\n    child-&gt;m_parent = parent;\n    parent = nullptr; // parent会被释放 !因为child指向他的是一个弱引用 !\n    child = nullptr;  // child会被释放 !因为parent已经被释放 !\n    return 0;\n}循环引用：解决方案2还有一种更适应“父子窗口”这一场景的解决方案。刚才提到原始指针的应用场景是“当该对象不属于我，但他释放前我必然被释放时”。这里我们可以发现父窗口的释放必然导致子窗口的释放。因此我们完全可以把 m_parent 变成原始指针。这样也不需要 weak_ptr 判断是否 expired() 了。\ncpp#include &lt;memory&gt;\nstruct C\n{\n    std::shared_ptr&lt;C&gt; m_child;\n    C* m_parent;\n};\nint main()\n{\n    auto parent = std::make_shared&lt;C&gt;();\n    auto child = std::make_shared&lt;C&gt;();\n    // 建立相互引用∶\n    parent-&gt;m_child = child;\n    child-&gt;m_parent = parent.get();\n    parent = nullptr; // parent会被释放 !因为child指向他的是一个原始指针\n    child = nullptr;  // child会被释放 !因为parent已经被释放 !\n    return 0;\n}解决方案2还可以更好！就是用原始指针和unique_ptr刚才提到 unique_ptr 的应用场景是“当该对象仅仅属于我时”。既然都用了原始指针（假定他释放前我必然被释放）。因为因此我们完全可以把 m_child 变成一个标志这“完全所有权”的 unique_ptr。这样也不需要 shared_ptr 维护一个原子计数器的开销了。\ncpp#include &lt;memory&gt;\nstruct C\n{\n    std::unique_ptr&lt;C&gt; m_child;\n    C* m_parent;\n};\nint main()\n{\n    auto parent = std::make_unique&lt;C&gt;();\n    auto child = std::make_unique&lt;C&gt;();\n    // 建立相互引用∶\n    parent-&gt;m_child = std::move(child);//移交所属权\n    child-&gt;m_parent = parent.get();\n    parent = nullptr; // parent会被释放 !因为child指向他的是一个原始指针\n    child = nullptr;  // child会被释放 !因为parent已经被释放 !\n    return 0;\n}综上所述：原始指针和unique_ptr是一对的，week_ptr和shared_ptr是一对的。我们在对性能要求比较高的时候使用原始指针和unique_ptr，这样是可以减小维护开销的。但是明显week_ptr和shared_ptr这一对安全性更高。\n哪些类型是安全的三五法则：什么时候需要担心一般来说，可以认为符合三五法则的类型是安全的。以下类型是安全的：int id;                                        // 基础类型std::vector&lt;int&gt; arr;                  // STL 容器std::shared_ptr&lt;Object&gt; child; // 智能指针Object *parent;                         // 原始指针，如果是从智能指针里 .get() 出来的  \n以下对象是不安全的：char *ptr;                                   // 原始指针，如果是通过 malloc/free 或 new/    delete 分配的GLint tex;                                  // 是基础类型 int，但是对应着某种资源std::vector&lt;Object *&gt; objs;       // STL 容器，但存了不安全的对象  \n成员都是安全的类型成员都是安全的类型：五大函数，一个也不用声明如果你的类所有成员，都是安全的类型，那么五大函数都无需声明（或声明为 = default），你的类自动就是安全的。最好的判断方式是：如果你不需要自定义的解构函数，那么这个类就不需要担心。因为如果用到了自定义解构函数，往往意味着你的类成员中，包含有不安全的类型。一般无外乎两种情况：你的类管理着资源。你的类是数据结构。 \n管理着资源管理着资源：删除拷贝函数，然后统一用智能指针管理这个类管理着某种资源，资源往往不能被“复制”。比如一个 OpenGL 的着色器，或是一个 Qt 的窗口。如果你允许 GLShader 拷贝，就相当于把 glCreateShader 返回的 int 拷贝两遍，解构时就会出现重复释放 (double free) 错误。你会想“那我是不是可以在 GLShader 里加一个引用计数器呢，这样就可以算拷贝次数避免重复释放了！”可以，但是既然标准库已经提供了 shared_ptr，还不如用 shared_ptr&lt;GLShader&gt; 来管理，省的每个类实现一遍原子引用计数器。  \n数据结构是数据结构：如果可以，定义拷贝和移动这个类是你精心设计的数据结构，如果这些数据结构是可以支持拷贝的，你可能需要自己一个个定义。如果不支持，那就删除（= delete）。\n函数参数类型优化规则函数参数类型优化规则：按引用还是按值？如果是基础类型（比如 int，float）则按值传递：float squareRoot(float val);如果是原始指针（比如 int *，Object *）则按值传递：void doSomethingWith(Object *ptr);如果是数据容器类型（比如 vector，string）则按常引用传递：int sumArray(std::vector &lt;int&gt; const &amp;arr);如果数据容器不大（比如 tuple&lt;int, int&gt;），则其实可以按值传递：glm::vec3 calculateGravityAt(glm::vec3 pos);如果是智能指针（比如 shared_ptr），且需要生命周期控制权，则按值传递：void addObject(std::shared_ptr&lt; Object &gt;obj);如果是智能指针，但不需要生命周期，则通过 .get() 获取原始指针后，按值传递：void modifyObject(Object *obj);\n","slug":"C-RAII与智能指针","date":"2022-11-06T04:22:00.000Z","categories_index":"C++","tags_index":"C++进阶,内存安全","author_index":"Ac-Accelerator"},{"id":"deafe07fcf5e4e17bdc29bc3bc203d8e","title":"深度学习多模态：CLIP","content":"本篇章搬运自同校同学snowy的笔记。\n什么是CLIPContrastive Language-Image Pre-Training—CLIP利用文本的监督信号训练一个迁移能力强的视觉模型\n\n这个模型有什么用呢？想象我们有一个图像分类的任务\n训练1000个类别，预测一张图片是这1000个类别中的哪一类\n现在如果加入50个新的类别的图像，试想会发生什么呢？\n传统的图像分类模型无法对类别进行拓展，想要保证准确率只能从头开始训练，费时费力。\nCLIP模型就可以用来解决这种问题，预训练后的模型就可以直接进行zero-shot\n\n与前人工作对比：\n\nCLIP论文指出，17年就已经开始有这些方法了，但是没获得太多关注。\n17年类似方法在ImageNet上的效果有17%。\n然后openAI说：不是方法不行，而是资源不到位（暴力出奇迹）\n一个648解决不了，那就再来十次648.。。。\n\nCLIP的成果：\n\nCLIP在完全不使用ImageNet中所有训练数据的前提下\n直接Zero-shot得到的结果与ResNet在128W ImageNet数据训练效果一致\nCLIP使用4亿个配对的数据和文本来进行训练，不标注直接爬取（没有解决transformer训练所需数据量大的缺点）\n\n监督训练和zero-shot在监督学习中，计算机通过示例学习。它从过去的数据中学习，并将学习的结果应用到当前的数据中，以预测未来的事件。在这种情况下，输入和期望的输出数据都有助于预测未来事件。无监督学习是训练机器使用既未分类也未标记的数据的方法。这意味着无法提供训练数据，机器只能自行学习。机器必须能够对数据进行分类，而无需事先提供任何有关数据的信息。简而言之：\n\n有监督训练：利用已经打好标签的数据训练模型。\n无监督训练：训练所用的数据没有任何标签。\n\n什么是zero-shot（零样本学习）：\n\n定义 zero-shot顾名思义即是对某些类别完全不提供训练样本，也就是说没有标注样本的迁移任务被称为zero-shot。\n不需要任何训练样本就可以直接进行预测\n模仿人脑的学习能力和知识的迁移能力，根据以往的经验对未知的事物做出预测。\n\n简单的zero-shot的实例：首先，我们可以将其视为一个类似于自然语言处理的任务，它使用词嵌入（将词汇表中的词或短语映射到实数向量，要求具有相似含义的词将具有相似的词嵌入）。那么对于上面的例子，零样本学习是下面这样来处理的，\n\n训练数据中并没有斑马的图像，但是有带条纹的动物（如老虎），有跟马长得相似的一类动物（如马、驴），还有黑白色的动物（如熊猫）的各种图像。可以提取这些图像的特征（条纹、形状似马、黑/白色）并生成词嵌入，组成字典。\n然后，我们描述斑马的外观，并使用前面训练集里提出的特征来将斑马的外观转化成相应的词嵌入。\n最后，当你给模型输入一张斑马的图像，它会先提取图像的特征，转化成词嵌入，然后与字典中最接近的词嵌入进行比较，得出那图像可能是只斑马。\n\n\n\n\n\n\n\n\n\n\n\nCLIP模型的基本架构模型训练：\n\n输入图片-&gt;图像编码器（vision transformer）-&gt;图片特征向量\n输入文字-&gt;文本编码器（text ）-&gt;文本特征向量\n对两个特征进行线性投射，得到相同维度的特征，并进行L2归一化\n计算两个特征向量的相似度（夹角余弦）\n对n个类别进行softmax，确定个正样本和个负样本，并最大化正样本的权重。\n\npython# 分别提取图像特征和文本特征\nI_f = image_encoder(I) #[n, d_i]\nT_f = text_encoder(T) #[n, d_t]\n\n# 对两个特征进行线性投射，得到相同维度的特征，并进行l2归一化\nI_e = l2_normalize(np.dot(I_f, W_i), axis=1)\nT_e = l2_normalize(np.dot(T_f, W_t), axis=1)\n\n# 计算缩放的余弦相似度：[n, n]\nlogits = np.dot(I_e, T_e.T) * np.exp(t)\n\n# 对称的对比学习损失：等价于N个类别的cross_entropy_loss\nlabels = np.arange(n) # 对角线元素的labels\nloss_i = cross_entropy_loss(logits, labels, axis=0)\nloss_t = cross_entropy_loss(logits, labels, axis=1)\nloss = (loss_i + loss_t)/2模型预测：\n\n给出一些文本提升（给出选项）\n选项中要包含正确答案\n然后计算每一个文本提升和图片特征的相似度。\n找到相似度最高的即为正确答案\n\n合理的提示：\n\n预测时的提示非常重要\n首先是需要一句话或者几个词来提示\n最好要加上预测的场景，要具有情景的相关性\n提示要全面，这样预测准确率也会提高。\n\n\nCLIP模型的展示","slug":"深度学习多模态：CLIP","date":"2022-11-06T03:54:00.000Z","categories_index":"人工智能","tags_index":"Transformer,多模态学习","author_index":"Ac-Accelerator"},{"id":"4d1e3a4a4afff0b0d31e07df9ad79915","title":"强化学习","content":"回顾监督学习： 学习一个模型，使得其能正确的将数据X映射到标签Y无监督学习 学习数据中潜在的结构以及信息\n强化学习的概念强化学习主要由两个对象组成：Environment(环境)和Agent(代理)。代理可以在环境中采取行动，改变环境的状态；环境返回给代理采取行动后整个环境的状态以及该行动的奖励；随后，代理根据新的状态和环境反馈的奖励，按照一定策略执行新的动作。\n强化学习的目的是学习如何根据环境的状态来采取行动以获得最大的奖励。\n在强化学习的过程中，代理将不被告知接下来该执行什么动作，而是通过多次的随机决策进行尝试，来发现获得最大奖励的行为。另外，随机决策的行为是对是错并不能马上得知，通常在完整的动作序列执行完毕才能得知，可以说是一个连续决策的问题。正因如此，当代理获得奖励的时候，将很难判断是过去的哪个行为导致获得了奖励，所以奖励分配在强化学习中显得非常重要。\n其次，在强化学习的过程中存在一些干扰，我们得到的状态可能是不完整的或者嘈杂的场景信息。同样，获得的奖励也可能带有干扰。例如：对同一个状态作出同一个动作，会在不同的时间步中获得不同的奖励。这里便是强化学习中随机性的来源。\n最后，强化学习存在不可微分的问题，因为我们并不知道环境是如何工作的，没有一个模型说明环境的行为方式。所以在进行反向传播的时候必须依靠其他的方法。\n强化学习的数学表达(马尔科夫决策过程)\n马尔科夫决策过程主要由如下的参数进行参与。  \n\n：可能状态的集合：可能采取动作的集合：通过状态和行为给予奖励的函数：下一个状态的转移概率分布：为近期奖励和远期奖励分配权重\n在时间步骤t=0的时候，环境从初始状态分布中采样得到，并将一些初始状态设置为0。对于每一个时间步：代理将选择一个行动。对于这个行动，环境从奖励函数采样返回一个奖励。然后环境再从中采样得到新的状态。最后代理接受环境的奖励和下一个状态，并继续根据最新的奖励和状态作出决策，直到接收到环境的终止信号。  \n基于以上的过程，我我们可以定义一个将状态映射到行为的函数，它指定了每个状态下要采取的行动，这个行动可以是确定性的也可以是随机的。\n可是，对于状态转移概率分布函数的抽样存在随机性；在不同的时间步中获得的奖励也有随机性。如何处理MDP中的随机性呢？解决方法是最大化预期奖励的总和，因为我们将获得实际奖励和实际结果在某种程度上是随机的，所以我们能做的是找到一个策略，将获得的期望值最大化\n\n其中：，，~\n定义：Value函数和Q-value函数：当我们遵循某个策略函数决策的时候，每次迭代都会产生一组行为轨迹(我们将把我们的初始状态设为零，然后进行马尔科夫决策过程，我们就会有一个状态、行动和奖励的轨迹)\n如何来评价：如果采取策略来行动，目前所处的状态有多好呢？价值函数的值，是遵循决策函数的条件下，从各个状态的决策中获得的预期累积奖励。\n\n如果状态值很高，这意味着从该状态开始以策略操作时，我们将在将来获得更多的奖励。\n如何来评估在状态s时采取的行动有多好呢？Q价值函数的值，是遵循决策函数，在状态下采取行动的预期累计奖励。\n\n不同场景下我们会选择动作值函数或者状态值函数来寻找最优策略\n最优值函数是从给定的(状态、行为)对中获得的最大期望累积报酬：\n\n告诉我：假设我们从状态s开始，然后在状态s中执行动作a，然后我们根据做在这种环境下我们能做的最好的事情，在接下来的时间里能获得多少奖励。和的关系：\n\n函数还满足Bellman等式  \n马尔科夫决策过程和贝尔曼方程\n\n如果下一个时间步骤的最优状态-动作已知，那么最优策略是采取是预期值最大化的动作。\n意思是：如果我们找到一个，那么它一定是。\n如何获得满足Bellman方程的函数呢？值迭代算法使用Bellman等式来迭代更新，可以使得无限接近于。\n\n但是这种方法需要显式的计算每个状态每个动作对应的值。对于小且有限的状态空间可以很好的运行。如果是对于很大的状态空间，基本上是不可计算的。如何解决？\n解决方法是通过一个神经网络去拟合，使用Bellman等式来提供一个损失函数。\nDeep Q-Learning训练一个带有权重的神经网络来近似。\n\n使用Bellman等式来告诉Q如何将状态和动作映射为输出。\n\n定义损失函数\n\n但是这种方法存在一些问题。问题一：预测的“目标”取决于当前网络本身的输出，随着网络的学习，网络预测的的结果会随着时间的推移进而改变。产生饿了非平稳性的问题。问题二：如何对训练中的批量数据进行采样。\nQ-Learning 和 策略梯度对于一些问题，可能很难学习到Q函数。对于某些问题，更容易学习从状态到操作的映射。  \n策略梯度：训练一个以状态为输入的网络，分配在该状态下采取的行动。\n目标函数：遵循决策时的预期累计奖励。输入神经网络的权重，给出如果我们执行该网络中的策略，我们在环境中获得的预期回报是多少。\n\n使用梯度上升来最大化奖励找到最优决策\n\n但是问题是无法计算，因为不可微。\n解决方法：定义为我们在遵循策略时的状态-行为轨迹。J为遵循策略下的预期奖励。\n\n\n\n\n这样我们就可以从策略中采样一些有限数量的轨迹来近似这个期望。\n\n转移概率分布依赖于无法直接观察到的环境，我们很难进行计算，但是我们可以学习到策略的行动可能性。\n\n求偏导，转移概率分布是无关项。\n\n这样，我们就可以让策略在环境中运行并收集轨迹x。预测行动分数相对于模型权重的梯度，反向传播至模型\n训练模型：1.初始化随机权值2.运行策略，收集轨迹x和使用政策  奖励f(X)3.计算4.梯度上升5.继续执行第二步\n如果f(x)较大，说明这个轨迹上的步骤都比较正确；如果如果f(x)较小，说明这个轨迹上的步骤都不太好。\n这个方法的缺点是我们需要很多轨迹来进行采样，才有可能获得较好的效果。\nActor-Critic训练一个预测行动的演员Actor(比如策略梯度)，一个评论家Critic预测我们从这些行动中得到的未来回报(比如Q-学习)。\nModel-Based学习世界状态转换函数的模型，然后通过模型进行规划决策.\nImitation Learning收集有关专家在环境中表现的数据，学习模仿他们所做的事情的函数(监督学习方法)\nInverse Reinforcement收集专家在环境中执行的数据，学习他们似乎正在优化的区域函数，然后在该奖励函数上使用强化学习。\nAdversarial Learning学会愚弄一个将行为分类为真实/假的鉴别者。\n","slug":"强化学习","date":"2022-07-14T13:23:00.000Z","categories_index":"人工智能","tags_index":"强化学习","author_index":"Ac-Accelerator"},{"id":"298601bdff7402f7c70804cf98e17980","title":"Python小应用——删除答案","content":"初衷有时候呢，考试前学校会发一些docx文档型的资料。这些资料类似于填了答案的填空题，方便我们快速复习、查找重点。然而一旦我们想要测试一下自己是不是真正记住了，就会想这如何不去看“答案”而把问题回答出来，就像做真正的填空题一样。你可以用手指蒙住，也可以手动将他们全部删除。  \n\n\n但是就我而言，手指蒙住根本抵挡不了看答案诱惑。我又是个懒鬼，不想一个一个删除（其实我还想通过看下划线的长短，或多或少的记起答案）。虽然这次一个一个删除省事一些，可是一想到以后可能还会遇到这种情况，我就忍不住偷懒了，加上我对编程感兴趣，索性用python来做一个小脚本。\n准备工作安装python-docx库。\ntxtpip install python-docxpython-docx的官方使用文档  \n可以参考B站的一个视频。稍微了解一下这个库的功能结构，我们便可以对docx文档进行任何想进行的操作。\n实践操作下面贴上代码和注释：\npythonfrom docx import Document\nimport docx\n\n#用已存在的文件'知识汇总.docx'创建一个Document对象，赋值给变量doc。这里可以是文件的绝对路径也可以是相对路径。\ndoc=Document('知识汇总.docx')\nprint(\"opened successfully,start processing\")\n\n#文章是由一个一个段落组成的，我们遍历所有段落\nfor p in doc.paragraphs:\n    #段落是由块组成的，我们遍历文章里的每一个块。\n    for block in p.runs:\n        #我这里是希望找到有下划线格式的块进行操作。你可以改变条件或者操作达到你想要的效果。\n        if(block.font.underline):\n            #替换\n            block.text='  '*len(block.text)\nprint('changed successfully')\n\n# doc.save('知识汇总.docx')#直接覆盖\ndoc.save('知识汇总(无答案版).docx')#保存到新的文件\nprint(\"saved successfully\")效果是这样啦\n","slug":"Python小应用——删除答案","date":"2022-06-01T09:22:00.000Z","categories_index":"Python","tags_index":"python-docx,docx,Python","author_index":"Ac-Accelerator"},{"id":"3adc7cb84d4ac3fb8fab9c8bd90e7a93","title":"计算机网络(四)","content":"传输层只有主机才有的层次  \n功能\n传输层提供进程和进程之间的逻辑通信  \n分用和复用。  \n对收到的报文进行差错检测。  \nTCP和UDP。\n\n复用:应用层所有的应用进程都可以通过传输层再传输到网络层。分用:传输层从网络层收到数据后交付指明的应用进程。  \n端口是传输层的SAP，标识主机中的应用进程。端口号只有本地意义，在因特网中不同计算机的相同端口是没有联系的。端口号长度为16bit，能表示65536个不同的端口号。  \n\n端口号\n服务端使用的端口号\n熟知端口号：给TCP/IP最重要的一些应用程序，让所有用户都知道。0~1023。\n登记端口号:为没有熟知端口号的应用程序使用的。1024~49151。\n\n\n客户端使用的端口号：客户端使用:仅在客户进程运行时才动态选择。49152~65535。\n\n\n\n\n\n\n应用程序\nFTP\nTELNET\nSMTP\nDNS\nTFTP\nHTTP\nSNMP\n\n\n\n熟知端口号\n21\n23\n25\n53\n69\n80\n161\n\n\n在网络中采用发送方和接收方的套接字组合来识别端点，套接字唯一标识了网络中的一个主机和它上面的一个进程。套接字Socket=(主机IP地址，端口号)\nUDP协议UDP只在IP数据报服务之上增加了很少功能，即复用分用和差错检测功能。\n特点\nUDP是无连接的，减少开销和发送数据之前的时延。\nUDP使用最大努力交付，即不保证可靠交付。\nUDP是面向报文的，适合一次性传输少量数据的网络应用。\nUDP无拥塞控制，适合很多实时应用。\nUDP首部开销小，8Bit，而TCP有20Bit。\n\n面向报文：应用层给UDP多长的报文，UDP就照样发送，即一次发一个完整报文。\n分用时，找不到对应的目的端口号，就丢弃报文，并给发送方发送ICMP“端口不可达”差错报告报文。\nTCP协议TCP协议的特点\nTCP是面向连接（虚连接）的传输层协议。\n每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的。\nTCP提供可靠交付的服务，无差错、不丢失、不重复、按序到达。\nTCP提供全双工通信。\nTCP面向字节流，把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。\n\n为了提供全双工通信，设立一个发送缓存和一个接收缓存。发送缓存是保存准备发送的数据和己发送但尚未收到确认的数据。接收缓存是保存按序到达但尚未被接受应用程序读取的数据和不按序到达的数据。  \nTCP的连接管理TCP连接传输三个阶段：连接建立→数据传送→连接释放 \nTCP连接的建立采用客户服务器方式，主动发起连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫服务器。  \n建立过程假设运行在一台主机（客户)上的一个进程想与另一台主机（服务器）上的一个进程建立一条连接，客户应用进程首先通知客户TCP，他想建立一个与服务器上某个进程之间的连接，客户中的TCP会用以下步骤与服务器中的TCP建立一条TCP连接。\n\n客户端发送连接请求报文段，无应用层数据。\n服务器端为该TCP连接分配缓存和变量，并向客户端返回确认报文段，允许连接，无应用层数据。\n客户端为该TCP连接分配缓存和变量，并向服务器端返回确认的确认，可以携带数据。\n\nSYN洪泛攻击SYN洪泛攻击发生在OSI第四层，这种方式利用TCP协议的特性，就是三次握手。攻击者发送TCP SYN，SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者。这样更加会浪费服务器的资源。攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。\n可以通过设置SYN cookie来解决。\n释放过程参与一条TCP连接的两个进程中的任何一个都能终止该连接，连接结束后，主机中的“资源”（缓存和变量）将被释放。\n\n客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接。\n服务器端回送一个确认报文段,客户到服务器这个方向的连接就释放了————半关闭状态。\n服务器端发完数据,就发出连接释放报文段,主动关闭TCP连接。\n客户端回送一个确认报文段，再等到时间等待计时器设置的2MSL(最长报文段寿命）后，连接彻底关闭。\n\nTCP可靠传输确认重传不分家，TCP的发送方在规定的时间内没有收到确认就要重传己发送的报文段。重传时间采用自适应算法，动态改变重传时间RTTs （加权平均往返时间）。\n其实实现方法与链路层大同小异。\nTCP流量控制TCP利用滑动窗口机制实现流量控制。  \n在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，即接收窗口rwnd（接收方设置确认报文段的窗口字段来将rwnd通知给发送方），发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值。\nTCP为每一个连接设有一个持续计时器，只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期,就发送一个零窗口探测报文段。接收方收到探测报文段时给出现在的窗口值。若窗口仍然是0，那么发送方就重新设置持续计时器。\nTCP拥塞控制出现拥塞的条件:对资源需求的总和&gt;可用资源\n网络中有许多资源同时呈现供应不足→网络性能变坏→网络吞吐量将随输入负荷增大而下降\n拥塞控制:防止过多的数据注入到网络中。\n慢开始和拥塞避免快重传和快回复\n应用层应用层对应用程序的通信提供服务。  \n应用层协议定义:应用进程交换的报文类型，请求还是响应?各种报文类型的语法，如报文中的各个字段及其详细描述。字段的语义，即包含在字段中的信息的含义。进程何时、如何发送报文，以及对报文进行响应的规则。  \n应用层的重要协议;FTP、SMTP、POP3、HTTP、DNS\n应用层的功能\n文件传输、访问和管理\n电子邮件\n虚拟终端\n查询服务和远程作业登录\n\n网络应用模型客户/服务器模型(Client/Server)服务器:提供计算服务的设备。\n\n永久提供服务\n永久性访问地址/域名\n\n客户机:请求计算服务的主机。\n\n与服务器通信，使用服务器提供的服务\n间歇性接入网络\n可能使用动态IP地址\n不与其他客户机直接通信\n\nP2P模型(Peer-to-peer)\n\n不存在永远在线的服务器  \n每个主机既可以提供服务，也可以请求服务\n任意端系统/节点之间可以直接通讯  \n节点间歇性接入网络  \n节点可能改变IP地址可扩展性好  \n网络健壮性好\n\n域名解析系统DNS随着网络的发展，对于上网的网民，记住各个网站IP地址是极为困难的。为了解决这个问题，计算机网络使用了域名，即通过有意义的字符串来代替网络中的主机。但是归根结底，设备间的通信还是要知道IP地址的，DNS就是提供了域名到IP地址的转换。\n比如www.baidu.com就是域名，最右边的叫做顶级域名，从右向左以此类推：顶级域名，二级域名，三级域名……\n域名服务器当一个主机发出DNS查询请求时，这个查询请求报文就发给本地域名服务器。如果本地域名服务器没有记录对应域名的IP地址，则查找根域名服务器，根域名服务器返回顶级域名服务器的IP地址，如果顶级域名服务器无法解析，则返回对应权限域名服务器。依次进行查询。\n域名查询方式  \n\n递归查询  \n迭代查询一般采取递归和迭代相结合的方式\n\n文件传输协议FTP提供不同种类主机系统（硬、软件体系等都可以不同）之间的文件传输能力。  \nFTP服务器和用户端FTP是基于客户/服务器（C/S）的协议。用户通过一个客户机程序连接至在远程计算机上运行的服务器程序。依照FTP协议提供服务，进行文件传送的计算机就是FTP服务器。连接FTP服务器，遵循FTP协议与服务器传送文件的电脑就是FTP客户端。  \nFTP工作原理要连接到FTP服务器并且从FTP服务器中操作数据，就需要：FTP服务器的地址，注册的用户名密码。\n匿名登录：互连网中有很大一部分FTP服务器被称为“匿名”(Anonymous）FTP服务器。这类服务器的目的是向公众提供文件拷贝服务，不要求用户事先在该服务器进行登记注册，也不用取得FTP服务器的授权。Anonymous（匿名文件传输）能够使用户与远程主机建立连接并以匿名身份从远程主机上拷贝文件，而不必是该远程主机的注册用户。用户使用特殊的用户名“anonymous”登陆FTP服务，就可访问远程主机上公开的文件。\nFTP实现TCP实现可靠传输。\n服务器的进程分为一个主进程和其他多个从属进程，主进程负责打开端口接受其他主机的请求。收到一个请求，就会启动一个从属进程为该请求的主机提供服务。\n控制连接始终保持数据连接保持一会  \n数据连接的端口号与传输方式有关：主动方式使用TCP 20端口被动方式由服务器和客户端自行协商决定（端口&gt;1024)  \nFTP传输模式：文本模式: A5CI模式，以文本序列传输数据;二进制模式: Binary模式,以二进制序列传输数据。\n电子邮件简单邮件传送协议SMTP：SMTP规定了在两个相互通信的SMTP进程之间应如何交换信息。负责发送邮件的SMTP进程就是SMTP客户，负责接收邮件的进程就是SMTP服务器。SMTP规定了14条命令(几个字母）和21种应答信息（三位数字代码t简单文字说明）。SMTP使用TCP协议连接，端口号25\nSMTP通信三个阶段:连接建立→邮件传送→连接释放\n通用因特网邮件扩充协议MIME：SMTP的缺点:1.SMTP不能传送可执行文件或者其他二进制对象。2.SMTP仅限于传送7位ASCIl码，不能传送其他非英语国家的文字。3.SMTP服务器会拒绝超过一定长度的邮件。\nMIME协议通过将非ASCII码转化成ASCII码，然后再交付给STMP进行传输，从而达到相关的目的。MIME使电子邮件系统可以支持声音、图像、视频、多种国家语言等等。使得传输内容丰富多彩。 \n邮局协议POP3POP3使用TCP协议连接，端口号110\n网际报文存取协议IMAP：由于POP3协议存在某些缺点，功能有限，于是产生了IMAP协议。IMAP协议比POP协议复杂。当用户PC上的IMAP客户程序打开IMAP服务器的邮箱时，用户可以看到邮箱的首部，若用户需要打开某个邮件，该邮件才上传到用户的计算机上。IMAP可以让用户在不同的地方使用不同的计算机随时上网阅读处理邮件，还允许只读取邮件中的某一个部分(先看止文，有WiFi的时候再下载附件)。\n基于万维网的电子邮件使用HTTP协议和SMTP协议。用户到服务器使用HTTP，服务器之间使用的还是SMTP协议\n万维网和HTTP协议万维网WWW （World Wide Web）是一个大规模的、联机式的信息储藏所/资料空间，是无数个网络站点和网页的集合。  \n通过设置统一资源定位符URL唯一标识网络上某个资源（不区分大小写）。&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;协议：HTTP和FTP等主机：域名和IP地址都可以\n用户通过点击超链接（http;//www.baidu.com）获取资源，这些资源通过超文本传输协议（HTTP）传送给使用者。万维网以客户/服务器方式工作，用户使用的浏览器就是万维网客户程序，万维网文档所驻留的主机运行服务器程序。万维网使用超文本标记语言HTML，使得万维网页面设计者可以很方便地从一个界面的链接转到另一个界面，并能够在自己的屏幕上显示出来。\n超文本传输协议HTTPHTTP协议定义了浏览器（万维网客户进程）怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。  \n用户：1.输入URL2.点击超链接  \n服务器：有一个服务器进程监听TCP的端口80\n具体过程:  \n\n浏览器分析URL  \n浏览器向DNS请求解析IP地址  \nDNS解析出IP地址\n浏览器与服务器建立TCP连接  \n浏览器发出取文件命令  \n服务器响应  \n释放TCP连接  \n浏览器显示\n\nHTTP协议的特点：HTTP是无状态的。对于每个相同的HTTP请求，服务器都会给予同样的回应。\n但是在实际工作中，一些万维网站点常常希望能够识别用户。\nCookie是存储在用户主机中的文本文件，记录一段时间内某用户的访问记录。这样就可以提供个性化服务。\nHTTP采用TCP作为运输层协议，但HTTP协议本身是无连接的(通信双方在交换HTTP报文之前不需要先建立HTTP连接)。\n","slug":"计算机网络-四","date":"2022-05-30T14:18:00.000Z","categories_index":"网络","tags_index":"网络,传输层,应用层","author_index":"Ac-Accelerator"},{"id":"3a327b02e6446ad9da6af37fe8dd2226","title":"神经网络的反向传播","content":"反向传播基本思想向前传播函数：   \n\nSVM损失函数，计算每一个样本的损失：  \n  \n附带正则项的所有样本SVM损失的平均值函数，带上正则项可以使得模型更加简单，更容易泛化。\n\n所以在损失函数中，我们希望找到一个合适的，使得这个更小，因为这样模型精度更高，准确率更好。\n那如何去找最优解呢？我们需要将作为函数的自变量，然后求解出当前状态下的对于的梯度,即，然后将朝着与梯度相反的方向调整，就可以使得损失函数的值最快地下降，如此往复迭代，就可以找到损失函数的最小值点。  \n使用计算图框架来理解反向传播算法如何递归的调用链式法则()来计算每个变量的梯度。\n为什么我们不直接解出中每个元素对的导函数，但是这种方法不推荐。因为对于计算机来说，可能会求解出非常复杂且多余的表达式(比如没有合并同类项)，这样会降低训练的效率；如果函数非常复杂，对其求导的步骤也会很冗杂，并且不能有效的利用之前的计算结果；递归更加容易理解和表达。\n计算图框架如下：\n如果出现分支的情况，则梯度需要相加:\n对矩阵求偏导公式：对于函数其偏导公式为更多求导公式\n神经网络介绍神经网络就是由简单函数构成的一组函数在顶层堆叠在一起。我们用一种层次化的方式将它们堆叠起来去形成一个更复杂的非线性函数。主要使用矩阵乘法来实现。\n神经网络有多层，每一层之间需要激活函数来连接，否则在逻辑上相当于没有分层。\n每一层的权重参数矩阵相当于多个特征的模板，一个分类的模板代表着使得该分类的神经元输出值最大的输入，形象的说就是该神经元希望在输入中寻找的特征。例如该卷积网络\n每一层的输出都是对该层输入的一个特征提取的得分，这些得分可以作为输入进入到下一层进行更加高级的处理。\n和生物学神经网络的联系：生物学的神经网络异常复杂，人工神经网络只是对真实神经网络的简化、抽象的表达。(有研究表明ReLU激活函数同真实神经激活相似，但仍需考虑真实神经网络中激活阈值发生变化的可能性。)\n","slug":"神经网络的反向传播","date":"2022-05-18T02:11:00.000Z","categories_index":"人工智能","tags_index":"反向传播","author_index":"Ac-Accelerator"},{"id":"0ca60c06fd1d7a39272aeb0b754b415e","title":"计算机网络(三)","content":"网络层把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。网络层传输单位是数据报。\n功能功能一:路由选择与分组转发最佳路径功能二:异构网络互联功能三:拥塞控制（开环控制、静闭环控制）\n数据交换方式电路交换当两台主机要通信的时候，将建立一条物理上的链路用于通信，类似于过去的电话进行接线。\n特点：独占资源\n优点:\n\n通信时延小\n有序传输\n没有冲突\n实时性强\n\n缺点:\n\n建立连接时间长\n线路独占,使用效率低\n灵活性差\n无差错控制能力\n\n报文交换当两个主机要通信的时候，会将报文发送到交换设备上，交换设备会先对报文进行储存，等到目标链路空闲的时候，再对报文进行转发。\n优点：\n\n无需建立连接\n存储转发,动态分配线路\n线路可靠性较高\n线路利用率较高\n多目标服务（一个报文可以发往多个目标地址）\n\n缺点：\n\n有存储转发时延（串行转发）\n报文大小不定,需要网络节点有较大缓存空间\n\n分组交换分组:把大的数据块分割成小的数据块。在报文交换中,因为报文大小不定,需要网络节点有较大缓存空间。分组交换通过把大的数据块分割成小的数据块改善了这点。\n优点：\n\n无需建立连接\n存储转发,动态分配线路\n线路可靠性较高\n线路利用率较高\n相对于报文交换，存储管理更容易\n时延比报文交换要小（并行转发）\n\n缺点：\n\n有存储转发时延（相对于电路交换）\n需要传输额外的信息量\n乱序到目的主机时，要对分组排序重组\n\n数据报方式（Internet正在使用的）提供无连接服务  \n无连接服务:不事先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同。\n路由器根据分组的目的地址转发分组:基于路由协议/算法构建转发表、检索转发表;每个分组独立选路。\n不保证分组的有序到达。\n虚电路方式提供连接服务，是数据报方式和电路交换方式的结合。\n连接服务:首先为分组的传输确定传输路径（建立连接），然后沿该路径(连接）传输系列分组，系列分组传输路径相同，传输结束后拆除连接。\n虚电路:一条源主机到目的主机类似于电路的路径（逻辑连接)，路径上所有结点都要维持这条虚电路的建立,都维持一张虚电路表，每一项记录了一个打开的虚电路的信息。\n目的地址仅在建立连接阶段使用,之后每个分组使用长度较短的虚电路号\n比较\n\n\n\n特点\n数据报服务\n虚电路服务\n\n\n\n连接的建立\n不要\n必须要\n\n\n目的地址\n每个分组都有完整的目的地址\n仅在建立连接阶段使用，之后每个分组使用长度较短的虚电路号\n\n\n路由选择\n每个分组独立地进行路由选择和转发\n属于同一条虚电路的分组按照同一路由转发\n\n\n分组顺序\n不保证分组的有序到达\n保证分组的有序到达\n\n\n可靠性\n不保证可靠通信，可靠性由用户主机来保证\n可靠性由网络保证\n\n\n对网络故障的适应性\n出故障的结点丢失分组，其他分组路径选择发生变化，可正常传输\n所有经过故障结点的虚电路均不能正常工作\n\n\n差错处理和流量控制\n由用户主机进行流量控制，不保证数据报的可靠性\n可由分组交换网负责，也可由用户主机负责\n\n\n路由算法静态路由算法管理员手工配置路由信息。优点：简便、可靠,在负荷稳定、拓扑变化不大的网络中运行效果很好，广泛用于高度安全性的军事网络和较小的商业网络。缺点：路由更新慢，不适用于大型网络\n动态路由算法路由器间彼此交换信息，按照路由算法优化出路由表项。优点：路由更新快，适用大型网络，及时响应链路费用或网络拓扑变化。缺点:算法复杂，增加网络负担。\n全局性链路状态路由算法(OSPF)网络层协议,直接IP传输所有路由器掌握完整的网络拓扑和链路费用信息，每隔30分钟刷新一次数据库中的链路状态，适用于大规模网络，收敛速度很快。\n迪杰斯塔拉算法。。。梦回离散数学。。。\nOSPF协议如何工作：\n\n使用洪泛法向自治系统内所有路由器发送信息，即路由器通过输出端口向所有相邻的路由器发送信息，而每一个相邻路由器又再次将此信息发往其所有的相邻路由器。最终整个区域内所有路由器都得到了这个信息的一个副本\n发送的信息就是与本路由器相邻的所有路由器的链路状态（本路由器和哪些路由器相邻，以及该链路的度量/代价――费用、距离、时延、带宽等）。\n只有当链路状态发生变化时，路由器才向所有路由器洪泛发送此信息。\n\n链路状态路由算法：\n\n每个路由器发现它的邻居结点[HELLO问候分组]，并了解邻居节点的网络地址。\n设置到它的每个邻居的成本度量metric。\n构造[DD数据库描述分组]，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。\n如果DD分组中的摘要自己都有，则邻站不做处理;如果有没有的或者是更新的，则发送[LSR链路状态请求分组]请求自己没有的和比自己更新的信息。\n收到邻站的LSR分组后，发送[LSU链路状态更新分组]进行更新。\n更新完毕后，邻站返回一个[LSAck链路状态确认分组]进行确认。\n\n只要一个路由器的链路状态发生变化:\n\n泛洪发送[LSU链路状态更新分组]进行更新。\n更新完毕后，其他站返回一个[LSAck链路状态确认分组]进行确认。\n\n最后使用Dijkstra根据自己的链路状态数据库构造到其他节点间的最短路径。\n分散性距离向量路由算法(RIP)应用层协议，采用UDP传输。RIP是一种分布式的基于距离向量的路由选择协议，是因特网的协议标准，最大优点是简单，但是如果出现网络故障，该网络故障信息就会传播的比较慢。网络中每一个路由器都维护从它自己到其他每一个目的网络的唯一最佳距离(从源端口到目的端口所经过的路由器个数)记录。RIP允许一条路由最多只能包含15个路由器，因此距离为16表示网络不可达，所以只适用于小互联网。  \nRIP协议如何工作：\n\n仅和相邻路由交换RIP报文，一个RIP报文最多可包括25个路由，如超过，必须再用一个RIP报文传送。\n每30秒交换一次路由信息，然后路由器根据新信息更新路由表。若超过180s没收到相邻路由器的通告，则判定该相邻路由器失效，并更新自己路由表。\n经过若干次更新后，所有路由器最终都会知道到达本自治系统任何一个网络的最短距离和下一跳路由器的地址，即“收敛”。\n\n距离向量算法\n\n修改相邻路由器发来的RIP报文中所有表项对地址为x的相邻路由器发来的RIP报文，修改此报文中的所有项目:把“下一跳”字段中的地址改为X，并把所有的“距离”字段+1。\n对修改后的RIP报文中的每一个项目，进行以下步骤:\nR1路由表中若没有Net3，则把该项目填入R1路由表\nR1路由表中若有Net3，则查看下一跳路由器地址:若下一跳是x，则用收到的项目替换源路由表中的项目;若下一跳不是x，原来距离比从x走的距离远则更新，否则不作处理。\n\n\n若180s还没收到相邻路由器x的更新路由表，则把x记为不可达的路由器，即把距离设置为16\n\n路由选择协议因特网规模很大，而且许多单位不想让外界知道自己的路由选择协议，但还想连入因特网，因此诞生了路由分层次的路由选择协议\n自治系统AS:在单一的技术管理下的一组路由器，而这些路由器使用一种AS内部的路由选择协议和共同的度量以确定分组在该AS内的路由，同时还使用一种AS之间的路由协议以确定在AS之间的路由。一个AS内的所有网络都属于一个行政单位来管辖，一个自治系统的所有路由器在本自治系统内都必须连通。\n内部网关协议IGP常用算法为RIP和OSPF\n外部网关协议BGP常用算法为BGP\nBGP协议：属于应用层协议，TCP传输BGP支持CIDR，因此 BGP的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。与其他AS的邻站BGP发言人交换网络可达性的信息，即要到达某个网络所要经过的一系列AS。发生变化时更新有变化的部分。当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各AS的较好路由。\nBGP-4的四种报文\n\nOPEN(打开）报文:用来与相邻的另一个BGP发言人建立关系，并认证发送方。\nUPDATE（更新）报文:通告新路径或撤销原路径\nKEEPALIVE（保活）报文:在无UPDATE时，周期性证实邻站的连通性;也作为OPEN的确认。\nNOTIFICATION(通知）报文:报告先前报文的差错;也被用于关闭连接。\n\n网络地址转换网络地址转换NAT(Network Address Translation):在专用网连接到因特网的路由器上安装NAT软件，安装了NAT软件的路由器叫NAT路由器，它至少有一个有效的外部全球IP地址。NAT百度百科\n子网划分和子网掩码某单位划分子网后，对外仍表现为一个网络，即本单位外的网络看不见本单位内子网的划分。子网划分就是将IP地址划分为网络前缀和主机号。  \n目标地址和子网掩码逐位相与，则得到目标所在的子网的地址。  \n子网掩码由连续的1和0组成，将网络前缀全部改成1，主机号全部改成0，即可得到当前子网的子网掩码\n无分类域间路由选择CIDR:消除了传统的A类，B类和c类地址以及划分子网的概念。记法:IP地址后加上“/”，然后写上网络前缀（可以任意长度)的位数。e.g.128.14.32.0/20。\n使用CIDR时，查找路由表可能得到几个匹配结果，应选择具有最长网络前缀的路由。前缀越长，地址块越小，路由越具体。\n构成超网和划分子网相逆的过程。将多个子网聚合成一个较大的子网，叫做构成超网，或路由聚合。方法：将网络前缀缩短。\n这也是为什么使用CIDR时，在路由表的几个匹配结果中，要选择具有最长网络前缀的路由。\nARP协议由于在实际网络的链路上传送数据帧时，最终必须使用MAC地址。ARP协议:完成主机或路由器IP地址到MAC地址的映射。解决下一跳走哪的问题。  \nARP协议使用过程:检查ARP高速缓存，有对应表项则写入MAC帧，没有则用目的MAC地址为FF-FF-FF-FF-FF-FF的帧封装并广播ARP请求分组，同一局域网中所有主机都能收到该请求。目的主机收到请求后就会向源主机单播一个ARP响应分组，源主机收到后将此映射写入ARP缓存（10-20min更新一次）。ARP协议4种典型情况:  \n\n主机A发给本网络上的主机B:用ARP找到主机B的硬件地址;\n主机A发给另一网络上的主机B:用ARP找到本网络上一个路由器（网关）的硬件地址;\n路由器发给本网络的主机A:用ARP找到主机A的硬件地址;\n路由器发给另一网络的主机B:用ARP找到本网络上的一个路由器的硬件地址。\n\nDHCP协议用于动态分配IP地址，是一种基于UDP的应用层协议。\nDHCP提供即插即用联网的机制，主机可以从服务器动态获取IP地址、子网掩码、默认网关、DNS服务器名称与IP地址,允许地址重用，支持移动用户加入网络，支持在用地址续租*。\n运行方法：\n\n主机广播DHCP发现报文，查找网络中的DHCP服务器，服务器获得一个IP地址。\nDHCP服务器广播DHCP提供报文，服务器拟分配给主机一个IP地址及相关配置。主机收到该报文之后，停止接受其他的DHCP提供报文。\n主机广播DHCP请求报文，告知其他的DHCP服务器，主机已经获得该IP地址。\nDHCP服务器广播DHCP确认报文，正式将地址分配给主机。\n\nICMP协议ICMP五种差错报文：\n\n终点不可达:当路由器或主机不能交付数据报时就向源点发送终点不可达报文。\n源点抑制(不再使用):当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。\n时间超过:当路由器收到生存时间TTL=O的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。\n参数问题:当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。\n改变路由(重定向)﹔路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器(可通过更好的路由）。\n\n不发送ICMP差错报文的情况\n\n对ICMP差错报告报文不再发送ICMP差错报告报文。\n对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文。\n对具有组播地址的数据报都不发送ICMP差错报告报文。\n对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错报告报文。\n\nICMP询问报文：\n\n回送请求和回答报文：主机或路由器向特定目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。测试目的站是否可达以及了解其相关状态。\n时间戳请求和回答报文︰请某个主机或路由器回答当前的日期和时间。用来进行时钟同步和测量时间。\n掩码地址请求和回答报文(不再使用)\n路由器询问和通告报文(不再使用)\n\nICMP的应用PING：测试两个主机之间的连通性，使用了ICMP回送请求和回答报文。Traceroute：跟踪一个分组从源点到终点的路径，使用了ICMP时间超过差错报告报文。\n移动IPA刚进入外部网络:\n\n在外部代理登记获得一个转交地址，离开时注销。\n外地代理向本地代理登记转交地址。\n\nB给A发送数据报:\n\n本地代理截获数据报。\n本地代理再封装数据报，新的数据报目的地址是转交地址，发给外部代理（隧道)。\n外部代理拆封数据报并发给A。\n\nA给B发送数据报:A用自己的主地址作为数据报源地址，用B的IP地址作为数据报的目的地址。\nA移动到了下一个网络:\n\n在新外部代理登记注册一个转交地址。\n新外部代理给本地代理发送新的转交地址（覆盖旧的）。3.通信\n\nA回到了归属网络:\n\nA向本地代理注销转交地址。\n按原始方式通信。\n\n网络层设备路由器：路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组。功能：\n\n路由选择：根据所选定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表。 \n分租转发\n交换结构:根据转发表（路由表得来〉对分组进行转发。\n\n分组若收到RIP/OSPF分组等，则转发把分组送往路由选择处理机;若收到数据分组，则查找转发表并输出。\n\n\n\n\n若路由器处理分组的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃。\n","slug":"计算机网络-三","date":"2022-05-16T06:14:00.000Z","categories_index":"网络","tags_index":"网络,网络层","author_index":"Ac-Accelerator"},{"id":"0c89500007ef3b784b27319aeed34361","title":"Java学习笔记(三)","content":"Maven构建工具构建工具功能:\n\n自动帮程序员甄别和下载第三方库(jar)\n完成整个项目编译(调用javac.exe)\n完成整个项目单元测试流程(调用Junit工具)\n完成项目打包(jar/war等格式，调用jar.exe)\nMaven是通过pom.xml文件来进行项目管理的。\n第三方库的使用方法：在中心库里面搜索自己想要的库，然后将依赖文本拷贝到pom.xml中的dependencies标签内部，即完成引入。\n\nMaven工具是单独下载的并且需要为其配置环境变量。必须保证系统变量中有JAVA_HOME变量且指向正确的地址。安装路径下的/conf/settings.xml文件是该应用的设置，内部有详细的注释帮助用户来个性化maven。安装完成后在cmd里面输入mvn help:system进行初始化，会下载大量文件。\n我由始至终都坚持使用Visual Studio Code进行开发。这里推荐几个别人的视频，对我的帮助很大，本人已经三连。VSCode及JDK配置Maven安装和配置VSCode创建Maven项目\n单元测试和JUnit测试：\n\n*白盒测试(white-box testing)*，全面了解程序内部逻辑结构，对所有的逻辑路径都进行测试。一般由程序员完成。  \n*黑盒测试(black-box testing)*，又名功能测试，将程序视为一个不能打开的黑盒子。在完全不考虑程序内部结构和内部特性的情况下，检查程序功能是否按照需求规格说明书的规定正常使用。一般由独立的使用者完成。\n单元测试(unit testing) ，是指对软件中的最小可测试单元进行检查和验证。通常是一个函数/方法。单元测试是已知代码结构进行的测试，属于白盒测试。\n集成测试是将多个单元相互作用，形成一个整体，对整体协调性进行测试。一般从构成系统的最小单元开始，持续推进到单元之间的接口直到集成为一个完成的软件系统为止。\n自动测试︰用程序批量、反复测试程序，并可自动检查程序结果是否满足预定的要求。\n手动测试:手动执行程序，手动输入所需要的参数，手动检查程序结果是否满足预定的要求。\n回归测试︰修改旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。回归测试在整个软件测试过程中占有很大的比重。软件快速迭代开发过程中，新版本的连续发布(Daily /Nightly Build)使得回归测试进行的更加频繁。\n\n测试策略\n\n基于main函数的策略\n优点:简单\n缺点:无法自动判断被测对象的行为是否符合预期，main方法需要添加大量的代码，这些代码在发布时候也需要手动删除，分散程序员在开发时的关注点\n\n\n基于自动化测试框架的策略\n初始化-&gt;输入测试数据执行被测代码-&gt;获取系统实际结果-&gt;比较结果是否一致-&gt;输出测试结论\n\n\n\n使用Maven构建的程序会自带一个test文件，在VSCode中可以很方便的进行测试。\nJava语法糖语法糖:Syntactic sugar / Syntax sugar语法糖使得程序员更容易编写程序，更清晰准确表达业务逻辑。不仅仅是语法的转换，也包括一些小的改进。\nfor和for-each\nfor-each 从JDK5.0开始引入，语法更简洁\nfor-each 可以避免越界错误\nfor可以删除元素，for-each不可以删除/替换元素\nfor-each遍历的时候，是不知道当前元素的具体位置索引\nfor-each只能正向遍历，不能反向遍历\nfor-each不能同时遍历2个集合\nfor和for-each性能接近\n\n使用方法如下：nums是某个可迭代数据类型的对象，item是其中的每个数据，和C++一样。\njavafor(double item : nums){\n    system.out.println(item);\n}枚举类型：枚举变量:变量的取值只在一个有限的集合内，如性别、星期几、颜色等。\n\nenum关键字声明枚举类，且都是Enum的子类(但不需写extends)\nenum内部有多少个枚举量，就有多少个实例对象\n不能直接new枚举类对象\n除了枚举量，居然还可以添加属性/构造函数/方法?!\n构造函数只能是package-private(default)或者private，内部调用。\nordinal()返回枚举量所在的索引位置,从0开始\ncompareTo()比较两个枚举量的索引位置大小\ntoString()返回枚举量的字符串表示\nvalueOf()将字符串初始化为枚举对象\nvalues()返回所有的枚举量\n\n使用方法如下：个人感觉比和C++ 有很多不同。\njavaenum Fruit\n{\n    APPLE,ORANGE,BANANA(8),PEACH;\n  //使用括号定义索引位置，和C++使用\"=\"不同；索引位置的值只能是整数。\n  //每个枚举量都有一个索引位置，如果如上定义，则apple值是0，orange值为1，banana为8，peach为9；\n    private int price;\n    Fruit(int price) {\n        this.price = price;\n    }\n    public int getPrice() {\n        return this.price;\n    }\n}不定项参数和C++ 不同的是 C++ 要使用函数模板来实现。C++ :\ncpptemplate &lt;class... Tmp&gt;\nvoid print(Tmp... pargs);Java就是这样的：\njavapublic static void print(String... args){\n  system.out.println(args.length);\n  for (String arg : args){\n    system.out.println(arg);\n  }\n}\n一个方法只能有一个不定项参数，且必须位于参数列表的最后\n重载的优先级规则1:固定参数的方法，比可变参数优先级更高\n重载的优先级规则2:调用语句，同时与两个带可变参数的方法匹配，则报错。\n\n静态导入import static导入一个类的静态方法和静态变量。\njavaimport static java.lang.Math.pow;//引入pow函数\nimport static java.lang.Math.sqrt;//引入sqrt函数\nimport static java.lang.System.* ;//引入System下的所有静态方法和静态变量。\nimport static java.lang.System.out;//引入System的静态变量out。少使用*通配符，不滥用，最好具体到静态变量或方法。静态方法名具有明确特征，如有重名，需要补充类名。  \n自动装箱和拆箱\n装箱和拆箱是编译器的工作，在class中已经添加转化。虚拟机没有自动装箱和拆箱的语句。\n==:基本类型是内容相同，对象是指针是否相同(内存同一个区域)\n基本类型没有空值，对象有null，可能触发NullPointerException。\n当一个基础数据类型与封装类进行==、+、-、*、/运算时，会将封装类进行拆箱，对基础数据类型进行运算。\n谨慎使用多个非同类的数值类对象进行运算。\n\njavaInteger obj1 = 5;//自动装箱\nInteger obj2= Integer.valueOf(5);\nint a1 = obj1;//自动拆箱\nint a2 = obj1.intValue();\n\nArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\nlist.add(1);//自动装箱\nlist.add(Integer.valueOf(2));\nint a3 = list.get(1);//自动拆箱\nint a4 = list.get(1).intValue();\n多异常并列javatry{\n  //code\n}\ncatch( IOException | FileNotFoundException ex){\n  //code\n}数值类型赋值优化整型用二进制赋值\njava//整型用二进制赋值\nbyte a1 = (byte) 0b00100001;\nshort a2= (short) 0b1010000101000101;\nint a3= 0b10100001010001011010000101000101;int a4 = 0b101;\nint a5 = 0B101;//B可以大小写\nlong a6 = 0b1010000101000101101000010110001011010000101000101L;\nfinal int[] s1 = { 0b00110001，0b01100010，0b11000100，0b10000100 };在数值字面量中使用下划线  \n下划线只能出现数字中间，前后必须都是数字。允许在二/八/十/十六进制的数字中使用。\njava//在数值字面量中使用下划线\nint a3 = 0b0111_1011_0001;//二进制\nint a4 = 02_014;//八进制\nint a5 = 123__45;//可以多个下划线\nint a6 = 0x7_B_1;//十六进制\nfloat a7 = 3.56_78f;//float接口方法Java最初的设计中，接口的方法都是没有实现的、公开的。Java 8推出接口的默认方法/静态方法(都带实现的)，为Lambda表达式提供支持。\n默认方法：以default关键字标注，其他的定义和普通函数一样\n\n规则1:默认方法不能重写Object中的方法\n规则2:实现类可以继承/重写父接口的默认方法\n规则3:接口可以继承/重写父接口的默认方法\n规则4:当父类和父接口都有(同名同参数)默认方法，子类继承父类的默认方法，这样可以兼容JDK7及以前的代码\n规则5:子类实现了2个接口(均有同名同参数的默认方法)，那么编译失败，必须在子类中重写这个default方法\n\n静态方法:该静态方法属于本接口的，不属于子类/子接口。子类(子接口)没有继承该静态方法，只能通过所在的接口名来调用。\n私有方法：解决多个默认方法/静态方法的内容重复问题。\n\n私有方法属于本接口，只在本接口内使用，不属于子类/子接口  \n子类(子接口)没有继承该私有方法，也无法调用。  \n静态私有方法可以被静态/默认方法调用，非静态私有方法被默认方法调用。\n\ntry-with-resource\n程序如果打开外部资源，那么在使用后需要正确关闭。\n考虑异常因素，Java提供try-catch-finally进行保证。\nJDK7提供try-with-resource，比try-catch-finally更简便。\n资源对象必须实现AutoCloseable接口，即实现close方法。\n\n局部变量推断Java 10推出var，使得在定义变量的时候不用指定数据类型:\n\n避免信息冗余\n对齐了变量名\n更容易阅读\n\n看上去Java变成了弱类型的语言，本质上还是强类型语言。编译器负责推断类型，并写入字节码文件。因此推断后不能更改! ! !注意事项：\n\n可以用在局部变量上，非类成员变量\n可以用在for/for-each循环中\n声明时必须初始化！\n不能用在方法(形式)参数和返回类型\n大面积滥用会使代码整体阅读性变差\nvar只在编译时起作用，没有在字节码中引入新的内容，也没有专门的JVM指令处理var\n\nswitchjava//多分支合并\nswitch(month){\n    case \"Jan\" , \"Mar\", \"May\",\"July\" , \"Aug\", \"oct\", \"Dec\" -&gt; result = 31;\n    case \"Apr\". \".une\" , \"sep\", \"Nov\" -&gt;result = 30;\n    case \"Feb\" -&gt; result = 28;\n    default -&gt; result = -1;\n}\n\n//switch直接在表达式赋值\nint num = 1;\nint days = switch.(num){\n    case 1,3,5,7,8,10,12-&gt;31;\n    case 4,6,9,11-&gt;30;\n    default -&gt;{\n        int result=28;\n        break result;//代码块中break返回结果\n    }\n};泛型Generic Programming，JDK1.5推出的特性编写的代码可以被很多不同类型的对象所重用。说的倒是这么高级,这不就是C++的template吗？\n\n泛型类: ArrayList，HashSet，HashMap等\n泛型方法:Collections.binarySearch，Arrays.sort等\n泛型接口: List, Iterator等\n\n泛型类\n具有泛型变量的类\n在类名后用&lt;T&gt;代表引入类型\n多个字母表示多个引入类型如&lt;T,U&gt;等\n引入类型可以修饰成员变量/局部变量/参数/返回值\n没有专门的template关键字\n\n\n\n类似于这样使用：\njavapublic class Interval&lt;T&gt;{\n    private T lower;\n    private T upper;\n    public Interval(lower, upper) {\n        this. lower = lower;\n        this. upper = upper;\n    }\n    public T getLower() {\n        return lower;\n    }\n    //部分get/set方法省略\n    public static void main (String[] args){\n        Interval&lt;Integer&gt; v1 = new Interval&lt;Integer&gt;(1,2);\n        int lower = v1.getLower() ;\n        int upper = v1.getUpper() ;\n        system.out.println(lower + \",\" + upper);\n        Interval&lt;Integer&gt; v2 = new Interval&lt;&gt;(1,2);Interval&lt;Integer&gt; v3 = getReverse(v2);\n        system.out.println(v3.getLower() +\",\" + v3.getUpper());\n    }\n    public static &lt;Interval&lt;T&gt;getReverse(Interval&lt;T&gt; interval) {\n        return new Interval&lt;T&gt;(interval.getUpper(),interval.getLower());\n    }\n}泛型方法：\n具有泛型参数的方法\n该方法可在普通类/泛型类中\n&lt;T&gt;在修饰符后,返回类型前\n\njavapublic class Arrayutil {\n    public static &lt;T&gt; T getMiddle(T... a){\n        return a[a.length/2];\n    }\n}泛型接口\n和泛型类相似，在类名后加&lt;T&gt;\nT用来指定方法返回值和参数,T可以是一个普通类也可以是一个泛型类\n实现接口时，指定类型\n\n泛型限定\n&lt;T extends Comparable&gt;约定T必须是Comparable的子类\nextends固定，后面可以多个，以&amp;拼接，如&lt;T extendsComparable &amp; Serializable&gt;\nextends限定可以有多个接口，但只能一个类，且类必须排第一位\n逗号隔参数，&lt;T extends File &amp; Cloneable, U extends Serializable&gt;\n\n上线界定符：&lt;? extends S&gt;，意思是能接收的参数类型是S自身或子类。只能get不能set，编译器只能保证出来的类型，但不保证放入的对象是什么类型。  \njavaPair&lt;? extends Fruit&gt;//代表Pair&lt;Fruit&gt;, Pair&lt;Apple&gt;, Pair&lt;Orange&gt;等\n? extends Fruit getFirst();//肯定可以转型到Fruit\nvoid setFirst(? extends Fruit)//未知具体的类型，错误下界鉴定符：&lt;? super S&gt;，意思是能接收的参数类型S的自身或超类。只能set不能get，编译器保证放入的是S本身或超类，但不保证出来是什么具体类型。\njavaPair&lt;? super Apple&gt;//代表Pair&lt;Object&gt;, Pair&lt;Fruit&gt;, Pair&lt;Apple&gt;等\nvoid setFirst(? super Apple)//可以放入Apple及子类对象\n? super Apple getFirst()//无法得知出来的对象类型，只能是Object无限定类型的泛型：&lt;?&gt;，摆烂了属于是，set和get都不能用。\n泛型PECS原则Producer Extends, Consumer Super\n\n要从泛型类读取类型T的数据，并且不能写入，可以使用 ? extends 通配符;(Producer Extends，泛型类是生产者，往外输出东西)\n如果要向泛型类写入类型T的数据，并且不需要读取，可以使用 ? super 通配符;(Consumer Super，泛型类是消费者，往内增加东西)\n如果既想写入又想读出，那就不用通配符\n\nJava类型的变化定义：A、B是类型，f(·)表示类型转换，≤表示继承关系，如A≤B,表示A继承于B  \n\nf(·)是协变(covariant)的，如果A≤B，有f(A)≤f(B)\nf(·)是逆变(contravariant)的，如果A≤B，有f(B)≤f(A)\nf(·)是不变(invariant)的，当上述两种都不成立，即f(A)和f(B)没有关系\nf(·)是双变(bivariant)的，如果A≤B，有f(B)≤f(A)和f(A)≤f(B)同时成立\n\n类型变化相关：\n\n数组是协变的(covariant)\n原始的泛型是不变的(invariant)-\n&lt;?extends A&gt;支持协变(covariant)\n&lt;?super B&gt;支持逆变(contravariant)\nJDK1.4重写的方法参数和返回值要求一样,JDK1.5＋重写的方法，参数要求一样的，返回值是协变的\n\n","slug":"Java学习笔记-三","date":"2022-05-12T12:04:00.000Z","categories_index":"Java","tags_index":"Java,Maven,语法糖,泛型","author_index":"Ac-Accelerator"},{"id":"f72442027e50aabe63bc800cc8297c91","title":"Java学习笔记(二)","content":"Java常用类Java类库*包名以Java开始的包是Java核心包(Java Core Package)*：  \n\n\n\nModule\nDescription\n\n\n\njava.applet.*\n提供了创建applet需要的所有类。\n\n\njava.awt.*\n提供了创建用户界面以及绘制和管理图形、图像的类\n\n\njava.beans.*\n提供了开发Java Beans需要的所有类。\n\n\njava.io.*\n提供了通过数据流、对象序列以及文件系统实现的系统输入、输出。\n\n\njava.lang.*\nJava编程语言的基本类库。\n\n\njava.math.*\n提供了简明的整数算术以及十进制算术的基本函数。\n\n\njava.net.*\n提供了用于实现网络通讯应用的所有类。\n\n\njava.nio.*,\n提供用于实现nio应用的所有类。\n\n\njava.rmi.*\n提供了与远程方法调用相关的所有类。\n\n\njava.security.*\n提供了设计网络安全方案需要的一些类。\n\n\njava.sql.*\n捉供了访问和处理来自于Java标准数据源数据的类。\n\n\njava.text.*\n包括以一种独立于自然语言的方式处理文本、日期、数字和消息的类和接口。\n\n\njava.time.*\n捉供Java日期、时间类(Java 8新增的包)。\n\n\njava.util.*\n包括集合类、时间处理模式、日期时间工具等各类常用工具包。\n\n\n包名以Javax开始的包是Java扩展包(Java Extension Package)\n数字相关类除了基本类及其包装类，还有大数类。\n\njava.math.Biglnteger 支持无限大的整数运算\n\njava.math.BigDecimal 支持无限大的小数运算(注意精度)。\n\njava.util.Random\n\nnextInt()返回一个随机int\nnextInt(int a)返回一个[0,a)之间的随机int\nints方法批量返回随机数数组\nnextDouble()返回一个[0.0,1.0]之间double\njava.lang.Math.random()返回一个[0.0,1.0]之间double\n\n\n\n\njava.lang.Math\n绝对值函数abs\n对数函数log\n比较函数max、 min\n幂函数pow\n四舍五入函数round等\n向下取整floor\n向上取整ceil\n\n\n\n字符串相关类：\njava.lang.String\njava.lang.StringBuffer\njava.lang.StringBuilder\n\n时间相关类：java.util.Calendar\n\nget(Field)来获取时间中每个属性的值.注意，月份0-11.\ngetTime()，返回相应的Date对象\ngetTimeInMillis(),返回自1970.1.1以来的毫秒数\nset(Field)设置时间字段\nadd(field, amount)根据指定字段增加/减少时间\nroll(field, amount)根据指定字段增加/减少时间，但不影响上一级的时间段\n\nJAVA8提供的新的包：\n\nLocalDate: 日期类\nLocalTime: 时间类(时分秒-纳秒)\nLocalDateTime: LocalDate +LocalTime\nInstant:时间戳\n\n格式化相关类：\n\nNumberFormat:数字格式化，抽象类\nDecimalFormat\n\n\nMessageFormat:字符串格式化\nDateFormat:日期/时间格式化，抽象类 \nSimpleDateFormat\n\n\n\n\n\nDateTimcFormatter\n\n异常及其处理异常分类\nThrowable:所有错误的祖先\nError:系统内部错误或者资源耗尽。\nException:程序有关的异常。\nRuntimcExccption:程序自身的错误\n非RuntimcException:外界相关的错误\n\n\n\n异常处理try:正常业务逻辑代码。catch:当try发生异常，将执行catch代码。若无异常，绕之。catch块可以有多个，每个有不同的入口形参。当已发生的异常和某一个catch块中的形参类型一致，那么将执行该catch块中的代码。一个异常只能进入一个catch块(通常小异常放在前面，大异常放在后面)。finally:当try或catch执行结束后，必须要执行finally。上述结构是可以嵌套的对于throw的写法类似于C++ 的异常规范，但两者有很大的不同：\njavapublic int divide(int x, int y) throws ArithmeticException\n{\n    int result = x/y ;\n    return x/y;\n}一个方法被覆盖，覆盖它的方法必须抛出相同的异常，或者异常的子类。如果父类的方法抛出多个异常，那么重写的子类方法必须抛出那些异常的子集，也就是不能抛出新的异常。\n自定义异常自定义异常，需要继承Exception类或其子类。\n\n继承自Exception，就变成Checked Exception\n继承自RuntimeException,就变成Unchecked Exception\n\n自定义重点在构造函数\n\n调用父类Exception的message构造函数\n可以自定义自己的成员变量在程序中采用throw主动抛出异常\n\n数据结构数组：  \njavaint a[]; //a 还没有new操作实际上是nu1l，也不知道内存位置\nint[] b; //b 还没有new操作实际上是null，也不知道内存位置\nint[] c = new int[2]; //c有2个元素，都是0\nc[0]= 10; c[1] = 20;//逐个初始化\nint d[] = new int[]{0,2,4};//d有3个元素,0,2,4，同时定义和初始化\nint d1[] = {1,3,5};//d1有3个元素,1,3,5同时定义和初始化\n//规则数组\nint a[][] = new int[2][3];\n//不规则数组\nint b[][];\nb =new int[3][];\nb[0]=new int[3];\nb[1]=new int[4];\nb[2]=new int[5];\n\n//注意声明变量时候没有分配内存，不需要指定大小，以下是错误示例\n//int e[5];\n//int[5] f;\n//int[5] g = new int[5];\n//int h[5] = new int[5];索引和遍历与C++相同。\nJCF:相当于C++的STL。JCF主要的数据结构实现类\n\n列表: \n(接口) \n) ,\n) \n\n\n\n集合:\n\n\n\n\n\n\n映射：\n\n\n\n\n\n\n\n\nJCF主要的算法类\n\n\nCollections:对Collection及其子类进行排序和查找操作\nComparable&lt;T&gt;(接口)：通过实现其中int compareTo(T obj)方法来实现自定义的排序；\n\n\n\n\n\n\n\n\n\n&gt;返回1，==返回0，&lt;返回-1\n\nComparator&lt;T&gt;(接口)：新建一个类来实现Comparator中的int compare(T obj1, T obj2)然后将该类的一个对象作为参数传入工具类的sort方法，这个对象叫做比较器。\n\n\n\n\n\n\n\n\n\n&gt;返回1，==返回0，&lt;返回-1\n\n\n文件操作java.io.File\n\nisDirectory是否是目录\nisFile是否是文件\ngetName获取文件名字\ngetParent获取上一层目录路径\ngetPath 获取这个文件的全路径\nlength获取文件的大小\nlastModified返回文件最后一次修改时间\n\njava.io(包括大部分文件操作)java.nio(Java7提供新IO包，是对原有的IO包的补充扩展)\n文本文件读写：读：\njavaimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.InputStreamReader;\n\npublic class TxtFileRead {\n    public static void main(String[] args) {\n        readFile1();\n        System.out.println(\"===================\");\n    }\n  //法1\n    public static void readFile1() {\n        FileInputStream fis = null;\n        InputStreamReader isr = null;\n        BufferedReader br = null;\n        try {\n            fis = new FileInputStream(\"c:/temp/abc.txt\"); // 节点类\n            isr = new InputStreamReader(fis, \"UTF-8\"); // 转化类\n            br = new BufferedReader(isr); // 装饰类\n            // 上面3行可以直接缩写为下面一行\n            // br = new BufferedReader(newInputStreamReader(newFileInputStream(\"c:/temp/abc.txt\"),\"UTF-8\"))\n            String line;\n            while ((line = br.readLine()) != null) // 每次读取一行\n            {\n                System.out.println(line);\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                br.close(); // 关闭最后一个类，会将所有的底层流都关闭\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n  //法2\n    public static void readFile2() {\n        String line;\n        // try-resource 语句，自动关闭资源\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(\"c:/temp/abc.txt\")))) {\n            while ((line = in.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n}写：\njavaimport java.io.*;\n\npublic class TxtFileWrite {\n    public static void main(String[] args) {\n        writeFile1();\n        System.out.println(\"===================\");\n    }\n  //法1\n    public static void writeFile1() {\n        FileOutputStream fos = null;\n        OutputStreamWriter osw = null;\n        BufferedWriter bw = null;\n        try {\n            fos = new FileOutputStream(\"c:/temp/abc.txt\"); // 节点类\n            osw = new OutputStreamWriter(fos, \"UTF-8\"); // 转化类\n            bw = new BufferedWriter(osw); // 装饰类\n            // 上面三行可替换为下面一行\n            // br = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(\"c:/temp/abc.txt\"),\"UTF-8\"))\n            bw.write(\"我们是\");\n            bw.newLine();\n            bw.write(\"Ecnuers.^^\");\n            bw.newLine();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                bw.close(); // 关闭最后一个类，会将所有的底层流都关闭\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n  //法2\n    public static void writeFile2() {\n        // try-resource 语句，自动关闭资源\n        try (BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(\"c:/temp/abc.txt\")))) {\n            bw.write(\"我们是\");\n            bw.newLine();\n            bw.write(\"Ecnuers.^^\");\n            bw.newLine();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n\n}二进制文件读写读：\njavaimport java.io.*;\n\npublic class BinFileRead {\n    public static void main(String[] args) throws Exception {\n        readFile();\n    }\n\n    public static void readFile() {\n        // try-resource 语句，自动关闭资源\n        try (DataInputStream dis = new DataInputStream(\n                new BufferedInputStream(new FileInputStream(\"c:/temp/def.dat\")))) {\n            String a, b;\n            int c, d;\n            a = dis.readUTF();\n            c = dis.readInt();\n            d = dis.readInt();\n            b = dis.readUTF();\n            System.out.println(\"a: \" + a);\n            System.out.println(\"c: \" + c);\n            System.out.println(\"d: \" + d);\n            System.out.println(\"b: \" + b);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n}写：\njavaimport java.io.*;\n\npublic class BinFileWrite {\n    public static void main(String[] args) throws Exception {\n        writeFile();\n        System.out.println(\"done.\");\n    }\n\n    public static void writeFile() {\n        FileOutputStream fos = null;\n        DataOutputStream dos = null;\n        BufferedOutputStream bos = null;\n        try {\n            fos = new FileOutputStream(\"c:/temp/def.dat\"); // 节点类\n            bos = new BufferedOutputStream(fos); // 装饰类\n            dos = new DataOutputStream(bos); // 装饰类\t\t\n\n            dos.writeUTF(\"a\");\n            dos.writeInt(20);\n            dos.writeInt(180);\n            dos.writeUTF(\"b\");\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        } finally {\n            try {\n                dos.close(); // 关闭最后一个类，会将所有的底层流都关闭\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n}压缩文件读写单个文件压缩：\njavaimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\nimport java.io.FileOutputStream;\n\npublic class SingleFileZip {\n    public static void main(String args[]) throws Exception {\n        File file = new File(\"c:/temp/abc.txt\"); // 定义要压缩的文件\n        File zipFile = new File(\"c:/temp/single2.zip\"); // 定义压缩文件名称\n\n        InputStream input = new FileInputStream(file); // 定义文件的输入流\n        ZipOutputStream zipOut = null; // 声明压缩流对象\n        zipOut = new ZipOutputStream(new FileOutputStream(zipFile));\n        zipOut.putNextEntry(new ZipEntry(file.getName())); // 设置ZipEntry对象\n        zipOut.setComment(\"single file zip\"); // 设置注释\n\n        // 压缩过程\n        int temp = 0;\n        while ((temp = input.read()) != -1) { // 读取内容\n            zipOut.write(temp); // 压缩输出\n        }\n        input.close(); // 关闭输入流\n        zipOut.close(); // 关闭输出流\n\n        System.out.println(\"single file zip done.\");\n    }\n}多个文件压缩\njavaimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\nimport java.io.FileOutputStream;\n\npublic class MultipleFileZip {\n    public static void main(String args[]) throws Exception { // 所有异常抛出\n        File file = new File(\"c:/temp/multiple\"); // 定义要压缩的文件夹\n        File zipFile = new File(\"c:/temp/multiple2.zip\"); // 定义压缩文件名称\n\n        InputStream input = null; // 定义文件输入流\n        ZipOutputStream zipOut = null; // 声明压缩流对象\n        zipOut = new ZipOutputStream(new FileOutputStream(zipFile));\n        zipOut.setComment(\"multiple file zip\"); // 设置注释\n\n        // 开始压缩\n        int temp = 0;\n        if (file.isDirectory()) { // 判断是否是文件夹\n            File lists[] = file.listFiles(); // 列出全部子文件\n            for (int i = 0; i &lt; lists.length; i++) {\n                input = new FileInputStream(lists[i]); // 定义文件的输入流\n                zipOut.putNextEntry(new ZipEntry(file.getName()\n                        + File.separator + lists[i].getName())); // 设置ZipEntry对象\n                System.out.println(\"正在压缩\" + lists[i].getName());\n                while ((temp = input.read()) != -1) { // 读取内容\n                    zipOut.write(temp); // 压缩输出\n                }\n                input.close(); // 关闭输入流\n            }\n        }\n        zipOut.close(); // 关闭输出流\n        System.out.println(\"multiple file zip done.\");\n    }\n}单个文件解压缩\njavaimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.OutputStream;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\npublic class SingleFileUnzip {\n    public static void main(String args[]) throws Exception {\n        // 待解压文件, 需要从zip文件打开输入流，读取数据到java中\n        File zipFile = new File(\"c:/temp/single.zip\"); // 定义压缩文件名称\n        ZipInputStream input = null; // 定义压缩输入流\n        input = new ZipInputStream(new FileInputStream(zipFile)); // 实例化ZIpInputStream\n        ZipEntry entry = input.getNextEntry(); // 得到一个压缩实体\n        System.out.println(\"压缩实体名称：\" + entry.getName()); // 获取压缩包中文件名字\n\n        // 新建目标文件，需要从目标文件打开输出流，数据从java流入\n        File outFile = new File(\"c:/temp/\" + entry.getName());\n        OutputStream out = new FileOutputStream(outFile); // 实例化文件输出流\n        int temp = 0;\n        while ((temp = input.read()) != -1) {\n            out.write(temp);\n        }\n        input.close(); // 关闭输入流\n        out.close(); // 关闭输出流\n        System.out.println(\"unzip done.\");\n    }\n}多个文件解压缩\njavaimport java.io.File;\nimport java.io.OutputStream;\nimport java.io.InputStream;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipInputStream;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\n\npublic class MultipleFileUnzip {\n    public static void main(String args[]) throws Exception {\n        // 待解压的zip文件，需要在zip文件上构建输入流，读取数据到Java中\n        File file = new File(\"c:/temp/multiple.zip\"); // 定义压缩文件名称\n        File outFile = null; // 输出文件的时候要有文件夹的操作\n        ZipFile zipFile = new ZipFile(file); // 实例化ZipFile对象\n        ZipInputStream zipInput = null; // 定义压缩输入流\n\n        // 定义解压的文件名\n        OutputStream out = null; // 定义输出流，用于输出每一个实体内容\n        InputStream input = null; // 定义输入流，读取每一个ZipEntry\n        ZipEntry entry = null; // 每一个压缩实体\n        zipInput = new ZipInputStream(new FileInputStream(file)); // 实例化ZIpInputStream\n\n        // 遍历压缩包中的文件\n        while ((entry = zipInput.getNextEntry()) != null) { // 得到一个压缩实体\n            System.out.println(\"解压缩\" + entry.getName() + \"文件\");\n            outFile = new File(\"c:/temp/\" + entry.getName()); // 定义输出的文件路径\n            if (!outFile.getParentFile().exists()) { // 如果输出文件夹不存在\n                outFile.getParentFile().mkdirs();\n                // 创建文件夹 ,如果这里的有多级文件夹不存在,请使用mkdirs()\n                // 如果只是单纯的一级文件夹,使用mkdir()就好了\n            }\n            if (!outFile.exists()) { // 判断输出文件是否存在\n                if (entry.isDirectory()) {\n                    outFile.mkdirs();\n                    System.out.println(\"create directory...\");\n                } else {\n                    outFile.createNewFile(); // 创建文件\n                    System.out.println(\"create file...\");\n                }\n            }\n            if (!entry.isDirectory()) {\n                input = zipFile.getInputStream(entry); // 得到每一个实体的输入流\n                out = new FileOutputStream(outFile); // 实例化文件输出流\n                int temp = 0;\n                while ((temp = input.read()) != -1) {\n                    out.write(temp);\n                }\n                input.close(); // 关闭输入流\n                out.close(); // 关闭输出流\n            }\n\n        }\n        input.close();\n    }\n}","slug":"Java学习笔记-二","date":"2022-05-11T15:24:00.000Z","categories_index":"Java","tags_index":"Java,异常,文件操作","author_index":"Ac-Accelerator"},{"id":"4fcfa8e6703310350c6e3442c24e0c97","title":"Java学习笔记(一)","content":"前言本篇不具体介绍Java的具体细节和语法，只记录在笔者眼中的Java和C++ 的相同和不同之处，因此需要有C++ 基础。\n类的结构和主函数\nmain函数的写法固定为:public static void main(string[] args)  \n\nJava文件必须以.java作为扩展名  \n\n一个Java文件只能有一个public class  \n\npublic class的名字必须和文件名字一样，大小写都要完全一致  \n\n一个文件可以有多个class，但是只能有一个是public。不提倡一个文件里面放多个类（内部类除外)  \n\nSystem.out.print()输出Systen.out.println()换行输出System.out.printf()格式化的输出，输出方式与C语言基本相同\n\n类是Java中的最基础逻辑单位  \n\nJava所有的内容都是需要放在类的范围中  \n内容不允许游离在类以外  \n换言之，Java项目就是由一个个类组成的\n\n\n类的构成\n\n成员变量/属性\n成员方法/函数 \n代码块\n\n\n一个class最多只能有一个main函数。类可以没有main函数，没有main函数的类就不能主动执行，但可以被动执行(被别人调用执行)。\n\n程序的入口都是main函数，这点和C/C++ 一致。有一点不同的是，Java要求所有程序都必须放在类对象中，即所有的代码都要放在class的所辖范围内。\n\n严格意义上说,main函数不属于这个类的所拥有函数。只是因为Java要求所有的内容都必须放置在class的范围内，所以main函数“寄居”在某一个class中。\n\nmain函数是一个Java程序的总入口。\n\nmain函数也无法被其他方法/类所调用。一个Java程序可以调用多个其他Java class。\n\nmain函数的形参传入方法和C++类似。\n\n\n数据类型和运算符基本数据类型：\n\nboolean布尔：\n只有true，或者false两种值，默认是false，严格大小写\n\n\nbyte字节：\n1 byte = 8 bits (8位)\n\n\n存储有符号的，以二进制补码表示的整数-最小值-128，最大值127，默认值0，超过范围会进行截断。\nbyte类型用在大型数组中可以显著节约空间，主要代替小整数，因为byte变量占用的空间只有int类型的四分之一\nbyte在二进制文件读写中使用较多\n\n\n整型\nshort短整数16位,2个字节,有符号的以二进制补码表示的整数,默认值为0\nint整数32位,4个字节,有符号的以二进制补码表示的整数,默认值为0\nlong长整数64位,8个字节,有符号的以二进制补码表示的整数,默认值为0L\n整型超过范围会报错，long类型的赋值最好在数的末尾加上L。\n\n\n浮点\nfloat单精度32位,4个字节，赋值必须在数值末尾加f\ndouble双精度64位，8个字节，赋值可省略末尾的d\n都不能用来表示很精确的数值，float转double会使尾数变多\n两个小数无限接近的时候，会直接认为两个数相等\n\n\nchar字符\n一个单一的16位Unicode字符\n赋值的时候可直接使用字符或者是Unicode编码\n\n\n\n运算符：    同C++\n选择与循环结构    同C++\n自定义函数\n函数必须放在类的范围内  \n修饰词(public 或者 static) 返回值 (int或者void)，函数名(形参列表){函数体}  \n通常情况下，我们都建议方法是public。  \n函数可以调用其他的函数。  \n重载同C++\n\n类和对象\n类的实例化：A obj = new A();  \nobj可以看作是内存中一个对象(包括若干个数据)的句柄  \n在C/C++中，obj称为指针，在Java中称为Reference  \n对象赋值是Reference赋值，而基本类型是直接值拷贝。基本类型的变量值小,可直拷贝;对象包含多个值，不易复制,赋值采用共享同一内存区域。\n类的成员变量如果没有被初始化，将默认为0\n\n构造函数和析构函数：  \n\n构造函数同C++，但没有析构函数。\n\nJava具有内存自动回收机制的，当变量退出其生命周期后,JVM会自动回收所分配的对象的内存。所以不需要析构函数来释放内存变量的生命周期：同C++\nthis指针：  \n\n指向本类中的成员变量 this.member\n指向本类中的成员方法 this.methord()\n可以当做构造函数使用 this()\n\n继承、接口和抽象类继承：与C++相比：\n\n使用 extends 表示继承。\n没有诸如private，protect、public继承方式。\n没有关于继承方式的描述。\n每个类都只能继承一个类。\n访问权限除了private，protect、public，还有一个default，权限介于protect和private之间。前三个和C++相似，default意思是，只有在同一个包(package) 内才能访问。类成员的访问权限默认是default，通常不写。\n\n如下代码段就表示Derived类继承于Base类。\njavapublic class Derived extends Base{\n    private int num = 20;\n}特性：\n\n如果不写extends，Java类都默认继承java.lang.Object类\nJava所有类从java.lang.Object开始，构建出一个类型继承树\nObject类里面默认就有clone, equals, finalize, getClass,hashCode, toString等方法\n每个子类的构造函数的第一句话，都默认调用父类的无参数构造函数super()，除非子类的构造函数第一句话是super，而且super语句必须放在第一条，不会出现连续两条super语句。\n\n抽象类：  \n\n如果类中存在没有实现的方法，那所在的类就要被定义为抽象类。\n使用abstract关键字来声明类和类的abstract方法。\n子类可以继承于抽象类，但是一定要实现父类们所有abstract的方法。如果不能完全实现，那么子类也必须被定义为抽象类。\n有构造函数不能被new。\n\n例如这里定义了一个叫Shape的抽象类，以及类里面calArea抽象方法：\njavapublic abstract class Shape {\n    int area;\n    public abstract void calArea();\n}接口：   \n\n类似于C++由虚函数和若干静态常量成员组成的类。\n由关键字interface定义。  \n接口可以继承(多个)接口，多个接口之间用逗号隔开，没有实现的方法将会叠加。\n类只可以继承(extends)一个类，但是可以实现(implements)多个接口，多个接口之间用逗号隔开。继承和实现可以同时，但extends 必须写在implements前。\n类实现接口，就必须实现所有未实现的方法。如果没有全部实现，那么只能成为一个抽象类。\n接口里可以定义变量，但是会被编译器当做常量处理\n没有构造函数且不能被new\n\n例如：\njava// 接口\ninterface Animal {\n    public void eat();\n    public void move();\n}\n\n// 实现Animal接口的抽象类\nabstract class LandAnimal implements Animal {\n    public abstract void eat();\n\n    public void move() {\n        System.out.println(\"I can walk by feet\");\n    }\n}\n\n// 继承抽象类并且实现了抽象方法\nclass GrassEating extends LandAnimal {\n    public void eat() {\n        System.out.println(\"I eat grass\");\n    }\n}\n\n// 继承完整类\nclass Rabbit extends GrassEating {\n    public void climb() {\n        System.out.println(\"Rabbit: I can climb\");\n    }\n\n    public static void main(String[] args) {\n        Rabbit t = new Rabbit();\n        t.eat();\n        t.climb();\n        t.move();\n    }\n}转型、多态和契约设置转型：\n\n通过Reference之间的赋值来实现转型。\n类型可以相互转型，但是只限制于有继承关系的类。\n子类可以转换成父类，而父类不可以转为子类。\n子类继承父类所有的成员，子类可以变成父类(向上转型);\n从父类直接变成子类(向下转型)则不允许。\n如果这个父类本身就是从子类转化过来的，则也可以向下转型。\n\n多态：  \n\n和C++用虚函数实现不同，Java是通过接口和函数重写实现的。\n以统一的接口来操纵某一类中不同的对象的动态行为。\n\n契约:  \n\n规定规范了对象应该包含的行为方法\n接口定义了方法的名称、参数和返回值，规范了派生类的行为\n基于接口，利用转型和多态，不影响真正方法的调用，成功地将调用类和被调用类解耦(decoupling)\n\nstatic、final和常量static在类中的表现同C++。\n\nstatic块\n只在类第一次被加载时调用。\n在程序运行期间，这段代码只运行一次。一执行顺序:static块&gt;匿名块&gt;构造函数。\n\n\n\n单例模式：保证一个类只有一个对象\n\n采用static来共享对象实例\n采用private构造函数，防止外界new操作\n定义一个函数获取该static实例\n\nfinal：  \n\n位置不一样，C++是将final关键字放在后面，Java则是放在前面。\nJava的final用来修饰类、方法时，作用和C++差不多。\n用来修饰基本类型的时候，就和C++的const一样。\n如果作用于对象,则对象的指针的值不可改变，但是对象的数据可以改变。相当于C++的指针常量。\n\njavafinal public class GrassEating extends LandAnimal {\n    final int const_int=100;\n    final public void eat() {\n        final GrassEating const_object=new GrassEating();\n        System.out.println(\"I eat grass\");\n    }\n}常量：  \n\n使用public static final来修饰常量\n常量命名最好大写\n接口里定义的变量默认是常量，是public static final的缺省\n常量式赋值创建，放在栈内存(将被常量化).如：\nInteger a = 10;  \nString b =“abc”;\n\n\nnew对象进行创建，放在堆内存(不会常量化)。如：  \nInteger c = new Integer(10);\n\n\nString d = new String(“abc”);\n\n\n基本类型和包装类进行比较,包装类自动拆箱\n\n常量池：Java为很多基本类型的包装类/字符串常量都建立常量池保存在编译期间就已经确定的数据是一块特殊的内存相同的值只存储一份，节省内存，共享访问基本类型的包装类Boolean，Byte，Short，Integer，Long，Character \n\nBoolean: true, false\nByte : -128~127\nCharacter : 0~127\nShort,Int,Long: -128~127\n\n不可变对象：  \n\n所有的属性都是final和private的\n不提供setter方法\n类是final的，或者所有的方法都是final\n\npackage、import和classpathpackage和C++中的namespace相似。但是包名必须和目录名相同且该语句必须放在文件的第一行。如package neuq.cs.test;表示该文件是在 neuq/cs/test目录下。类的全称为”包名+类名”\nimport语句的使用和python相似。但仍需注意几个地方。  \n\nimport必须全部放在package之后，类定义之前。多个import的顺序无关。\n可以用*来引入一个目录下的所有类，比如import java.lang.*;此意思是引入java.lang下面所有的类文件，但不包括java.lang下面所有的子目录文件，即不能递归包含各个目录下的文件。\nimport尽量精确，不推荐用*，以免新增的同名程序会使得老程序报错。\n\njar：类似于C++的库文件。jar文件是Java所特有的一种文件格式，用于可执行程序文件的传播。jar文件实际上是一组class文件的压缩包。项目引入一个jar文件,就可以使用jar文件中所有类(.class文件),无需类的源码(.java文件)\n","slug":"Java学习笔记-一","date":"2022-05-09T08:43:00.000Z","categories_index":"Java","tags_index":"Java","author_index":"Ac-Accelerator"},{"id":"1400880ea83318bcbc365c9ffe072342","title":"计算机网络(二)","content":"数据链路层数据链路层负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报。  \n基本概念结点:主机、路由器链路:网络中两个结点之间的物理通道，链路的传输介质主要有双绞线、光纤和微波。分为有线链路、无线链路。数据链路:网络中两个结点之间的逻辑通道，把实现控制数据传输协议的硬件和软件加到链路上就构成数据链路帧︰链路层的协议数据单元，封装网络层数据报。\n功能数据链路层在物理层提供服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。  \n封装成帧封装成帧就是在一段数据的前后部分添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。首部和尾部包含许多的控制信息，他们的一个重要作用:**帧定界(确定帧的界限)**。\n帧同步:接收方应当能从接收到的二进制比特流中区分出帧的起始和终止。\n组帧的四种方法:  \n\n字符计数法:帧首部使用一个计数字段(第一个字节，八位)来标明帧内字符数。（若第一个字节出错，将导致灾难性的后果）    \n字符填充法:帧中的数据部分的某个字节可能与帧的控制信息相同。这时候在该字节前添加转义字符实现透明传输。（实现复杂且兼容差）  \n零比特填充法:帧首部和尾部都是01111110。在发送端，扫描整个信息字段，只要连续5个1，就立即填入1个0。在接收端收到一个帧时，先找到标志字段确定边界，再用硬件对比特流进行扫描。发现连续5个1时，就把后面的0删除。   \n违规编码法体现在物理层中。例如在曼彻斯特编码中，连续的高电平或连续第低电平是违规的。把这两种违规编码作为帧的起始和终止。\n\n差错控制传输中的差错都是由于噪声引起的。位错：0→1或1→0  \n检错编码：  \n\n奇偶校验法（帧中的1的个数是奇数还是偶数）  \nCRC循环冗余码：  \n对发送端：  \n要传的数据%生成多项式=FCS帧检验序列(冗余码)最终发送的数据=要传的数据+FCS帧检验序列(冗余码)\n\n\n对接收端：  \n如果接受到的数据能被生成多项式整除，则有无限接近于1的概率判定传输无错。\n\n\n\n\n\n纠错编码：海明码\n流量控制较高的发送速度和较低的接收能力的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作。数据链路层流量控制手段:接收方收不下就不回复确认。\n流量控制方法：停止-等待协议： \n\n条件：每个帧及其对应的ASK都需要进行编号  \n发送方：  \n每发送完一个帧就停止发送，并启动一个超时计时器，并且等待对方的确认。若在规定时间内收到确认则发送下一个帧。  \n若超出规定时间，则重新发送，若收到不属于当前传输的帧的确认，则直接忽略该确认。\n\n\n接受方：  \n每接受到一个帧就返回一个确认。\n若收到一个和之前收到过的某个帧相同的帧，则丢弃该帧，并重新发送之前那个帧的确认。\n\n\n\n以下两个协议的帧的编号是可以重复利用的。**后退N帧协议(GBN)**：\n\n发送窗口(多个):发送方维持一组连续的允许发送的帧的序号。发送窗口的长度应该大于等于1且小于等于帧的最大编号(从0开始编号)   \n接收窗口（单个）:接收方维持的一个允许接收帧的序号。  \n发送方：  \n上层的调用：上层要发送数据时，发送方先检查发送窗口是否已满，如果未满，则产生一个帧并将其发送;如果窗口已满,发送方只需将数据返回给上层，暗示上层窗口已满。上层等一会再发送。(实际实现中，发送方可以缓存这些数据，窗口不满时再发送帧）。  \n收到了一个ACK：GBN协议中，对n号帧的确认采用累积确认的方式，标明接收方已经收到n号帧和它之前的全部帧。  \n超时事件：协议的名字为后退N帧/回退N帧，来源于出现丢失和时延过长帧时发送方的行为。就像在停等协议中一样，定时器将再次用于恢复数据帧或确认帧的丢失。如果出现超时，发送方重传所有已发送但未被确认的帧。\n\n\n接收方：  \n如果正确收到n号帧，并且按序，那么接收方为n帧发送一个ACK，并将该帧中的数据部分交付给上层。  \n其余情况都丢弃帧，并为最近按序接收的帧重新发送ACK。接收方无需缓存任何失序帧，只需要维护一个信息:expectedseqnum(下一个按序接收的帧序号)。\n\n\n\n**选择重传协议(SR)**：GBN协议中，如果某个帧出错可能会导致批量重传。而在SR协议中，只重传出错的帧。  \n\n发送窗口长度等于接收窗口长度等于(帧的最大编号(从0开始)+1)/2。  \n发送方： \n上层的调用（同GBN）  \n收到了一个ACK：如果收到ACK，如果该帧序号在窗口内，则将那个被确认的帧标记为已接收。如果该帧序号是窗口的下界（还留在窗口中的且是最早进入窗口的序号），则窗口下界移动到下一个未确认帧处。如果窗口移动了并且有序号在窗口内的未发送帧，则发送这些帧。  \n超时事件：每个帧都有自己的定时器，一个超时事件发生后只重传一个帧。\n\n\n接受方\n返回每一个收到的帧的ASK。失序的帧将被缓存，并返回给发送方一个该帧的ASK，直到窗口下界的帧收到为止，这时才可以将一批帧按序交付给上层，然后移动滑动窗口。\n\n\n\n信道划分介质访问控制信道划分介质访问控制:将使用介质的每个设备与来自同一信道上的其他设备的通信隔离开，把时域和频域资源合理地分配给网络上的设备。\n多路复用技术：把多个信号组合在一条物理信道上进行传输，使得多个计算机或终端设备共享信道资源,提高信道利用率。即把一条广播信道，逻辑上分成几条用于两个节点之间通信的互不干扰的子信道，实际就是把广播信道转变为点对点信道。  \n*频分多路复用(FDM)*：用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽(颜率带宽)资源。  \n*时分多路复用(TDM)*：将时间划分为一段段等长的时分复用帧（TDM帧)。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙,所有用户轮流占用信道。  \n*统计时分复用(STDM)*：各用户有了数据就随时发往集中器的输入缓存，然后集中器按顺序依次扫描输入缓存，把缓存中的输入数据放入STDM帧中，一个STDM帧满了就发出。STDM帧不是固定分配时隙,而是按动态分配时隙。  \n*波分多路复用(WDM)*：波分多路复用就是光的频分多路复用，在一根光纤中传输的多种不同波长（频率）的光信号互不干扰，最后再用波长分解复用器将各路波长分解出来。  \n码分多路复用：码分多址（CDMA）是码分复用的一种方式。1个比特分为多个码片/芯片(chip)，每一个站点被指定一个唯一的m位的芯片序列。发送1时站点发送芯片序列，发送0时发送芯片序列反码。要求： \n\n发送:多个站点同时发送数据的时候，要求各个站点芯片序列相互正交  \n合并:各路数据在信道中被线性相加  \n分离:合并的数据和源站规格化内积\n\n\n轮询访问介质访问控制：令牌传递协议、轮询协议\n\n纯ALOHA协议:不监听信道，不按时间槽发送，随机重发。如果发生冲突，接收方在就会检测出差错，然后不予确认，发送方在一定时间内收不到就判断发生冲突。   \n时隙ALOHA协议:把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道,若发生冲突，则必须等到下一个时间片开始时刻再发送。\n\n载波监听多路访问协议(CSMA):每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据。多点接入，表示许多计算机以多点接入的方式连接在一根总线上。若信道空闲，则发送完整帧；如果信道忙，则推迟发送。\n缺点：发生冲突后还是要坚持把数据帧发送完，造成了浪费。  \n1-坚持CSMA:\n\n如果一个主机要发送消息，那么它先监听信道。\n空闲则直接传输，不必等待。忙则一直监听，直到空闲马上传输。  \n如果有冲突（一段时间内未收到肯定回复），则等待一个随机长的时间再监听，重复上述过程。 \n优点:只要媒体空闲，站点就马上发送，避免了媒体利用率的损失。  \n缺点:假如有两个或两个以上的站点有数据要发送，冲突就不可避免。\n\n非坚持CSMA:\n\n如果一个主机要发送消息，那么它先监听信道。\n空闲则直接传输，不必等待。忙则等待一个随机的时间之后再进行监听。 \n优点:采用随机的重发延迟时间可以减少冲突发生的可能性。  \n缺点:可能存在大家都在延迟等待过程中，使得媒体仍可能处于空闲状态，媒体使用率降低。\n\np-坚持CSMA:\n\n如果一个主机要发送消息，那么它先监听信道。\n空闲则以p概率直接传输，不必等待;概率1-p等待到下一个时间槽再传输。忙则等待一个随机的时间之后再进行监听。  \n优点:既能像非坚持算法那样减少冲突，又能像1-坚持算法那样减少媒体空闲时间的这种方案。\n\n\nCSMA/CD协议：(常用于总线以太网、树形网络)CSMA/CD  \nCSMA/CA协议：(常用于无线局域网)CSMA/CA\n以太网以太网提供无连接、不可靠的服务无连接:发送方和接收方之间无“握手过程”。不可靠:不对发送方的数据帧编号，接收方不向发送方进行确认，差错帧直接丢弃，差错纠正由高层负责。  \n\n\n\n\n\n\n\n\n\n以太网只实现无差错接收，不实现可靠传输。\n10BASE-T以太网:10BASE-T是传送基带信号的双绞线以太网，T表示采用双绞线，现10BASE-T采用的是无屏蔽双绞线(UTP），传输速率是10Mb/s。  \n\n\n\n\n\n\n\n\n\n物理上采用星型拓扑，逻辑上总线型，每段双绞线最长为100m。采用曼彻斯特编码。采用CSMA/CD介质访问控制。\n100BASE-T以太网:在双绞线上传送100Mb/s基带信号的星型拓扑以太网，仍使用IEEE802.3的CSMA/CD协议。支持全双工和半双工，可在全双工方式下工作而无冲突。  \n吉比特以太网:在光纤或双绞线上传送1Gb/s信号。支持全双工和半双工，可在全双工方式下工作而无冲突。  \n10吉比特:10吉比特以太网在光纤上传送10Gb/s信号。只支持全双工，无争用问题。\n链路层设备网段（冲突域）:一般指一个计算机网络中使用同一物理层设备(传输介质，中继器，集线器等)能够直接通讯的那一部分。\n网桥：网桥根据MAC帧的目的地址对帧进行转发和过滤。当网桥收到一个帧时，并不向所有接口转发此帧，而是先检查此帧的目的MAC地址，然后再确定将该帧转发到哪一个接口，或者是把它丢弃（即过滤）。优点:  \n\n过滤通信量，增大吞吐量。  \n扩大了物理范围。  \n提高了可靠性。  \n可互连不同物理层、不同MAC子层和不同速率的以太网。\n\n网桥分类  \n\n透明网桥:以太网上的站点并不知道所发送的帧将经过哪几个网桥，是一种即插即用设备  \n源路由网桥:在发送帧时，把详细的最佳路由信息（路由最少/时间最短）放在帧的首部中。\n\n多接口网桥――以太网交换机直通式交换机：  \n\n查完目的地址（6B）就立刻转发。  \n延迟小，可靠性低，无法支持具有不同速率的端口的交换。\n\n存储转发式交换机:  \n\n将帧放入高速缓存，并检查否正确，正确则转发，错误则丢弃。  \n延迟大，可靠性高，可以支持具有不同速率的端口的交换。\n\n","slug":"计算机网络-二","date":"2022-05-08T03:29:00.000Z","categories_index":"网络","tags_index":"网络,数据链路层","author_index":"Ac-Accelerator"},{"id":"f667b4d44d41991982b8841954899495","title":"计算机网络(一)","content":"计算机网络初步概念计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。\n计算机网络是互连的、自治的计算机集合。互连:互联互通  通信链路自治:即无主从关系  \n功能计算机网络的功能包括：  \n\n数据通信  \n资源共享（硬件、软件、数据）  \n分布式处理（多台计算机各自承担同一工作的不同部分）  \n提高可靠性（替代机）  \n负载均衡。\n\n组成组成部分：硬件 软件 协议  \n工作方式：边缘部分（用户直接使用）C/S方式 or P2P方式核心部分（为边缘部分服务） \n功能组成:通信子网(实现数据通信)  包括应用层、表示层、会话层资源子网(实现资源共享/数据处理)  包括网络层、数据链路层、物理层（传输层是两个子网之间的接口）\n分类按分布范围分：广域网WAN、城域网MAN、局域网WAN、个人区域网PAN按使用者分: 公用网、专用网按交换技术分： 电路交换、报文交换、分组交换按拓扑结构分：总线型、星型、环形、网状型（常用于广域网）按传输技术分：广播式网络（共享公共通信通道）、点对点网络（使用分组存储转发和路由选择机制）\n速率相关性能指标速率即数据率或称数据传输率或比特率。连接在计算机网络上的主机在数字信道上传送数据位数的速率。单位是b/s，kb/s，Mb/s，Gb/s，Tb/s。单位之间是以进行换算。（注意区分描述数据存储时使用的KB、MB、GB、TB，它们之间是以进行换算）  \n带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。单位是“比特每秒”，b/s，kb/s，Mb/s，Gb/s。网络设备所支持的最高速度   \n吞吐量表示在单位时间内通过某个网络或信道、接口的数据量。单位b/s，kb/s，Mb/s等。吞吐量受网络的带宽或网络的额定速率的限制。\n时延、时延带宽积、RTT和利用率时延：  \n\n**发送时延(传输时延)**：从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需的时间。（数据大小信道带宽）  \n传播时延:取决于电磁波的传播速度和链路的长度  （信道长度电磁波在信道上传播的速率）  \n排队时延：等待输入/输出链路可用的时间  \n处理时延：检查错误，找出口的时间。\n\n时延带宽积：以比特为单位的链路长度传播时延带宽\n往返时间RTT:从发送方发送数据开始，到发送方收到接收方的确认（接收方收到数据后立即发送确认)总共经历的时延。往返传播时延传播时延末端处理时间RTT越大，在收到确认之前，可以发送的数据越多。  \n利用率：信道利用率有数据通过时间总时间网络利用率=信道利用率加权平均值\n利用率趋向于1时，时延急剧增大，传输效率反而下降。\n网络体系结构分层结构、协议、接口、服务分层的原因：发送文件前要完成的工作:(1)发起通信的计算机必须将数据通信的通路进行激活。(2)要告诉网络如何识别目的主机。(3)发起通信的计算机要查明目的主机是否开机，并且与网络连接正常。(4)发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作。(5）确保差错和意外可以解决。  \n分层的基本原则：(1)各层之间相互独立，每层只实现一种相对独立的功能。(2)每层之间界面自然清晰，易于理解，相互交流尽可能少。(3)结构上可分割开。每层都采用最合适的技术来实现。(4)保持下层对上层的独立性，上层单向使用下层提供的服务。(5)整个分层结构应该能促进标准化工作。\n分层的相关概念：实体:第n层中的活动元素称为n层实体。同一层的实体叫对等实体。协议:为进行网络中的对等实体数据交换而建立的规则、标准或约定称为网络协议。（水平 ）协议包括：    \n\n语法:规定传输数据的格式  \n语义:规定所要完成的功能  \n同步:规定各种操作的顺序\n\n接口（访问服务点SAP):上层使用下层服务的入口。4.服务:下层为相邻上层提供的功能调用。（垂直）SDU服务数据单元:为完成用户所要求的功能而应传送的数据。PCI协议控制信息:控制协议操作的信息。PDU协议数据单元:对等层次之间传送的数据单位。  \n\n\n\n\n\n\n\n\n\n网络体系结构是从功能上描述计算机网络结构。计算机网络体系结构简称网络体系结构是分层结构。每层遵循某个/些网络协议以完成本层功能。计算机网络体系结构是计算机网络的各层及其协议的集合。第n层在向n+1层提供服务时，此服务不仅包含第n层本身的功能，还包含由下层服务提供的功能。仅仅在相邻层间有接口，且所提供服务的具体实现细节对上一层完全屏蔽。体系结构是抽象的，而实现是指能运行的一些软件和硬件。  \nOSI(开放系统互联)参考模型七层结构： \n\n应用层  \n表示层  \n会话层  \n传输层  \n网络层  \n数据链路层  \n物理层\n\n数据链路层与其以上层不一样的地方就是：数据链路层会在其上一层的PDU的首尾都加上信息，而其它层只会在首部加信息。物理层不会对上层信息进行处理。   \n应用层：所有能和用户交互产生网络流量的程序。  \n表示层：用于处理在两个通信系统中交换信息的表示方式(语法和语义)功能一:数据格式变换功能二:数据加密解密功能三:数据压缩和恢复  \n会话层：向表示层实体/用户进程提供建立连接并在连接上有序地传输数据。这是会话，也是建立同步(SYN)功能一:建立、管理、终止会话功能二:使用校验点可使会话在通信失效时从校验点/同步点继续恢复通信，实现数据同步。  \n传输层：负责主机中两个进程的通信，即端到端的通信。传输单位是报文段或用户数据报。功能一:可靠传输(TCP)、不可靠传输(UTP)功能二:差错控制功能三:流量控制功能四:复用分用\n\n\n\n\n\n\n\n\n\n复用:多个应用层进程可同时使用下面运输层的服务。分用:运输层把收到的信息分别交付给上面应用层中相应的进程。\n网络层：主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务网络层传输单位是数据报。功能一:路由选择功能二:流量控制功能三:差错控制功能四:拥塞控制  \n\n\n\n\n\n\n\n\n\n若所有结点都来不及接受分组,而要丢弃大量分组的话，网络就处于拥塞状态。因此要采取一定措施,缓解这种拥塞。\n数据链路层：主要任务是把网络层传下来的数据报组装成帧。数据链路层/链路层的传输单位是帧。功能一:成帧（定义帧的开始和结束)功能二:差错控制(帧错和位错)功能三:流量控制功能四:控制对信道的访问\n物理层：主要任务是在物理媒体上实现比特流的透明传输。物理层传输单位是比特。透明传输:指不管所传数据是什么样的比特组合,都应当能够在链路上传送。功能一:定义接口特性功能二:定义传输模式(单工、半双工、双工)功能三:定义传输速率功能四:比特同步功能五:比特编码  \nTCP/IP和5层参考模型TCP/IP四层结构：  \n\n应用层  \n传输层  \n网际层  \n网络接口层\n\n五层结构：  \n\n应用层  \n传输层  \n网络层  \n数据链路层  \n物理层\n\n物理层基本概念物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层主要任务:确定与传输媒体接口有关的一些特性定义标准。机械特性定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况。电气特性规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制等。功能特性指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途。规程特性定义各条物理线路的工作规程和时序关系。\n数据通信基础通信的目的是传送消息。数据:传送信息的实体，通常是有意义的符号序列。信号:数据的电气/电磁的表现，是数据在传输过程中的存在形式。  \n\n数字信号:代表消息的参数取值是离散的。  \n模拟信号:代表消息的参数取值是连续的。\n\n信源:产生和发送数据的源头。信宿:接收数据的终点。信道:信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。  \n通信方式：  \n\n单工通信只有一个方向的通信而没有反方向的交互，仅需要一条信道。  \n半双工通信通信的双方都可以发送或接收信息，但任何一方都不能同时发送和接收，需要两条信道  \n全双工通信通信双方可以同时发送和接受信息，也需要两条信道。\n\n数据传输方式：  \n\n串行传输：速度慢，费用低，适合远距离  \n并行传输：速度快，费用高，适合近距离\n\n码元、波特、速率、带宽码元是指用一个固定时长的信号波形（数字脉冲），代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，而该时长称为码元宽度。当码元的离散状态有M个时(M大于2)，此时码元为M进制码元。1个码元可以携带多个比特的信息量。例如，在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态。速率也叫数据率，是指数据的传输速率，表示单位时间内传输的数据量。可以用码元传输速率和信息传输速率表示。码元传输速率别名码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数(也可称为脉冲个数或信号变化的次数)，单位是**波特(Baud)**。1波特表示数字通信系统每秒传输一个码元。这里的码元可以是多进制的，也可以是二进制的，但码元速率与进制数无关。信息传输速率别名信息速率、比特率等，表示单位时间内数字通信系统传输的二进制码元个数（即比特数)单位是比特/秒(b/s) 。带宽表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”，常用来表示网络的通信线路所能传输数据的能力。单位是b/s。\n奈氐准则和香农定理码间串扰:接收端收到的信号波形失去了码元之间清晰界限的现象。奈氏准则:在理想低通（无噪声，带宽受限)条件下，为了避免码间串扰，极限码元传输速率为2W Baud，W是信道带宽，单位是Hz。\n\n\n\n\n\n\n\n\n\n在任何信道中，码元传输的速率是有上限的。若传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能。信道的频带越宽(即能通过的信号高频分量越多)，就可以用更高的速率进行码元的有效传输。奈氏准则给出了码元传输速率的限制，但并没有对信息传输速率给出限制。由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多个比特的信息量，这就需要采用多元制的调制方法。\n噪声存在于所有的电子设备和通信信道中。由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但是噪声的影响是相对的，若信号较强，那么噪声影响相对较小。因此，信噪比就很重要。信噪比=信号的平均功率/噪声的平均功率，常记为S/N，并用分贝（dB）作为度量单位，即:信噪比香农定理:在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。信道的极限数据传输速率(b/s)\n\n\n\n\n\n\n\n\n\n信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了。只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现无差错的传输。香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少。从香农定理可以看出，若信道带宽W或信噪比S/N没有上限(不可能)，那么信道的极限信息传输速率也就没有上限。\n编码和调制基带信号将数字信号1和0直接用两种不同的电压表示，再送到数字信道上去传输（基带传输）。来自信源的信号，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的直接表达了要传输的信息的信号，比如我们说话的声波就是基带信号。宽带信号将基带信号进行调制后形成的频分复用模拟信号，再传送到模拟信道上去传输（宽带传输）把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。\n\n\n\n\n\n\n\n\n\n在传输距离较近时，计算机网络采用基带传输方式(近距离衰减小，从而信号内容不易发生变化)在传输距离较远时，计算机网络采用宽带传输方式(远距离衰减大，即使信号变化大也能最后过滤出来基带信号)\n数字数据编码为数据信号非归零编码【NRZ】：高1低0，编码容易实现，但没有检错功能，且无法判断一个码元的开始和结束，以至于收发双方难以保持同步。归零编码【RZ】：信号电平在一个码元之内都要恢复到零的这种编码成编码方式。反向不归零编码【NRZ1】：信号电平翻转表示o，信号电平不变表示1。曼彻斯特编码将一个码元分成两个相等的间隔,前一个间隔为低电平后一个间隔为高电平表示码元1;码元0则正好相反。也可以采用相反的规定。该编码的特点是在每一个码元的中间出现电平跳变，位中间的跳变既作时钟信号（可用于同步）,又作数据信号,但它所占的频带宽度是原始的基带宽度的两倍。每一个码元都被调成两个电平,所以数据传输速率只有调制速率的1/2。差分曼彻斯特编码同1异0常用于局域网传输，其规则是:若码元为1，则前半个码元的电平与上一个码元的后半个码元的电平相同，若为0，则相反。该编码的特点是，在每个码元的中间,都有一次电平的跳转，可以实现自同步，且抗干扰性强于曼彻斯特编码。4B/5B编码：比特流中插入额外的比特以打破一连串的0或1，就是用5个比特来编码4个比特的数据，之后再传给接收方，因此称为4B/5B。编码效率为80%。\n数字数据调制为模拟信号调幅、调频、调相、调幅+调相。\n模拟数据编码为数字信号最典型的例子就是对音频信号进行编码的脉码调制(PCM)，在计算机应用中，能够达到最高保真水平的就是PCM编码，被广泛用于素材保存及音乐欣赏，CD、DVD以及我们常见的WAV文件中均有应用。它主要包括三步:抽样、量化、编码。采样频率最高频率\n","slug":"计算机网络(一)","date":"2022-05-05T02:13:00.000Z","categories_index":"网络","tags_index":"网络,网络体系结构,物理层","author_index":"Ac-Accelerator"},{"id":"71d1afeec993a23db80ca1627d2eb461","title":"网页浮动布局","content":"多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动\n浮动先用标准流的父元素排列上下位置,之后内部子元素采取浮动排列左右位置。\nfloat属性定义浮动。属性值有left和right。\n浮动特性\n脱离标准普通流的控制，移动到指定位置(俗称脱标)  \n浮动的盒子不再保留原先的位置\n如果多个盒子都设置了浮动，则它们会按照属性值一行内显示并且顶端对齐排列。\n浮动的元素是互相不会有缝隙，如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐。\n任何元素都可以浮动。不管原先是什么模式的元素，添加浮动之后具有行内块元素相似的特性。\n浮动的盒子只会影响浮动盒子后面的标准流不会影响前面的标准流。\n\n清除浮动使用clear属性清除浮动，属性值有left、right、both(常用)。\n由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为0时，就会影响下面的标准流盒子。\n清除浮动的本质是清除浮动元素造成的影响。如果父盒子本身有高度，则不需要清除浮动。清除浮动之后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了。\n清除浮动常用策略：\n\n额外标签法会在浮动元素末尾添加一个空的块级元素标签。例如&lt; divstyle=” clear:both” &gt; &lt; /div &gt;，或者其他标签(如&lt; br /&gt;等)缺点是结构性较差。  \n给父级元素添加overflow:hidden属性，缺点是无法显示溢出部分。  \n对父元素使用类选择器添加如下CSS样式\n\ncss.clearfix:after {\n    content : \"\";\n    display : block;\n    height: 0;\n    clear : both;\n    visibility: hidden;\n}\n.clearfix {\n    *zoom : 1;\n}对父元素使用类选择器添加如下CSS样式\ncss.clearfix:before, \n.clearfix:after {\n    content : \" \";\n    display: table;\n}\n.clearfix:after {\n    clear: both;\n}\n.clearfix {\n    zoom: 1;\n}","slug":"CSS网页浮动布局","date":"2022-04-04T16:57:37.000Z","categories_index":"前端","tags_index":"CSS","author_index":"Ac-Accelerator"},{"id":"2cd531c7170c2dbe47cea834debb4679","title":"CSS网页标准布局和美化","content":"&gt;网页布局就是利用CSS摆盒子。\n布局盒子边框border：&lt;line-width&gt; || &lt;line-style&gt; || &lt;color&gt;\n第一个是盒子边框的粗细，有thin、medium、thick等预设值，还可以是带单位的数值第二个是盒子边框的样式none、hidden、dotted、dashed、solid、double、groove、ridge、inset、outset。第三个是颜色。\ncss.test {\n    border: 5px solid #000;\n}\n.test2 {\n    margin-top: 10px;\n    border: 5px solid;\n    color: #f00;\n}相关的标签还有border-top、border-right、border-bottom、border-left，属性都是一样的。\n另外，border-collapse属性可以用来合并相邻表格的边框，以至于不会太粗。属性值为collapse。\n加了边框会可能增加盒子的实际大小，要根据具体情况缩小盒子的大小。\n盒子内边距padding属性修改内边距。属性值是具体的数值或百分比。  \npadding可以有一到四个属性值：只有一个值，代表所有方向上的内边距。有两个值，前一个代表上下，后一个代表左右。三个值，前一个代表上边距，中间代表左右，后一个代表下边距。四个值，分别代表上、右、下、左四个方向。  \n相关的标签还有padding-top、padding-right、padding-bottom、padding-left。\n加了内边距会可能增加盒子的实际大小，要根据具体情况缩小盒子的大小。\n盒子外边距margin属性修改内边距。属性值是具体的数值或百分比，也可以是预设的auto。margin可以有一到四个属性值,具体和padding一样。\n其他的相关属性还有margin-top、margin-right、margin-bottom、margin-left。\n常用做使块级盒子水平居中。但是盒子的宽度width必须指定，左右外边距都设置为auto。\n注意：父元素和子元素同时存在上外边距的时候，父元素会坍塌较大的外边距值。这种情况叫做嵌套块元素垂直外边距的塌陷。解决办法：为父元素定义上边框或上内边框，或添加overflow:hidden属性。\n清除内外边距在实际开发过程中，经常使用如下CSS样式,使原本HTML标签自带的属性消失，从而更好的自定义元素的显示样式。\ncss* {\n    margin: 0;\n    padding: 0;\n}美化圆角边框border-radius属性可以为盒子设置圆角边框。属性值是圆的半径，可以是具体的值或者百分比。\n传入一个值的时候，四个角圆的半径都是一样的。传入四个值的时候，可以分别给左上、右上、右下、左下角定义圆的半径。\n其他相关属性有分开写: border-top-left-radius、border-top-right-radius、border-bottom-right-radius、border-bottom-left-radius。\n盒子阴影box-shadow属性定义阴影。box-shadow: &lt;h-shadow&gt; || &lt;v-shadow&gt; || &lt;blur&gt; || &lt;spread&gt; || &lt;color&gt; || &lt;inset&gt;。\n前两个属性必须写，分别代表水平阴影，垂直阴影。其他可选的分别代表阴影模糊，阴影大小，阴影颜色，内外阴影(值为空时，是外阴影)。\n过渡使用transition属性进行过渡。transition：&lt;single-transition-property&gt; || &lt;time&gt; || &lt;single-transition-timing-function&gt; || &lt;delay-time&gt; ,[else…]。第一个属性是对象中的参与过渡的属性(可以是all，全部属性)、第二个属性是持续的时间、第三个属性是过渡的动画类型(linear、ease、ease-in、ease-out、ease-in-out、step-start、step-end)、动画延时。\n当有多个属性需要过渡时，使用逗号来分隔。\n","slug":"CSS网页标准布局和美化","date":"2022-04-04T02:57:00.000Z","categories_index":"前端","tags_index":"CSS","author_index":"Ac-Accelerator"},{"id":"2d84197b69c87d393530863c6fed2f9f","title":"深度学习的模型训练","content":"兄弟们，看了二十来天的人工智能概述还有实现方法，我终于搞懂了。\n一个有关人工智能的pytorch程序应该包含数据集废话，没数据怎么玩啊，这里以FashionMNIST数据集举个例子。\npythonimport torch\nfrom torch import nn\nimport torchvision\nimport torchvision.transforms as transforms\n#首先是数据集的内容。\n#mnist_train代表要进行训练的数据集，root属性是其存放的位置，train属性代表这是用作训练的数据集，download属性为true表示无则下载，有则现用，transform属性代表将数据集转化为Tensor。\nmnist_train = torchvision.datasets.FashionMNIST(\n    root='./Datasets', train=True, download=True, transform=transforms.ToTensor())\n#mnist_train代表是对训练结果进行测试的数据集，属性意义和上面的几乎一致\nmnist_test = torchvision.datasets.FashionMNIST(\n    root='./Datasets', train=False, download=True, transform=transforms.ToTensor())\n\n#设置批大小，即迭代数据的时候每一批次样本的量\nbatch_size=256\n\n#train_iter代表对训练数据集迭代的迭代器，shuffle代表随机打乱顺序，这样符合机器学习的原理，num_workers为载入数据时使用处理器的数量，win下一般为0。\ntrain_iter = torch.utils.data.DataLoader(\n    mnist_train, batch_size=batch_size, shuffle=True, num_workers=0)\n#test_iter的shuffle为false不必打乱。\ntest_iter = torch.utils.data.DataLoader(\n    mnist_test, batch_size=batch_size, shuffle=False, num_workers=0)模型有了数据，那我们该采取哪种方式处理呢？那么就需要模型了。\n自定义不带参数的层：python#CenteredLayer类通过继承Module类自定义了一个将输入减掉均值后输出的层，并将层的计算定义在了forward函数里。这个层不含模型参数。\nclass CenteredLayer(nn.Module):\n    def __init__(self, **kwargs):\n        super(CenteredLayer, self).__init__(**kwargs)\n    def forward(self, x):\n        return x - x.mean()\n\n#FlattenLayer类通过继承Module类自定义了一个将输入X的维度降低为2维，第一维是数据的量，第二维是数据的内容\nclass FlattenLayer(nn.Module):\n    def __init__(self):\n        super(FlattenLayer, self).__init__()\n    def forward(self, x):  # x shape: (batch, *, *, ...)\n        return x.view(x.shape[0], -1)自定义带参数的层：python#这里的例子是定义了一个按列表顺序向前传播的层\nclass MyDense(nn.Module):\n    def __init__(self):\n        super(MyDense, self).__init__()\n        self.params = nn.ParameterList([nn.Parameter(torch.randn(4, 4)) for i in range(3)])\n        self.params.append(nn.Parameter(torch.randn(4, 1)))\n\n    def forward(self, x):\n        for i in range(len(self.params)):\n            x = torch.mm(x, self.params[i])\n        return x这是自定义的模型样本，我来解释一下。\n定义模型并生成模型实例python#一般情况下自定义的模型都以类的形式声明，继承自nn.Module类\n#这里是一个自定义的多层感知机\nclass MLP(nn.Module):\n    def __init__(self):\n        super(MLP, self).__init__()# 调用MLP父类Module的构造函数来进行必要的初始化。\n        self.flat=FlattenLayer()#自定义的层\n        self.hidden1 = nn.Linear(784, 512) # 全连接隐藏层1\n        self.hidden2 = nn.Linear(512, 256)# 全连接隐藏层2\n        self.output = nn.Linear(256, 10)  # 全连接输出层\n        self.act = nn.ReLU() #激活函数\n        #注意，在使用Linear或其他相关函数定义层的时候，就已经了自带的权重参数。\n\n    # 需要定义模型的向前传播算法，即如何根据输入x计算返回所需要的模型输出。\n    def forward(self, x):\n        #在调用的时候将以这种方式向前传播\n        return self.output(self.act(self.hidden2(self.act(self.hidden1(self.flat(x))))))\n\nnet=MLP()\t#生成对象实例使用Module类自带的子类Sequential类可以更加方便的进行模型构造，但是不能构造复杂的模型。类似于这样的使用\npython#比如这个例子，它的向前传播算法是这样的\nnet = nn.Sequential(\n    nn.Linear(num_inputs, num_hiddens),#第一步，计算隐藏层1\n    nn.ReLU(),#对隐藏层1的结果使用激活函数\n    nn.Dropout(0.1),#对隐藏层的结果使用丢弃法，丢弃概率为0.1\n    nn.Linear(num_hiddens,256),#计算隐藏层2\n    nn.ReLU(),#对隐藏层2的结果使用激活函数\n    nn.Dropout(0.2),#对隐藏层的结果使用丢弃法，丢弃概率为0.2\n    nn.Linear(256, num_outputs),#计算输出层\n)可以看到Sequential类的特点就是按顺序进行向前传播。非常直观。Sequential内的模块需要按照顺序排列，要保证相邻层的输入输出大小相匹配，内部forward功能已经实现。其他的还有ModuleList和ModuleDict，但是它们的forward方法需要自己去定义，个人觉得一般般（任何事物都有其存在的价值，可能是我才疏学浅吧）。\n访问模型中的参数：python#net是一个实例化的模型对象，使用named_parameters可以访问&lt;名称，参数&gt;键值对。\n#name是个str,param是一个Parameter对象。\nfor name, param in net.named_parameters():\n    #在这里什么也不干，单纯就打印出来\n    print(name, param.size())初始化模型中的参数：python#nn.Module的模块参数都采取了较为合理的初始化策略，但是我们有时候依然希望自定义模型中的参数\n#使用init方法对权重进行初始化，除了normal_外还有其他的初始化函数。\nfor name, param in net.named_parameters():\n    if 'weight' in name:\n        init.normal_(param, mean=0, std=0.01)\n        print(name, param.data)模型参数可以共用，只要向前传播的时候调用的是同一个模型参数即可。\n读写和保存对Tensor：\npythonx = torch.ones(3)\n\n#将tensor x 保存到x.pt文件里面\ntorch.save(x, 'x.pt')\n\n#将tensor x 从x.pt文件里面读取到x2\nx2 = torch.load('x.pt')\n\n#还可以将x,x2形成列表储存进xx2.pt，\ntorch.save([x, x2], 'xx2.pt')\n\n#再读取到xx2_list里\nxx2_list = torch.load('xx2.pt')\n\n#字典同理对模型呢：\npython#这里使用之前定义的MLP模型来举例\n\n#只保存和加载模型参数的方法\n# 注意，使用state_dict方法时一定要先有一个实例化的对象\nmodel=MLP()\n#使用state_dict()方法保存和加载模型参数，这里的model是一个实例化的模型对象，PATH是要保存的路径还有文件名\ntorch.save(model.state_dict(), PATH) # 推荐的文件后缀名是pt或pth\n#在载入的时候也要有一个实例对象，这里就命名为model2吧\nmodel2=MLP()\n#载入！\nmodel.load_state_dict(torch.load(PATH))\n\n#保存和加载整个模型的方法\ntorch.save(model, PATH)\nmodel = torch.load(PATH)损失函数可以自己写，也可以使用自带的。例如使用自带的CrossEntropyLoss()交叉熵损失函数。\npythonloss = torch.nn.CrossEntropyLoss()其他的还有\npythontorch.nn.L1Loss()#绝对值损失\ntorch.nn.MSELoss()#均方差损失\ntorch.nn.KLDivLoss()#散度损失\ntorch.nn.BCELos()#二进制交叉熵损失\ntorch.nn.BCEWithLogitsLoss()# 带Sigmoid层的二进制交叉熵损失\ntorch.nn.MarginRankingLoss()\ntorch.nn.HingeEmbeddingLoss()\ntorch.nn.MultiLabelMarginLoss#多标签分类损失\ntorch.nn.SmoothL1Loss()#平滑版绝对值损失\ntorch.nn.SoftMarginLoss()#2分类的logistic损失\ntorch.nn.MultiLabelSoftMarginLoss()#多标签 one-versus-all 损失\ntorch.nn.CosineEmbeddingLoss()#cosine损失\ntorch.nn.MultiMarginLoss()#多类别分类的hinge损失参见博客\n优化函数可以自己写，也可以使用自带的。例如使用自带的SGD函数。\npython#这里可以设置，lr学习率，weight_decay权重衰减\noptimizer = torch.optim.SGD(net.parameters(), lr=0.4,weight_decay=0.0005)其他的还有\npythontorch.optim.SGD()#随机梯度下降算法\ntorch.optim.ASGD()#异步随机梯度下降法\ntorch.optim.Rprop()#弹性反向传播算法\ntorch.optim.Adagrad()#自适应学习率优化算法\ntorch.optim.Adadelta()#改进版自适应学习率优化算法\ntorch.optim.RMSprop()#均方根反向传播算法\ntorch.optim.Adam()\ntorch.optim.Adamax()\ntorch.optim.SparseAdam()\ntorch.optim.LBFGS()#拟牛顿法正确率评估函数(可选)这个非必须，主要是给人看模型训练的正确率的，一般都要有例如这个：\npythondef evaluate_accuracy(data_iter, net):\n    acc_sum, n = 0.0, 0\n    for X, y in data_iter:\n        acc_sum += (net(X).argmax(dim=1) == y).float().sum().item()\n        n += y.shape[0]\n    return acc_sum / n训练方法告诉python怎么使用数据和模型进行计算\npythondef train_ch3(net, train_iter, test_iter, loss, num_epochs, batch_size,\n              params=None, lr=None, optimizer=None):\n    for epoch in range(num_epochs):#首先对每个周期来说，要执行以下操作：\n        train_l_sum, train_acc_sum, n = 0.0, 0.0, 0\n        for X, y in train_iter:#对每个样本\n            y_hat = net(X)#根据模型向前传播算出对应的标签值\n            l = loss(y_hat, y).sum()#计算该样本的损失并使用sum方法并加起来\n\n            # 对优化器记得梯度清零\n            optimizer.zero_grad()\n\n            l.backward() #使用backward对损失函数进行反向传播\n            optimizer.step()  #使用SGD算法进行优化\n\n            #统计正确数和总数(非必须)\n            train_l_sum += l.item()\n            train_acc_sum += (y_hat.argmax(dim=1) == y).sum().item()#计算当前的正确率\n            n += y.shape[0]#已训练的样本数量要加上当前批次的训练数量\n\n        #计算正确率(非必须)\n        test_acc = evaluate_accuracy(test_iter, net)#使用评估函数对随机样本进行评估\n        print('epoch %d, loss %.4f, train acc %.3f, test acc %.3f' % (epoch + 1, train_l_sum / n, train_acc_sum / n, test_acc))#输出","slug":"人工智能学习笔记","date":"2022-04-04T02:28:00.000Z","categories_index":"人工智能","tags_index":"Pytorch","author_index":"Ac-Accelerator"},{"id":"e8e899a32442557ba38f16b4d4d99793","title":"CSS盒子和背景","content":"Emmet语法快速开发对于HTML标签:\n\n\n\n\n\n\n\n\n\n1．生成标签直接输入标签名按tab键即可比如div然后tab键，就可以生成&lt;div&gt;&lt;/div&gt;2．如果想要生成多个相同标签加上就可以了比如div*3就可以快速生成3个div3．如果有父子级关系的标签，可以用&gt;比如ul &gt; li就可以了4．如果有兄弟关系的标签，用＋就可以了比如div+p5．如果生成带有类名或者id名字的，直接写.demo或者#two tab键就可以了6．如果生成的div类名是有顺序的，可以用自增符号$7．如果想要在生成的标签内部写内容可以用{}表示\n对于CSS样式:\n\n\n\n\n\n\n\n\n\n1．比如w200按tab 可以生成width: 200px;2.比如lh26按tab 可以生成 line-height: 26px;\n元素的显示模式元素显示模式就是元素以什么方式显示，比如div自己占一行，一行可以放多个span。HTML元素一般分为块元素和行内元素两种。\n块元素块状元素的特点：\n\n\n\n\n\n\n\n\n\n1.独占一行2.高度、宽度、内边距和内边距都可以控置。3.宽度默认是父级宽度。4.块元素是一个容器，里面可以放行内或者块元素。\n注意：文字类的块元素内部不能放其他块元素。\n行内元素行内元素的特点：  \n\n\n\n\n\n\n\n\n\n1.相邻行内元素在一行上，一行可以显示多个。2.高、宽直接设置是无效的。3.默认宽度就是它本身内容的宽度。4.行内元素只能容纳文本或其他行内元素。\n注意：链接里面不能放链接，但是可以放块元素。\n行内块元素行内块元素的特点：\n\n\n\n\n\n\n\n\n\n1.和相邻行内元素(行内块)在一行上，但是他们之间会有空白缝隙。一行可以显示多个(行内元素特点)。2.默认宽度就是它本身内容的宽度(行内元素特点)。3.高度，行高、外边距以及内边距都可以控制(块级元素特点)。  \n元素显示模式的切换使用display属性进行转换。\n常用属性值有none(隐藏)、inline(行内元素)、block(块元素)、inline-block(行内块元素)。\nCSS背景背景颜色使用background-color来定义元素的背景。\n背景图片使用背景图片属性background-image描述。语法是 background-image: url()  在url那里填上图片的url。\n背景图片在背景颜色的上层。\n背景平铺使用background-repeat属性定义背景图片是否平铺。有no-repeat(不平铺),repeat-x(x方向上平铺),repeat-y(y方向上平铺),repeat(默认，x、y上平铺)。\n背景位置使用background-position属性定义背景图片的位置。\n参数是center、left、right、top、bottom和偏移量。\n如果提供两个参数，第一个用于横坐标，第二个用于纵坐标。\n如果只提供一个参数，该值将用于横坐标；纵坐标将默认为50%（即center）。 \n如果提供三或四个，每个偏移量前都必须跟着一个方位名词。\n背景附着使用background-attachment属性定义背景图片是否附着。\n参数有fixed(相对于窗体固定)、scroll(默认，相对于元素固定)、local(相对于元素内容固定)。\n背景属性缩写background属性，参数是各种背景属性的参数。\n","slug":"CSS盒子和背景","date":"2022-04-03T02:57:00.000Z","categories_index":"前端","tags_index":"CSS","author_index":"Ac-Accelerator"},{"id":"99ee2dab73c41d51a135362a1fafc76c","title":"CSS字体常用属性","content":"上一篇学习了CSS的选择器，这一篇就学习：\nCSS属性字体使用font-family属性对元素的字体定义样式，可以设置多种不同的字体(如果浏览器不支持当前字体则找下一个字体替换)，字体之间用逗号隔开。字体名称可以是中文名，但是最好写英文名。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;字体样式&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        body {\n            /* 页面基本属性 */\n            font-family: Arial, Helvetica, sans-serif,\"宋体\";\n            /* 字体类型 */\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;p&gt;定义字体类型&lt;/p&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;字号使用font-size属性对元素的文字大小定义样式，常用单位是px(像素)、em(以父辈字体大小为参考值设置大小)。\n标题标签要单独特别指定大小。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;字体样式&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        body {\n            /* 网页字体大小 */\n            font-size: 0.75em;\n            /* 约等于12像素 */\n        }\n\n        body,\n        div,\n        p {\n            font-size: 0.75em;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div id=\"content\"&gt;框架\n        &lt;div id=\"sub\"&gt;子框架\n            &lt;p&gt;段落文本&lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;字体粗细使用font-weight属性对元素的文字粗细定义样式，常用属性值有normal、bold、bolder、lighter等自带的属性值，也有数值属性值，一般normal=400。\n标题标签要单独特别指定粗细。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;字体样式&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        p {\n            font-weight: normal\n        }\n\n        /* 等于400 */\n        h1 {\n            font-weight: 700\n        }\n\n        /* 等于bold */\n        div {\n            font-weight: bolder\n        }\n\n        /* 可能为500 */\n        .bold {\n            /* 粗体样式类 */\n            font-weight: bold;\n            /* 加粗显示 */\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;p&gt;绊爱（キズナアイ）是YouTube上一个虚拟YouTuber，自称为世界第一个Virtual YouTuber，YouTube频道名为A.I.Channel。角色形象由森倉円设计，3D模型由Tomitake制作，Tda监督。2016年12月25日，免费公开自身3D模型素材，作为圣诞礼物。2018年成为推广日本旅游的Come to Japan的宣传大使，目前是Kizuna AI株式会社的虚拟YouTuber和音乐艺术家。声称是人工智能（AI）。\n    &lt;/p&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;字体倾斜这个属性最常用于把倾斜的字体变得不倾斜\n使用font-style属性对元素的文字粗细定义样式，属性值为normal、italic、oblique。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;字体样式&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        span {\n            font-style: normal;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;p&gt;&lt;i&gt;绊爱（キズナアイ）是&lt;span&gt;YouTuber&lt;/span&gt;上一个虚拟&lt;span&gt;YouTuber&lt;/span&gt;，自称为世界第一个&lt;span&gt;YouTuber&lt;/span&gt;，&lt;span&gt;YouTuber&lt;/span&gt;频道名为A.I.Channel。角色形象由森倉円设计，3D模型由Tomitake制作，Tda监督。2016年12月25日，免费公开自身3D模型素材，作为圣诞礼物[1]。2018年成为推广日本旅游的Come\n            to Japan的宣传大使，目前是Kizuna AI株式会社的虚拟&lt;span&gt;YouTuber&lt;/span&gt;和音乐艺术家。声称是人工智能（AI）。 &lt;/i&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;!-- 所有的YouTuber都归正了。 --&gt;\n\n&lt;/html&gt;行间距使用line-height属性对元素的文字行间距定义样式。\n常用单位px。\n字体复合属性使用font属性对字体设置样式。语法font: font-style | font-variant | font-weight | font-size | line-height | font-family属性值之间用空格分隔。至少设置字体大小和字体类型，且必须放在后面。各个属性值要严格遵循相应的顺序。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;字体样式&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        body {\n            /* 斜体样式类 */\n            font: bolder 24px \"隶书\";\n            /* 斜体 */\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;p&gt;绊爱（キズナアイ）是YouTuber上一个虚拟YouTuber，自称为世界第一个YouTuber，YouTuber频道名为A.I.Channel。目前是Kizuna\n        AI株式会社的虚拟YouTuber和音乐艺术家。声称是人工智能（AI）。&lt;/p&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;字体颜色使用color属性对元素的文字颜色定义样式。  \n可以使用预定义的颜色、十六进制颜色、RGB表示颜色。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;字体样式&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        body {\n            color: gray;\n        }\n\n        p {\n            color: #666666;\n        }\n\n        div {\n            color: rgb(120, 120, 120);\n        }\n\n        span {\n            color: rgb(50%, 50%, 50%);\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;p&gt;定义字体颜色&lt;/p&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;文本对齐使用text-align属性对元素的对齐定义样式。常用属性值有:left、right、center、justify、start、end、match-parent、justify-all。\n使用vertical-align属性对元素的垂直对齐定义样式。常用属性有：auto、baseline、sub、super、top、text-top、middle、bottom、text-bottom、length。\n文本装饰使用text-decoration属性定义字体的下划线效果。常用属性有：none、underline、blink、overline、line-through。\nlist-style属性可以控制文本的标记。list-style: &lt; list-style-type&gt; || &lt; list-style-position &gt; || &lt; list-style-image &gt;\n第一项是预设标记、有disc(实心圆) circle(空心圆) 、square(实心方块) 、decimal(阿拉伯数字) 、lower-roman(小写罗马数字) 、upper-roman(大写罗马数字) 、lower-alpha(小写英文字母) 、upper-alpha(大写英文字母) 、none(不使用项目符号) 、armenian(传统的亚美尼亚数字) 、cjk-ideographic(浅白的表意数字) 、georgian(传统的乔治数字) 、lower-greek(基本的希腊小写字母) 、hebrew(传统的希伯莱数字) 、hiragana(日文平假名字符) 、hiragana-iroha(日文平假名序号) 、katakana(日文片假名字符) 、katakana-iroha(日文片假名序号) 、lower-latin(小写拉丁字母) 、upper-latin(大写拉丁字母) 。\n第二项是作为对象的列表项标记如何根据文本排列，取outside和inside。\n第三项是图像的url。\n文本缩进使用text-indent属性对元素的缩进定义样式,可以是浮点数，可以是负数。常用单位是：em(字距)。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;文本样式&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        p {\n            text-indent: -2em;\n            padding-left: 2em;/* 左侧补白 */\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n\n    &lt;h1&gt;《人间词话》节选&lt;/h1&gt;\n    &lt;h2&gt;王国维&lt;/h2&gt;\n    &lt;p&gt;古今之成大事业、大学问者，必经过三种之境界：\"昨夜西风凋碧树。独上高楼，望断天涯路。\"此第一境也。\"衣带渐宽终不悔，为伊消得人憔悴。\"此第二境也。\"众里寻他千百度，蓦然回首，那人却在灯火阑珊处。\"此第三境也。此等语皆非大词人不能道。然遽以此意解释诸词，恐为晏欧诸公所不许也。\n    &lt;/p&gt;\n\n&lt;/body&gt;\n\n&lt;/html&gt;","slug":"CSS字体常用属性","date":"2022-04-02T08:19:00.000Z","categories_index":"前端","tags_index":"CSS","author_index":"Ac-Accelerator"},{"id":"a436d0c5ab40b72eca296c2bdd2e3201","title":"CSS伪类选择器","content":"伪类选择器伪选择器包括伪类和伪对象选择器,伪选择器以冒号’:’作为前缀标识。冒号 前面可以添加选择符,限定伪类应用的范围。冒号后面为伪类和伪对象名。冒号前后没有空格，否则将错认为类选择器。\n动态伪类动态伪类只有当用户与页面进行交互时才能体现出来。其中，动态伪类选择器分为\n锚点伪类有:link(链接没被激活时)、:visited(链接被激活过),常见于链接中。行为伪类有:hover(鼠标移动到上方时)、:active(对元素按下鼠标左键时)和:focus(表单元素成为焦点时)。  \n注意:为了确保生效，需要按照先后顺序：link-&gt;visited-&gt;hover-&gt;active。\ncssa:hover,\na:active {\n  outline: 0;\n}","slug":"CSS伪类选择器","date":"2022-04-01T12:11:00.000Z","categories_index":"前端","tags_index":"CSS","author_index":"Ac-Accelerator"},{"id":"77b2bb6af72e4872676c2271a80ae12d","title":"CSS基本选择器和组合选择器","content":"新一轮的学习又开始了！之前学完CSS的语法和使用。现在学习的是~~\nCSS选择器基本选择器基本选择器分为标签选择器、类选择器、ID选择器和通配选择器。\n层叠性:如果样式冲突，则采用最新的样式。继承性:子标签会继承父标签的某些样式。优先级:继承&lt;元素选择器&lt;类/伪类选择器&lt;I选择器&lt;行内样式&lt;!important。\n标签选择器标签选择器直接引用HTML标签的名称，控制页面标签的默认显示效果,快速为页面中同类型的标签设置统一样式。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        p {\n            font-size: 12px;\n            color: red;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;p&gt;我的低调不是你们装逼的资本&lt;/p&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n类选择器差异化选择不同的标签，或单独选一个或者几个标签。开发中最常使用的方法。\n需要在HTML标签中定义class属性。类选择器以一个”.”号开头，后面紧跟类名。\n一个标签可以有多个类名，不同类名之间用空格隔开，尽量使用纯英文做类名。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;我的低调不是你们装逼的资本&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        p {\n            font-size: 12px;\n            color: red;\n        }\n\n        .font18px {\n            font-size: 18px;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;p&gt;这里是来自2010年&lt;/p&gt;\n    &lt;p class=\"font18px\"&gt;我是MC石头，在这里给你们带来好听的歌曲&lt;/p&gt;\n    &lt;p&gt;请认准唯一联系QQ：337845818&lt;/p&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;ID选择器通过ID选择一个特定的元素。\n需要在HTML标签中定义id属性。类选择器以一个”#”号开头，后面紧跟对象id。\n此选择器常和JavaScript配合使用\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        div#box {\n            background: url(images/bg1.gif) center bottom;\n            height: 200px;\n            width: 400px;\n            border: solid 2px red;\n            padding: 20px;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div id=\"box\"&gt;这就是爱&lt;/div&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;通配选择器为所有标签打上样式。\n选择器就是一个*号。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;CSS基础&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        * {\n            margin: 0;\n            padding: 0;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div id=\"box\"&gt;我寄愁心与明月随风直到夜郎西。&lt;/div&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;组合选择器组合选择器包括包含选择器、子选择器、相邻选择器、兄弟选择器和分组选择器。\n注意，优先级有权重叠加的问题。\n包含选择器、子选择器包含选择器通过空格标识符来表示。前面一个选择器表示包含框对象的选择器。而后面的选择器表示被包含的选择器。\n子选择器是指定父元素所包含的子元素，使用”&gt;”表示。\n下面的例子注意区分子选择器和组合选择器的区别。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        #header&gt;p {/* 子选择器 */\n            font-size: 14px;\n        }\n        \n        #main p {/* 包含选择器 */\n            font-size: 12px;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div id=\"wrap\"&gt;\n        &lt;div id=\"header\"&gt;\n            &lt;h2&gt;\n                &lt;p&gt;头部区域第1段文本&lt;/p&gt;\n            &lt;/h2&gt;\n            &lt;p&gt;头部区域第2段文本&lt;/p&gt;\n            &lt;p&gt;头部区域第3段文本&lt;/p&gt;\n        &lt;/div&gt;\n        &lt;div id=\"main\"&gt;\n            &lt;div&gt;\n                &lt;p&gt;主体区域第1段文本&lt;/p&gt;\n                &lt;p&gt;主体区域第2段文本&lt;/p&gt;\n            &lt;/div&gt;\n            &lt;p&gt;主体区域第3段文本&lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;html&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        span {\n            font-size: 12px;\n        }\n\n        div&gt;span {\n            font-size: 16px;\n        }\n\n        div&gt;.font24px {\n            font-size: 20px;\n        }\n\n        #box&gt;.font24px {\n            font-size: 24px;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;h2&gt;&lt;span&gt;HTML文档树状结构&lt;/span&gt;&lt;/h2&gt;\n    &lt;div id=\"box\"&gt;&lt;span class=\"font24px\"&gt;问君能有几多愁，恰似一江春水向东流。&lt;/span&gt;&lt;/div&gt;\n    &lt;div&gt;&lt;span class=\"font24px\"&gt;问君能有几多愁，恰似一江春水向东流。&lt;/span&gt;&lt;/div&gt;\n    &lt;div&gt;&lt;span&gt;问君能有几多愁，恰似一江春水向东流。&lt;/span&gt;&lt;/div&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;相邻选择器通过(+)号分隔符进行定义，第一个选择器指定前面相邻元素，后面选择器指定相邻元素。前后选择符的关系是兄弟关系，即在HTML结构中，两个标签先为兄后为弟，否则样式无法使用。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;style type=\"text/css\"&gt;\n        h2,\n        p,\n        h3 {\n            margin: 0;\n            padding: 0;\n            height: 30px;\n        }\n\n        p+h3 {\n            background-color: #0099FF;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div class=\"header\"&gt;\n        &lt;h2&gt;情况一：&lt;/h2&gt;\n        &lt;p&gt;子选择器控制p标签，能控制我吗&lt;/p&gt;\n        &lt;h3&gt;子选择器控制p标签&lt;/h3&gt;\n        &lt;h2&gt;情况二：&lt;/h2&gt;\n        &lt;div&gt;我隔开段落和h3直接&lt;/div&gt;\n        &lt;p&gt;子选择器控制p标签，能控制我吗&lt;/p&gt;\n        &lt;h3&gt;相邻选择器&lt;/h3&gt;\n        &lt;h2&gt;情况三：&lt;/h2&gt;\n        &lt;h3&gt;相邻选择器&lt;/h3&gt;\n        &lt;p&gt;子选择器控制p标签，能控制我吗&lt;/p&gt;\n        &lt;div&gt;\n            &lt;h2&gt;情况四：&lt;/h2&gt;\n            &lt;p&gt;子选择器控制p标签，能控制我吗&lt;/p&gt;\n            &lt;h3&gt;相邻选择器&lt;/h3&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;兄弟选择器通过”~”分隔符进行定义。第一个选择器指定同级前置元素，后面的选择器指定其后同级所有匹配元素，前后选择符的关系是兄弟关系，即在HTML结构中，两个标签先为兄后为弟，否则样式无法使用。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;style type=\"text/css\"&gt;\n        h2,\n        p,\n        h3 {\n            margin: 0;\n            padding: 0;\n            height: 30px;\n        }\n\n        p~h3 {\n            background-color: #0099FF;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div class=\"header\"&gt;\n        &lt;h2&gt;情况一：&lt;/h2&gt;\n        &lt;p&gt;子选择器控制p标签，能控制我吗&lt;/p&gt;\n        &lt;h3&gt;子选择器控制p标签&lt;/h3&gt;\n        &lt;h2&gt;情况二：&lt;/h2&gt;\n        &lt;div&gt;我隔开段落和h3直接&lt;/div&gt;\n        &lt;p&gt;子选择器控制p标签，能控制我吗&lt;/p&gt;\n        &lt;h3&gt;相邻选择器&lt;/h3&gt;\n        &lt;h2&gt;情况三：&lt;/h2&gt;\n        &lt;h3&gt;相邻选择器&lt;/h3&gt;\n        &lt;p&gt;子选择器控制p标签，能控制我吗&lt;/p&gt;\n        &lt;div&gt;\n            &lt;h2&gt;情况四：&lt;/h2&gt;\n            &lt;p&gt;子选择器控制p标签，能控制我吗&lt;/p&gt;\n            &lt;h3&gt;相邻选择器&lt;/h3&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;分组选择器分组选择器就是用逗号隔开不同的选择器啦。\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;script type=\"text/javascript\" src=\"IE8.js\"&gt;&lt;/script&gt;\n    &lt;style type=\"text/css\"&gt;\n        h1,\n        h2,\n        h3,\n        h4,\n        h5,\n        h5,\n        h6 {\n            background-color: #99CC33;\n            /* 设置背景色 */\n            margin: 0;\n            /* 清除标题的默认外边距 */\n            margin-bottom: 10px;\n            /* 使用下边距拉开各个标题之间的距离 */\n        }\n\n        h1+h2,\n        h2+h3,\n        h4+h5 {\n            color: #0099FF;\n            /* 兄弟关系 设置字体的颜色 */\n        }\n\n        body&gt;h6,\n        h1&gt;span,\n        h4&gt;span {\n            font-size: 20px;\n            /* 子选择器 设置字体的大小 */\n        }\n\n        h2 span,\n        h3 span {\n            padding: 0 20px;\n            /* &lt;span&gt;标签的左右间距 */\n        }\n\n        h5 span[class],\n        h6 span[class] {\n            background-color: #CC0033;\n            /* h5、h6标题中含有class属性的span标签设置背景色 */\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;h1&gt;h1元素&lt;span&gt;这里是span元素&lt;/span&gt;&lt;/h1&gt;\n    &lt;h2&gt;h2元素&lt;span&gt;这里是span元素&lt;/span&gt;&lt;/h2&gt;\n    &lt;h3&gt;h3元素&lt;span&gt;这里是span元素&lt;/span&gt;&lt;/h3&gt;\n    &lt;h4&gt;h4元素&lt;span&gt;这里是span元素&lt;/span&gt;&lt;/h4&gt;\n    &lt;h5&gt;h5元素&lt;span class=\"S1\"&gt;这里是span元素&lt;/span&gt;&lt;/h5&gt;\n    &lt;h6&gt;h6元素&lt;span class=\"S2\"&gt;这里是span元素&lt;/span&gt;&lt;/h6&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;结束学习了CSS的基本选择器，组合选择器。其实还有属性选择器、伪类选择器。\n","slug":"CSS基本选择器和组合选择器","date":"2022-03-30T12:11:00.000Z","categories_index":"前端","tags_index":"CSS","author_index":"Ac-Accelerator"},{"id":"06cb31f739141f028e7d96fc342e06c9","title":"CSS语法初探以及使用","content":"CSS语法CSS规则由两个主要的部分构成：选择器，以及一条或多条声明\n选择器通常是您需要改变样式的对象，这些对象可以是某个标签、所有网页对象、指定Class或ID值等。每条声明由一个属性和一个值组成。属性是CSS提供的设置好的样式选项。每个属性有一个值。属性和值被冒号分隔开。属性值是用来显示属性效果的参数。它包括数值和单位，或者关键字。CSS声明总是以分号 ; 结束，声明总以大括号 {} 括起来\n例如：\ncssbody\n{\n  front-size: 12px;\n  color: #333;\n}在这个例子中，body就是选择器，表示&lt;body&gt;这个标签。\nfront-size:12px;和color:#333;就是该条CSS的两个声明。\n在声明中，冒号前面的是属性，后面的是属性值。\n一般在属性值和前面的冒号之间放一个空格，会更加美观。字母最好全部小写。\nCSS应用CSS样式代码必须保存在.css文件中(链接式、导入式)，或者放在网页内style标签中(内嵌式)，或者插在网页标签的style属性值中(行内样式)。\n行内样式：html&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;p style=\"background-color: #999900\"&gt;行内元素，控制段落-1&lt;/p&gt;\n    &lt;h2 style=\"background-color: #FF6633\"&gt;行内元素，h2标题元素&lt;/h2&gt;\n    &lt;p style=\"background-color: #999900\"&gt;行内元素，控制段落-2&lt;/p&gt;\n    &lt;strong style=\"font-size: 30px;\"&gt;行内元素，strong比em效果要强&lt;/strong&gt;\n    &lt;div style=\"background-color: #66CC99; color: #993300;height: 30px; line-height: 30px;\"&gt;行内元素，div块级元素&lt;/div&gt;\n    &lt;em style=\"font-size: 2em;\"&gt;行内元素，em强调&lt;/em&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;直接将CSS的声明作为style的属性值。多个声明之间用分号间隔。只能操作当前一个元素，优先级最高。\n内嵌式html&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        p {\n            text-align: left;\n            /* 文本左对齐 */\n            font-size: 18px;\n            /* 字体大小18像素 */\n            line-height: 25px;\n            /* 行高25像素 */\n            width: 500px;\n            /* 段落宽度500像素 */\n            margin: 0 auto;\n            /* 浏览器下居中 */\n            margin-bottom: 20px;\n            /* 段落下边距20像素 */\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;p&gt;某个地方有个正在旅行的魔女，&lt;br /&gt;她的名字是伊蕾娜。&lt;br /&gt;身为旅人，&lt;br /&gt;在很长很长的旅途中，&lt;br /&gt;她与形形色色的国家与人们邂逅。&lt;/p&gt;\n    &lt;p&gt;只允许魔法师入境的国家、&lt;br /&gt;最喜欢肌肉的壮汉、&lt;br /&gt;在死亡深渊等待恋人归来的青年、&lt;br /&gt;独自留守国家早已灭亡的公主…&lt;/p&gt;\n    &lt;p&gt;最后，还有她身为魔女的至今为止与从今以后。&lt;br /&gt;和莫名其妙、滑稽可笑的人们相遇，&lt;br /&gt;接触某人美丽的日常生活，&lt;br /&gt;魔女日复一日编织出相逢与离别的故事。&lt;/p&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;将CSS的内容直接写入网页源文件的&lt;style&gt;标签内部，只能控制当前一个页面，一般情况下&lt;style&gt;标签位于&lt;head&gt;内，但实际上&lt;style&gt;标签也可放在其他地方。\n注意，&lt;style&gt;不仅可以定义CSS样式，还可以定义JavaScript脚本。常用属性为type(类型)、title(样式名称)。其中，type的属性值有text/css和test/javascript。\n一个网页可以有多个CSS样式表，一个网页文档中有多个&lt;style&gt;标签，就有多个样式表。通过title属性可以做到在多种样式直接切换。\n例如：\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;style type=\"text/css\" title=\"字体14号\"&gt;\n        p {\n            text-align: left;\n            /* 文本左对齐 */\n            font-size: 14px;\n            /* 字体大小14像素 */\n            line-height: 25px;\n            /* 行高25像素 */\n            width: 500px;\n            /* 段落宽度500像素 */\n            margin: 0 auto;\n            /* 浏览器下居中 */\n        }\n    &lt;/style&gt;\n    &lt;style type=\"text/css\" title=\"字体18号\"&gt;\n        p {\n            text-align: left;\n            /* 文本左对齐 */\n            font-size: 18px;\n            /* 字体大小18像素 */\n            line-height: 25px;\n            /* 行高25像素 */\n            width: 500px;\n            /* 段落宽度500像素 */\n            margin: 0 auto;\n            /* 浏览器下居中 */\n        }\n\n        p {\n            color: #6699FF;\n            /* 字体颜色的改变 */\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;p&gt;精灵，存在于邻界，被指定为特殊灾害的生命体。&lt;br /&gt;（精霊、隣界に存在する特殊災害指定生命体。）&lt;br /&gt;\n        处置方法1，以武力歼灭精灵。&lt;br /&gt;（対処法１、武力を以てこれを殲滅する。）&lt;br /&gt;\n        处置方法2，与精灵约会，使其娇羞。&lt;br /&gt;（対処法２、デートして、デレさせる。） ”\n    &lt;/p&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;链接式：链接式就是通过&lt;link /&gt;标签将外部样式表文件链接到HTML文档中。这是网络上网站应用最多的方式，同时也是最实用的方式。增强网页结构的拓展性和CSS样式的可维护性。例如：lianjie.css文件：\ncss/* CSS Document */\nh3{font-weight: normal; background-color: #66CC99;height: 50px; line-height: 50px;}\nspan{ color: #FF0000; font-weight: bold; }lianjie-2.css文件：\ncss/* CSS Document */\np{color: #FF3333; font-weight: bold; border-bottom:3px dashed #009933; line-height: 30px;}HTML文件:\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;link href=\"lianjie.css\" type=\"text/css\" rel=\"stylesheet\" /&gt;\n    &lt;link href=\"lianjie-2.css\" type=\"text/css\" rel=\"stylesheet\" /&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;p&gt;我是被lianjie-2.css文件控制的，楼下的你呢？？&lt;/p&gt;\n    &lt;h3&gt;楼上的,&lt;span&gt;lianjie.css&lt;/span&gt;文件给我穿的花衣服。&lt;/h3&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;&lt;link /&gt; 标签定义文档与外部资源的关系。常用属性有href(链接目标)、type(链接文档的类型)、rel(链接外部文件的关联类型)、title(样式表标题)。\n其中rel属性的属性值有alternate、author、help、icon、licence、next、pingback、prefetch、prev、search、sidebar、stylesheet、tag。\n链接到CSS时，type选择text/css，rel选择stylesheet。\n通过title属性可以做到在多种样式直接切换。\ntitle属性和rel属性存在联系，来的网页文档会使用多个&lt;link /&gt;元素导入不同的外部文件。如样式文件，脚本文件，主题文件，甚至可以包括个人自定义的其他补充文件。导入这么多不同类型、名称各异的文件后，可以使用title属性进行选择。这时，属性的作用就显现出来了。它可以指定网页文件初始显示时应用的导入文件类型。目前只能关联样式表类型。  \n外部样式是CSS应用最佳方案，一个样式表文件可以被多个网页文件引用，同时一个网页文件可以导入多个样式表，方法是重复使用&lt;link /&gt;元素导入不同的样式表文件。\n导入样式使用@import命令导入外部样式表。daoru.css文件：\ncss/* CSS Document */\n@import url(\"lianjie-2.css\");\np{text-indent:3em;}HTML文件：\nhtml&lt;!doctype html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        @import url(lianjie.css);\n        @import url(daoru.css);\n\n        body {\n            background-color: #e4e929;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div&gt;\n        &lt;p&gt;我是被lianjie-2.css文件控制的，楼下的你呢？？&lt;/p&gt;\n        &lt;h3&gt;楼上的,&lt;span&gt;lianjie.css&lt;/span&gt;文件给我穿的花衣服。&lt;/h3&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;注意在&lt;style&gt;中@import语句必须写标签中靠前的位置，后接CSS样式，否则可能导致样式失效。在CSS文件中使用@import也应该如此。\n&lt;link /&gt;和@import导入样式表的区别：  \n\n\n\n\n\n\n\n\n\nlink属于HTML标签，而@import是CSS提供的。link和页面同时加载，@import引用的CSS会等页面被加载完再加载。link兼容性更好。link的优先级更高。  \n结束学习了CSS基本语法和如何在HTML文件中使用CSS，接下来学习CSS选择器方面的知识。\n","slug":"CSS语法初探以及使用","date":"2022-03-30T02:44:00.000Z","categories_index":"前端","tags_index":"CSS","author_index":"Ac-Accelerator"},{"id":"a6e203121c86bba787d1ff23e359b97c","title":"HTML更多常用标签","content":"继续学习HTML5的相关标签。\n无序列表html&lt;ul&gt;\n  &lt;li&gt;列表项1&lt;/li&gt;\n  &lt;li&gt;列表项2&lt;/li&gt;\n  ...\n  &lt;li&gt;列表项n&lt;/li&gt;\n&lt;/ul&gt;&lt;ul&gt;标签中只能嵌套&lt;li&gt;，不能输入其他标签和文字；&lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有元素。可以使用css设置无序列表的样式属性。\n有序列表html&lt;ol&gt;\n  &lt;li&gt;列表项1&lt;/li&gt;\n  &lt;li&gt;列表项2&lt;/li&gt;\n  ...\n  &lt;li&gt;列表项n&lt;/li&gt;\n&lt;/ol&gt;大致和无序列表相似，但是是有强制的顺序。\n自定义列表html&lt;dl&gt;\n  &lt;dt&gt;名称&lt;/dt&gt;\n  &lt;dd&gt;列表项1&lt;/dd&gt;\n  &lt;dd&gt;列表项2&lt;/dd&gt;\n  &lt;dd&gt;...&lt;/dd&gt;\n  &lt;dd&gt;列表项n&lt;/dd&gt;\n&lt;/dl&gt;&lt;dl&gt;内只能包含&lt;dt&gt;和&lt;dd&gt;。不一定只有一个&lt;dt&gt;,&lt;dt&gt;也不一定放在&lt;dd&gt;的前面。&lt;dt&gt;和&lt;dd&gt;没有个数限制。\n表单html&lt;form &gt;\n  &lt;label&gt;元素&lt;/label&gt;\n  提示信息1\n  &lt;input /&gt;\n  &lt;select&gt;\n    &lt;option&gt;选项1&lt;/option&gt;\n    &lt;option&gt;选项2&lt;/option&gt;\n    &lt;option&gt;...&lt;/option&gt;\n    &lt;option&gt;选项n&lt;/option&gt;\n  &lt;/select&gt;\n  &lt;textarea&gt;请输入~&lt;/textarea&gt;\n&lt;/form&gt;表单由表单域、表单元素、提示信息组成。&lt;form&gt;构成表单域，属性有action(处理表单信息的程序)、method(提交方式)、name(表单名称)。其中，method属性有get和post两种。\n提示信息就是表单域内的文字。\n&lt;input /&gt;表示输入信息的表单元素，是单标签。常用属性为type(表单类型)、name(表单名称)、value(默认值)、checked(默认勾选)、maxlength(字符最大长度)。  \n其中type属性属性值包括button、checkbox、color、date、datetime、datetime-local、email、file、hidden、image、month、number、password、radio、range、reset、search、submit、tel、text、time、url、week。  \n其中checked属性属性值为checked。\n其中单选按钮和复选框的name属性值要一致。\n &lt;label&gt;表示给&lt;input /&gt;定义标注，即点击该标签相当于点击对应&lt;input /&gt;标签。常用属性为for(绑定&lt;input /&gt;标签的id属性值)。被绑定的&lt;input /&gt;标签必须有id属性。\n&lt;selcet&gt;是选择下拉列表的标签，&lt;option&gt;是该标签下的选项。其中：&lt;selcet&gt;中至少包含一个选项。&lt;option&gt;的常用属性有selected(默认选中),属性值有selected和””。\n&lt;textarea&gt;用于定义多行文本输入。若要预先显示内容，则输入文本元素。常用属性有cols(每行输入的字符数)、rows(显示的行数)。但通常使用css来改变大小。\n结束：基本上完成了对常用的HTML5标签的学习，更多标签可等日后要用的时候上网搜索，可能以后阅历丰富了会出一个其他HTML5标签和特性介绍的博客。\n由此HTML5便告一段落，迎接CSS3的学习吧！\n","slug":"HTML更多常用标签","date":"2022-03-29T12:37:00.000Z","categories_index":"前端","tags_index":"HTML","author_index":"Ac-Accelerator"},{"id":"04af9c93be90c311478eb160a4d5a3e4","title":"HTML语法和常用标签","content":"我终于开始学习前端知识了。网站是由一个个网页组成，网页就是浏览器打开的HTML文件。HTML文档是由一个又一个标签组成的。 \n基本语法：\n\n\n\n\n\n\n\n\n1.代码的第一行使用DOCTYPE声明文档类型。2.&lt;html&gt;标签应该设置文档名字空间。3.所有标签都包含在 “&lt;”和”&gt; “起止标识符中，构成一个标签。4.绝大多数元素都有起始标签和结束标签，在起始标签和结束标签之间包含的是元素主体。5.起始标签包含元素的名称以及可选属性。  6.元素的属性包含属性名称和属性值两部分。7.少数元素的属性也可能不包含属性值，仅包含一个属性名称。8.一般属性值应该包含在引号内。9.属性是可选的。10.标签可以互相嵌套，形成文档结构。嵌套必须匹配。合法的嵌套，应该是包含或被包含的关系。11.文档所有信息都必须包含在&lt;html&gt;标签中。所有文档元信息应该包含在&lt;head&gt;子标签中。传递信息和网页显示内容应包含在&lt;body&gt;子标签中。\n网页模板：下面是网页的一个基本模板。\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=\"zh-CN\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    \n&lt;/body&gt;\n&lt;/html&gt;&lt;!DOCTYPE html&gt;声明这是一个HTML5文档。&lt;html&gt;告诉浏览器这是中文文档。&lt;meta charset=”UTF-8”&gt;告诉浏览器这是使用UTF-8进行编码&lt;title&gt;Document&lt;/title&gt;指明这篇文章的标题是Document。\n标签学习：大部分标签都有三个核心属性class(所属类名)、id(元素的唯一标识)、style(元素样式声明)\n大部分标签还有语言属性lang(元素的语言代码和编码)、dir(定义文本方向，有ltr和rtl两个属性)。\n还有定义元素键盘访问方法的键盘属性accesskey(定义访问某元素的快捷键，按下Alt+该键来访问指定URL)、tabindex(定义tab键访问的顺序)\n还有定义元素包含内容的附加信息的内容属性alt(定义元素的替换文本)、title(定义元素提示文本)、longdesc(长描述信息)、cite(定义引用信息)、datetime(定义时间)。\n其他属性如：rel(当前页面和其他页面的关系)、rev(从目标文档到源文档的关系)。\n剩下就是所有标签都有的全局属性！：contentEditable(是否允许用户在线编辑元素中的内容，true和false)、contextmenu(用于定义&lt;div&gt;元素的右键菜单，属性值和要打开的&lt;menu&gt;元素的id值保持一致)、data-*(用于储存页面或web应用私有的自定义数据，用于JavaScript)、draggable(元素是否能拖动，true和false)、dropzone(在元素上拖动数据时，是否复制、移动或链接被拖动数据，copy、move和link)、hidden(元素是否可见，true和false)、spellcheck(是否对元素进行拼写语法检查，true和false)、translate(是否翻译元素内容，yes和no)。\n标题标签：html&lt;h1&gt;这是一个标题&lt;/h1&gt;\n&lt;h2&gt;这是一个标题&lt;/h2&gt;\n···\n&lt;h6&gt;这是一个标题&lt;/h6&gt;分为1~6级标题，一级标题是最大的，六级是最小的。标题标签独占一行。\n段落标签：html&lt;p&gt;这是一个段落。&lt;/p&gt;\n&lt;p&gt;这是另外一个段落。&lt;/p&gt;不同段落在放不同的段落标签中。段落与段落之间有一定的间距。段落内自动换行，自动排版。\n换行标签：html&lt;br/&gt;这是位数不多的几个单标签之一。如果希望某段文本强制换行显示，就需要使用换行标签。\n水平线：html&lt;hr/&gt;这是位数不多的几个单标签之一。产生水平分隔线。   \n \n\n包含框标签：html&lt;div&gt;包含框&lt;/div&gt;\n&lt;span&gt;行内包含框&lt;/span&gt;前者独占一行，后者将一行分割成许多部分。\n修饰标签：html&lt;b&gt;粗体&lt;/b&gt;\n&lt;i&gt;斜体&lt;/i&gt;\n&lt;u&gt;下划线&lt;/u&gt;\n&lt;s&gt;删除线&lt;/s&gt;粗体斜体下划线删除线\n图像标签：html&lt;img /&gt;这是位数不多的几个单标签之一。必选参数为src，即图片地址。常用可选参数有alt(替换文本)、title(提示文本)、width(宽度)、height(高度)和border(边框粗细)。一般高度和宽度任选其一来保证长宽比与原图一致。\n超链接标签：html&lt;a &gt;超链接元素&lt;/a&gt;常用属性有href(跳转的目标)、target(打开方式)  \n如果跳转目标指向网页，则跳转至该网页；指向文件，则下载该文件。  \n若跳转目标暂时未定，则传入参数”#”，表示空链接。\n若是锚点链接，则href传入参数”#example”,其中example是某个元素的id属性的参数，单击此链接将跳转至该元素。\ntarget的默认值是_self，即切换当前界面至目标。可修改为_blank,新建标签页打开目标。\n表格标签：html&lt;table &gt;\n    &lt;thead&gt;\n        &lt;tr&gt; &lt;th&gt;1,1&lt;/th&gt; &lt;th&gt;1,2&lt;/th&gt;&lt;th&gt;...&lt;/th&gt;&lt;th&gt;1,n&lt;/th&gt; &lt;/tr&gt;\n    &lt;/thead&gt;\n    &lt;tbody&gt;\n        &lt;tr&gt; &lt;td&gt;2,1&lt;/td&gt; &lt;td&gt;2,2&lt;/td&gt;&lt;td&gt;...&lt;/td&gt;&lt;td&gt;2,n&lt;/td&gt; &lt;/tr&gt;\n        &lt;tr&gt; &lt;th&gt;3,1&lt;/th&gt; &lt;td&gt;3,2&lt;/td&gt;&lt;td&gt;...&lt;/td&gt;&lt;td&gt;3,n&lt;/td&gt; &lt;/tr&gt;\n        &lt;tr&gt; &lt;td&gt;...&lt;/td&gt; &lt;td&gt;...&lt;/td&gt; &lt;td&gt;...&lt;/td&gt; &lt;td&gt;...&lt;/td&gt;&lt;/tr&gt;\n        &lt;tr&gt; &lt;td&gt;m,1&lt;/td&gt; &lt;td&gt;m,2&lt;/td&gt;&lt;td&gt;...&lt;/td&gt;&lt;td&gt;m,n&lt;/td&gt; &lt;/tr&gt;\n    &lt;/tbody&gt;\n&lt;/table&gt;用于展示数据。可使用&lt;thead&gt;和&lt;tbody&gt;划分表格的表头部分和主体部分(只是为了方便管理而已)，值得注意的是&lt;thead&gt;里面必须包含&lt;tr&gt;标签;&lt;tr&gt;代表行；&lt;td&gt;代表一行中的每个元素(单元格)；&lt;th&gt;表示表头，其实它可以用于表中任何位置如(3,1)，第一行也不一定非要是表头，可以说是&lt;td&gt;带了强调效果(居中加粗),？\n\n    \n         1,1 1,2...1,n \n    \n    \n         2,1 2,2...2,n \n         3,1 3,2...3,n \n         ... ... ... ...\n         m,1 m,2...m,n \n    \n\n常用属性有align(对齐)、border(有无边框)、cellpadding(单元边缘与内容的间隙),cellspacing(单元格之间的间隙),width(表格的宽度),height(表格的高度)。\n\nalign的参数有left，center，right。border的参数有1，0。\nwidth,height的参数可以说像素和百分比。  \n单元格合并的属性的使用：  \n\n\n\n\n\n\n\n\n\n跨行向下合并：rowspan=”合并单元格的个数”跨列向右合并：colspan=”合并单元格的个数”找到合并的起点单元格，向该单元格添加上述属性。删除被合并的单元格。\n一般使用css3进行表格的布局渲染，很少使用表格的属性。\n结束学习了HTML5的相关知识，重点是标签，标签种类以及其属性复杂繁多，应该多加运用才能准确记忆。\n","slug":"HTML语法和常用标签","date":"2022-03-29T07:01:00.000Z","categories_index":"前端","tags_index":"HTML","author_index":"Ac-Accelerator"},{"id":"82bb5c4aa6675d3807368598b5169a90","title":"高等数学上册复习纲要","content":"重新复习高等数学，记下纲要以备查看右键在新标签页中可放大查看。","slug":"高等数学上册复习纲要","date":"2022-03-25T08:40:00.000Z","categories_index":"数学","tags_index":"微积分","author_index":"Ac-Accelerator"},{"id":"c680c055c2c55942f701ddf0f0509a08","title":"Linux系统的常用命令(1)","content":"文件管理说到操作系统，那就不得不提文件管理了。文件管理是使用计算机的基础，是最频繁的操作。学会linux下的文件管理是非常重要的。更多说明可以通过指令\ntxtinfo [指令名称]来查看官方详细文档\nls:列出文件ls为英语单词list的缩写。列出指定文件夹下的内容及其相关属性信息。默认状态下，ls命令会列出当前文件夹的内容。\n格式：ls [参数] [文件夹]\n常用参数：（区分大小写）   \n\n\n\n\n\n\n\n\n\n-a或 --all 显示所有文件及文件夹 (包括以“.”开头的隐藏文件)  -l或--format=long使用长格式列出文件及文件夹信息  -r或--reverse将文件以相反次序显示(默认依英文字母次序)-t或--sort=time根据最后的修改时间排序-A或--almost-all同 -a ，但不列出 “.” (当前文件夹) 及 “..” (父文件夹)-S或--sort=size根据文件大小排序-R或--recursive递归列出所有子文件夹  \n实例:列出当前文件夹下的所有文件和文件夹的详细信息 :\ntxtls -l递归列出 /etc 文件夹下的所有文件夹及文件的详细信息 :\ntxtls -lR /etc列出当前文件夹所有名称是 “a” 开头的文件 :\ntxtls a*列出当前文件夹下所有名称是 “gz” 结尾的文件并按时间排序 :\ntxtls -t *gzmkdir:创建文件夹mkdir命令是make directories的缩写。  \n默认状态下，如果要创建的文件夹已经存在，则提示已存在，而不会继续创建文件夹。 所以在创建文件夹时，应保证新建的文件夹与它所在文件夹下的文件没有重名。 mkdir命令还可以同时创建多个文件夹\n格式:mkdir [参数] [文件夹]  \n常用参数:（区分大小写） \n\n\n\n\n\n\n\n\n\n-p\t递归创建多级文件夹-m\t建立文件夹的同时设置文件夹的权限-z\t设置安全上下文-v\t显示文件夹的创建过程  \n实例在当前文件夹下，建立一个名为 dir 的子文件夹:\ntxtmkdir dir在文件夹/usr/linuxcool下建立子文件夹dir，并且设置文件属主有读、写和执行权限，其他人无权访问\ntxtmkdir -m 700 /usr/linuxcool/dir同时创建子文件夹dir1，dir2，dir3：\ntxtmkdir dir1 dir2 dir3递归创建文件夹：\ntxtmkdir -p linuxcool/dircp:复制cp命令是copy的缩写。  \ncp命令可以将多个文件复制到一个具体的文件名或一个已经存在的文件夹下，也可以同时复制多个文件到一个指定的文件夹中。\n格式:cp [参数] [文件夹]  \n常用参数:（区分大小写）  \n\n\n\n\n\n\n\n\n\n-f或--force若目标文件已存在，则会直接覆盖原文件-i或--interactive若目标文件已存在，则会询问是否覆盖-p或--preserve保留源文件或文件夹的所有属性-r或-R或--recursive递归复制文件和文件夹-d\t当复制符号连接时，把目标文件或文件夹也建立为符号连接，并指向与源文件或文件夹连接的原始文件或文件夹-l或--link对源文件建立硬连接，而非复制文件-s或--symbolic-link对源文件建立符号连接，而非复制文件-b或--backup覆盖已存在的文件目标前将目标文件备份-v或--verbose详细显示cp命令执行的操作过程-a或--archive等价于“dpr”选项  \n实例复制文件夹dir1到dir2下：\ntxtcp -r dir1 dir2将文件f1改名为f2：  \ntxtcp -f f1 f2复制file1,file2,file3到dir下：\ntxtcp -r file1 file2 file3 dir交互式地将文件夹 /usr/linuxcool 中的所有.c文件复制到文件夹 dir 中：\ntxtcp -r /usr/linuxcool/*.c dirpwd:显示当前路径pwd命令是print working directory缩写。显示当前工作文件夹的绝对路径。  \n格式:pwd [参数]\n常用参数:(区分大小写)  \n\n\n\n\n\n\n\n\n\n-L或--logical显示逻辑路径-P或--physica显示物理路径 \nmv:移动或改名文件mv命令是move单词的缩写，可以移动文件或对其改名。  \n格式:mv [参数]\n常用参数:(区分大小写)  \n\n\n\n\n\n\n\n\n\n-i或--interactive若存在同名文件，则向用户询问是否覆盖-f或--force覆盖已有文件时，不进行任何提示-b或--backup当文件存在时，覆盖前为其创建一个备份-u或--update当源文件比目标文件新，或者目标文件不存在时，才执行移动此操作  \n实例将文件file_1重命名为file_2：\ntxtmv file_1 file_2将文件file移动到文件夹dir中 ：\ntxtmv file /dir将文件夹dir1移动文件夹dir2中（前提是文件夹dir2已存在，若不存在则改名)：\ntxtmv /dir1 /dir2将文件夹dir1下的文件移动到当前文件夹下：\ntxtmv /dir1/* ./touch:创建文件pwd命令是print working directory缩写。显示当前工作文件夹的绝对路径。  \n格式:touch [参数] [文件]\n常用参数:  \n\n\n\n\n\n\n\n\n\n-a或--time=access改变档案的读取时间记录-m或--time=modify改变档案的修改时间记录-r或--reference=FILE使用参考档的时间记录，与 –file 的效果一样-c或--no-create不创建新文件-d或--date==TIME设定时间与日期，可以使用各种不同的格式-t\t设定档案的时间记录，格式与 date 命令相同--no-create\t不创建新文件--help\t显示帮助信息--version\t列出版本讯息  \n实例创建空文件file.txt：\ntxttouch file.txt批量创建文件，在当前文件夹生成file1.txt file2.txt file3.txt file4.txt file5.txt 五个文件：\ntxttouch file{1..5}.txt 修改文件的access(访问)时间：\ntxttouch -a file.txtuserdel:删除用户userdel英文全称user delete,用于删除指定的用户及与该用户相关的文件。其实userdel命令实际上是修改了系统的用户账号文件 /etc/passwd、/etc/shadow以及/etc/group文件。如果有该要删除用户相关的进程正在运行，userdel命令通常不会删除一个用户账号。如果确实必须要删除，可以先终止用户进程，然后再执行userdel命令进行删除。但是userdel命令也提供了一个面对该种情况的参数，即”-f”选项。\n格式:userdel [参数] [用户名]\n常用参数:(区分大小写)  \n\n\n\n\n\n\n\n\n\n-f或--force强制删除用户账号-r或--remove删除用户主文件夹及其中的任何文件-h或--help显示命令的帮助信息\n实例删除用户，但不删除其home文件夹及文件：\ntxtuserdel [username]删除用户，并将其家文件夹及文件一并删除：\ntxtuserdel -r [username]强制删除用户：\ntxtuserdel -f [username]ln:创建链接ln英文全称是link，即链接的意思，它的功能是为某一个文件在另外一个位置建立一个同步的链接。 一种是hard link，又称为硬链接，另一种是symbolic link，又称为符号链接。  \n可以把硬链接当成源文件的副本，他和源文件一样的大小，但是事实上却不占任何空间。符号链接可以理解为类似windows一样的快捷方式。  \n\n\n\n\n\n\n\n\n\n符号链接：1.符号链接以路径的形式存在，类似于Windows操作系统中的快捷方式。2.符号链接可以跨文件系统 ，硬链接不可以。3.符号链接可以对一个不存在的文件名进行链接，硬链接不可以。4.符号链接可以对文件夹进行链接，硬链接不可以。  \n\n\n\n\n\n\n\n\n\n硬链接：1.硬链接以文件副本的形式存在，但不占用实际空间。2.硬链接不允许给文件夹创建硬链接。3.硬链接只有在同一个文件系统中才能创建。  \n格式:ln [参数] [源文件或文件夹] [目标文件或文件夹]\n常用参数:(区分大小写) \n\n\n\n\n\n\n\n\n\n-b或--backup为每个已存在的目标文件创建备份文件-d或--directory或-F此选项允许“root”用户建立文件夹的硬链接-f或--force强制创建链接，即使目标文件已经存在-n或--no-dereference把指向文件夹的符号链接视为一个普通文件-i或--interactive交互模式，若目标文件已经存在，则提示用户确认进行覆盖-s或--symbolic对源文件建立符号链接，而非硬链接-v或--verbose详细信息模式，输出指令的详细执行过程 \n实例为源文件file.txt创建硬链接file_1：\ntxtln /root/dir/file.txt ./file_1使用ln命令的“-s”参数来创建文件夹的符号链接，并使用ls命令来查看链接文件的详细信息：\ntxtln -s dir file使用ln命令的“-b”命令来创建目标文件的备份文件:\ntxtln -b /root/dir/file.txt ./file_1chattr:更改文件属性chattr指令可改变linux文件系统的文件属性，通用格式为：+-=[aAcCdDeijsStTu]“ aAcCdDeijsStTu ” 表示可以赋予文件的新属性，这些属性共有以下几种模式 。 \n\n\n\n\n\n\n\n\n\na：让文件或文件夹仅供附加用途；A：当一个具有“A”属性的文件被访问时，它的atime记录不会被修改；c：将文件或文件夹压缩后存放；d：将文件或文件夹排除在倾倒操作之外；i：不得任意更动文件或文件夹；j：如果文件系统安装有“data=order”或“data=writeback”选项，则具有“j”属性的文件在写入文件本身之前将其所有数据写入ext 3日志；s：当删除具有“s”属性集的文件时，其块将被归零并写回磁盘；S：当修改具有“S”属性集的文件时，更改将同步写入磁盘；这相当于应用于文件子集的“同步”挂载选项；u：当删除具有‘u’属性集的文件时，它的内容将被保存。  \n格式chattr [参数] [文件]\n常用参数（区分大小写）  \n\n\n\n\n\n\n\n\n\n-R\t递归处理文件夹下的所有文件-v\t设置文件或文件夹版本-V\t显示指令执行过程+\t开启文件或文件夹的该项属性--\t关闭文件或文件夹的该项属性=\t指定文件或文件夹的该项属性  \n实例用chattr命令防止系统中某个关键文件被修改(加锁)：\ntxtchattr +i /etc/resolv.conf解锁：\ntxtchattr -i /home/omd/h.txt 让某个文件只能往里面追加数据，但不能删除，适用于各种日志文件：\ntxtchattr +a /var/log/messagescd:切换文件夹cd是change directory的缩写，功能是从当前文件夹切换到指定文件夹。其中文件夹的路径可分为绝对路径和相对路径。若文件夹名称省略，则切换至使用者的用户文件夹(也就是刚登录时所在的文件夹)。另外，“~”也表示为用户文件夹的意思，“.”则是表示目前所在的文件夹，”..”则表示当前文件夹位置的上一级文件夹。  \n格式cd [参数] [文件夹名]\n常用参数：  \n\n\n\n\n\n\n\n\n\n-P\t如果切换的目标文件夹是一个符号链接，则直接切换到符号链接指向的目标文件夹-L\t如果切换的目标文件夹是一个符号链接，则直接切换到符号链接名所在的文件夹--\t仅使用”-“选项时，当前文件夹将被切换到环境变量”OLDPWD”对应值的文件夹~\t切换至当前用户文件夹..\t切换至当前文件夹位置的上一级文件夹  \n实例将当前工作文件夹切换到dir文件夹：\ntxtcd dir返回上两级文件夹：\ntxtcd ../..返回上一次所在文件夹：\ntxtcd --locate:快速查找文件locate命令其实是find -name的另一种写法，但是要比后者快得多，原因在于它不搜索具体文件夹，而是搜索一个数据库/var/lib/locatedb，值得注意的是：版本不同，会有所不同。有的版本位置是 /var/lib/mlocate/mlocatedb ，还有的是/var/lib/slocate/slocate.db ，这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。\n格式locate [参数] [文件]\n常用参数  \n\n\n\n\n\n\n\n\n\n-d&lt;文件夹&gt;或--database=&lt;文件夹&gt;\t指定数据库所在的文件夹--help\t显示帮助--version\t显示版本信息  \n实例搜索/etc文件夹下所有以sh开头的文件：\ntxtlocate /etc/sh查找和pwd相关的所有文件：\ntxtlocate pwdwget:文件下载wget命令用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。wget支持HTTP，HTTPS和FTP协议，可以使用HTTP代理。所谓的自动下载是指，wget可以在用户退出系统的之后在后台执行。这意味这你可以登录系统，启动一个wget下载任务，然后退出系统，wget将在后台执行直到任务完成，相对于其它大部分浏览器在下载大量数据时需要用户一直的参与，这省去了极大的麻烦。\n格式：wget [参数]\n常用参数：(区分大小写)  \n\n\n\n\n\n\n\n\n\n-V或–-version 显示wget的版本后退出-O或--output-document=FILE 保存为-h或–-help 打印语法帮助-b或–-background 启动后转入后台执行-e或–-execute=COMMAND   作为wgetrc的一部分执行命令  \n实例使用wget下载单个文件:\ntxtwget https://ac-accelerator.github.io/testfile.zip下载并以不同的文件名保存：\ntxtwget -O test.zip https://ac-accelerator.github.io/testfile.zip使用wget断点续传：\ntxtwget -c https://ac-accelerator.github.io/test.zip使用wget后台下载：\ntxtwget -b https://ac-accelerator.github.io/test.ziptar:打包和备份的归档工具tar命令可以为linux的文件和文件夹创建档案。利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。利用tar命令，可以把一大堆的文件和文件夹全部打包成一个文件。\n格式：tar [参数] [文件或文件夹]\n常用参数：（区分大小写） \n\n\n\n\n\n\n\n\n\n-A\t新增文件到以存在的备份文件-B\t设置区块大小-c\t建立新的备份文件-C &lt;文件夹&gt;\t切换工作文件夹，先进入指定文件夹再执行压缩/解压缩操作，可用于仅压缩特定文件夹里的内容或解压缩到特定文件夹-d\t记录文件的差别-x\t从归档文件中提取文件-t\t列出备份文件的内容-z\t通过gzip指令压缩/解压缩文件，文件名最好为*.tar.gz-Z\t通过compress指令处理备份文件-f &lt;备份文件&gt;\t指定备份文件-v\t显示指令执行过程-r\t添加文件到已经压缩的文件-u\t添加改变了和现有的文件到已经存在的压缩文件-j\t通过bzip2指令压缩/解压缩文件，文件名最好为*.tar.bz2-v\t显示操作过程-l\t文件系统边界设置-k\t保留原有文件不覆盖-m\t保留文件不被覆盖-w\t确认压缩文件的正确性-p\t保留原来的文件权限与属性-P\t使用文件名的绝对路径，不移除文件名称前的“/”号-N &lt;日期格式&gt;\t只将较指定日期更新的文件保存到备份文件里-- -exclude=&lt;范本样式&gt;\t排除符合范本样式的文件-- -remove-files\t归档/压缩之后删除源文件  \n实例将所有.jpg的文件打成一个名为jpg.tar的包：\ntxttar -cf jpg.tar *.jpg打包文件之后删除源文件：\ntxttar -cvf file.tar file --remove-files打包文件以后，以 gzip 压缩：\ntxttar -zcvf log.tar.gz file.log解压缩file.tar.gz：\ntxttar -zxvf file.tar.gz结束至此，linux系统常用命令第一弹到此结束了，相信掌握了上述命令，对linux系统常用的文件操作应该是不陌生了，其实本文的许多内容都来自LinuxCool，一个非常好的学linux的网站，不会的都可以进行参考。\n","slug":"Linux系统的常用命令-1","date":"2022-03-06T02:30:00.000Z","categories_index":"Linux","tags_index":"文件操作,Linux","author_index":"Ac-Accelerator"},{"id":"0b8c5b2ddab35fde5457c41855fd8f40","title":"图的相关算法","content":"打算把图的相关算法都复习记录一遍。以相关题目为主，代码并非最优解。\n图的创建和删除边请编写程序对给定的有向图删除若干条边。有向图中包含n个顶点，编号为0至n-1。输入格式:输入第一行为两个正整数n和e，分别表示图的顶点数和边数，其中n不超过20000，e不超过1000。接下来e行表示每条边的信息，每行为3个非负整数a、b、c，其中a和b表示该边的端点编号，c表示权值。各边并非按端点编号顺序排列。随后一行为一个整数k，表示删除的边的条数，接下来k行，每行为2个非负整数a、b，表示待删除的边为a-&gt;b。保证删除的边一定在原图中。  输出格式:输出执行删边操作之后的图。每行表示一个顶点引出的所有边，格式为a:(a,b,w)……，表示有向边a-&gt;b的权值为w，a引出的多条边按编号b的递增序排列。若某顶点没有引出边，则不输出。输入样例:  \ntxt7 7\n0 1 5\n0 3 7\n0 6 6\n1 2 4\n2 5 1\n3 5 3\n6 5 4\n2\n2 5\n0 1输出样例:  \ntxt0:(0,3,7)(0,6,6)\n1:(1,2,4)\n3:(3,5,3)\n6:(6,5,4)代码:  \ncpp#include &lt;iostream&gt;\n#include &lt;map&gt;\nusing namespace std;\nclass Node\n{\npublic:\n    int value;//节点下标\n    map&lt;int, int&gt; connection; //first:连接的节点的下标，second：对应边的权值\n};\nmain()\n{\n    int n, e;\n    cin &gt;&gt; n &gt;&gt; e;\n    Node list[n];\n    for (int i = 0; i &lt; e; i++)\n    {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        list[a].value = a;\n        list[a].connection[b] = c;\n    }\n    int x;\n    cin &gt;&gt; x;\n    for (int i = 0; i &lt; x; i++)//删边\n    {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        list[a].connection.erase(b);\n    }\n    for (int i = 0; i &lt; n; i++)//按格式输出\n    {\n        if (!list[i].connection.empty())\n        {\n            cout &lt;&lt; i &lt;&lt; ':';\n            for (auto j = list[i].connection.begin(); j != list[i].connection.end(); j++)\n            {\n                cout &lt;&lt; '(' &lt;&lt; i &lt;&lt; ',' &lt;&lt; j-&gt;first &lt;&lt; ',' &lt;&lt; j-&gt;second &lt;&lt; ')';\n            }\n            cout &lt;&lt; endl;\n        }\n    }\n}岛屿数量：深度优先遍历给你一个由 1（陆地）和 0（水）组成的n*m的二维网格，请你计算网格中岛屿的数量num。\n岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。例如\n\n\n\n例\n例\n例\n\n\n\n0\n0\n0\n\n\n0\n1\n0\n\n\n0\n0\n1\n\n\n此为两个岛屿\n此外，你可以假设该网格的四条边均被水包围。1&lt;=n,m&lt;=100输入格式:第一行中给出网格长宽n,m 接下来的n行表示网格情况输出格式:岛屿个数num输入样例:  \ntxt4 5\n1 1 0 0 0\n1 1 0 0 0\n0 0 1 0 0\n0 0 0 1 1输出样例:  \ntxt3代码:  \ncpp#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nstruct node\n{\n    int num = 0;//该点的值\n    bool done = 0;//是否被搜索过\n};\nnode nodes[2002][2002];//图\nvoid dfs(int, int);//选定算法：深度优先遍历\nint sum=0;\nmain()\n{\n    int m, n;\n    cin &gt;&gt; m &gt;&gt; n;\n    for (int i = 1; i &lt;= m;i++)//建图\n        for (int j = 1; j &lt;=n;j++)\n            cin &gt;&gt; nodes[i][j].num;\n    for (int i = 1; i &lt;= m;i++)\n        for (int j = 1; j &lt;=n;j++)\n            if((!nodes[i][j].done)&amp;&amp;nodes[i][j].num==1)//遍历每个点，如果是陆地且没有被走过，则深度优先遍历和它相连的陆地\n            {\n                dfs(i, j);\n                sum++;//岛屿的数量增加\n            }\n    cout &lt;&lt; sum;\n}\nvoid dfs(int i ,int j)\n{\n    if (nodes[i][j].done==1)//被走过，return\n        return;  \n    nodes[i][j].done = 1;//没被走过，进行标记\n    if(nodes[i+1][j].num==1)   //遍历搜索\n        dfs(i + 1, j);  \n    if(nodes[i-1][j].num==1)   \n        dfs(i - 1, j);   \n    if(nodes[i][j+1].num==1)   \n        dfs(i, j+1);\n    if(nodes[i][j-1].num==1) \n        dfs(i , j-1);\n}繁忙的都市：最小生成树城市 C 是一个非常繁忙的大都市，城市中的道路十分的拥挤，于是市长决定对其中的道路进行改造。城市 C 的道路是这样分布的：城市中有 n 个交叉路口，有些交叉路口之间有道路相连，两个交叉路口之间最多有一条道路相连接。这些道路是双向的，且把所有的交叉路口直接或间接的连接起来了。每条道路都有一个分值，分值越小表示这个道路越繁忙，越需要进行改造。但是市政府的资金有限，市长希望进行改造的道路越少越好，于是他提出下面的要求：\n改造的那些道路能够把所有的交叉路口直接或间接的连通起来。\n在满足要求 (1) 的情况下，改造的道路尽量少。\n在满足要求 (1)、(2) 的情况下，改造的那些道路中分值最大的道路分值尽量小。\n任务：作为市规划局的你，应当作出最佳的决策，选择那些道路应当被修建。输入格式:第一行有两个整数 n,m 表示城市有 n 个交叉路口，m 条道路。\n接下来 m 行是对每条道路的描述，u,v,c 表示交叉路口 u 和 v 之间有道路相连，分值为 c 。  1≤n≤300,1≤c≤10000输出格式:两个整数 s,max，表示你选出了几条道路，分值最大的那条道路的分值是多少。输入样例:  \ntxt4 5\n1 2 3\n1 4 5\n2 4 7\n2 3 6\n3 4 8输出样例:  \ntxt3 6代码:  \ncpp#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nclass Node //路径类\n{\npublic:\n    int a, b, c; //节点1，节点2，权\n} list[10000];\nint sign[10000];//用于归类，下标是路径，数值是路径对应的类的编号\nint find(int);//用于找到路径属于哪一类\nbool compare(Node, Node);\nmain()\n{\n    int n, m, maxx=0, num=0;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1; i &lt;= n; i++)//初始化sign数组，每个路基都属于不同类\n        sign[i] = i;\n    for (int i = 1; i &lt;= m; i++)//建图\n        cin &gt;&gt; list[i].a &gt;&gt; list[i].b &gt;&gt; list[i].c;\n    sort(list + 1, list + 1 + m, compare); //对路径按权进行排序\n    for (int i = 1; i &lt;= m; i++)           //遍历所有路径\n    {\n        int u = list[i].a, v = list[i].b;\n        if (find(u) == find(v)) //左节点和右节点属于一类，则已经被连接，说明此路径不是两个节点的最短路径\n            continue;\n        num++;\n        sign[find(u)] = find(v); //连接左节点和右节点，即两个节点归属一类\n        maxx = max(maxx, list[i].c); //更新最大分值\n    }\n    cout &lt;&lt; num &lt;&lt; ' ' &lt;&lt; maxx;\n}\nbool compare(Node a, Node b)\n{\n    return a.c &lt; b.c;\n}\nint find(int x)//难点\n{\n    if (sign[x] != x)//如果不是初始化时的值\n        sign[x] = find(sign[x]);//则更新自己的值\n    return sign[x];\n}排列论文:拓扑排序给定编号为1至n的n篇论文，以及m个形如d, u (1≤d,u≤n,d=u)的引用关系，表示论文论文d中定义的一个名词在论文u中被引用。现在要对这n篇论文重新排列，排列方案须满足如下要求：一篇论文引用的名词必须在排在他前面的论文中被定义过。\n请编写程序粗略计算都有多少种满足要求的方案，如果无满足要求的方案则输出0，如果有唯一方案则输出1，如果有多种方案则输出2。输入格式:输入包含多组数据，每组数据第一行为两个正整数n和m，分别表示论文篇数和引用关系数，均不超过100。接下来m行表示论文引用关系，每行为空格间隔的2个正整数d和u，表示论文论文d中定义的一个名词在论文u中被引用。输出格式:对于每组数据输出一个整数：无满足要求的排列方案则输出0，如果有唯一方案则输出1，如果有多种方案则输出2。输入样例:  \ntxt5 4\n1 5\n5 2\n3 2\n4 3\n5 4\n3 1\n4 2\n1 5\n5 4输出样例:  \ntxt2\n1代码:  \ncpp#include &lt;cstring&gt;\n#include &lt;deque&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nint howMuchBefore[1000];\ndeque&lt;int&gt; dict[1000];//节点名称对子节点的索引\ndeque&lt;int&gt; outcome; //保存结果\ndeque&lt;int&gt; list;   //队列\nmain()\n{\n    int n, m;\n    while (cin &gt;&gt; n &gt;&gt; m)\n    {\n        bool sign = 0; //是否有多种结果\n        int num = 0;  // 起点的数量\n        for (int i = 1; i &lt;= m; i++)\n        {\n            int d, u;\n            cin &gt;&gt; d &gt;&gt; u;\n            dict[d].push_back(u); //给节点d添加一个子节点u\n            howMuchBefore[u]++;     //在u前面的论文个数增加\n        }\n        for (int i = 1; i &lt;= n; i++)\n        {\n            if (howMuchBefore[i] == 0)//拓扑排序，先找出所有起点\n            {              \n                list.push_back(i); //找到就加入队列\n                num++;\n            }\n        }\n        if (num &gt; 1) //起点太多，排序肯定不唯一\n            sign = 1;\n        while (!list.empty())\n        {\n            int p = list.front();//取队列中最前面的元素为p\n            list.pop_front();//删去队列中最前的元素\n            outcome.push_back(p);//添加到排序队列中去\n            for (int i = 0; i &lt; dict[p].size(); i++)//遍历p的子节点\n            {\n                int y = dict[p][i];\n                howMuchBefore[y]--;//告诉这些子节点，在你们之前的元素减少一个\n                if (!howMuchBefore[y])//如果y的前面没有元素了，只能直接将y放入队列\n                {\n                    list.push_back(y);\n                }\n            }\n        }\n        if (outcome.size() == n) //可以进行拓扑排序\n        {\n            if (!sign)\n                cout &lt;&lt; \"1\" &lt;&lt; endl;\n            else\n                cout &lt;&lt; \"2\" &lt;&lt; endl;\n        }\n        else\n            cout &lt;&lt; \"0\" &lt;&lt; endl;    //不能拓扑排序\n        for (int i = 0; i &lt; m; i++) //清空操作\n            dict[i].clear();\n        outcome.clear();\n        while (!list.empty())\n            list.pop_front();\n        memset(howMuchBefore, 0, sizeof(howMuchBefore));\n    }\n}双十一:最短路径算法Floyd双十一期间，某著名电商平台“东东”为应对销售高峰，准备在n个城市中再增加一个自营仓库，其要求是该仓库设在n个城市中的某个城市，且距离其他所有城市的最短距离之和最小。请编写程序帮助“东东”找出设立仓库的地点。假定n个城市编号为0至n-1，它们之间至少有一个城市与其他所有城市可及。输入格式:输入包含多组数据。每组数据第一行为两个正整数n和e，均不超过100。n表示城市数。接下来e行表示两个城市间的距离信息，每行为3个非负整数a、b、c，其中a和b表示两个城市编号，c表示城市间的距离。\n提示：可使用EOF判断输入结束。输出格式:输出为一个整数，表示建立仓库的城市编号，如多个城市满足要求，则输出编号最小者。输入样例:  \ntxt6 5\n0 1 1\n0 2 1\n0 3 1\n0 4 1\n0 5 1\n4 5\n0 1 1\n0 2 5\n1 2 2\n1 3 4\n2 3 1输出样例:  \ntxt0\n1代码:  \ncpp#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\nint map[200][200];//邻接矩阵，出发点到目标的距离=map[出发点][目标];距离为0视为无限大\nmain()\n{\n    int v, e;\n    while (cin &gt;&gt; v &gt;&gt; e)\n    {\n        memset(map, 0, sizeof(map));//初始化为无限大\n        for (int t = 0; t &lt; e; t++)//建图\n        {\n            int i, j;\n            cin &gt;&gt; i &gt;&gt; j &gt;&gt; map[i][j];\n            map[j][i] = map[i][j];\n        }\n        for (int k = 0; k &lt; v; k++)\t\t//Floyd算法找最短路\n            for (int j = 0; j &lt; v; j++)\t\n                for (int i = 0; i &lt; v; i++)\n                    if ((map[i][j] &gt; map[i][k] + map[k][j] || map[i][j] == 0) &amp;&amp; map[i][k] != 0 &amp;&amp; map[k][j] != 0)\n                        map[i][j] = map[i][k] + map[k][j];\n        int sum = 0;\n        int minsum = 99999;\n        int minn = 0;\n        for (int i = 0; i &lt; v; i++)//遍历所有起点找到最短的距离之和\n        {\n            for (int j = 0; j &lt; v; j++)\n            {\n                sum += map[i][j];\n            }\n            if (minsum &gt; sum)\n            {\n                minsum = sum;\n                minn = i;\n            }\n            sum = 0;\n        }\n        cout &lt;&lt; minn&lt;&lt;endl;\n    }\n}最短路径之Dijkstra算法、广度优先搜索本题目要求通过读入无向网的边的信息（省略了各顶点的信息，仅用顶点编号来表示），构造图，并利用Dijkstra算法，求出指定源点到其它各点的最短路径。输入格式:第一行，两个整数，顶点数vN和边数eN。 以后若干行，是相关边的信息，无向图的边是对称的，只输入一半的边（小编号到大编号的，间以空格），最后两行各一个整数，前一个指定源点，后一个指定的查询的终到点。 （注意，示例中34条边，只输入了17条边的信息）输出格式:在一行中输出从源点到指定终点的短路径及代价，注意：所有符号均为西文符号。输入样例:  \ntxt10 34\n0 1 2\n0 3 5\n1 2 5\n1 3 2\n2 4 8\n2 5 4\n3 5 4\n3 6 2\n4 7 5\n4 5 2\n5 6 3\n5 7 9\n5 8 7\n6 8 7\n7 8 3\n7 9 4\n8 9 8\n0\n8输出样例:  \ntxt0--&gt;1--&gt;3--&gt;6--&gt;8:13这里献上B站UP 从0开始数 的算法视频！\n \n\n代码:  \ncpp#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;deque&gt;\nusing namespace std;\nclass Node\n{\npublic:\n    int value;\n    int front;\n    int length = 99999;\n    map&lt;int, int&gt; connect; // first:子节点下标，second:到该子节点的路径权重\n} list[20];//采用邻接表\nbool sign[20];\nint v, e;\nvoid dij(int);\nvoid findpath(int, int);\nmain()\n{\n    cin &gt;&gt; v &gt;&gt; e;\n    for (int i = 0; i &lt; e / 2; i++)//建无向图\n    {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        list[a].value = a;\n        list[b].value = b;\n        list[a].connect[b] = c;\n        list[b].connect[a] = c;\n    }\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    if (n == m)\n        cout &lt;&lt; n &lt;&lt; \"--&gt;\" &lt;&lt; m &lt;&lt; ':' &lt;&lt; 0;\n    else\n    {\n        dij(n);//从n开始进行迪杰斯塔拉\n        findpath(n, m);\n        cout &lt;&lt; m &lt;&lt; ':' &lt;&lt; list[m].length;\n    }\n}\nvoid dij(int s)\n{\n    int minn = 0;//保存目前找到的 离s最近 的节点\n    int num = 0;//保存最小的路径长度\n    list[s].length = 0;//对起点长度先标记为0\n    sign[s] = 1;//不进行比较的标记\n    deque&lt;int&gt; que;//类似于广搜的队列\n    que.push_back(s);\n    while (que.size() != 0)//类广度优先搜索\n    {\n        int min = 99999;\n        for (auto i = list[*que.begin()].connect.begin(); i != list[*que.begin()].connect.end(); i++)//对当前 离s最近 的节点进行子节点遍历\n        {\n            if (sign[list[i-&gt;first].value])//如果已经被标记为不进行比较\n                continue;\n            if (list[i-&gt;first].length &gt; list[*que.begin()].length + i-&gt;second)//还可以更小\n            {\n                list[i-&gt;first].length = list[*que.begin()].length + i-&gt;second; //计算路程\n                list[i-&gt;first].front = list[*que.begin()].value;\t\t\t   //记录下标\n            }\n        }\n        for (int i = 0; i &lt; v; i++)//找到 离s最近 的节点\n            if (list[i].length &lt; min &amp;&amp; sign[i] != 1)\n            {\n                min = list[i].length;\n                minn = i;\n            }\n        sign[minn] = 1;//标记\n        num++;\n        que.pop_back();//删除队首元素\n        if (num &lt; v)//还没搜完\n            que.push_back(minn);//加入此节点\n    }\n}\nvoid findpath(int start, int target)//递归找路\n{\n    if (target == start)\n        return;\n    findpath(start, list[target].front);\n    cout &lt;&lt; list[target].front &lt;&lt; \"--&gt;\";\n}最长路题目描述:设 G 为有 n 个顶点的带权有向无环图，G 中各顶点的编号为 1 到 n，请设计算法，计算图 G 中 1,n 间的最长路径。输入格式:输入的第一行有两个整数，分别代表图的点数 n 和边数m。\n第 22 到第 行，每行 3 个整数 u, v, w（u &lt; v），代表存在一条从 u 到 v 边权为 w 的边。输出格式输出一行一个整数，代表 1 到 n 的最长路。\n若 1 与 n 不连通，请输出 -1。输入  \ntxt2 1\n1 2 1输出\ntxt1代码\ncpp#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cmath&gt;\n#define INF 0x7fffffff   \nusing namespace std;\nint n,m,x,y,z,map[1501][1501];    //邻接矩阵\nint main()\n{\n    cin&gt;&gt;n&gt;&gt;m;   //输入点数和边数\n    for(int i=0;i&lt;n;i++)\n        for(int j=0;j&lt;n;j++)\n            if(i==j) \n                map[i][j]=0;    //邻接矩阵赋初值\n            else map[i][j]=INF;    \n    for(int i=0;i&lt;m;i++)\n    {\n        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;\n        x--,y--;   //编号从1~n，注意处理数组越界问题\n        map[x][y]=min(map[x][y],-z);   //当两个点有多条路时取最长的那条\n    }\n    for(int k=0;k&lt;n;k++)   //Floyd\n        for(int i=0;i&lt;n;i++)\n            for(int j=0;j&lt;n;j++)\n                if(map[i][k]!=INF&amp;&amp;map[k][j]!=INF)\n                    map[i][j]=min(map[i][j],map[i][k]+map[k][j]);\n    if(map[0][n-1]==INF) \n        cout&lt;&lt;-1;   //判断两个点是否连通\n    else \n        cout&lt;&lt;-map[0][n-1];  //相当于map[0][n-1]*-1\n}愿天下有情人都是失散多年的兄妹: 深度有限搜索题目描述:呵呵。大家都知道五服以内不得通婚，即两个人最近的共同祖先如果在五代以内（即本人、父母、祖父母、曾祖父母、高祖父母）则不可通婚。本题就请你帮助一对有情人判断一下，他们究竟是否可以成婚？输入格式:输入第一行给出一个正整数N（2 ≤ N ≤104 ），随后N行，每行按以下格式给出一个人的信息：\ntxt本人ID 性别 父亲ID 母亲ID其中ID是5位数字，每人不同；性别M代表男性、F代表女性。如果某人的父亲或母亲已经不可考，则相应的ID位置上标记为-1。接下来给出一个正整数K，随后K行，每行给出一对有情人的ID，其间以空格分隔。注意：题目保证两个人是同辈，每人只有一个性别，并且血缘关系网中没有乱伦或隔辈成婚的情况。\n输出格式对每一对有情人，判断他们的关系是否可以通婚：如果两人是同性，输出Never Mind；如果是异性并且关系出了五服，输出Yes；如果异性关系未出五服，输出No。输入样例:  \ntxt24\n00001 M 01111 -1\n00002 F 02222 03333\n00003 M 02222 03333\n00004 F 04444 03333\n00005 M 04444 05555\n00006 F 04444 05555\n00007 F 06666 07777\n00008 M 06666 07777\n00009 M 00001 00002\n00010 M 00003 00006\n00011 F 00005 00007\n00012 F 00008 08888\n00013 F 00009 00011\n00014 M 00010 09999\n00015 M 00010 09999\n00016 M 10000 00012\n00017 F -1 00012\n00018 F 11000 00013\n00019 F 11100 00018\n00020 F 00015 11110\n00021 M 11100 00020\n00022 M 00016 -1\n00023 M 10012 00017\n00024 M 00022 10013\n9\n00021 00024\n00019 00024\n00011 00012\n00022 00018\n00001 00004\n00013 00016\n00017 00015\n00019 00021\n00010 00011输出样例：  \ntxtNever Mind\nYes\nNever Mind\nNo\nYes\nNo\nYes\nNo\nNo代码  \ncpp#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;//要深度遍历两个人，所以要两个缓存区\nint path1[100] = {0};//深度遍历的缓存，储存遍历数据\nint path2[100] = {0};\nint depth1 = 0, deep1 = 0;//分别是深度遍历缓存的指针、深度遍历的层数\nint depth2 = 0, deep2 = 0;\nvoid dls(int, int);\nstruct people\n{\n    char sex;\n    int fid = -1;\n    int mid = -1;\n};\npeople guy[100000];\nmain()\n{\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; i++)\n    {\n        int id;\n        cin &gt;&gt; id;\n        cin &gt;&gt; guy[id].sex &gt;&gt; guy[id].fid &gt;&gt; guy[id].mid;\n        if (guy[id].fid != -1)//这里最好给父母亲标好性别，有的人只存在ID\n            guy[guy[id].fid].sex = 'M';\n        if(guy[id].mid!=-1)\n            guy[guy[id].mid].sex = 'F';\n    }\n    cin &gt;&gt; n;\n    int i;\n    for (i = 0; i &lt; n; i++)\n    {\n        depth1 = 0, depth2 = 0;//归零开始新一轮的工作\n        int g1, g2;\n        cin &gt;&gt; g1 &gt;&gt; g2;\n        if (guy[g1].sex == guy[g2].sex)//同性恋\n        {\n            cout &lt;&lt; \"Never Mind\" &lt;&lt; endl;\n            continue;\n        }\n        dls(g1, 1), dls(g2, 2);//对双方分别遍历\n        deep1 = 0, deep2 = 0;//归零以备下次调用\n        bool done = 0;          //优化，用于跳出循环节省时间\n        for (int k = 0; k &lt; depth1; k++)//找是否有共同祖先\n        {\n            for (int l = 0; l &lt; depth2; l++)\n                if (path1[k] == path2[l])\n                {\n                    done = 1;//优化\n                    break;\n                }\n            if (done == 1)//优化\n                break;\n        }\n        if (i != n - 1)//对输出格式的调整\n        {\n            if (done == 1)       \n                cout &lt;&lt; \"No\" &lt;&lt; endl;            \n            else\n                cout &lt;&lt; \"Yes\" &lt;&lt; endl;\n        }\n        else\n        {\n            if (done == 1)           \n                cout &lt;&lt; \"No\";            \n            else\n                cout &lt;&lt; \"Yes\";\n        }\n    }\n}\nvoid dls(int s, int j)\n{\n    if (s == -1)\n        return;//此人无法考证，返回    \n    if ((deep1 == 5 &amp;&amp; j == 1) || (deep2 == 5 &amp;&amp; j == 2))\n        return;//超过5层，停止搜索，返回\n    if (j == 1)\n    {\n        path1[depth1++] = s;//记录在缓存中\n        deep1++;//遍历前，层数增加\n        dls(guy[s].fid, 1);//对父母遍历\n        dls(guy[s].mid, 1);\n        deep1--;//关键，层数回退\n    }\n    else        //同理\n    {\n        path2[depth2++] = s;\n        deep2++;\n        dls(guy[s].fid, 2);\n        dls(guy[s].mid, 2);\n        deep2--;\n    }\n}生化危机:深度优先搜索人类正在经历一场生化危机，许多城市已经被病毒侵袭，这些城市中的人们为了避免感染病毒，计划开车逃往其他没有被病毒入侵的城市（安全城市）。有些城市之间有公路直达，有些没有。虽然他们知道哪些城市是安全的，但是不知道有没有一条安全路径能够到达安全城市（只有该路径上经过的所有城市都是安全的，该路径才是安全路径）。请你编写一个程序帮助他们判断。输入格式:输入第一行为三个正整数，分别表示所有城市个数m（m&lt;=100）、安全城市个数n（m&lt;=50）、公路个数k（k&lt;=100）。随后一行给出n个安全城市的编号。随后k行，每一行给出两个整数，表示连接一条公路的两个城市编号。最后一行输入两个整数，分别表示当前所在城市s、目标城市d。每行整数之间都用空格分隔。\n输出格式:若目标城市已被病毒入侵（非安全城市），输出”The city i is not safe!”；若目标城市为安全城市且从当前所在城市能够经过一条安全路径到达目标城市，输出”The city can arrive safely！”；若目标城市为安全城市但是从当前所在城市没有一条安全路径到达目标城市，输出”The city can not arrive safely！”，i为目标城市编号。\n输入样例1:\ntxt5 2 5\n3 4\n0 1\n0 2\n0 4\n1 2\n2 4\n0 4输出样例1:\ntxtThe city 4 can arrive safely!输入样例2:\ntxt5 2 5\n3 4\n0 1\n0 2\n0 4\n1 2\n2 4\n0 3输出样例2:\ntxtThe city 3 can not arrive safely!输入样例3:\ntxt5 2 5\n3 4\n0 1\n0 2\n0 4\n1 2\n2 4\n0 1输出样例3:\ntxtThe city 1 is not safe!代码\ncpp#include &lt;iostream&gt;\nusing namespace std;\nstruct city//城市类\n{\n    bool done = 0;//是否被搜索过\n    bool safe = 0;//是否安全\n    int conect[101] = {0};//连接的城市\n    int conectnum = 0;//连接城市的数量\n};\nbool dfs(city a[], int start, int end);\nmain()\n{\n    int m, n, k;\n    cin &gt;&gt; m &gt;&gt; n &gt;&gt; k;\n    city a[m];\n    for (int i = 0; i &lt; n; i++)//建图\n    {\n        int no;\n        cin &gt;&gt; no;\n        a[no].safe = 1;\n    }\n    for (int i = 0; i &lt; k; i++)\n    {\n        int d, b;\n        cin &gt;&gt; d &gt;&gt; b;\n        a[d].conect[a[d].conectnum] = b;\n        a[d].conectnum++;\n        a[b].conect[a[b].conectnum] = d;\n        a[b].conectnum++;\n    }\n    int there, that;\n    cin &gt;&gt; there &gt;&gt; that;\n    if (!(a[that].safe))\n    {\n        cout &lt;&lt; \"The city \" &lt;&lt; that &lt;&lt; \" is not safe!\";\n        return 0;\n    }\n    if (dfs(a, there, that))\n        cout &lt;&lt; \"The city \" &lt;&lt; that &lt;&lt; \" can arrive safely!\";\n    else\n        cout &lt;&lt; \"The city \" &lt;&lt; that &lt;&lt; \" can not arrive safely!\";\n}\nbool dfs(city a[], int start, int end)//传入保存城市的数组，开始节点，结束节点\n{\n    if (start == end)//找到\n        return true;\n    if (a[start].done)//被搜索过\n        return false;\n    a[start].done = 1;//标记为被搜索过\n    for (int i = 0; i &lt; a[start].conectnum; i++)//对相连的城市进行深度优先搜索\n        if (dfs(a, a[start].conect[i], end))\n            return true;\n    return false;\n}","slug":"图的相关算法","date":"2022-03-04T04:29:00.000Z","categories_index":"竞赛","tags_index":"C++,算法,图论","author_index":"Ac-Accelerator"},{"id":"39fc6ddd2165079a9fa7e53c3022af95","title":"关于Aurora主题代码高亮的问题","content":"起因这几天兴致勃勃的搞了一个博客，换了几款主题，最后还是选定了极富科技感的Aurora主题。按照官方文档，折腾配置了很久，终于能够使用了。可是最最最最最蛋疼的就是这个代码块的语法高亮。我本人是C++语言的代码（不知道其他语言表现得怎么样），括号颜色极淡，其他的代码颜色也很单一，这就使我很难受。我在官方文档里找不到如何调节这种语法高亮，甚至我把prismjs的文档也看了一遍。还是fail了。\n发现问题可能是源于我前端知识的不足，我过了好久才想明白，任何网页上的元素都可以通过浏览器的F12进行查看和调试。到最后，我通过浏览器的调试功能（F12）找到了根源：post.9f951a60.css\n解决问题使用win自带的文件查找功能，在目录\\node_modules\\hexo-theme-aurora\\source\\static\\css下成功找到此文件。进去一看，乖乖，密密麻麻写的什么玩意儿。介于vscode是我的主力编辑器，我在安装了JS-CSS-HTML Formatter插件后Ctrl + Alt+F成功格式化CSS代码，这看上去不清晰得多？\n修改案例\n找到目标！！  \nCtrl+F搜索这个，\n```css\n.language-markup .token.punctuation,\n```\n你就可以看到一个：\n```css\n.language-css .token.punctuation,\n.language-html .token.punctuation,\n.language-markup .token.punctuation,\n.token.punctuation {\n    color: var(--subs);\n}\n```\n这个 var(--subs)就是造成你括号暗淡的罪魁祸首。\n\n法一：你可以搜索:root,并到–subs这里进行修改。\n法二：直接吧var(--subs)修改为其他颜色如#33ff00。\n关于其他问题都可以通过浏览器的F12功能来找到问题，然后对应修改\n","slug":"关于Aurora主题代码高亮的问题","date":"2022-03-03T11:28:00.000Z","categories_index":"前端","tags_index":"CSS,前端","author_index":"Ac-Accelerator"},{"id":"8d834d6f39e88bf7e2572d42a71885db","title":"字符串匹配算法","content":"1.暴力匹配：设三个指针，第一个用来指向原字符串，表示当前位置。剩下两个分别用来指向当前正在进行匹配的字符。  这是最简单的字符串匹配，其效率比较低，在算法竞赛中最好不要使用。\n2.KMP算法：找第一个匹配的下标\ncppvoid get_Next(string &amp;target, size_t tl, size_t *Next) //求出Next数组\n{                                                      // Next数组是从 target[0到i-1]前子串 的前缀后缀最大值\n    size_t point1 = 0, point2;\n    Next[0] = point2 = ULLONG_MAX;                                    // next数组首位默认为ULLONG_MAX\n    while (point1 &lt; tl)                                               //边界条件\n        if (point2 == ULLONG_MAX || target[point1] == target[point2]) //类似于KMP的匹配\n            Next[++point1] = ++point2;\n        else\n            point2 = Next[point2]; //失配\n}\nsize_t KMP(string &amp;origin, string &amp;target, size_t ol, size_t tl)\n{\n    size_t Next[tl];\n    get_Next(target, tl, Next);    //获得next数组\n    size_t point1 = 0, point2 = 0; //从0位开始匹配\n    while (point1 &lt; ol)            //临界值\n    {\n        if (point2 == ULLONG_MAX || origin[point1] == target[point2]) //相应字符匹配成功，继续\n        {\n            point2++, point1++;\n            if (point2 == tl)\n                return point1 - tl;\n        }\n        else\n            point2 = Next[point2]; //失配\n    }\n    return ol; //返回\n}计算包含多少个子串\ncppvoid get_Next(string &amp;target, size_t tl, size_t *Next) //求出Next数组\n{                                                      // Next数组是从 target[0到i-1]前子串 的前缀后缀最大值\n    size_t point1 = 0, point2;\n    Next[0] = point2 = ULLONG_MAX;                                    // next数组首位默认为ULLONG_MAX\n    while (point1 &lt; tl)                                               //边界条件\n        if (point2 == ULLONG_MAX || target[point1] == target[point2]) //类似于KMP的匹配\n            Next[++point1] = ++point2;\n        else\n            point2 = Next[point2]; //失配\n}\nsize_t KMP(string &amp;origin, string &amp;target, size_t ol, size_t tl)\n{\n    size_t Next[tl], sum = 0;\n    get_Next(target, tl, Next);    //获得next数组\n    size_t point1 = 0, point2 = 0; //从0位开始匹配\n    while (point1 &lt; ol)            //临界值\n    {\n        if (point2 == ULLONG_MAX || origin[point1] == target[point2]) //相应字符匹配成功，继续\n            point2++, point1++;\n        else\n            point2 = Next[point2]; //失配\n        if (point2 == tl)\n            sum++, point2 = Next[point2];\n    }\n    return sum; //返回\n}Sunday算法：找第一个匹配的下标\ncpp#define MAX_CHAR 256\nvoid GetNext(string &amp;p, size_t ot, size_t *Next);\nsize_t Sunday(string &amp;origin, size_t ol, string &amp;target, size_t tl);\nvoid GetNext(string &amp;p, size_t ot, size_t *Next) //标记各个字符所在的最大位置\n{\n    for (size_t i = 1; i &lt;= ot; ++i) //标记\n        Next[static_cast&lt;size_t&gt;(p[i - 1])] = i;\n}\nsize_t Sunday(string &amp;origin, size_t ol, string &amp;target, size_t tl)\n{\n    size_t Next[MAX_CHAR]{}; //声明next数组，用于存放字符位移量\n    GetNext(target, tl, Next);\n    size_t j = 0, k = 0; // origin 的下标 . target 的下标\n    size_t i = 0;\n    while (i &lt;= ol - tl) //走到尾部退出循环\n    {\n        j = i, k = 0;                                      // origin的下标指向最新的位置，target的下标重置，指向首位\n        while (j &lt; ol &amp;&amp; k &lt; tl &amp;&amp; origin[j] == target[k]) //如果相同，且未越界，则进行下一个字符的比对\n        {\n            j++, k++;\n        }\n        if (k == tl) //如果比对成功，则有k= target的长度，可进行操作\n            return j - tl;\n        if (i + tl &lt; ol)                               //如果在范围内，则重新将i定义为\n            i += (tl - Next[static_cast&lt;size_t&gt;(origin[i + tl])] + 1); ////////****算法核心****////////\n        /*  origin[i+tl]  指的是原字符串下一个字符，next[]是储存该字符位移量的数组。\n            如果target里有该字符，则进行指定长度的位移，没有则位移 (target的长度 +1)   */\n        else\n            break; //优化\n    }\n    return ol;\n}计算包含多少个子串\ncpp#define MAX_CHAR 256\nvoid GetNext(string &amp;p, size_t ot, size_t *Next);\nsize_t Sunday(string &amp;origin, size_t ol, string &amp;target, size_t tl);\nvoid GetNext(string &amp;p, size_t ot, size_t *Next) //标记各个字符所在的最大位置\n{\n    for (size_t i = 1; i &lt;= ot; ++i) //标记\n        Next[static_cast&lt;size_t&gt;(p[i - 1])] = i;\n}\nsize_t Sunday(string &amp;origin, size_t ol, string &amp;target, size_t tl)\n{\n    size_t Next[MAX_CHAR]{}, sum = 0; //声明next数组，用于存放字符位移量\n    GetNext(target, tl, Next);\n    size_t j = 0, k = 0; // origin 的下标 . target 的下标\n    size_t i = 0;\n    while (i &lt;= ol - tl) //走到尾部退出循环\n    {\n        j = i, k = 0;                                      // origin的下标指向最新的位置，target的下标重置，指向首位\n        while (j &lt; ol &amp;&amp; k &lt; tl &amp;&amp; origin[j] == target[k]) //如果相同，且未越界，则进行下一个字符的比对\n            ++j, ++k;\n        if (k == tl) //如果比对成功，则有k= target的长度，可进行操作\n            ++sum;\n        if (i + tl &lt; ol)                                               //如果在范围内，则重新将i定义为\n            i += (tl - Next[static_cast&lt;size_t&gt;(origin[i + tl])] + 1); ////////****算法核心****////////\n        /*  origin[i+tl]  指的是原字符串下一个字符，next[]是储存该字符位移量的数组。\n            如果target里有该字符，则进行指定长度的位移，没有则位移 (target的长度 +1)   */\n        else\n            break; //优化\n    }\n    return sum;\n}上述两种算法都是比较快速的算法，都是通过初始化Next数组，来实现对比位置的快速跳转。其中KMP属于时间复杂度稳定的算法，在ACM竞赛中经常使用，由此来避免特殊的字符串。而Sunday算法属于时间复杂度不稳定的算法，偏向实用，在实际工程中的效率KMP算法高。\n","slug":"字符串匹配算法","date":"2022-03-02T16:02:00.000Z","categories_index":"竞赛","tags_index":"C++,算法,字符串","author_index":"Ac-Accelerator"},{"id":"bdc46d1d5c3047d25f1a097055d8e321","title":"第十一届蓝桥杯省赛C++ A组题解","content":"出于能力和精力问题，有一部分题目暂无题解，见谅\n试题A 门牌制作小蓝要为一条街的住户制作门牌号这条街一共有 2020 位住户，门牌号从 1 到 2020 编号。小蓝制作门牌的方法是先制作 0 到 9 这几个数字字符，最后根据需要将字符粘贴到门牌上，例如门牌 1017 需要依次粘贴字符 1、0、1、7，即需要 1 个字符 0，2 个字符 1，1 个字符 7。请问要制作所有的 1 到 2020 号门牌，总共需要多少个字符 2?\ncpp#include &lt;iostream&gt;\nusing namespace std;\nint sum = 0;\nvoid find2(int a)\n&#123;\n    while (a != 0)\n    &#123;\n        if (a % 10 == 2)\n            sum++;\n        a /= 10;\n    &#125;\n&#125;\nint main()\n&#123;\n    for (int i = 0; i &lt;= 2020; i++)\n        find2(i);\n    cout &lt;&lt; sum;\n&#125;试题B 既约分数如果一个分数的分子和分母的最大公约数是1，这个分数称为既约分数。例如，$3&#x2F;4$ ， $5&#x2F;2$ ， $1&#x2F;8$  ， $7&#x2F;1$ 都是既约分数。请问，有多少个既约分数，分子和分母都是1 到2020 之间的整数（包括1和2020）？\ncpp#include &lt;iostream&gt;\nusing namespace std;\nint GreatestCommonDivisor(int a, int b)\n&#123;\n    if (a == 0 || b == 0)\n        return 1;\n    int tmp;\n    while (a % b != 0)\n    &#123;\n        tmp = a;\n        a = b;\n        b = tmp % b;\n    &#125;\n    return b;\n&#125;\nint main()\n&#123;\n    int sum = 0;\n    for (int i = 1; i &lt; 2021; i++)\n        for (int j = 1; j &lt; 2021; j++)\n            if (GreatestCommonDivisor(i, j) == 1)\n                sum++;\n    cout &lt;&lt; sum;\n&#125;试题C 蛇形填数如下图所示，小明用从 1 开始的正整数“蛇形”填充无限大的矩阵。1 2 6 7 15 …3 5 8 14 …4 9 13 …10 12 …11 ……求20行第20列的数字观察规律可得第i行第i列公式为 $2i^2-2i+1$求出答案为761\n试题D 七段码有127中情况，用用二进制可以表示哪个灯亮了哪个灯没亮；建图，然后就深度优先遍历看看亮的灯是否联通\n试题F 平面分割20 个圆和20 条直线最多能把平面分成多少个部分？\ncpp#include&lt;iostream&gt;\nusing namespace std;\nint main()\n&#123;\n    int n=20;\n    int m=20;\n    int ans=1+(n*(n+1))/2+(m*(2*n+2*n+2*(m-1)))/2;\n    cout&lt;&lt;ans&lt;&lt;endl;\n    return 0;\n&#125;试题F 成绩分析小蓝给学生们组织了一场考试，卷面总分为100分，每个学生的得分都是一个0到100的整数。请计算这次考试的最高分、最低分和平均分\ncpp#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nint main()\n&#123;\n    int n;\n    cin &gt;&gt; n;\n    int list[n];\n    double sum = 0;\n    for (int i = 0; i &lt; n;i++)\n    &#123;\n        cin &gt;&gt; list[i];\n        sum += list[i];\n    &#125;\n    sort(list, list + n);\n    cout &lt;&lt; list[n - 1] &lt;&lt; endl\n         &lt;&lt; list[0] &lt;&lt; endl\n         &lt;&lt; sum / n;\n&#125;试题G 回文日期2020 年春节期间，有一个特殊的日期引起了大家的注意：2020 年 2 月 2日。因为如果将这个日期按 “yyyymmdd” 的格式写成一个 8 位数是 20200202，恰好是一个回文数。我们称这样的日期是回文日期。有人表示 20200202 是 “千年一遇” 的特殊日子。对此小明很不认同，因为不到 2 年之后就是下一个回文日期：20211202 即 2021 年 12 月 2 日。也有人表示 20200202 并不仅仅是一个回文日期，还是一个 ABABBABA型的回文日期。对此小明也不认同，因为大约 100 年后就能遇到下一个ABABBABA 型的回文日期：21211212 即 2121 年 12 月 12 日。算不上 “千年一遇”，顶多算 “千年两遇”。给定一个 8 位数的日期，请你计算该日期之后下一个回文日期和下一个ABABBABA 型的回文日期各是哪一天。   \n解：一共约366种回文日期，用sort排序然后与输入对比，找到之后就输出。\ncpp#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nstring turn(int a)//转化为标准格式输出\n&#123;\n    string ans;\n    for (int i = 0; i &lt; 8;i++)\n    &#123;\n        ans = char(a % 10 + &#39;0&#39;) + ans;\n        a /= 10;\n    &#125;\n    return ans;\n&#125;\nint rev(int a)//对 （月/日） 进行回文获得年份\n&#123;\n    int ans = 0;\n    for (int i = 0; i &lt; 4;i++)\n    &#123;\n        ans = ans * 10 + a % 10;\n        a /= 10;\n    &#125;\n    return ans;\n&#125;\nint main()\n&#123;\n    int lists[370], p = 0;//所有回文\n    int abab[14], l = 0;//abab形回文\n    int month[] = &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;//十二个月\n    for (int i = 1; i &lt;= 12; i++)\n    &#123;\n        for (int j = 1; j &lt;= month[i]; j++)\n        &#123;\n            int k = i * 100 + j;\n            k = rev(k) * 10000 + k;\n            lists[p++] = k;\n            if (i == j &amp;&amp; i / 10 != i % 10)//判断abab形回文\n            &#123;\n                abab[l++] = k;\n            &#125;\n        &#125;\n    &#125;\n    lists[p++] = 92200229;//闰年\n    sort(lists, lists + p);\n    sort(abab, abab + l);\n    int stds;\n    cin &gt;&gt; stds;\n    for (int i = 0; i &lt; p; i++)\n    &#123;\n        if (lists[i] &gt; stds)\n        &#123;\n            cout &lt;&lt; turn(lists[i]);\n            break;\n        &#125;   \n    &#125;\n    cout &lt;&lt; endl;\n    for (int i = 0; i &lt; l; i++)\n    &#123;\n        if (abab[i] &gt; stds)\n        &#123;\n            cout &lt;&lt; turn(abab[i]);\n            break;\n        &#125;   \n    &#125;\n&#125;","slug":"第十一届蓝桥杯省赛C-A组题解","date":"2022-03-02T12:30:00.000Z","categories_index":"竞赛","tags_index":"C++,算法,蓝桥杯","author_index":"Ac-Accelerator"},{"id":"30bb43ff3003d537e8635ebe0ad2a3db","title":"第十届蓝桥杯省赛C++ A组题解","content":"出于能力和精力问题，有一部分题目暂无题解，见谅\n试题A 平方和小明对数位中含有2、0、1、9的数字很感兴趣，在1到40中这样的数包括1、2、9、10至32、39和40，共28个，他们的和是574，平方和是14362。注意，平方和是指将每个数分别平方后求和。请问，在1到2019中，所有这样的数的平方和是多少?\ncpp#include &lt;iostream&gt;\nusing namespace std;\nbool find(int a)\n{\n    while (a != 0)\n    {\n        int t = a % 10;\n        if (t == 0 || t == 9 || t == 1 || t == 2)\n            return true;\n        a /= 10;\n    }\n    return false;\n}\nint main()\n{\n    unsigned long long a = 0;\n    for (int i = 1; i &lt; 2020; i++)\n        if (find(i))\n            a += i * i;\n    cout &lt;&lt; a;\n}试题B 数列求值给定数列1,1,1,3,5,9,17…，从第4项开始，每项都是前3项的和。求第20190324项的最后4位数字。\ncpp#include &lt;iostream&gt;\n#include &lt;cmath&gt;    \nusing namespace std;\nint cal(int a)\n{\n    int ans = 0;\n    for (int i = 0; i &lt; 4&amp;&amp;a!=0; i++)\n    {\n        ans = (a % 10) * pow(10,i)+ans;\n        a /= 10;\n    }\n    return ans;\n}\nint list[20190325] = {0, 1, 1, 1};\nint main()\n{\n    for (int i = 4; i &lt; 20190325;i++)\n    {\n        list[i] = cal(list[i - 1] + list[i - 2] + list[i - 3]);\n    }\n    cout &lt;&lt; list[20190324];\n}试题C 最大降雨量由于沙之国长年干旱，法师小明准备施展自己的一个神秘法术来求雨。这个法术需要用到他手中的49张法术符，上面分别写着1至49这49个数字。法术一共持续7周，每天小明都要使用一张法术符，法术符不能重复使用。每周，小明施展法术产生的能量为这周7张法术符上数字的中位数。法术施展完7周后，求雨将获得成功，降雨量为7周能量的中位数。由于干旱太久，小明希望这次求雨的降雨量尽可能大，请大最大值是多少?\n解：贪心算法，尽量取每周都取到能取得最大的中位数，然后加起来。\n\n\n\n第一周\n第二周\n第三周\n…\n\n\n\n46\n42\n38\n…\n\n\n得到结果：238\n试题D 迷宫下图给出了一个迷宫的平面图，其中标记为 1 的为障碍，标记为 0 的为可以通行的地方。010000000100001001110000迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这个它的上、下、左、右四个方向之一。对于上面的迷宫，从入口开始，可以按DRRURRDDDR 的顺序通过迷宫，一共 10 步。其中 D、U、L、R 分别表示向下、向上、向左、向右走。对于下面这个更复杂的迷宫（30 行 50 列），请找出一种通过迷宫的方式，其使用的步数最少，在步数最少的前提下，请找出字典序最小的一个作为答案。请注意在字典序中D &lt; L &lt; R &lt; U。（如果你把以下文字复制到文本文件中，请务必检查复制的内容是否与文档中的一致。在试题目录下有一个文件 maze.txt，内容与下面的文本相同）\ntxt01010101001011001001010110010110100100001000101010\n00001000100000101010010000100000001001100110100101\n01111011010010001000001101001011100011000000010000\n01000000001010100011010000101000001010101011001011\n00011111000000101000010010100010100000101100000000\n11001000110101000010101100011010011010101011110111\n00011011010101001001001010000001000101001110000000\n10100000101000100110101010111110011000010000111010\n00111000001010100001100010000001000101001100001001\n11000110100001110010001001010101010101010001101000\n00010000100100000101001010101110100010101010000101\n11100100101001001000010000010101010100100100010100\n00000010000000101011001111010001100000101010100011\n10101010011100001000011000010110011110110100001000\n10101010100001101010100101000010100000111011101001\n10000000101100010000101100101101001011100000000100\n10101001000000010100100001000100000100011110101001\n00101001010101101001010100011010101101110000110101\n11001010000100001100000010100101000001000111000010\n00001000110000110101101000000100101001001000011101\n10100101000101000000001110110010110101101010100001\n00101000010000110101010000100010001001000100010101\n10100001000110010001000010101001010101011111010010\n00000100101000000110010100101001000001000000000010\n11010000001001110111001001000011101001011011101000\n00000110100010001000100000001000011101000000110011\n10101000101000100010001111100010101001010000001000\n10000010100101001010110000000100101010001011101000\n00111100001000010000000110111000000001000000001011\n10000001100111010111010001000110111010101101111000解：广度优先搜索\ncpp#include &lt;iostream&gt;\n#include &lt;deque&gt;\nusing namespace std;\n\nbool notout(int x, int y)\n{\n    return x &gt;= 0 &amp;&amp; x &lt; 30 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; 50;\n}\nstruct point\n{\n    int x, y;\n    char front;\n    bool done = 0;\n};\nint main()\n{\n    point map[30][50];\n    for (int i = 0; i &lt; 30; i++)\n    {\n        for (int j = 0; j &lt; 50; j++)\n        {\n            char t;\n            cin &gt;&gt; t;\n            map[i][j].x = i, map[i][j].y = j;\n            if (t - '0' == 1)\n            {\n                map[i][j].done = 1;\n            }\n        }\n    }\n    deque&lt;point&gt; list;\n    point start;\n    start.x = 0, start.y = 0;\n    list.push_back(start);\n    map[0][0].done = 1;\n    while (!list.empty())\n    {\n        if (notout(list.begin()-&gt;x, list.begin()-&gt;y + 1) &amp;&amp; !map[list.begin()-&gt;x][list.begin()-&gt;y + 1].done)\n        {\n            map[list.begin()-&gt;x][list.begin()-&gt;y + 1].done = 1;\n            list.push_back(map[list.begin()-&gt;x][list.begin()-&gt;y + 1]);\n            map[list.begin()-&gt;x][list.begin()-&gt;y + 1].front = 'R';\n        }\n        if (notout(list.begin()-&gt;x - 1, list.begin()-&gt;y) &amp;&amp; !map[list.begin()-&gt;x - 1][list.begin()-&gt;y].done)\n        {\n            map[list.begin()-&gt;x - 1][list.begin()-&gt;y].done = 1;\n            list.push_back(map[list.begin()-&gt;x - 1][list.begin()-&gt;y]);\n            map[list.begin()-&gt;x - 1][list.begin()-&gt;y].front = 'U';\n        }\n        if (notout(list.begin()-&gt;x + 1, list.begin()-&gt;y) &amp;&amp; !map[list.begin()-&gt;x + 1][list.begin()-&gt;y].done)\n        {\n            map[list.begin()-&gt;x + 1][list.begin()-&gt;y].done = 1;\n            list.push_back(map[list.begin()-&gt;x + 1][list.begin()-&gt;y]);\n            map[list.begin()-&gt;x + 1][list.begin()-&gt;y].front = 'D';\n        }\n        if (notout(list.begin()-&gt;x, list.begin()-&gt;y - 1) &amp;&amp; !map[list.begin()-&gt;x][list.begin()-&gt;y - 1].done)\n        {\n            map[list.begin()-&gt;x][list.begin()-&gt;y - 1].done = 1;\n            list.push_back(map[list.begin()-&gt;x][list.begin()-&gt;y - 1]);\n            map[list.begin()-&gt;x][list.begin()-&gt;y - 1].front = 'L';\n        }\n        list.pop_front();\n    }\n    start.x = 29, start.y = 49;\n    string ans;\n    while (!(start.x == 0 &amp;&amp; start.y == 0))\n    {\n        ans = map[start.x][start.y].front + ans;\n        if (map[start.x][start.y].front == 'U')\n            start.x += 1;\n        else if (map[start.x][start.y].front == 'D')\n            start.x -= 1;\n        else if (map[start.x][start.y].front == 'R')\n            start.y -= 1;\n        else if (map[start.x][start.y].front == 'L')\n            start.y += 1;\n    }\n    cout &lt;&lt; ans;\n}试题F 完全二叉树的权值现在小明要把相同深度的节点的权值加在- - 起，他想知道哪个深度的节点权值之和最大?如果有多个深度的权值和同为最大，请你输出其中最小的深度。注:根的深度是1。\ncpp#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nusing namespace std;\nint main()\n{\n    int n;\n    cin &gt;&gt;n;\n    int list[n];\n    for (int i = 0; i &lt; n;i++)\n        cin &gt;&gt; list[i];\n    int p=0;\n    int ma = 0;\n    int c = 0;\n    for (int i = 0; i &lt; log(n+1)/log(2);i++)\n    {\n        int sum = 0;\n        for (int j = 0; j &lt; pow(2, i);j++)\n            sum += list[p++];\n        if(ma&lt;sum)\n        {\n            ma = sum;\n            c = i + 1;\n        }\n    }\n    cout &lt;&lt; c;\n}试题G 外卖店优先级cpp#include&lt;bits/stdc++.h&gt;\n#define ll long long\nusing namespace std;\nint mon[2][13]=&lt;!--swig￼0--&gt;;\nint n;\nbool isleap(int x);\nbool islegaldate(int x);\nbool ishui(int x);\nbool isab(int x);\nint main(){\n    cin &gt;&gt; n;\n    int t = n;\n    int i = 0,j = 0;\n    while(!i){\n        t++;\n        if(islegaldate(t)){\n            if(ishui(t)){\n                i = t;\n            }\n        }\n    }\n    t = i-1;\n    while(!j){\n        t++;\n        if(islegaldate(t))\n        {\n            if(ishui(t))\n            {\n                if(isab(t))\n                j = t;\n            }\n        }\n    }\n    cout &lt;&lt; i &lt;&lt; endl &lt;&lt; j &lt;&lt; endl;\n    return 0;\n}\n\nbool isleap(int x){\n    if((x%4==0 &amp;&amp; x%100!=0)||(x%400==0)){\n        return 1;\n    }\n    return 0;\n}\n\nbool islegaldate(int x){\n    int y=x/10000;\n    int m=(x/100)%100;\n    int d=x%100;\n    if(y&gt;0 &amp;&amp; m&gt;0 &amp;&amp; m&lt;=12){\n        if(d&lt;mon[isleap(y)][m])\n            return 1;\n    }\n    return 0;\n}\n\nbool ishui(int x){\n    int t=x,r=0;\n    while(x){\n        r=r*10+x%10;\n        x/=10;\n    }\n    if(t==r){\n        return 1;\n    }\n    return 0;\n}\n\nbool isab(int x){\n    int y=x/10000;\n    int m=(x/100)%100;\n    int d=x%100;\n    int k=y/100;\n    int n=y%100;\n    if(k==n &amp;&amp; m==d){\n        return 1;\n    }\n    return 0;\n}\n","slug":"第十届蓝桥杯省赛C-A组题解","date":"2022-03-02T12:27:00.000Z","categories_index":"竞赛","tags_index":"C++,算法,蓝桥杯","author_index":"Ac-Accelerator"},{"id":"4f751f81a9110dfd7e708061eb5ee903","title":"第十二届蓝桥杯省赛C++ A组题解","content":"出于能力和精力问题，有一部分题目暂无题解，见谅\n试题A 卡片小蓝有很多数字卡片，每张卡片上都是数字0到9。小蓝准备用这些卡片来拼一些数，他想从1开始拼出正整数，每拼一个，就保存起来，卡片就不能用来拼其它数了。小蓝想知道自己能从1拼到多少。例如，当小蓝有30张卡片，其中0到9各3张，则小蓝可以拼出1到10,但是拼11时卡片1已经只有一张了，不够拼出11。现在小蓝手里有0到9的卡片各2021张，共20210 张，请问小蓝可以从1拼到多少?\ncpp#include &lt;iostream&gt;\nusing namespace std;\nint list[10];\nint find(int a)\n{\n    while (a != 0)\n    {\n        if (list[a % 10] == 0)\n        {\n            return 0;\n        }\n        list[a % 10]--;\n        a /= 10;\n    }\n    return 1;\n}\nint main()\n{\n    for (int i = 0; i &lt; 10; i++)\n    {\n        list[i] = 2021;\n    }\n    for (int i = 1; i &lt; 999999; i++)\n    {\n        if (find(i) == 0)\n        {\n            cout &lt;&lt; i - 1;\n            break;\n        }\n    }\n}试题B 直线在平面直角坐标系中，两点可以确定一条直线。如果有多点在一条直线上，那么这些点中任意两点确定的直线是同一条。给定平面上2×3个整点{(x,y)|0≤x&lt;2,0≤y&lt;3,x∈Z,y∈Z}，即横坐标是0到1(包含0和1)之间的整数、纵坐标是О到2(包含О和2)之间的整数的点。这些点一共确定了11条不同的直线。给定平面上20×21个整点{(x,y)[0 ≤x &lt;20,0 ≤ y &lt; 21,x ∈ ‘Z,y ∈Z)，即横坐标是О到19(包含0和 19)之间的整数、纵坐标是О到20(包含О和20)之间的整数的点。请问这些点一共确定了多少条不同的直线。\ncpp#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;vector&gt;\n#include &lt;cmath&gt;\nusing namespace std;\ntypedef pair&lt;int, int&gt; PII;//二维\ntypedef pair&lt;PII, int&gt; PIII;//三维\nset&lt;PIII&gt; line;//线的参数\nvector&lt;PII&gt; point;//点\nint gcd(int a, int b)//最大公约数\n{\n    if (b == 0)\n        return a;\n    return gcd(b, a % b);\n}\nint main()\n{\n    for (int i = 0; i &lt; 20; i++)\n        for (int j = 0; j &lt; 21; j++)\n            point.push_back({i, j});//记录点的坐标\n    for (int i = 0; i &lt; point.size(); i++)\n    {\n        for (int j = i + 1; j &lt; point.size(); j++)\n        {\n            int x1 = point[i].first, y1 = point[i].second;\n            int x2 = point[j].first, y2 = point[j].second;\n            int A = x2 - x1, B = y1 - y2, C = x1 * y2 - x2 * y1;\n            int gcdd = gcd(gcd(A, B), C);//约分前的工作\n            line.insert(","slug":"第十二届蓝桥杯省赛C-A组题解","date":"2022-03-02T12:19:00.000Z","categories_index":"竞赛","tags_index":"C++,算法,蓝桥杯","author_index":"Ac-Accelerator"},{"id":"03e1cda0baa3a649921c8af01fed4d68","title":"我的第一篇博客","content":"博客的开始经过了一天的努力，我参照了很多帖子，终于在github平台上搭建起了自己的博客。以后我会尝试在这上面分享我的生活和学习。包括很多的算法和计算机知识也会在这里分享。由于本人才疏学浅，所理解的知识难免存在不够好的地方，欢迎指正和交流！\n写博客的理由在我初学计算机的时候，我曾经也是个P都不懂的小白。经常进行各种傻逼操作，我和我的电脑都累坏了。看了很多大佬的博客还有帖子，我才找到正确的路。于是，我也想成为学弟学妹的领路人。总之就是这种情况。还有就是我其实是一个非常健忘的people。所以我想把我学到的算法，学到的知识记录下来，管他有没有人看，我自己看。在浏览器里看总比在doc里面看养眼多了吧。\n结语加油，先更他个一百篇！\n","slug":"我的第一篇博客-1","date":"2022-03-02T10:29:00.000Z","categories_index":"生活","tags_index":"","author_index":"Ac-Accelerator"}]