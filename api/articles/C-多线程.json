{"title":"C++多线程","uid":"29c0bb26f17c8d5598125731d7dbd2bf","slug":"C-多线程","date":"2022-11-08T17:02:00.000Z","updated":"2023-09-25T16:37:57.941Z","comments":true,"path":"api/articles/C-多线程.json","keywords":"C++,Pyhton,Java,算法","cover":"/img/CPPcover.webp","content":"<p>这是观看一位大佬<a href=\"https://space.bilibili.com/263032155\">双笙子佯谬</a>的视频后写的笔记。</p>\n<h3 id=\"时间标准库chrono（C-11）\"><a href=\"#时间标准库chrono（C-11）\" class=\"headerlink\" title=\"时间标准库chrono（C++11）\"></a>时间标准库chrono（C++11）</h3><h4 id=\"std-chrono\"><a href=\"#std-chrono\" class=\"headerlink\" title=\"std::chrono\"></a>std::chrono</h4><p><strong>定义于头文件&lt;chrono&gt;</strong></p>\n<p>利用 C++ 强类型的特点，明确区分时间点与时间段，明确区分不同的时间单位。<br>时间点类型：chrono::steady_clock::time_point 等<br>时间段类型：chrono::milliseconds，chrono::seconds，chrono::minutes 等<br>方便的运算符重载：时间点+时间段=时间点，时间点-时间点=时间段<br>auto t0 = chrono::steady_clock::now(); <em>//获取当前时间点</em><br>auto t1 = t0 + chrono::seconds(30);<em>// 当前时间点的30秒后</em><br>auto dt = t1 - t0;<em>// 获取两个时间点的差（时间段）</em><br>int64_t sec = chrono::duration_cast&lt;chrono::seconds&gt;(dt).count();<em>// 时间差的秒数</em>  </p>\n<p>计算花费的时间ms。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">auto</span><span style=\"color: #D4D4D4\"> t0 = </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">chrono</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">steady_clock</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">now</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #569CD6\">volatile</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> i = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">; i &lt; </span><span style=\"color: #B5CEA8\">10000000</span><span style=\"color: #D4D4D4\">; i++)</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">auto</span><span style=\"color: #D4D4D4\"> t1 = </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">chrono</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">steady_clock</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">now</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">auto</span><span style=\"color: #D4D4D4\"> dt = t1 - t0;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">int64_t</span><span style=\"color: #D4D4D4\"> ms = </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">chrono</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">duration_cast</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">chrono</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">milliseconds</span><span style=\"color: #D4D4D4\">&gt;(dt).</span><span style=\"color: #DCDCAA\">count</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cout &lt;&lt; </span><span style=\"color: #CE9178\">\"time elapsed: \"</span><span style=\"color: #D4D4D4\"> &lt;&lt; ms &lt;&lt; </span><span style=\"color: #CE9178\">\" ms\"</span><span style=\"color: #D4D4D4\"> &lt;&lt; </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::endl;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p><strong>duration_cast</strong> 可以在任意的 duration 类型之间转换<br><strong>duration&lt;T, R&gt;</strong> 表示用 <strong>T</strong> 类型表示，且时间单位是 <strong>R</strong><br><strong>R</strong> 省略不写就是秒，<strong>std::milli</strong> 就是毫秒，<strong>std::micro</strong> 就是微秒<br><strong>seconds</strong> 是 <strong>duration&lt;int64_t&gt;</strong> 的类型别名<br><strong>milliseconds</strong> 是 <strong>duration&lt;int64_t, std::milli&gt;</strong> 的类型别名  </p>\n<p>下面这样可以输出小数单位的时间段。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">auto</span><span style=\"color: #D4D4D4\"> t0 = </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">chrono</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">steady_clock</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">now</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #569CD6\">volatile</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> i = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">; i &lt; </span><span style=\"color: #B5CEA8\">10000000</span><span style=\"color: #D4D4D4\">; i++)</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">auto</span><span style=\"color: #D4D4D4\"> t1 = </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">chrono</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">steady_clock</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">now</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">auto</span><span style=\"color: #D4D4D4\"> dt = t1 - t0;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">double</span><span style=\"color: #D4D4D4\"> ms = </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">chrono</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">duration_cast</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">chrono</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">duration</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #569CD6\">double</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">milli</span><span style=\"color: #D4D4D4\">&gt;&gt;(dt).</span><span style=\"color: #DCDCAA\">count</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cout &lt;&lt; </span><span style=\"color: #CE9178\">\"time elapsed: \"</span><span style=\"color: #D4D4D4\"> &lt;&lt; ms &lt;&lt; </span><span style=\"color: #CE9178\">\" ms\"</span><span style=\"color: #D4D4D4\"> &lt;&lt; </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::endl;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><h4 id=\"sleep\"><a href=\"#sleep\" class=\"headerlink\" title=\"sleep\"></a>sleep</h4><p><strong>std::this_thread::sleep_for</strong>可以让当前线程休眠一段时间，然后继续。<br>而且单位也可以自己指定，比如这里是 <strong>milliseconds</strong> 表示毫秒，也可以换成 <strong>microseconds</strong> 表示微秒，<strong>seconds</strong> 表示秒，chrono 的强类型让单位选择更自由。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">this_thread</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">sleep_for</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">chrono</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">milliseconds</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">400</span><span style=\"color: #D4D4D4\">));</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p><strong>std::this_thread::sleep_until</strong>让当前线程休眠直到某个时间点。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;iostream&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;thread&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;chrono&gt;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">auto</span><span style=\"color: #D4D4D4\"> t = </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">chrono</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">steady_clock</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">now</span><span style=\"color: #D4D4D4\">() + </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">chrono</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">milliseconds</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">400</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">this_thread</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">sleep_until</span><span style=\"color: #D4D4D4\">(t);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><h3 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h3><h4 id=\"std-thread\"><a href=\"#std-thread\" class=\"headerlink\" title=\"std::thread\"></a>std::thread</h4><p><strong>定义于头文件&lt;thread&gt;</strong></p>\n<p>C++11 开始，为多线程提供了语言级别的支持。<strong>std::thread</strong> 这个类来表示线程。<br>std::thread构造函数的参数可以是任意可调用对象。<br>当那个线程启动时，就会执行这个可调用对象的内容。<br>用 std::thread 类的成员函数 <strong>join()</strong> 来等待该进程结束。  </p>\n<p>作为一个 C++ 类，std::thread 同样遵循 RAII 思想和三五法则：因为管理着资源，它自定义了解构函数，删除了拷贝构造/赋值函数，但是提供了移动构造/赋值函数。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">download</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">string</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">file</span><span style=\"color: #D4D4D4\">)</span><span style=\"color: #6A9955\">//模拟的一个下载过程</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> i = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">; i &lt; </span><span style=\"color: #B5CEA8\">10</span><span style=\"color: #D4D4D4\">; i++)</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cout &lt;&lt; </span><span style=\"color: #CE9178\">\"Downloading \"</span><span style=\"color: #D4D4D4\"> &lt;&lt; file</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                  &lt;&lt; </span><span style=\"color: #CE9178\">\" (\"</span><span style=\"color: #D4D4D4\"> &lt;&lt; i * </span><span style=\"color: #B5CEA8\">10</span><span style=\"color: #D4D4D4\"> &lt;&lt; </span><span style=\"color: #CE9178\">\"%)...\"</span><span style=\"color: #D4D4D4\"> &lt;&lt; </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::endl;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">this_thread</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">sleep_for</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">chrono</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">milliseconds</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">400</span><span style=\"color: #D4D4D4\">));</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cout &lt;&lt; </span><span style=\"color: #CE9178\">\"Download complete: \"</span><span style=\"color: #D4D4D4\"> &lt;&lt; file &lt;&lt; </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::endl;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">interact</span><span style=\"color: #D4D4D4\">()</span><span style=\"color: #6A9955\">//模拟与用户交互的函数</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::string name;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cin &gt;&gt; name;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cout &lt;&lt; </span><span style=\"color: #CE9178\">\"Hi, \"</span><span style=\"color: #D4D4D4\"> &lt;&lt; name &lt;&lt; </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::endl;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::thread </span><span style=\"color: #DCDCAA\">t1</span><span style=\"color: #D4D4D4\">([&amp;]</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                   { </span><span style=\"color: #DCDCAA\">download</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"hello.zip\"</span><span style=\"color: #D4D4D4\">); });</span><span style=\"color: #6A9955\">//构造函数，会执行这个 lambda 里的内容。</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">interact</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cout &lt;&lt; </span><span style=\"color: #CE9178\">\"Waiting for child thread...\"</span><span style=\"color: #D4D4D4\"> &lt;&lt; </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::endl;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">t1</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">join</span><span style=\"color: #D4D4D4\">();</span><span style=\"color: #6A9955\">//使用join()来等待线程t1结束。如果没有这一步，随着interact的结束，父线程立刻退出，它的子线程t1也会随之销毁，download就无法完成了。</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cout &lt;&lt; </span><span style=\"color: #CE9178\">\"Child thread exited!\"</span><span style=\"color: #D4D4D4\"> &lt;&lt; </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::endl;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>std::thread的析构函数会销毁线程，因此，当某个std::thread对象生命周期结束的时候，就会调用析构函数，这会销毁线程。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">myfunc</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::thread </span><span style=\"color: #DCDCAA\">t1</span><span style=\"color: #D4D4D4\">([&amp;]</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                   { </span><span style=\"color: #DCDCAA\">download</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"hello.zip\"</span><span style=\"color: #D4D4D4\">); });</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    // 退出函数体时，会销毁 t1 线程的句柄！</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>调用成员函数 <strong>detach()</strong> 分离该线程，意味着线程的生命周期不再由当前 std::thread 对象管理，而是在线程退出以后自动销毁自己。<br>不过这样还是会在进程退出时候自动退出。</p>\n<p>但是 detach 的问题是进程退出时候不会等待所有子线程执行完毕。所以另一种解法是把std::thread对象移动到一个全局变量去，从而延长其生命周期。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::vector&lt;</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::thread&gt; pool;</span><span style=\"color: #6A9955\">//全局线程池</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">myfunc</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::thread </span><span style=\"color: #DCDCAA\">t1</span><span style=\"color: #D4D4D4\">([&amp;]</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                   { </span><span style=\"color: #DCDCAA\">download</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"hello.zip\"</span><span style=\"color: #D4D4D4\">); });</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    // t1.detach();//分离该线程，线程将继续执行直至退出。</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">pool</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">push_back</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">move</span><span style=\"color: #D4D4D4\">(t1));</span><span style=\"color: #6A9955\">// 移交控制权到全局的线程池，以延长 t1 的生命周期</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">myfunc</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">interact</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #569CD6\">auto</span><span style=\"color: #D4D4D4\"> &amp;t : pool)</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">t</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">join</span><span style=\"color: #D4D4D4\">();</span><span style=\"color: #6A9955\"> // 等待池里的线程全部执行完毕</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><h4 id=\"main-函数退出后自动-join-全部线程\"><a href=\"#main-函数退出后自动-join-全部线程\" class=\"headerlink\" title=\"main 函数退出后自动 join 全部线程\"></a>main 函数退出后自动 join 全部线程</h4><p>我们可以自定义一个类 ThreadPool，并用它创建一个全局变量tpool，其析构函数会在 main 退出后自动调用。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">ThreadPool</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::vector&lt;</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::thread&gt; m_pool;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">push_back</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">thread</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">thr</span><span style=\"color: #D4D4D4\">)</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">m_pool</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">push_back</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">move</span><span style=\"color: #D4D4D4\">(thr));</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">~ThreadPool</span><span style=\"color: #D4D4D4\">()</span><span style=\"color: #6A9955\">// lmain函数退出后会自动调用</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #569CD6\">auto</span><span style=\"color: #D4D4D4\"> &amp;t : m_pool)</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">t</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">join</span><span style=\"color: #D4D4D4\">();</span><span style=\"color: #6A9955\">//等待池里的线程全部执行完毕</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">} tpool;</span></span></code></pre></div><h4 id=\"std-jthread-C-20\"><a href=\"#std-jthread-C-20\" class=\"headerlink\" title=\"std::jthread(C++20)\"></a>std::jthread(C++20)</h4><p>C++20 引入了 <strong>std::jthread</strong> 类，和 <strong>std::thread</strong> 不同在于：它的析构函数里会<strong>自动调用 join() 函数</strong>，从而保证 pool 析构时会自动等待全部线程执行完毕。</p>\n<h3 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h3><h4 id=\"std-async\"><a href=\"#std-async\" class=\"headerlink\" title=\"std::async\"></a>std::async</h4><p><strong>定义于头文件&lt;future&gt;</strong>  </p>\n<p><strong>std::async</strong> 接受一个带返回值的可调用对象，自身返回一个 <strong>std::future</strong> 对象。<br>可调用对象将在另一个线程里执行。  </p>\n<p>等到要用到异步返回值的时候，就调用 future 的 <strong>get()</strong> 方法，如果此时异步线程还没结束，会等待其完成，并获取该可调用对象的返回值。  </p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::future&lt;</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\">&gt; fret = </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">async</span><span style=\"color: #D4D4D4\">([&amp;]</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                                       { </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">download</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"hello.zip\"</span><span style=\"color: #D4D4D4\">); });</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">interact</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> ret = </span><span style=\"color: #9CDCFE\">fret</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">get</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cout &lt;&lt; </span><span style=\"color: #CE9178\">\"Download result: \"</span><span style=\"color: #D4D4D4\"> &lt;&lt; ret &lt;&lt; </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::endl;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>除了 get() 会等待外，<strong>wait()</strong> 也可以等待，但是不会返回其值。  </p>\n<p>只要线程没有执行完，wait() 会无限等下去。<br>而 <strong>wait_for()</strong> 则可以指定一个最长等待时间，用 <strong>std::chrono</strong> 里的类表示单位。它会返回一个 <strong>std::future_status</strong> 表示等待是否成功。<br>如果超过这个时间线程还没有执行完毕，则放弃等待，返回 <strong>future_status::timeout</strong>。<br>如果线程在指定的时间内执行完毕，则认为等待成功，返回 <strong>future_status::ready</strong>。  </p>\n<p>同理还有 <strong>wait_until()</strong> 其参数是一个时间点。</p>\n<p>std::async的第一个参数可以设为 <strong>std::launch::deferred</strong>，这时不会创建一个线程来执行，它只会把可调用对象的运算推迟到 future 的 get() 被调用时。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::future&lt;</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\">&gt; fret = </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">async</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">launch</span><span style=\"color: #D4D4D4\">::deferred, [&amp;]</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                                       { </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">download</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"hello.zip\"</span><span style=\"color: #D4D4D4\">); });</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">interact</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> ret = </span><span style=\"color: #9CDCFE\">fret</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">get</span><span style=\"color: #D4D4D4\">();</span><span style=\"color: #6A9955\">//现在才开始运行</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cout &lt;&lt; </span><span style=\"color: #CE9178\">\"Download result: \"</span><span style=\"color: #D4D4D4\"> &lt;&lt; ret &lt;&lt; </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::endl;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><h4 id=\"std-promise\"><a href=\"#std-promise\" class=\"headerlink\" title=\"std::promise\"></a>std::promise</h4><p>如果不想让 std::async 帮你自动创建线程，想要手动创建线程，可以直接用 <strong>std::promise</strong>。<br>然后在线程返回的时候，用 <strong>set_value()</strong> 设置返回值。在主线程里，用 <strong>get_future()</strong> 获取其 std::future 对象，进一步 <strong>get()</strong> 可以等待并获取线程返回值。</p>\n<p>future 为了三五法则，删除了拷贝构造/赋值函数。如果需要浅拷贝，实现共享同一个 future 对象，可以用std::shared_future。<br>如果不需要返回值，std::async 里可调用对象的返回类型可以为 void， 这时 future 对象的类型为 std::future&lt;void&gt;。<br>同理有 std::promise&lt;void&gt;，它的 set_value() 不接受参数，仅仅作为同步用，不传递任何实际的值。  </p>\n<h3 id=\"互斥量\"><a href=\"#互斥量\" class=\"headerlink\" title=\"互斥量\"></a>互斥量</h3><p>vector 不是多线程安全（MT-safe）的容器。<br>多个线程同时访问同一个 vector 会出现数据竞争（data-race）现象。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::vector&lt;</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\">&gt; arr;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::thread </span><span style=\"color: #DCDCAA\">t1</span><span style=\"color: #D4D4D4\">([&amp;]</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                   {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> i = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">; i &lt; </span><span style=\"color: #B5CEA8\">1000</span><span style=\"color: #D4D4D4\">; i++) </span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">arr</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">push_back</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">); });</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::thread </span><span style=\"color: #DCDCAA\">t2</span><span style=\"color: #D4D4D4\">([&amp;]</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                   {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> i = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">; i &lt; </span><span style=\"color: #B5CEA8\">1000</span><span style=\"color: #D4D4D4\">; i++) </span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">arr</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">push_back</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">2</span><span style=\"color: #D4D4D4\">); });</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">t1</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">join</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">t2</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">join</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>这样会导致vector的顺序是随机的。</p>\n<h4 id=\"std-mutex\"><a href=\"#std-mutex\" class=\"headerlink\" title=\"std::mutex\"></a>std::mutex</h4><p><strong>定义在头文件&lt;mutex&gt;</strong></p>\n<p>防止多个线程同时进入某一代码段</p>\n<p>调用 std::mutex 的 <strong>lock()</strong> 时，会检测 mutex 是否已经上锁。<br>如果没有锁定，则对 mutex 进行上锁。<br>如果已经锁定，则陷入等待，直到 mutex 被另一个线程解锁后，才再次上锁。<br>而调用 <strong>unlock()</strong> 则会进行解锁操作。<br>这样，就可以保证 mtx.lock() 和 mtx.unlock() 之间的代码段，同一时间只有一个线程在执行，从而避免数据竞争。  </p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::vector&lt;</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\">&gt; arr;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::mutex mtx;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::thread </span><span style=\"color: #DCDCAA\">t1</span><span style=\"color: #D4D4D4\">([&amp;]</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                   {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> i = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">; i &lt; </span><span style=\"color: #B5CEA8\">1000</span><span style=\"color: #D4D4D4\">; i++) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">mtx</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">lock</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">arr</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">push_back</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">mtx</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">unlock</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        } });</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::thread </span><span style=\"color: #DCDCAA\">t2</span><span style=\"color: #D4D4D4\">([&amp;]</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                   {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> i = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">; i &lt; </span><span style=\"color: #B5CEA8\">1000</span><span style=\"color: #D4D4D4\">; i++) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">mtx</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">lock</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">arr</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">push_back</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">2</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">mtx</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">unlock</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        } });</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">t1</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">join</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">t2</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">join</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><h4 id=\"std-lock-guard\"><a href=\"#std-lock-guard\" class=\"headerlink\" title=\"std::lock_guard\"></a>std::lock_guard</h4><p>符合 RAII 思想的上锁和解锁</p>\n<p>根据 RAII 思想，可将锁的持有视为资源，上锁视为锁的获取，解锁视为锁的释放。<br>std::lock_guard 就是这样一个工具类，它的构造函数里会调用 lock()，解构函数会调用unlock()。从而退出函数作用域时能够自动解锁，避免程序员粗心不小心忘记解锁。  </p>\n<h4 id=\"std-unique-lock\"><a href=\"#std-unique-lock\" class=\"headerlink\" title=\"std::unique_lock\"></a>std::unique_lock</h4><p>更自由的std::lock_guard</p>\n<p>std::lock_guard 严格在解构时 unlock()，但是有时候我们会希望提前 unlock()。这时可以用 std::unique_lock，它额外存储了一个 flag 表示是否已经被释放。它会在解构检测这个 flag，如果没有释放，则调用 unlock()，否则不调用。<br>然后可以直接调用 unique_lock 的 unlock() 函数来提前解锁，但是即使忘记解锁也没关系，退出作用域时候它还会自动检查一遍要不要解锁。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::vector&lt;</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\">&gt; arr;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::mutex mtx;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::thread </span><span style=\"color: #DCDCAA\">t1</span><span style=\"color: #D4D4D4\">([&amp;]</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                   {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> i = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">; i &lt; </span><span style=\"color: #B5CEA8\">1000</span><span style=\"color: #D4D4D4\">; i++) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::unique_lock </span><span style=\"color: #DCDCAA\">grd</span><span style=\"color: #D4D4D4\">(mtx);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">arr</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">push_back</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        } });</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::thread </span><span style=\"color: #DCDCAA\">t2</span><span style=\"color: #D4D4D4\">([&amp;]</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                   {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> i = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">; i &lt; </span><span style=\"color: #B5CEA8\">1000</span><span style=\"color: #D4D4D4\">; i++) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::unique_lock </span><span style=\"color: #DCDCAA\">grd</span><span style=\"color: #D4D4D4\">(mtx);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">arr</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">push_back</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">2</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">grd</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">unlock</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"outside of lock</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            // grd.lock();  // 如果需要，还可以重新上锁</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        } });</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">t1</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">join</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">t2</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">join</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p><strong>std::unique_lock：用 std::adopt_lock 做参数</strong><br>如果当前 mutex 已经上锁了，但是之后仍然希望用 RAII 思想在解构时候自动调用 unlock()，可以用 <strong>std::adopt_lock</strong> 作为 std::unique_lock 或 std::lock_guard 的第二个参数，这时它们会默认对象已经上锁。</p>\n<p><strong>多个对象就每个对象各分配一把锁</strong></p>\n<h4 id=\"上锁失败不等待\"><a href=\"#上锁失败不等待\" class=\"headerlink\" title=\"上锁失败不等待\"></a>上锁失败不等待</h4><p>lock() 如果发现 mutex 已经上锁的话，会等待它直到它解锁。<br>也可以用无阻塞的 **try_lock()**，它在上锁失败时不会陷入等待，而是直接返回 false；如果上锁成功，则会返回 true。<br>比如下面这个例子，第一次上锁，因为还没有上锁，所以成功了，返回 true。<br>第二次上锁，由于已经上锁，所以失败了，返回 false。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::mutex mtx1;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #9CDCFE\">mtx1</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">try_lock</span><span style=\"color: #D4D4D4\">())</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"succeed</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"failed</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #9CDCFE\">mtx1</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">try_lock</span><span style=\"color: #D4D4D4\">())</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"succeed</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"failed</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">mtx1</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">unlock</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p><strong>std::unique_lock：用 std::try_to_lock 做参数</strong><br>和无参数相比，它会调用 try_lock() 而不是 lock()。之后，可以用owns_lock() 判断是否上锁成功。</p>\n<h4 id=\"上锁失败等待一段时间\"><a href=\"#上锁失败等待一段时间\" class=\"headerlink\" title=\"上锁失败等待一段时间\"></a>上锁失败等待一段时间</h4><p>try_lock() 碰到已经上锁的情况，会立即返回 false。<br>如果需要等待，但仅限一段时间，可以用 <strong>std::timed_mutex</strong> 的 <strong>try_lock_for()</strong> 函数，它的参数是最长等待时间，同样是由 chrono 指定时间单位。超过这个时间还没成功就会“不耐烦地”失败并返回 false；如果这个时间内上锁成功则返回 true。<br>同理还有接受时间点的 **try_lock_until()**。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::timed_mutex mtx1;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #9CDCFE\">mtx1</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">try_lock_for</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">chrono</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">milliseconds</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">500</span><span style=\"color: #D4D4D4\">)))</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"succeed</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"failed</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #9CDCFE\">mtx1</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">try_lock_for</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">chrono</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">milliseconds</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">500</span><span style=\"color: #D4D4D4\">)))</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"succeed</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"failed</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">mtx1</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">unlock</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><h4 id=\"unique-lock和mutex接口相同\"><a href=\"#unique-lock和mutex接口相同\" class=\"headerlink\" title=\"unique_lock和mutex接口相同\"></a>unique_lock和mutex接口相同</h4><p>其实 std::unique_lock 具有 mutex 的所有成员函数：lock(), unlock(), try_lock(), try_lock_for() 等。除了它会在解构时按需自动调用 unlock()。<br>因为 std::lock_guard 无非是调用其构造参数名为 lock() 的成员函数，所以 std::unique_lock 也可以作为 std::lock_guard 的构造参数！<br>这种只要具有某些指定名字的成员函数，就判断一个类是否满足某些功能的思想，在 Python 称为鸭子类型，而 C++ 称为 concept（概念）。比起虚函数和动态多态的接口抽象，concept 使实现和接口更加解耦合且没有性能损失。 </p>\n<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><h4 id=\"两个锁互相锁\"><a href=\"#两个锁互相锁\" class=\"headerlink\" title=\"两个锁互相锁\"></a>两个锁互相锁</h4><p>由于同时执行的两个线程，它们中发生的指令不一定是同步的，因此有可能出现这种情况：<br>t1 执行 mtx1.lock()。<br>t2 执行 mtx2.lock()。<br>t1 执行 mtx2.lock()：失败，陷入等待<br>t2 执行 mtx1.lock()：失败，陷入等待<br>双方都在等着对方释放锁，但是因为等待而无法释放锁，从而要无限制等下去。 </p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::mutex mtx1;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::mutex mtx2;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::thread </span><span style=\"color: #DCDCAA\">t1</span><span style=\"color: #D4D4D4\">([&amp;]</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                   {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> i = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">; i &lt; </span><span style=\"color: #B5CEA8\">1000</span><span style=\"color: #D4D4D4\">; i++) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">mtx1</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">lock</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">mtx2</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">lock</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">mtx2</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">unlock</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">mtx1</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">unlock</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        } });</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::thread </span><span style=\"color: #DCDCAA\">t2</span><span style=\"color: #D4D4D4\">([&amp;]</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                   {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> i = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">; i &lt; </span><span style=\"color: #B5CEA8\">1000</span><span style=\"color: #D4D4D4\">; i++) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">mtx2</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">lock</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">mtx1</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">lock</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">mtx1</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">unlock</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">mtx2</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">unlock</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        } });</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">t1</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">join</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">t2</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">join</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>这种现象称为死锁（dead-lock）。  </p>\n<p><strong>解决1：永远不要同时持有两个锁</strong><br>最简单的方法，就是保证在一个线程中，得处于lock状态的锁不超过一个，即可以避免死锁。  </p>\n<p><strong>解决2：保证两个锁双方上锁顺序一致</strong><br>比方有两个锁，mtx1和mtx2，每个运行的线程都保证先锁mtx1，再锁mtx2。这时，无论实际执行顺序是怎样，都不会出现一方等着对方的同时持有了对方等着的锁的情况。<br>。</p>\n<p><strong>解决3：用 std::lock 同时对多个上锁（更推荐）</strong><br>如果没办法保证上锁顺序一致，可以用标准库的 std::lock(mtx1, mtx2, …) 函数，一次性对多个 mutex 上锁。<br>它接受任意多个 mutex 作为参数，并且它保证在无论任意线程中调用的顺序是否相同，都不会产生死锁问题。</p>\n<p><strong>std::lock 的 RAII 版本：std::scoped_lock</strong><br>和 std::lock_guard 相对应，std::lock 也有 RAII 的版本 <strong>std::scoped_lock</strong>。只不过他可以同时对多个 mutex 上锁。</p>\n<h4 id=\"一个锁自己锁自己\"><a href=\"#一个锁自己锁自己\" class=\"headerlink\" title=\"一个锁自己锁自己\"></a>一个锁自己锁自己</h4><p>除了两个线程同时持有两个锁会造成死锁外，即使只有一个线程一个锁，如果 lock() 以后又调用 lock()，也会造成死锁。<br>比如下面的 func 函数，上了锁之后，又调用了 other 函数，他也需要上锁。而 other 看到 mtx1 已经上锁，还以为是别的线程上的锁，于是陷入等待。殊不知是调用他的 func 上的锁，other 陷入等待后 func 里的 unlock() 永远得不到调用。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::mutex mtx1;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">other</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">mtx1</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">lock</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    // do something</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">mtx1</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">unlock</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">func</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">mtx1</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">lock</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">other</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">mtx1</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">unlock</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">func</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p><strong>解决1：other 里不要再上锁</strong><br>把 other 里的 lock() 去掉，并在其文档中说明：“other 不是线程安全的，调用本函数之前需要保证某 mutex 已经上锁。”</p>\n<p><strong>解决2：改用 std::recursive_mutex</strong><br>如果实在不能改的话，可以用 std::recursive_mutex。他会自动判断是不是同一个线程 lock() 了多次同一个锁，如果是则让计数器加1，之后 unlock() 会让计数器减1，减到0时才真正解锁。但是相比普通的std::mutex有一定性能损失。<br>同理还有<strong>std::recursive_timed_mutex</strong>，如果你同时需要 try_lock_for()的话。</p>\n<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><h4 id=\"std-vector\"><a href=\"#std-vector\" class=\"headerlink\" title=\"std::vector\"></a>std::vector</h4><p>vector 不是多线程安全的容器。<br>多个线程同时访问同一个 vector 会出现数据竞争（data-race）现象。<br>我们可以封装一个线程安全的vector，类似下面的。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">MTVector</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::vector&lt;</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\">&gt; m_arr;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">mutable</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::mutex m_mtx;</span><span style=\"color: #6A9955\">//设为mutable否则size()函数报错</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">push_back</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">val</span><span style=\"color: #D4D4D4\">)</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">m_mtx</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">lock</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">m_arr</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">push_back</span><span style=\"color: #D4D4D4\">(val);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">m_mtx</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">unlock</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">size</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">m_mtx</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">lock</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> ret = </span><span style=\"color: #9CDCFE\">m_arr</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">size</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">m_mtx</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">unlock</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> ret;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span></code></pre></div><p>在数据结构中：读可以共享，写必须独占，且写和读不能共存。<br>那么在这种要求下，我们引入<strong>读写锁</strong>的概念。</p>\n<h4 id=\"std-shared-mutex\"><a href=\"#std-shared-mutex\" class=\"headerlink\" title=\"std::shared_mutex\"></a>std::shared_mutex</h4><p>上锁时，可以指定你的需求是写入还是读取，负责调度的读写锁会帮你判断要不要等待。<br>如果需要写入数据，使用 lock() 和 unlock() 的组合。<br>如果是要读取数据，使用 lock_shared() 和 unlock_shared() 的组合。</p>\n<h4 id=\"std-shared-lock\"><a href=\"#std-shared-lock\" class=\"headerlink\" title=\"std::shared_lock\"></a>std::shared_lock</h4><p>在函数体退出时自动调用 unlock_shared()。</p>\n<h4 id=\"访问者模式\"><a href=\"#访问者模式\" class=\"headerlink\" title=\"访问者模式\"></a>访问者模式</h4><p>只需一次性上锁，且符合 RAII 思想</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">MTVector</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::vector&lt;</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\">&gt; m_arr;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::mutex m_mtx;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Accessor</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        MTVector &amp;m_that;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::unique_lock&lt;</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::mutex&gt; m_guard;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">Accessor</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">MTVector</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #9CDCFE\">that</span><span style=\"color: #D4D4D4\">)</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            : </span><span style=\"color: #DCDCAA\">m_that</span><span style=\"color: #D4D4D4\">(that), </span><span style=\"color: #DCDCAA\">m_guard</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #9CDCFE\">that</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">m_mtx</span><span style=\"color: #D4D4D4\">) {}</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">push_back</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">val</span><span style=\"color: #D4D4D4\">) </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> { </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">m_that</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">m_arr</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">push_back</span><span style=\"color: #D4D4D4\">(val); }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">size</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> { </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">m_that</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">m_arr</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">size</span><span style=\"color: #D4D4D4\">(); }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    };</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">Accessor</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">access</span><span style=\"color: #D4D4D4\">() { </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> {*</span><span style=\"color: #569CD6\">this</span><span style=\"color: #D4D4D4\">}; }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    MTVector arr;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::thread </span><span style=\"color: #DCDCAA\">t1</span><span style=\"color: #D4D4D4\">([&amp;]()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                   {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #569CD6\">auto</span><span style=\"color: #D4D4D4\"> axr = </span><span style=\"color: #9CDCFE\">arr</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">access</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> i = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">; i &lt; </span><span style=\"color: #B5CEA8\">1000</span><span style=\"color: #D4D4D4\">; i++) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">axr</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">push_back</span><span style=\"color: #D4D4D4\">(i);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        } });</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::thread </span><span style=\"color: #DCDCAA\">t2</span><span style=\"color: #D4D4D4\">([&amp;]()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                   {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #569CD6\">auto</span><span style=\"color: #D4D4D4\"> axr = </span><span style=\"color: #9CDCFE\">arr</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">access</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> i = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">; i &lt; </span><span style=\"color: #B5CEA8\">1000</span><span style=\"color: #D4D4D4\">; i++) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">axr</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">push_back</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">1000</span><span style=\"color: #D4D4D4\"> + i);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        } });</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">t1</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">join</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">t2</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">join</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cout &lt;&lt; </span><span style=\"color: #9CDCFE\">arr</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">access</span><span style=\"color: #D4D4D4\">().</span><span style=\"color: #DCDCAA\">size</span><span style=\"color: #D4D4D4\">() &lt;&lt; </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::endl;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><h3 id=\"条件变量\"><a href=\"#条件变量\" class=\"headerlink\" title=\"条件变量\"></a>条件变量</h3><p><strong>定义于头文件&lt;condition_variable&gt;</strong></p>\n<h4 id=\"等待被唤醒\"><a href=\"#等待被唤醒\" class=\"headerlink\" title=\"等待被唤醒\"></a>等待被唤醒</h4><div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::condition_variable cv;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::mutex mtx;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::thread </span><span style=\"color: #DCDCAA\">t1</span><span style=\"color: #D4D4D4\">([&amp;]</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                   {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">unique_lock</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">lck</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">mtx</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">cv</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">wait</span><span style=\"color: #D4D4D4\">(lck);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cout &lt;&lt; </span><span style=\"color: #CE9178\">\"t1 is awake\"</span><span style=\"color: #D4D4D4\"> &lt;&lt; </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::endl; });</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">this_thread</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">sleep_for</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">chrono</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">milliseconds</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">400</span><span style=\"color: #D4D4D4\">));</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cout &lt;&lt; </span><span style=\"color: #CE9178\">\"notifying...\"</span><span style=\"color: #D4D4D4\"> &lt;&lt; </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::endl;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">cv</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">notify_one</span><span style=\"color: #D4D4D4\">();</span><span style=\"color: #6A9955\"> // 唤醒t1</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">t1</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">join</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>cv.wait(lck) 将会让当前线程陷入等待。<br>在其他线程中调用 cv.notify_one() 则会唤醒那个陷入等待的线程。<br>可以发现 <strong>std::condition_variable</strong> 必须和 <strong>std::unique_lock&lt;std::mutex&gt;</strong> 一起用，稍后会解释原因。</p>\n<h4 id=\"等待条件为true\"><a href=\"#等待条件为true\" class=\"headerlink\" title=\"等待条件为true\"></a>等待条件为true</h4><p>给成员函数wait额外指定一个参数，变成 wait(lock, expr) 的形式，其中 expr 是一个可调用对象，只有其返回值为 true 时才会真正唤醒，否则继续等待。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::condition_variable cv;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::mutex mtx;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">bool</span><span style=\"color: #D4D4D4\"> ready = </span><span style=\"color: #569CD6\">false</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::thread </span><span style=\"color: #DCDCAA\">t1</span><span style=\"color: #D4D4D4\">([&amp;]</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                   {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">unique_lock</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">lck</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">mtx</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">cv</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">wait</span><span style=\"color: #D4D4D4\">(lck, [&amp;] { </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> ready; });</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cout &lt;&lt; </span><span style=\"color: #CE9178\">\"t1 is awake\"</span><span style=\"color: #D4D4D4\"> &lt;&lt; </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::endl; });</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cout &lt;&lt; </span><span style=\"color: #CE9178\">\"notifying not ready\"</span><span style=\"color: #D4D4D4\"> &lt;&lt; </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::endl;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">cv</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">notify_one</span><span style=\"color: #D4D4D4\">();</span><span style=\"color: #6A9955\"> // 没用，因为ready为false</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ready = </span><span style=\"color: #569CD6\">true</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cout &lt;&lt; </span><span style=\"color: #CE9178\">\"notifying ready\"</span><span style=\"color: #D4D4D4\"> &lt;&lt; </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::endl;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">cv</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">notify_one</span><span style=\"color: #D4D4D4\">();</span><span style=\"color: #6A9955\"> // t1被唤醒，因为ready为true</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><h4 id=\"多个等待者\"><a href=\"#多个等待者\" class=\"headerlink\" title=\"多个等待者\"></a>多个等待者</h4><p>std::condition_variable成员函数<strong>notify_all()</strong> 唤醒全部等待中的线程。<br>这就是为什么 wait() 需要一个 unique_lock 作为参数，因为要保证多个线程被唤醒时，只有一个能够被启动。如果不需要，在 wait() 返回后调用 unlock() 即可。<br>wait() 的过程中会暂时 unlock() 这个锁。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::condition_variable cv;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::mutex mtx;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::thread </span><span style=\"color: #DCDCAA\">t1</span><span style=\"color: #D4D4D4\">([&amp;]</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                   {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">unique_lock</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">lck</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">mtx</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">cv</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">wait</span><span style=\"color: #D4D4D4\">(lck);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cout &lt;&lt; </span><span style=\"color: #CE9178\">\"t1 is awake\"</span><span style=\"color: #D4D4D4\"> &lt;&lt; </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::endl; });</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::thread </span><span style=\"color: #DCDCAA\">t2</span><span style=\"color: #D4D4D4\">([&amp;]</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                   {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">unique_lock</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">lck</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">mtx</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">cv</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">wait</span><span style=\"color: #D4D4D4\">(lck);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cout &lt;&lt; </span><span style=\"color: #CE9178\">\"t2 is awake\"</span><span style=\"color: #D4D4D4\"> &lt;&lt; </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::endl; });</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::thread </span><span style=\"color: #DCDCAA\">t3</span><span style=\"color: #D4D4D4\">([&amp;]</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                   {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">unique_lock</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">lck</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">mtx</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">cv</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">wait</span><span style=\"color: #D4D4D4\">(lck);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cout &lt;&lt; </span><span style=\"color: #CE9178\">\"t3 is awake\"</span><span style=\"color: #D4D4D4\"> &lt;&lt; </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::endl; });</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">this_thread</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">sleep_for</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">chrono</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">milliseconds</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">400</span><span style=\"color: #D4D4D4\">));</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cout &lt;&lt; </span><span style=\"color: #CE9178\">\"notifying one\"</span><span style=\"color: #D4D4D4\"> &lt;&lt; </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::endl;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">cv</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">notify_one</span><span style=\"color: #D4D4D4\">();</span><span style=\"color: #6A9955\"> // 仅仅唤醒t1</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">this_thread</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">sleep_for</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">chrono</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">milliseconds</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">400</span><span style=\"color: #D4D4D4\">));</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cout &lt;&lt; </span><span style=\"color: #CE9178\">\"notifying all\"</span><span style=\"color: #D4D4D4\"> &lt;&lt; </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::endl;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">cv</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">notify_all</span><span style=\"color: #D4D4D4\">();</span><span style=\"color: #6A9955\"> // 唤醒剩下的t2和t3</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">t1</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">join</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">t2</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">join</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">t3</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">join</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><h4 id=\"实现生产者-消费者模式\"><a href=\"#实现生产者-消费者模式\" class=\"headerlink\" title=\"实现生产者-消费者模式\"></a>实现生产者-消费者模式</h4><div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::condition_variable cv;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::mutex mtx;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::vector&lt;</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\">&gt; foods;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::thread </span><span style=\"color: #DCDCAA\">t1</span><span style=\"color: #D4D4D4\">([&amp;]</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                   {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> i = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">; i &lt; </span><span style=\"color: #B5CEA8\">2</span><span style=\"color: #D4D4D4\">; i++) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::unique_lock </span><span style=\"color: #DCDCAA\">lck</span><span style=\"color: #D4D4D4\">(mtx);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">cv</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">wait</span><span style=\"color: #D4D4D4\">(lck, [&amp;] {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">foods</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">size</span><span style=\"color: #D4D4D4\">() != </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            });</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #569CD6\">auto</span><span style=\"color: #D4D4D4\"> food = </span><span style=\"color: #9CDCFE\">foods</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">back</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">foods</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">pop_back</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">lck</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">unlock</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cout &lt;&lt; </span><span style=\"color: #CE9178\">\"t1 got food:\"</span><span style=\"color: #D4D4D4\"> &lt;&lt; food &lt;&lt; </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::endl;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        } });</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::thread </span><span style=\"color: #DCDCAA\">t2</span><span style=\"color: #D4D4D4\">([&amp;]</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                   {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> i = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">; i &lt; </span><span style=\"color: #B5CEA8\">2</span><span style=\"color: #D4D4D4\">; i++) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::unique_lock </span><span style=\"color: #DCDCAA\">lck</span><span style=\"color: #D4D4D4\">(mtx);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">cv</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">wait</span><span style=\"color: #D4D4D4\">(lck, [&amp;] {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">foods</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">size</span><span style=\"color: #D4D4D4\">() != </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            });</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #569CD6\">auto</span><span style=\"color: #D4D4D4\"> food = </span><span style=\"color: #9CDCFE\">foods</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">back</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">foods</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">pop_back</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">lck</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">unlock</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cout &lt;&lt; </span><span style=\"color: #CE9178\">\"t2 got food:\"</span><span style=\"color: #D4D4D4\"> &lt;&lt; food &lt;&lt; </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::endl;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        } });</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">foods</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">push_back</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">42</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">foods</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">push_back</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">233</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">cv</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">notify_one</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">foods</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">push_back</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">666</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">foods</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">push_back</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">4399</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">cv</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">notify_all</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">t1</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">join</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">t2</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">join</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>std::condition_variable 仅仅支持 std::unique_lock&lt;std::mutex&gt; 作为 wait 的参数，如果需要用其他类型的 mutex 锁，可以用 std::condition_variable_any。<br>他还有 wait_for() 和 wait_until() 函数，分别接受 chrono 时间段和时间点作为参数。</p></blockquote>\n<h3 id=\"原子操作\"><a href=\"#原子操作\" class=\"headerlink\" title=\"原子操作\"></a>原子操作</h3><p><strong>定义于头文件&lt;atomic&gt;</strong></p>\n<h4 id=\"多个线程修改同一个计数器\"><a href=\"#多个线程修改同一个计数器\" class=\"headerlink\" title=\"多个线程修改同一个计数器\"></a>多个线程修改同一个计数器</h4><p>多个线程同时往一个 int 变量里累加，这样肯定会出错，因为 counter += i 在 CPU 看来会变成三个指令：<br>读取 counter 变量到 rax 寄存器<br>rax 寄存器的值加上 1<br>把 rax 写入到 counter 变量<br>即使编译器优化成 add [counter], 1 也没用，因为现代 CPU 为了高效，会把一条汇编指令拆分成很多微指令 (micro-ops)，具体是如何实现的跟硬件有很大的关系。  </p>\n<p>如果有多个线程同时运行，顺序是不确定的：<br>t1：读取 counter 变量，到 rax 寄存器<br>t2：读取 counter 变量，到 rax 寄存器<br>t1：rax 寄存器的值加上 1<br>t2：rax 寄存器的值加上 1<br>t1：把 rax 写入到 counter 变量<br>t2：把 rax 写入到 counter 变量<br>如果是这种顺序，最后 t1 的写入就被 t2 覆盖了，从而 counter 只增加了 1，而没有像预期的那样增加 2。<br>更不用说现代 CPU 还有高速缓存，乱序执行，指令级并行等优化策略，你根本不知道每条指令实际的先后顺序。  </p>\n<p><strong>解决1：std::mutex 上锁</strong><br>防止多个线程同时修改 counter 变量，从而不会冲突。<br>问题：mutex 太过重量级，他会让线程被挂起，从而需要通过系统调用，进入内核层，调度到其他线程执行，有很大的开销。</p>\n<p><strong>解决2：std::atomic（推荐）</strong><br>因此可以用更轻量级的 atomic，对他的 += 等操作，会被编译器转换成专门的指令。<br>CPU 识别到该指令时，会锁住内存总线，放弃乱序执行等优化策略（将该指令视为一个同步点，强制同步掉之前所有的内存操作），从而向你保证该操作是原子 (atomic) 的，不会加法加到一半另一个线程插一脚进来。<br>对于程序员，只需把 int 改成 atomic&lt;int&gt; 即可，也不必像 mutex 那样需要手动上锁解锁，因此用起来也更直观。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p>不过要注意了，这种写法：<br>counter = counter + 1;  // 错，不能保证原子性<br>counter += 1;                // OK，能保证原子性<br>counter++;                    // OK，能保证原子性</p>\n\n</div>\n","feature":true,"text":"这是观看一位大佬双笙子佯谬的视频后写的笔记。 时间标准库chrono（C++11）std::chrono定义于头文件&lt;chrono&gt; 利用 C++ ...","permalink":"/post/C-多线程","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"16 mins."},"categories":[{"name":"C++","slug":"C","count":3,"path":"api/categories/C.json"}],"tags":[{"name":"C++进阶","slug":"C-进阶","count":3,"path":"api/tags/C-进阶.json"},{"name":"多线程","slug":"多线程","count":1,"path":"api/tags/多线程.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%B6%E9%97%B4%E6%A0%87%E5%87%86%E5%BA%93chrono%EF%BC%88C-11%EF%BC%89\"><span class=\"toc-text\">时间标准库chrono（C++11）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#std-chrono\"><span class=\"toc-text\">std::chrono</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#sleep\"><span class=\"toc-text\">sleep</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">线程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#std-thread\"><span class=\"toc-text\">std::thread</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#main-%E5%87%BD%E6%95%B0%E9%80%80%E5%87%BA%E5%90%8E%E8%87%AA%E5%8A%A8-join-%E5%85%A8%E9%83%A8%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">main 函数退出后自动 join 全部线程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#std-jthread-C-20\"><span class=\"toc-text\">std::jthread(C++20)</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%82%E6%AD%A5\"><span class=\"toc-text\">异步</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#std-async\"><span class=\"toc-text\">std::async</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#std-promise\"><span class=\"toc-text\">std::promise</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%92%E6%96%A5%E9%87%8F\"><span class=\"toc-text\">互斥量</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#std-mutex\"><span class=\"toc-text\">std::mutex</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#std-lock-guard\"><span class=\"toc-text\">std::lock_guard</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#std-unique-lock\"><span class=\"toc-text\">std::unique_lock</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%8A%E9%94%81%E5%A4%B1%E8%B4%A5%E4%B8%8D%E7%AD%89%E5%BE%85\"><span class=\"toc-text\">上锁失败不等待</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%8A%E9%94%81%E5%A4%B1%E8%B4%A5%E7%AD%89%E5%BE%85%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">上锁失败等待一段时间</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#unique-lock%E5%92%8Cmutex%E6%8E%A5%E5%8F%A3%E7%9B%B8%E5%90%8C\"><span class=\"toc-text\">unique_lock和mutex接口相同</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81\"><span class=\"toc-text\">死锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E4%B8%AA%E9%94%81%E4%BA%92%E7%9B%B8%E9%94%81\"><span class=\"toc-text\">两个锁互相锁</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%B8%AA%E9%94%81%E8%87%AA%E5%B7%B1%E9%94%81%E8%87%AA%E5%B7%B1\"><span class=\"toc-text\">一个锁自己锁自己</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">数据结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#std-vector\"><span class=\"toc-text\">std::vector</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#std-shared-mutex\"><span class=\"toc-text\">std::shared_mutex</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#std-shared-lock\"><span class=\"toc-text\">std::shared_lock</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">访问者模式</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">条件变量</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AD%89%E5%BE%85%E8%A2%AB%E5%94%A4%E9%86%92\"><span class=\"toc-text\">等待被唤醒</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6%E4%B8%BAtrue\"><span class=\"toc-text\">等待条件为true</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E4%B8%AA%E7%AD%89%E5%BE%85%E8%80%85\"><span class=\"toc-text\">多个等待者</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">实现生产者-消费者模式</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">原子操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BF%AE%E6%94%B9%E5%90%8C%E4%B8%80%E4%B8%AA%E8%AE%A1%E6%95%B0%E5%99%A8\"><span class=\"toc-text\">多个线程修改同一个计数器</span></a></li></ol></li></ol>","author":{"name":"Ac-Accelerator","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一位计算机技术爱好者，大学在读，目前正在学习C++、Python、Java和计算机系统以及计算机视觉深度学习等相关知识，欢迎交流","socials":{"github":"https://github.com/Ac-Accelerator","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_31702515?spm=1000.2115.3001.5343","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/74120250?spm_id_from=333.1007.0.0"},"rss":{"icon":"/svg/rss.svg","link":"atom.xml"},"qq":{"icon":"/svg/QQ.svg","link":"http://tool.gljlw.com/qq/?qq=2583832841"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"数据库系统原理（一）","uid":"13bf866f8a267e47702ed2383b6aca22","slug":"数据库系统原理（一）","date":"2023-03-28T10:56:00.000Z","updated":"2023-09-25T17:40:11.345Z","comments":true,"path":"api/articles/数据库系统原理（一）.json","keywords":"C++,Pyhton,Java,算法","cover":"/img/db.jpeg","text":"绪论数据库是什么广义定义：指包含关于某单位、机构、部门，或是某领域、业务主题，或是某对象的信息、互相关联的大量数据的集合。 狭义定义：特指用专门通用软件管理，长...","permalink":"/post/数据库系统原理（一）","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"数据库","slug":"数据库","count":2,"path":"api/categories/数据库.json"}],"tags":[{"name":"数据库","slug":"数据库","count":2,"path":"api/tags/数据库.json"},{"name":"学习笔记","slug":"学习笔记","count":2,"path":"api/tags/学习笔记.json"}],"author":{"name":"Ac-Accelerator","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一位计算机技术爱好者，大学在读，目前正在学习C++、Python、Java和计算机系统以及计算机视觉深度学习等相关知识，欢迎交流","socials":{"github":"https://github.com/Ac-Accelerator","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_31702515?spm=1000.2115.3001.5343","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/74120250?spm_id_from=333.1007.0.0"},"rss":{"icon":"/svg/rss.svg","link":"atom.xml"},"qq":{"icon":"/svg/QQ.svg","link":"http://tool.gljlw.com/qq/?qq=2583832841"}}}},"feature":true},"next_post":{"title":"编译器优化","uid":"654198c9751861f6164cbde797aab0ed","slug":"编译器优化","date":"2022-11-08T09:13:00.000Z","updated":"2023-09-25T16:40:39.684Z","comments":true,"path":"api/articles/编译器优化.json","keywords":"C++,Pyhton,Java,算法","cover":"/img/CPPcover.webp","text":"这是观看一位大佬双笙子佯谬的视频后写的笔记。 汇编基础x64架构CPU寄存器模型 汇编语言 gcc编译器里函数的前6个参数：分别通过*di，*si，*dx，*c...","permalink":"/post/编译器优化","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"C++","slug":"C","count":3,"path":"api/categories/C.json"}],"tags":[{"name":"C++进阶","slug":"C-进阶","count":3,"path":"api/tags/C-进阶.json"},{"name":"编译器优化","slug":"编译器优化","count":1,"path":"api/tags/编译器优化.json"}],"author":{"name":"Ac-Accelerator","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一位计算机技术爱好者，大学在读，目前正在学习C++、Python、Java和计算机系统以及计算机视觉深度学习等相关知识，欢迎交流","socials":{"github":"https://github.com/Ac-Accelerator","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_31702515?spm=1000.2115.3001.5343","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/74120250?spm_id_from=333.1007.0.0"},"rss":{"icon":"/svg/rss.svg","link":"atom.xml"},"qq":{"icon":"/svg/QQ.svg","link":"http://tool.gljlw.com/qq/?qq=2583832841"}}}},"feature":true}}