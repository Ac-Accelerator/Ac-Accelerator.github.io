{"title":"Linux网络编程（libevent）","uid":"8dd59640d6bc3d377df04d40d6faff25","slug":"Linux网络编程（libevent）","date":"2024-07-19T12:26:18.000Z","updated":"2024-07-24T09:13:49.282Z","comments":true,"path":"api/articles/Linux网络编程（libevent）.json","keywords":"C++,Pyhton,Java,算法","cover":"img/linux.jpeg","content":"<h1 id=\"libevent的作用\"><a href=\"#libevent的作用\" class=\"headerlink\" title=\"libevent的作用\"></a>libevent的作用</h1><p>对于简单的socket编程，采用阻塞的方式是最基础的。例如，当调用recv函数时，如果没有数据到来就会一直阻塞。这种方式的问题在于，如果只有一个线程，那么就无法同时处理多个连接（处理其中一个连接时被阻塞后，另一个连接将无法被响应直到阻塞解除）。为了解决这个问题，可以采用多线程或者多进程的方式，一个进程负责监听连接，一旦有连接到来就创建一个新的线程或者进程来处理这个连接。但是线程和进程的创建和销毁都需要不小的开销，一旦并发数量大，将导致系统资源耗尽。那么把socket设置为非阻塞然后轮询呢？这样的问题在于，如果没有数据到来，那么就会一直占用CPU资源（还会进行大量系统调用）。</p>\n<p>一个解决问题的原始方法是，使用select函数。让内核帮助我们监视多个文件描述符，当其中一个文件描述符有数据到来时，select函数就会返回。后来的poll函数和epoll函数都能实现对应的功能。但是在不同的操作系统上，并不是都有统一的接口。libevent就是为了解决这个问题而生的。</p>\n<h1 id=\"event-base\"><a href=\"#event-base\" class=\"headerlink\" title=\"event_base\"></a>event_base</h1><p><code>event_base</code>结构体是libevent的核心，在使用libevent时，首先需要创建一个<code>event_base</code>对象。每个 event_base 结构体持有一组事件，并且可以通过轮询来确定哪些事件处于活动状态。</p>\n<p>如果要在多个线程中访问 <code>event_base</code> 结构体（如多个线程向里面添加事件），则需要使用锁机制来保证线程安全。但是，它的事件循环只能在单个线程中运行。如果希望多个线程轮询 I/O，则需要为每个线程创建一个 <code>event_base</code> （这也是保证线程安全的最简单的实践）。</p>\n<p><code>event_base</code> 有一个“方法”，用来指定事件循环的实现，包括 select、poll、epoll、kqueue 等。libevent 会根据当前系统的支持情况自动选择最合适的实现。也可以通过<code>event_config_avoid_method()</code>函数来指定不使用的方法。</p>\n<h2 id=\"event-base-new\"><a href=\"#event-base-new\" class=\"headerlink\" title=\"event_base_new\"></a>event_base_new</h2><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;event2/event.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_base *</span><span style=\"color: #DCDCAA\">event_base_new</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_base *</span><span style=\"color: #DCDCAA\">event_base_new_with_config</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_config *</span><span style=\"color: #9CDCFE\">cfg</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_base_free</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_base *</span><span style=\"color: #9CDCFE\">base</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p>使用默认设置在堆上创建一个新的 <code>event_base</code> 对象，并返回指针。如果创建失败，返回 <code>NULL</code>。</p>\n<p>如果要在初始化的时候配置 <code>event_base</code> 对象，则需要使用 <code>event_base_new_with_config()</code> 函数，传入一个 <code>event_config</code> 对象。</p>\n<p><code>event_base_free()</code> 用来释放 <code>event_base</code> 对象。</p>\n<div class=\"custom-quote danger\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M19.76 5.23C15.84 5.23 12 2 12 2C12 2 8.15996 5.23 4.23996 5.23C4.23996 5.23 1.86996 16.99 12 22C22.13 16.99 19.76 5.23 19.76 5.23Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 16H12\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">特别注意</p>\n<p><code>event_base_free()</code>函数不会释放当前与 <code>base</code> 关联的任何事件，不会关闭它们的任何套接字，也不会释放它们的任何指针。</p>\n\n</div>\n<h2 id=\"event-config\"><a href=\"#event-config\" class=\"headerlink\" title=\"event_config\"></a>event_config</h2><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;event2/event.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_config *</span><span style=\"color: #DCDCAA\">event_config_new</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_config_free</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_config *</span><span style=\"color: #9CDCFE\">cfg</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p>要配置 <code>event_base</code> ，先调用 <code>event_config_new()</code> 分配一个新的 <code>event_config</code>。然后，在 <code>event_config</code> 上调用其他函数来传入配置。最后，调用 <code>event_base_new_with_config()</code> 获取新的 <code>event_base</code>。完成后，可以使用 <code>event_config_free()</code> 释放 <code>event_config</code>。</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">char</span><span style=\"color: #D4D4D4\"> **</span><span style=\"color: #DCDCAA\">event_get_supported_methods</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\">);</span><span style=\"color: #6A9955\">//返回一个字符串数组，包含当前系统支持的所有方法的名字。</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_config_avoid_method</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_config *</span><span style=\"color: #9CDCFE\">cfg</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">char</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">method</span><span style=\"color: #D4D4D4\">);</span><span style=\"color: #6A9955\">//传入方法的名字str</span></span></code></pre></div><p><code>event_config_avoid_method()</code> 函数用来指定不使用的方法。传入方法的名字字符串，如 <code>\"select\"</code>、<code>\"poll\"</code>、<code>\"epoll\"</code>、<code>\"kqueue\"</code> 等。</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">enum</span><span style=\"color: #D4D4D4\"> event_method_feature {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    EV_FEATURE_ET = </span><span style=\"color: #B5CEA8\">0x01</span><span style=\"color: #D4D4D4\">,</span><span style=\"color: #6A9955\">//需要支持边缘触发 I/O 的后端方法。</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    EV_FEATURE_O1 = </span><span style=\"color: #B5CEA8\">0x02</span><span style=\"color: #D4D4D4\">,</span><span style=\"color: #6A9955\">//需要一种后端方法，其中添加或删除单个事件或单个事件变为活动状态的操作的时间复杂度为 O(1)。</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    EV_FEATURE_FDS = </span><span style=\"color: #B5CEA8\">0x04</span><span style=\"color: #D4D4D4\">,</span><span style=\"color: #6A9955\">//需要一种后端方法，它可以支持任意文件描述符类型，而不仅仅是套接字。</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_config_require_features</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_config *</span><span style=\"color: #9CDCFE\">cfg</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                                  </span><span style=\"color: #569CD6\">enum</span><span style=\"color: #D4D4D4\"> event_method_feature </span><span style=\"color: #9CDCFE\">feature</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">enum</span><span style=\"color: #D4D4D4\"> event_base_config_flag {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    EVENT_BASE_FLAG_NOLOCK = </span><span style=\"color: #B5CEA8\">0x01</span><span style=\"color: #D4D4D4\">,</span><span style=\"color: #6A9955\">//不要为 event_base 分配锁。（导致线程不安全）</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    EVENT_BASE_FLAG_IGNORE_ENV = </span><span style=\"color: #B5CEA8\">0x02</span><span style=\"color: #D4D4D4\">,</span><span style=\"color: #6A9955\">//在选择要使用的后端方法时，不要检查 EVENT_* 环境变量。</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    EVENT_BASE_FLAG_STARTUP_IOCP = </span><span style=\"color: #B5CEA8\">0x04</span><span style=\"color: #D4D4D4\">,</span><span style=\"color: #6A9955\">//在启动时启用任何必要的 IOCP 调度逻辑（仅Windows）</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    EVENT_BASE_FLAG_NO_CACHE_TIME = </span><span style=\"color: #B5CEA8\">0x08</span><span style=\"color: #D4D4D4\">,</span><span style=\"color: #6A9955\">//在每个超时回调之后检查当前时间</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST = </span><span style=\"color: #B5CEA8\">0x10</span><span style=\"color: #D4D4D4\">,</span><span style=\"color: #6A9955\">//使用epoll-changelist 后端</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    EVENT_BASE_FLAG_PRECISE_TIMER = </span><span style=\"color: #B5CEA8\">0x20</span><span style=\"color: #6A9955\">//使用更精细计时精度的较慢计时机制</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_config_set_flag</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_config *</span><span style=\"color: #9CDCFE\">cfg</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">enum</span><span style=\"color: #D4D4D4\"> event_base_config_flag </span><span style=\"color: #9CDCFE\">flag</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_config_set_max_dispatch_interval</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_config *</span><span style=\"color: #9CDCFE\">cfg</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> timeval *</span><span style=\"color: #9CDCFE\">max_interval</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">max_callbacks</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">min_priority</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>event_config_set_max_dispatch_interval()</code>通过限制在检查更多高优先级事件之前可以调用多少个低优先级事件回调来防止优先级反转。如果 max_interval 不为 NULL，则事件循环在每次回调后检查时间，并在 max_interval 已过时重新扫描高优先级事件。如果 max_callbacks 为非负数，则事件循环还会在调用 max_callbacks 个回调后检查更多事件。这些规则适用于任何优先级等于或高于 min_priority 的事件。</p>\n<h2 id=\"event-base-get\"><a href=\"#event-base-get\" class=\"headerlink\" title=\"event_base_get_\"></a>event_base_get_</h2><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;event2/event.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">char</span><span style=\"color: #D4D4D4\"> **</span><span style=\"color: #DCDCAA\">event_get_supported_methods</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">char</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #DCDCAA\">event_base_get_method</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_base *</span><span style=\"color: #9CDCFE\">base</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">enum</span><span style=\"color: #D4D4D4\"> event_method_feature </span><span style=\"color: #DCDCAA\">event_base_get_features</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_base *</span><span style=\"color: #9CDCFE\">base</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event *</span><span style=\"color: #DCDCAA\">event_base_get_running_event</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_base *</span><span style=\"color: #9CDCFE\">base</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>event_base_get_method()</code> 返回 <code>event_base</code> 使用的方法的名字字符串。</p>\n<p><code>event_base_get_features()</code> 返回 <code>event_base</code> 使用的方法的特性，如 <code>EV_FEATURE_ET</code>、<code>EV_FEATURE_O1</code>、<code>EV_FEATURE_FDS</code>。</p>\n<p><code>event_base_get_running_event()</code> 返回当前正在运行的事件的指针。</p>\n<div class=\"custom-quote danger\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M19.76 5.23C15.84 5.23 12 2 12 2C12 2 8.15996 5.23 4.23996 5.23C4.23996 5.23 1.86996 16.99 12 22C22.13 16.99 19.76 5.23 19.76 5.23Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 16H12\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">特别注意</p>\n<p><p><code>event_base_get_running_event()</code>函数的行为在其提供的 event_base 的事件循环中调用时有效。从另一个线程调用它不受支持，并且会导致未定义的行为。</p>\n</p>\n</div>\n<h2 id=\"event-base-priority\"><a href=\"#event-base-priority\" class=\"headerlink\" title=\"event_base_priority\"></a>event_base_priority</h2><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;event2/event.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_base_priority_init</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_base *</span><span style=\"color: #9CDCFE\">base</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">n_priorities</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p>默认情况下，event_base 只支持单个优先级。您可以通过调用 <code>event_base_priority_init()</code> 函数来设置 event_base 上的优先级数量。</p>\n<p>在成功时返回 0，失败时返回 -1。<code>base</code> 参数是要修改的 event_base，<code>n_priorities</code> 是要支持的优先级数量。它必须至少为 1。新事件的可用优先级将从 0（最重要）到 <code>n_priorities-1</code>（最不重要）进行编号。</p>\n<p>常量 <code>EVENT_MAX_PRIORITIES</code> 设置了 <code>n_priorities</code> 值的上限。使用高于此值的 <code>n_priorities</code> 调用此函数是错误的。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p>如果要调用此函数，最好在创建 event_base 后立即调用它，避免在添加事件之后调用。</p>\n\n</div>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_base_get_npriorities</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_base *</span><span style=\"color: #9CDCFE\">base</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p>查找 <code>base</code> 当前支持的优先级数量，如果没使用 <code>event_base_priority_init()</code> 设置优先级数量，则返回默认值 1。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>默认情况下，与此 base 关联的所有新事件都将初始化为优先级等于 <code>n_priorities / 2</code>。</p>\n</p>\n</div>\n<h2 id=\"event-reinit\"><a href=\"#event-reinit\" class=\"headerlink\" title=\"event_reinit\"></a>event_reinit</h2><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;event2/event.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_reinit</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_base *</span><span style=\"color: #9CDCFE\">base</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p>在 Forking 之后，子进程会继承父进程 event_base 的副本。此时必须在子进程中调用 <code>event_reinit()</code>，然后才能使用继承的 event_base。这很关键，因为：</p>\n<ul>\n<li><strong>文件描述符：</strong> 子进程会继承打开的文件描述符，而 libevent 的后端可能依赖于这些描述符（例如，epoll、kqueue）。 <code>event_reinit()</code> 确保在子进程上下文中正确地重新初始化后端。</li>\n<li><strong>信号处理程序：</strong> 信号处理程序可能无法正确继承。 <code>event_reinit()</code> 帮助重置子进程中事件循环的信号处理。</li>\n</ul>\n<p>在成功时返回 0，失败时返回 -1。</p>\n<h1 id=\"event\"><a href=\"#event\" class=\"headerlink\" title=\"event\"></a>event</h1><p>在 libevent 中，事件代表一组条件：</p>\n<ul>\n<li>文件描述符已准备好进行读取或写入。</li>\n<li>文件描述符变为可读取或写入状态（仅限边缘触发 IO）。</li>\n<li>超时到期。</li>\n<li>发生信号。</li>\n<li>用户触发的事件。</li>\n</ul>\n<p>添加到 event_base 的事件一开始是待处理状态，如果满足条件，就会变为活动状态并运行用户指定的回调函数。</p>\n<p>回调函数执行后，如果事件配置为持久性，它将回到待处理状态。如果不是持久性的事件，则在运行回调函数时将变成<em>非待处理状态</em>。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><strong>在 libevent 中：</strong></p>\n<ul>\n<li><p><strong>非持久性事件</strong> 被触发并且其回调函数执行后，它会自动从事件队列中移除，不再等待下次触发。</p>\n</li>\n<li><p><strong>持久性事件</strong> 被触发并且其回调函数执行后，它仍然会继续保留在事件队列中等待下次触发。简单来说，持久性事件在每次被触发后不会自动移除，需要手动停止或删除。</p>\n</li>\n</ul>\n\n</div>\n<h2 id=\"event-new\"><a href=\"#event-new\" class=\"headerlink\" title=\"event_new\"></a>event_new</h2><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#define</span><span style=\"color: #569CD6\"> EV_TIMEOUT      </span><span style=\"color: #B5CEA8\">0x01</span><span style=\"color: #6A9955\">//在超时过后变为活动状态，（构造事件时，将被忽略）</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#define</span><span style=\"color: #569CD6\"> EV_READ         </span><span style=\"color: #B5CEA8\">0x02</span><span style=\"color: #6A9955\">//准备好进行读取时变为活动状态</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#define</span><span style=\"color: #569CD6\"> EV_WRITE        </span><span style=\"color: #B5CEA8\">0x04</span><span style=\"color: #6A9955\">//准备好进行写入时变为活动状态</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#define</span><span style=\"color: #569CD6\"> EV_SIGNAL       </span><span style=\"color: #B5CEA8\">0x08</span><span style=\"color: #6A9955\">//实现信号检测功能</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#define</span><span style=\"color: #569CD6\"> EV_PERSIST      </span><span style=\"color: #B5CEA8\">0x10</span><span style=\"color: #6A9955\">//持久性事件</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#define</span><span style=\"color: #569CD6\"> EV_ET           </span><span style=\"color: #B5CEA8\">0x20</span><span style=\"color: #6A9955\">//指示事件为边缘触发的</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">typedef</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> (*event_callback_fn)(</span><span style=\"color: #4EC9B0\">evutil_socket_t</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">short</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event *</span><span style=\"color: #DCDCAA\">event_new</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_base *</span><span style=\"color: #9CDCFE\">base</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #4EC9B0\">evutil_socket_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">fd</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">short</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">what</span><span style=\"color: #D4D4D4\">, event_callback_fn </span><span style=\"color: #9CDCFE\">cb</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">arg</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_free</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event *</span><span style=\"color: #9CDCFE\">event</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>event_new()</code> 函数尝试分配和构造一个新事件，以便与 <code>base</code> 一起使用。 </p>\n<p><code>what</code> 参数是上面列出的标志集。如果 <code>fd</code> 为非负数，则它是我们将观察读取或写入事件的文件。当事件处于活动状态时，Libevent 将调用提供的 <code>cb</code> 函数，并将以下作为参数传递：文件描述符 <code>fd</code>、触发所有事件的位字段<code>what</code>以及在构造函数时为 <code>arg</code> 传递的值。</p>\n<p>如果出现内部错误或参数无效，<code>event_new()</code> 将返回 <code>NULL</code>。</p>\n<p>要释放事件，请调用 <code>event_free()</code>。</p>\n<p>所有新事件都已初始化且未处于待处理状态。要使事件处于待处理状态，请调用 <code>event_add()</code>。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><ol>\n<li>传入<code>event_new()</code>的<code>fd</code>必须先设置为非阻塞模式。防止在事件循环中因为阻塞I/O操作而导致整个应用程序挂起。</li>\n<li>在处于待处理或活动状态的事件上调用 <code>event_free()</code> 是安全的：这样做会在释放事件之前使其变为非待处理和非活动状态。</li>\n<li>参数<code>fd</code>为-1时，将不与任何文件描述符绑定，该事件可以作为<strong>用户触发事件</strong>（用<code>event_active()</code>手动激活）或者是<strong>接收自身作为回调参数的事件</strong>（允许回调函数在运行时能够访问并修改与该事件相关的信息或对该事件进行进一步的操作如：访问事件的上下文信息、重新配置或重新添加、停止或删除），特别注意如果要创建<strong>接收自身作为回调参数的事件</strong>，<code>arg</code>参数必须是<code>event_self_cbarg()</code>，<code>event_self_cbarg()</code> 函数返回一个“魔法”指针，当将其作为事件回调参数传递时，会告诉 <code>event_new()</code> 创建一个接收自身作为回调参数的事件。</li>\n</ol>\n</p>\n</div>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#define</span><span style=\"color: #569CD6\"> evtimer_new(</span><span style=\"color: #9CDCFE\">base</span><span style=\"color: #569CD6\">, </span><span style=\"color: #9CDCFE\">callback</span><span style=\"color: #569CD6\">, </span><span style=\"color: #9CDCFE\">arg</span><span style=\"color: #569CD6\">) </span><span style=\"color: #D7BA7D\">\\</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">    </span><span style=\"color: #DCDCAA\">event_new</span><span style=\"color: #569CD6\">((base), </span><span style=\"color: #D4D4D4\">-</span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #569CD6\">, </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #569CD6\">, (callback), (arg))</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#define</span><span style=\"color: #569CD6\"> evtimer_add(</span><span style=\"color: #9CDCFE\">ev</span><span style=\"color: #569CD6\">, </span><span style=\"color: #9CDCFE\">tv</span><span style=\"color: #569CD6\">) </span><span style=\"color: #D7BA7D\">\\</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">    </span><span style=\"color: #DCDCAA\">event_add</span><span style=\"color: #569CD6\">((ev),(tv))</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#define</span><span style=\"color: #569CD6\"> evtimer_del(</span><span style=\"color: #9CDCFE\">ev</span><span style=\"color: #569CD6\">) </span><span style=\"color: #D7BA7D\">\\</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">    </span><span style=\"color: #DCDCAA\">event_del</span><span style=\"color: #569CD6\">(ev)</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#define</span><span style=\"color: #569CD6\"> evtimer_pending(</span><span style=\"color: #9CDCFE\">ev</span><span style=\"color: #569CD6\">, </span><span style=\"color: #9CDCFE\">tv_out</span><span style=\"color: #569CD6\">) </span><span style=\"color: #D7BA7D\">\\</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">    </span><span style=\"color: #DCDCAA\">event_pending</span><span style=\"color: #569CD6\">((ev), EV_TIMEOUT, (tv_out))</span></span></code></pre></div><p>这些宏用来分配和操作纯超时事件。可以提高代码的可读性。</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#define</span><span style=\"color: #569CD6\"> evsignal_new(</span><span style=\"color: #9CDCFE\">base</span><span style=\"color: #569CD6\">, </span><span style=\"color: #9CDCFE\">signum</span><span style=\"color: #569CD6\">, </span><span style=\"color: #9CDCFE\">cb</span><span style=\"color: #569CD6\">, </span><span style=\"color: #9CDCFE\">arg</span><span style=\"color: #569CD6\">) </span><span style=\"color: #D7BA7D\">\\</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">    </span><span style=\"color: #DCDCAA\">event_new</span><span style=\"color: #569CD6\">(base, signum, EV_SIGNAL</span><span style=\"color: #D4D4D4\">|</span><span style=\"color: #569CD6\">EV_PERSIST, cb, arg)</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#define</span><span style=\"color: #569CD6\"> evsignal_add(</span><span style=\"color: #9CDCFE\">ev</span><span style=\"color: #569CD6\">, </span><span style=\"color: #9CDCFE\">tv</span><span style=\"color: #569CD6\">) </span><span style=\"color: #D7BA7D\">\\</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">    </span><span style=\"color: #DCDCAA\">event_add</span><span style=\"color: #569CD6\">((ev),(tv))</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#define</span><span style=\"color: #569CD6\"> evsignal_del(</span><span style=\"color: #9CDCFE\">ev</span><span style=\"color: #569CD6\">) </span><span style=\"color: #D7BA7D\">\\</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">    </span><span style=\"color: #DCDCAA\">event_del</span><span style=\"color: #569CD6\">(ev)</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#define</span><span style=\"color: #569CD6\"> evsignal_pending(</span><span style=\"color: #9CDCFE\">ev</span><span style=\"color: #569CD6\">, </span><span style=\"color: #9CDCFE\">what</span><span style=\"color: #569CD6\">, </span><span style=\"color: #9CDCFE\">tv_out</span><span style=\"color: #569CD6\">) </span><span style=\"color: #D7BA7D\">\\</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">    </span><span style=\"color: #DCDCAA\">event_pending</span><span style=\"color: #569CD6\">((ev), (what), (tv_out))</span></span></code></pre></div><p>这个宏用来分配一个新的信号事件。<code>signum</code> 是信号的编号。使用它可以提高代码的可读性（由此可窥探，当<code>event_new()</code>传入<code>EV_SIGNAL</code>时<code>fd</code>参数代表信号编号）。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p>每个进程一次只能有一个 event_base 监听信号。如果您将信号事件添加到两个 event_base 中（即使信号不同！），也只有一个 event_base 会收到信号。</p>\n\n</div>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p><code>event_new()</code>将event分配在堆上，该event的内存由libevent管理。如果要将event内存分配在栈上，或者手动管理event的内存，可以使用<code>event_assign()</code>函数。（可能会破坏与其他版本 Libevent 的二进制兼容性，因为其他版本的事件结构体大小可能不同）</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_assign</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event *</span><span style=\"color: #9CDCFE\">event</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_base *</span><span style=\"color: #9CDCFE\">base</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">evutil_socket_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">fd</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">short</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">what</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> (*callback)(</span><span style=\"color: #4EC9B0\">evutil_socket_t</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">short</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *), </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">arg</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>event_assign()</code> 的所有参数都与 event_new() 相同，但 event 参数除外，它必须指向一个未初始化的事件。成功返回 0，内部错误或参数错误返回 -1。</p>\n<p>永远不要在已在事件循环中待处理的事件上调用 <code>event_assign()</code>，请先对其调用 <code>event_del()</code></p>\n</p>\n</div>\n<h2 id=\"event-add\"><a href=\"#event-add\" class=\"headerlink\" title=\"event_add\"></a>event_add</h2><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_add</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event *</span><span style=\"color: #9CDCFE\">ev</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> timeval *</span><span style=\"color: #9CDCFE\">tv</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>event_add()</code> 函数将事件添加到其配置的 base 的监听事件队列中。<code>tv</code> 是以秒和微秒为单位的超时时间，如果 <code>tv</code> 不为 <code>NULL</code>，则事件将在 <code>tv</code> 指定的时间后变为活动状态，如果 <code>tv</code> 为 <code>NULL</code>，则添加事件时不设置超时。</p>\n<p>对已经添加到事件监听队列中的事件再次调用 <code>event_add()</code>，将会重新设置超时时间（超时为NULL时，该函数不会有任何作用，也就是说<strong>并不会设置为不超时</strong>）。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>要删除超时，需要调用<code>event_remove_timer()</code>（见下文）</p>\n\n</div>\n<h2 id=\"event-del\"><a href=\"#event-del\" class=\"headerlink\" title=\"event_del\"></a>event_del</h2><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_del</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event *</span><span style=\"color: #9CDCFE\">ev</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p>将<code>ev</code>指向的事件从其配置的event_base的监听队列中删除（如果不在监听队列中，该函数不会有任何作用）返回值在成功时为 0，失败时为 -1。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><p>如果在一个事件变为活动状态后但在其回调有机会执行之前将其删除，则不会执行该回调。</p>\n</p>\n</div>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_remove_timer</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event *</span><span style=\"color: #9CDCFE\">ev</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p>删除事件超时属性的正确做法，如果没有超时属性则函数不起作用。（如果事件只有超时但没有 IO 或信号组件，即<code>fd</code>为-1，此时效果与 <code>event_del()</code>相同）</p>\n<h2 id=\"event-priority\"><a href=\"#event-priority\" class=\"headerlink\" title=\"event_priority\"></a>event_priority</h2><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_priority_set</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event *</span><span style=\"color: #9CDCFE\">event</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">priority</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p>如果要设置事件的优先级（默认优先级为<code>n_priorities / 2</code>）请在初始化事件之后，调用<code>event_add()</code>之前。该函数在成功时返回 0，失败时返回 -1。</p>\n<p>当多个具有不同优先级的事件变为活动状态时，Libevent会运行高优先级事件，然后再次检查事件。只有当没有高优先级事件处于活动状态时，才会运行低优先级事件。（详细逻辑见下文event_loop的描述）</p>\n<h2 id=\"event-get\"><a href=\"#event-get\" class=\"headerlink\" title=\"event_get_\"></a>event_get_</h2><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_pending</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event *</span><span style=\"color: #9CDCFE\">ev</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">short</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">what</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> timeval *</span><span style=\"color: #9CDCFE\">tv_out</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#define</span><span style=\"color: #569CD6\"> event_get_signal(</span><span style=\"color: #9CDCFE\">ev</span><span style=\"color: #569CD6\">)</span><span style=\"color: #6A9955\"> /* ... */</span></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">evutil_socket_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_get_fd</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event *</span><span style=\"color: #9CDCFE\">ev</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_base *</span><span style=\"color: #DCDCAA\">event_get_base</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event *</span><span style=\"color: #9CDCFE\">ev</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">short</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_get_events</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event *</span><span style=\"color: #9CDCFE\">ev</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">event_callback_fn </span><span style=\"color: #DCDCAA\">event_get_callback</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event *</span><span style=\"color: #9CDCFE\">ev</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #DCDCAA\">event_get_callback_arg</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event *</span><span style=\"color: #9CDCFE\">ev</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_get_priority</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event *</span><span style=\"color: #9CDCFE\">ev</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_get_assignment</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event *</span><span style=\"color: #9CDCFE\">event</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_base **</span><span style=\"color: #9CDCFE\">base_out</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #4EC9B0\">evutil_socket_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">fd_out</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #569CD6\">short</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">events_out</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        event_callback_fn *</span><span style=\"color: #9CDCFE\">callback_out</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> **</span><span style=\"color: #9CDCFE\">arg_out</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>event_pending()</code> 函数用于检查事件是否处于待处理状态，用返回值表示。<code>what</code> 参数是要检查的事件类型，可以是 <code>EV_TIMEOUT</code>、<code>EV_READ</code>、<code>EV_WRITE</code>、<code>EV_SIGNAL</code> 中的一个或多个。如果提供了 <code>tv_out</code> 参数，并且在 <code>what</code> 中设置了 <code>EV_TIMEOUT</code>，并且事件当前处于基于时间的待处理或活动状态，则<code>tv_out</code>用于存储设置的超时时间。</p>\n<h2 id=\"event-base-once\"><a href=\"#event-base-once\" class=\"headerlink\" title=\"event_base_once\"></a>event_base_once</h2><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_base_once</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_base *, </span><span style=\"color: #4EC9B0\">evutil_socket_t</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">short</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> (*)(</span><span style=\"color: #4EC9B0\">evutil_socket_t</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">short</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *), </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *, </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> timeval *);</span></span></code></pre></div><p>如果事件不需要被添加多次、在添加后不需要被删除，并且不需要是持久的，则可以使用 <code>event_base_once()</code> 函数。</p>\n<p>此函数的接口与 <code>event_new()</code> 相同，除了它不支持 <code>EV_SIGNAL</code> 或 <code>EV_PERSIST</code>。 调度的事件将以默认优先级插入并运行。当回调最终完成时，Libevent 会自动释放内部事件结构。 成功返回 0，失败返回 -1。</p>\n<h1 id=\"event-loop\"><a href=\"#event-loop\" class=\"headerlink\" title=\"event_loop\"></a>event_loop</h1><h2 id=\"event-base-loop\"><a href=\"#event-base-loop\" class=\"headerlink\" title=\"event_base_loop\"></a>event_base_loop</h2><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #6A9955\">//循环将等待，直到某些事件变为活动状态，然后运行活动事件，直到没有更多事件要运行，然后返回。</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#define</span><span style=\"color: #569CD6\"> EVLOOP_ONCE             </span><span style=\"color: #B5CEA8\">0x01</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">//循环不会等待事件触发，只检查是否有任何事件准备好立即触发，如果是，则运行它们的回调函数</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#define</span><span style=\"color: #569CD6\"> EVLOOP_NONBLOCK         </span><span style=\"color: #B5CEA8\">0x02</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">//循环在没有待处理或活动事件时不会立即退出</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#define</span><span style=\"color: #569CD6\"> EVLOOP_NO_EXIT_ON_EMPTY </span><span style=\"color: #B5CEA8\">0x04</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_base_loop</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_base *</span><span style=\"color: #9CDCFE\">base</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">flags</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_base_dispatch</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_base *</span><span style=\"color: #9CDCFE\">base</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p>创建完event_base并向其中添加了event后，就可以让event_base开始监听事件的到来并在到来的时候进行处理。</p>\n<p><code>event_base_loop()</code> 函数会运行一个 event_base 直到其中没有要处理的事件为止。</p>\n<p><code>event_base_loop()</code> 正常退出返回 0；如果由于后端中的一些未处理错误而退出，返回 -1；如果由于没有更多待处理或活动事件而退出，则返回 1。</p>\n<p>下面是 <code>event_base_loop()</code> 的大致逻辑：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">while</span><span style=\"color: #D4D4D4\"> (有事件在监视队列 or EVLOOP_NO_EXIT_ON_EMPTY) {</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (EVLOOP_NONBLOCK or 有事件已经处于活动状态)</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        如果在监视队列中的事件已触发，则将其标记为活动状态。</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        阻塞等待到至少有一个事件触发，并将其标记为活动状态。</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\"> (p = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">; p &lt; n_priorities; ++p) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">       </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (优先级为 p 的事件处于活动状态) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">          运行所有优先级为 p 的活动事件。</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">          </span><span style=\"color: #C586C0\">break</span><span style=\"color: #D4D4D4\">;</span><span style=\"color: #6A9955\"> /* 不要运行任何优先级较低的事件 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">       }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (EVLOOP_ONCE or EVLOOP_NONBLOCK)</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">       </span><span style=\"color: #C586C0\">break</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p><code>event_base_dispatch()</code> 函数是<code>flags</code>为0的 <code>event_base_loop()</code> 。</p>\n<h2 id=\"event-base-loopexit\"><a href=\"#event-base-loopexit\" class=\"headerlink\" title=\"event_base_loopexit\"></a>event_base_loopexit</h2><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_base_loopexit</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_base *</span><span style=\"color: #9CDCFE\">base</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                        </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> timeval *</span><span style=\"color: #9CDCFE\">tv</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_base_loopbreak</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_base *</span><span style=\"color: #9CDCFE\">base</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>event_base_loopexit()</code> 函数通知 <code>event_base</code> 在经过给定时间后停止循环。如果 <code>tv</code> 参数为 <code>NULL</code>，则 <code>event_base</code> 会立即停止循环。如果 <code>event_base</code> 当前正在为任何活动事件运行回调函数，它将继续运行它们，直到它们全部运行完毕才会退出。</p>\n<p><code>event_base_loopbreak()</code> 函数通知 <code>event_base</code> 立即退出其循环。它与 <code>event_base_loopexit(base, NULL)</code> 的区别在于，如果 <code>event_base</code> 当前正在为任何活动事件运行回调函数，它将在完成当前正在处理的回调函数后立即退出。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>即使事件循环当前没有运行，<code>event_base_loopexit()</code> 仍然有效。它会影响下一次事件循环运行的行为，确保事件循环启动后会按照设定的时间退出。</p>\n<p>如果事件循环当前没有运行，<code>event_base_loopbreak()</code> 不会有任何效果。它只影响当前正在运行的事件循环。</p>\n\n</div>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_base_got_exit</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_base *</span><span style=\"color: #9CDCFE\">base</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_base_got_break</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_base *</span><span style=\"color: #9CDCFE\">base</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p>这两个函数用于查看 <code>event_base</code> 是被上面哪个函数通知退出的。如果没有退出或不是对应的函数通知退出的，返回 0；否则返回 1。</p>\n<h2 id=\"event-base-loopcontinue\"><a href=\"#event-base-loopcontinue\" class=\"headerlink\" title=\"event_base_loopcontinue\"></a>event_base_loopcontinue</h2><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_base_loopcontinue</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_base *);</span></span></code></pre></div><p>通常情况下，Libevent 会扫描事件，然后以最高优先级运行所有活动事件，然后再扫描事件，依此类推。</p>\n<p>如果需要在当前回调运行后立即停止 Libevent，并告诉它再次扫描，可以使用 <code>event_base_loopcontinue()</code> 函数来实现。</p>\n<p>如果当前没有运行事件回调，则调用 <code>event_base_loopcontinue()</code> 没有效果。</p>\n<h2 id=\"event-base-foreach-event\"><a href=\"#event-base-foreach-event\" class=\"headerlink\" title=\"event_base_foreach_event\"></a>event_base_foreach_event</h2><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">typedef</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> (*event_base_foreach_event_cb)(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_base *,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event *, </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">event_base_foreach_event</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_base *</span><span style=\"color: #9CDCFE\">base</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                             event_base_foreach_event_cb </span><span style=\"color: #9CDCFE\">fn</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                             </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">arg</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p>遍历每个与 event_base 关联的事件，将其作为回调函数的参数传入并执行回调函数，顺序不定。<code>event_base_foreach_event()</code> 的第三个参数将作为第三个参数传递给每次回调函数调用。</p>\n<p>回调函数必须返回 0 以继续迭代，或者返回其他整数以停止迭代。回调函数最终返回的任何值都将由 <code>event_base_foreach_function()</code> 返回。</p>\n<div class=\"custom-quote danger\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M19.76 5.23C15.84 5.23 12 2 12 2C12 2 8.15996 5.23 4.23996 5.23C4.23996 5.23 1.86996 16.99 12 22C22.13 16.99 19.76 5.23 19.76 5.23Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 16H12\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">特别注意</p>\n<p><p>传入的回调函数不得修改它接收的任何事件，也不得向事件库添加或从中删除任何事件，或者以其他方式修改与事件库关联的任何事件，否则可能会发生未定义的行为，包括崩溃和堆栈溢出。</p>\n<p>event_base 锁将在调用 <code>event_base_foreach_event()</code> 期间保持——这将阻止其他线程对 event_base 执行任何有用的操作，因此请确保您的回调函数不会花费很长时间。</p>\n</p>\n</div>\n<h1 id=\"bufferevent\"><a href=\"#bufferevent\" class=\"headerlink\" title=\"bufferevent\"></a>bufferevent</h1><p>除了响应事件之外，还希望执行一定数量的数据读写。为了避免手动管理缓冲区的复杂性，libevent 提供了 <code>bufferevent</code> 接口。</p>\n<p>与event不同，event在底层传输层准备好读取或写入时提供回调，而 bufferevent 在读取或写入足够数据时调用用户提供的回调。</p>\n<h2 id=\"bufferevent-socket-new\"><a href=\"#bufferevent-socket-new\" class=\"headerlink\" title=\"bufferevent_socket_new\"></a>bufferevent_socket_new</h2><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> bufferevent *</span><span style=\"color: #DCDCAA\">bufferevent_socket_new</span><span style=\"color: #D4D4D4\">(</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_base *</span><span style=\"color: #9CDCFE\">base</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">evutil_socket_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">fd</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">enum</span><span style=\"color: #D4D4D4\"> bufferevent_options </span><span style=\"color: #9CDCFE\">options</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>bufferevent_socket_new()</code>创建基于套接字的 bufferevent，<code>base</code> 是一个 event_base，<code>options</code> 是 bufferevent 选项的位掩码（<code>BEV_OPT_CLOSE_ON_FREE</code> 等）。<code>fd</code> 参数是套接字的可选文件描述符。<em>如果要稍后设置文件描述符，可以将 fd 设置为 -1。</em></p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p>确保提供给 bufferevent_socket_new() 的套接字处于非阻塞模式。</p>\n\n</div>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">bufferevent_free</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> bufferevent *</span><span style=\"color: #9CDCFE\">bev</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p>此函数释放一个 bufferevent。Bufferevent 在内部是引用计数的，因此如果您在释放 bufferevent 时它有挂起的延迟回调，则在回调完成之前不会删除它。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><p>但是，<code>bufferevent_free()</code> 函数会尝试尽快释放 bufferevent。所以如果 bufferevent 上有待写入的数据，则在释放 bufferevent 之前可能不会刷新这些数据。</p>\n<p>如果设置了 <code>BEV_OPT_CLOSE_ON_FREE</code> 标志，并且此 bufferevent 的套接字或底层 bufferevent 与其关联为其传输层，则在释放 bufferevent 时将关闭该传输层。</p>\n</p>\n</div>\n<h2 id=\"bufferevent-socket-connect\"><a href=\"#bufferevent-socket-connect\" class=\"headerlink\" title=\"bufferevent_socket_connect\"></a>bufferevent_socket_connect</h2><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">bufferevent_socket_connect</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> bufferevent *</span><span style=\"color: #9CDCFE\">bev</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> sockaddr *</span><span style=\"color: #9CDCFE\">address</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">addrlen</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>address</code> 和 <code>addrlen</code> 参数与标准调用 <code>connect()</code> 相同。<strong>如果 bufferevent 还没有设置套接字，则调用此函数会为其分配一个新的流套接字，并使其非阻塞。</strong></p>\n<p>此函数在连接成功启动时返回 0，如果发生错误则返回 -1。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>在连接完成之前将数据添加到输出缓冲区是可以的。</p>\n\n</div>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">bufferevent_socket_connect_hostname</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> bufferevent *</span><span style=\"color: #9CDCFE\">bev</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> evdns_base *</span><span style=\"color: #9CDCFE\">dns_base</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">family</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">char</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">hostname</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">port</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">bufferevent_socket_get_dns_error</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> bufferevent *</span><span style=\"color: #9CDCFE\">bev</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p>便捷接口解析主机名和连接到主机名合并到一个操作中。</p>\n<p>如果发生错误，则可能是 DNS 主机名查找错误。通过调用 <code>bufferevent_socket_get_dns_error()</code> 来找出最近的错误是什么。如果返回的错误代码为 0，则表示未检测到 DNS 错误。</p>\n<h2 id=\"bufferevent-setcb\"><a href=\"#bufferevent-setcb\" class=\"headerlink\" title=\"bufferevent_setcb\"></a>bufferevent_setcb</h2><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">typedef</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> (*bufferevent_data_cb)(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> bufferevent *bev, </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *ctx);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">typedef</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> (*bufferevent_event_cb)(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> bufferevent *bev,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">short</span><span style=\"color: #D4D4D4\"> events, </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *ctx);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">bufferevent_setcb</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> bufferevent *</span><span style=\"color: #9CDCFE\">bufev</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    bufferevent_data_cb </span><span style=\"color: #9CDCFE\">readcb</span><span style=\"color: #D4D4D4\">, bufferevent_data_cb </span><span style=\"color: #9CDCFE\">writecb</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    bufferevent_event_cb </span><span style=\"color: #9CDCFE\">eventcb</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">cbarg</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">bufferevent_getcb</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> bufferevent *</span><span style=\"color: #9CDCFE\">bufev</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    bufferevent_data_cb *</span><span style=\"color: #9CDCFE\">readcb_ptr</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    bufferevent_data_cb *</span><span style=\"color: #9CDCFE\">writecb_ptr</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    bufferevent_event_cb *</span><span style=\"color: #9CDCFE\">eventcb_ptr</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> **</span><span style=\"color: #9CDCFE\">cbarg_ptr</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>bufferevent_setcb()</code> 函数更改 bufferevent 的一个或多个回调。当读取足够的数据、写入足够的数据或发生事件时，将分别调用 <code>readcb</code>、<code>writecb</code> 和 <code>eventcb</code> 函数。每个函数的第一个参数是已发生事件的 bufferevent。最后一个参数是用户在 bufferevent_callcb() 的 <code>cbarg</code> 参数中提供的值：您可以使用它将数据传递给回调。event 回调的 <code>events</code> 参数是事件标志的位掩码。</p>\n<p>传入<code>NULL</code>指针将禁用相应的回调。所有回调函数共享一个 <code>cbarg</code> 值。</p>\n<h2 id=\"bufferevent-enable\"><a href=\"#bufferevent-enable\" class=\"headerlink\" title=\"bufferevent_enable\"></a>bufferevent_enable</h2><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">bufferevent_enable</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> bufferevent *</span><span style=\"color: #9CDCFE\">bufev</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">short</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">events</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">bufferevent_disable</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> bufferevent *</span><span style=\"color: #9CDCFE\">bufev</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">short</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">events</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">short</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">bufferevent_get_enabled</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> bufferevent *</span><span style=\"color: #9CDCFE\">bufev</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p>上述函数在 bufferevent 上启用或禁用事件 <code>EV_READ</code>、<code>EV_WRITE</code> 或 <code>EV_READ|EV_WRITE</code>。未启用读取或写入时，bufferevent 将不会尝试读取或写入数据。</p>\n<p>当输出缓冲区为空时，无需禁用写入：bufferevent 会自动停止写入，并在有数据要写入时再次启动。</p>\n<p>同样，当输入缓冲区达到其高水位时，无需禁用读取：bufferevent 会自动停止读取，并在有空间读取时再次启动。</p>\n<p>默认情况下，新创建的 bufferevent 启用了写入，但未启用读取。</p>\n<p>调用 bufferevent_get_enabled() 来查看当前在 bufferevent 上启用了哪些事件。</p>\n<h2 id=\"bufferevent-setwatermark\"><a href=\"#bufferevent-setwatermark\" class=\"headerlink\" title=\"bufferevent_setwatermark\"></a>bufferevent_setwatermark</h2><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">bufferevent_setwatermark</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> bufferevent *</span><span style=\"color: #9CDCFE\">bufev</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">short</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">events</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">lowmark</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">highmark</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>bufferevent_setwatermark()</code> 函数调整单个 bufferevent 的读取水位、写入水位或两者。（如果在 events 字段中设置了 EV_READ，则调整读取水位。如果在 events 字段中设置了 EV_WRITE，则调整写入水位。）</p>\n<p>高水位 0 等效于“无限制”。</p>\n<h2 id=\"bufferevent-I-O\"><a href=\"#bufferevent-I-O\" class=\"headerlink\" title=\"bufferevent I/O\"></a>bufferevent I/O</h2><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">bufferevent_write</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> bufferevent *</span><span style=\"color: #9CDCFE\">bufev</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">data</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">size</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">bufferevent_write_buffer</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> bufferevent *</span><span style=\"color: #9CDCFE\">bufev</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> evbuffer *</span><span style=\"color: #9CDCFE\">buf</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p>这些函数将数据添加到 bufferevent 的输出缓冲区。调用 <code>bufferevent_write()</code> 会将 <code>data</code> 处的内存中的 <code>size</code> 个字节添加到输出缓冲区的末尾。调用 <code>bufferevent_write_buffer()</code> 会删除 <code>buf</code> 的全部内容，并将它们放在输出缓冲区的末尾。两者在成功时都返回 0，如果发生错误则返回 -1。</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">bufferevent_read</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> bufferevent *</span><span style=\"color: #9CDCFE\">bufev</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">data</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">size</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">bufferevent_read_buffer</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> bufferevent *</span><span style=\"color: #9CDCFE\">bufev</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> evbuffer *</span><span style=\"color: #9CDCFE\">buf</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p>这些函数从 bufferevent 的输入缓冲区中删除数据。<code>bufferevent_read()</code> 函数从输入缓冲区中删除最多 <code>size</code> 个字节，并将它们存储到 <code>data</code> 处的内存中。它返回实际删除的字节数。<code>bufferevent_read_buffer()</code> 函数清空输入缓冲区的全部内容，并将它们放入 <code>buf</code> 中；它在成功时返回 0，在失败时返回 -1。</p>\n<h1 id=\"evconnlistener\"><a href=\"#evconnlistener\" class=\"headerlink\" title=\"evconnlistener\"></a>evconnlistener</h1><p>evconnlistener 提供了一种监听和接受传入 TCP 连接的方法。</p>\n<h2 id=\"evconnlistener-new\"><a href=\"#evconnlistener-new\" class=\"headerlink\" title=\"evconnlistener_new\"></a>evconnlistener_new</h2><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">typedef</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> (*evconnlistener_cb)(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> evconnlistener *listener,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">evutil_socket_t</span><span style=\"color: #D4D4D4\"> sock, </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> sockaddr *addr, </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> len, </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *ptr);</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">//sock 参数是新套接字本身。addr 和 len 参数分别是接收连接的地址和该地址的长度。ptr 参数是传递给 evconnlistener_new() 的用户提供的指针。</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> evconnlistener *</span><span style=\"color: #DCDCAA\">evconnlistener_new</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_base *</span><span style=\"color: #9CDCFE\">base</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    evconnlistener_cb </span><span style=\"color: #9CDCFE\">cb</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">ptr</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">unsigned</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">flags</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">backlog</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">evutil_socket_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">fd</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> evconnlistener *</span><span style=\"color: #DCDCAA\">evconnlistener_new_bind</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> event_base *</span><span style=\"color: #9CDCFE\">base</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    evconnlistener_cb </span><span style=\"color: #9CDCFE\">cb</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">ptr</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">unsigned</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">flags</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">backlog</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> sockaddr *</span><span style=\"color: #9CDCFE\">sa</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">socklen</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">evconnlistener_free</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> evconnlistener *</span><span style=\"color: #9CDCFE\">lev</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p>这两个 <code>evconnlistener_new*()</code> 函数都分配并返回一个新的连接监听器对象。连接监听器使用 event_base 来注意给定监听器套接字上何时存在新的 TCP 连接。当新连接到达时，它会调用您提供的回调函数。</p>\n<p>在这两个函数中，<code>base</code> 参数是一个 event_base，监听器应该使用它来监听连接。<code>cb</code> 函数是在收到新连接时调用的回调；如果 <code>cb</code> 为 <code>NULL</code>，则监听器将被视为禁用，直到设置回调。<code>ptr</code> 指针将被传递给回调。<code>flags</code> 参数控制监听器的行为。</p>\n<table>\n<thead>\n<tr>\n<th>Flag</th>\n<th>Description</th>\n<th>Availability</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>LEV_OPT_LEAVE_SOCKETS_BLOCKING</td>\n<td>默认情况下，当连接侦听器接受新的传入套接字时，它会将其设置为非阻塞模式，以便您可以将其与 Libevent 的其余部分一起使用。如果您不希望这种行为，请设置此标志。</td>\n<td>所有版本</td>\n</tr>\n<tr>\n<td>LEV_OPT_CLOSE_ON_FREE</td>\n<td>如果设置了此选项，则连接侦听器会在您释放它时关闭其底层套接字。</td>\n<td>所有版本</td>\n</tr>\n<tr>\n<td>LEV_OPT_CLOSE_ON_EXEC</td>\n<td>如果设置了此选项，则连接侦听器会在底层监听器套接字上设置 close-on-exec 标志。有关更多信息，请参阅您的平台文档以获取 fcntl 和 FD_CLOEXEC。</td>\n<td>所有版本</td>\n</tr>\n<tr>\n<td>LEV_OPT_REUSEABLE</td>\n<td>默认情况下，在某些平台上，一旦监听器套接字关闭，在一段时间过去之前，其他任何套接字都无法绑定到同一个端口。设置此选项会使 Libevent 将套接字标记为可重用，因此一旦它关闭，就可以打开另一个套接字来监听同一个端口。</td>\n<td>所有版本</td>\n</tr>\n<tr>\n<td>LEV_OPT_THREADSAFE</td>\n<td>为侦听器分配锁，以便可以从多个线程安全地使用它。</td>\n<td>Libevent 2.0.8-rc 起</td>\n</tr>\n<tr>\n<td>LEV_OPT_DISABLED</td>\n<td>将侦听器初始化为禁用状态，而不是启用状态。您可以使用 evconnlistener_enable() 手动启用它。</td>\n<td>Libevent 2.1.1-alpha 起</td>\n</tr>\n<tr>\n<td>LEV_OPT_DEFERRED_ACCEPT</td>\n<td>如果可能，告诉内核不要宣布套接字已被接受，直到收到一些数据并且它们准备好读取。如果您的协议不是从客户端传输数据开始的，请不要使用此选项，因为在这种情况下，此选项有时会导致内核永远不会告诉您连接。并非所有操作系统都支持此选项：在不支持的操作系统上，此选项无效。</td>\n<td>Libevent 2.1.1-alpha 起</td>\n</tr>\n</tbody></table>\n<p><code>backlog</code> 参数相当于<code>listen()</code>函数的第二个参数。</p>\n<p><code>evconnlistener_new()</code> 函数假定您已经将套接字绑定到要监听的端口，并且您将套接字作为 <code>fd</code> 传入。如果您希望 Libevent 自行分配和绑定到套接字，请调用 <code>evconnlistener_new_bind()</code>，并传入要绑定到的 <code>sockaddr</code> 及其长度。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><p>使用 <code>evconnlistener_new()</code> 时，请确保监听套接字处于非阻塞模式。</p>\n</p>\n</div>\n<p>要释放连接监听器，请将其传递给 <code>evconnlistener_free()</code>。</p>\n<h2 id=\"evconnlistener-enable\"><a href=\"#evconnlistener-enable\" class=\"headerlink\" title=\"evconnlistener_enable\"></a>evconnlistener_enable</h2><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">evconnlistener_disable</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> evconnlistener *</span><span style=\"color: #9CDCFE\">lev</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">evconnlistener_enable</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> evconnlistener *</span><span style=\"color: #9CDCFE\">lev</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p>这些函数临时禁用或重新启用对新连接的侦听。</p>\n<h2 id=\"evconnlistener-set-cb\"><a href=\"#evconnlistener-set-cb\" class=\"headerlink\" title=\"evconnlistener_set_cb\"></a>evconnlistener_set_cb</h2><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">evconnlistener_set_cb</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> evconnlistener *</span><span style=\"color: #9CDCFE\">lev</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    evconnlistener_cb </span><span style=\"color: #9CDCFE\">cb</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">arg</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p>此函数调整现有 evconnlistener 的回调和回调参数。</p>\n","feature":true,"text":"libevent的作用对于简单的socket编程，采用阻塞的方式是最基础的。例如，当调用recv函数时，如果没有数据到来就会一直阻塞。这种方式的问题在于，如果只...","permalink":"/post/Linux网络编程（libevent）","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"17 mins."},"categories":[{"name":"Linux","slug":"Linux","count":8,"path":"api/categories/Linux.json"}],"tags":[{"name":"Linux","slug":"Linux","count":8,"path":"api/tags/Linux.json"},{"name":"C++","slug":"C","count":12,"path":"api/tags/C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#libevent%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">libevent的作用</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#event-base\"><span class=\"toc-text\">event_base</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#event-base-new\"><span class=\"toc-text\">event_base_new</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#event-config\"><span class=\"toc-text\">event_config</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#event-base-get\"><span class=\"toc-text\">event_base_get_</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#event-base-priority\"><span class=\"toc-text\">event_base_priority</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#event-reinit\"><span class=\"toc-text\">event_reinit</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#event\"><span class=\"toc-text\">event</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#event-new\"><span class=\"toc-text\">event_new</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#event-add\"><span class=\"toc-text\">event_add</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#event-del\"><span class=\"toc-text\">event_del</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#event-priority\"><span class=\"toc-text\">event_priority</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#event-get\"><span class=\"toc-text\">event_get_</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#event-base-once\"><span class=\"toc-text\">event_base_once</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#event-loop\"><span class=\"toc-text\">event_loop</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#event-base-loop\"><span class=\"toc-text\">event_base_loop</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#event-base-loopexit\"><span class=\"toc-text\">event_base_loopexit</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#event-base-loopcontinue\"><span class=\"toc-text\">event_base_loopcontinue</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#event-base-foreach-event\"><span class=\"toc-text\">event_base_foreach_event</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#bufferevent\"><span class=\"toc-text\">bufferevent</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bufferevent-socket-new\"><span class=\"toc-text\">bufferevent_socket_new</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bufferevent-socket-connect\"><span class=\"toc-text\">bufferevent_socket_connect</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bufferevent-setcb\"><span class=\"toc-text\">bufferevent_setcb</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bufferevent-enable\"><span class=\"toc-text\">bufferevent_enable</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bufferevent-setwatermark\"><span class=\"toc-text\">bufferevent_setwatermark</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bufferevent-I-O\"><span class=\"toc-text\">bufferevent I&#x2F;O</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#evconnlistener\"><span class=\"toc-text\">evconnlistener</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#evconnlistener-new\"><span class=\"toc-text\">evconnlistener_new</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#evconnlistener-enable\"><span class=\"toc-text\">evconnlistener_enable</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#evconnlistener-set-cb\"><span class=\"toc-text\">evconnlistener_set_cb</span></a></li></ol></li></ol>","author":{"name":"Ac-Accelerator","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一位计算机技术爱好者，大学在读，目前正在学习C++、Python、Java和计算机系统以及计算机视觉深度学习等相关知识，欢迎交流","socials":{"github":"https://github.com/Ac-Accelerator","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_31702515?spm=1000.2115.3001.5343","juejin":"","customs":{"qq":{"icon":"/svg/QQ.svg","link":"http://tool.gljlw.com/qq/?qq=2583832841"}}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"Linux网络编程（UDP）","uid":"49a0a815b68a3a838049f5994375a9d3","slug":"Linux网络编程（UDP）","date":"2024-07-17T12:28:55.000Z","updated":"2024-07-18T07:48:03.658Z","comments":true,"path":"api/articles/Linux网络编程（UDP）.json","keywords":"C++,Pyhton,Java,算法","cover":"img/linux.jpeg","text":"创建UDP套接字cint sockfd = socket(AF_INET, SOCK_DGRAM, 0);使用socket函数创建一个UDP套接字，注意第二个参...","permalink":"/post/Linux网络编程（UDP）","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"Linux","slug":"Linux","count":8,"path":"api/categories/Linux.json"}],"tags":[{"name":"Linux","slug":"Linux","count":8,"path":"api/tags/Linux.json"},{"name":"C++","slug":"C","count":12,"path":"api/tags/C.json"}],"author":{"name":"Ac-Accelerator","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一位计算机技术爱好者，大学在读，目前正在学习C++、Python、Java和计算机系统以及计算机视觉深度学习等相关知识，欢迎交流","socials":{"github":"https://github.com/Ac-Accelerator","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_31702515?spm=1000.2115.3001.5343","juejin":"","customs":{"qq":{"icon":"/svg/QQ.svg","link":"http://tool.gljlw.com/qq/?qq=2583832841"}}}},"feature":true}}