{"title":"Linux系统编程（信号与多线程）","uid":"ffc7901ba136221db8bdbec1296c9feb","slug":"Linux系统编程（信号与多线程）","date":"2024-07-05T07:09:36.000Z","updated":"2024-07-08T05:05:57.448Z","comments":true,"path":"api/articles/Linux系统编程（信号与多线程）.json","keywords":"C++,Pyhton,Java,算法","cover":"img/linux.jpeg","content":"<h1 id=\"信号\"><a href=\"#信号\" class=\"headerlink\" title=\"信号\"></a>信号</h1><h2 id=\"信号概述\"><a href=\"#信号概述\" class=\"headerlink\" title=\"信号概述\"></a>信号概述</h2><p>在Linux操作系统中，信号（Signal）是一种用于进程间通信的机制，可以用来通知进程某些事件的发生。信号的主要作用是让操作系统或其他进程可以向进程发送某种信息，以便该进程可以采取相应的动作。</p>\n<ol>\n<li><strong>概念</strong>：信号是一种软件中断，通过信号，内核和进程可以通知进程某些事件的发生。例如，当用户按下 <code>Ctrl+C</code> 时，系统会向前台进程发送 <code>SIGINT</code> 信号。</li>\n<li><strong>作用</strong>：<ul>\n<li><strong>通知事件</strong>：信号可以通知进程发生了某些事件，例如非法内存访问（<code>SIGSEGV</code>）、定时器到期（<code>SIGALRM</code>）等。</li>\n<li><strong>控制进程</strong>：信号可以用来控制进程的行为，例如终止进程（<code>SIGKILL</code>）、暂停进程（<code>SIGSTOP</code>）、继续进程（<code>SIGCONT</code>）等。</li>\n<li><strong>进程间通信</strong>：信号可以用作进程间通信的手段，以实现进程之间的协作和同步。</li>\n</ul>\n</li>\n</ol>\n<p>信号可以由多种途径产生，包括：</p>\n<ol>\n<li><strong>用户输入</strong>：例如，用户按下 <code>Ctrl+C</code> 组合键会产生 <code>SIGINT</code> 信号。</li>\n<li><strong>系统调用</strong>：进程可以通过系统调用（如 <code>kill</code>）向自身或其他进程发送信号。</li>\n<li><strong>硬件异常</strong>：例如非法内存访问会产生 <code>SIGSEGV</code> 信号、除以0。</li>\n<li><strong>软件条件</strong>：例如定时器到期会产生 <code>SIGALRM</code> 信号。</li>\n</ol>\n<p>信号的处理过程可以概括为以下几个步骤：</p>\n<ol>\n<li><strong>发送信号</strong>：信号可以由内核、其他进程或进程自身发送。</li>\n<li><strong>捕获信号</strong>：进程可以通过设置信号处理程序（signal handler）来捕获和处理信号。信号处理程序是一段代码，当进程收到某个信号时，系统会自动调用该程序。</li>\n<li><strong>默认动作</strong>：如果进程没有设置信号处理程序，系统会执行该信号的默认动作。不同信号有不同的默认动作，例如终止进程、<strong>忽略信号</strong>等。</li>\n<li><strong>处理信号</strong>：信号处理程序执行完毕后，进程会恢复到原来的状态，继续执行。</li>\n</ol>\n<p>在使用信号之前，先要确定其<strong>编号、名称、对应事件、默认处理动作</strong>。再去使用。</p>\n<p>以下是一个简单的示例代码，展示了如何在C语言中处理信号：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;stdio.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;stdlib.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;signal.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;unistd.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">// 信号处理程序</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">handle_signal</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">signal</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (signal == SIGINT) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"Received SIGINT (Ctrl+C). Exiting gracefully...</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">exit</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">() {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #6A9955\">// 设置信号处理程序</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">signal</span><span style=\"color: #D4D4D4\">(SIGINT, handle_signal);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #6A9955\">// 无限循环，等待信号</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">while</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"Running... Press Ctrl+C to exit.</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">sleep</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>在这个例子中，程序设置了一个信号处理程序 <code>handle_signal</code> 来捕获 <code>SIGINT</code> 信号。当用户按下 <code>Ctrl+C</code> 时，程序会捕获该信号并执行相应的处理程序，输出一条消息并退出程序。</p>\n<h2 id=\"信号屏蔽字（Signal-Mask）\"><a href=\"#信号屏蔽字（Signal-Mask）\" class=\"headerlink\" title=\"信号屏蔽字（Signal Mask）\"></a>信号屏蔽字（Signal Mask）</h2><p>信号屏蔽字是一组信号，它们被进程当前屏蔽或阻塞。被屏蔽的信号在它们到达时不会立即被处理，而是保持待处理状态（进入未决信号集），直到它们被从信号屏蔽字中移除。</p>\n<p><strong>作用：</strong></p>\n<ol>\n<li><strong>阻止信号的处理</strong>：当一个信号被屏蔽时，即使它被发送到进程，进程也不会立即处理它。这允许进程在关键代码段中阻止信号的干扰。</li>\n<li><strong>管理信号处理</strong>：通过屏蔽和解除屏蔽信号，进程可以更好地控制何时处理信号。</li>\n</ol>\n<h2 id=\"未决信号集（Pending-Signals）\"><a href=\"#未决信号集（Pending-Signals）\" class=\"headerlink\" title=\"未决信号集（Pending Signals）\"></a>未决信号集（Pending Signals）</h2><p>未决信号集是进程已经接收到但尚未处理的信号的集合。即使这些信号被送达进程，但如果它们在信号屏蔽字中被屏蔽，它们会保持未决状态，直到信号屏蔽字解除。</p>\n<p><strong>功能：</strong></p>\n<ol>\n<li><strong>保持信号待处理状态</strong>：当信号被屏蔽时，它们不会被丢弃，而是进入未决信号集，等待被处理。</li>\n<li><strong>保证信号处理</strong>：未决信号集确保所有发送到进程的信号在适当的时候都会被处理。</li>\n</ol>\n<h2 id=\"Linux内核信号捕捉机制详细解析\"><a href=\"#Linux内核信号捕捉机制详细解析\" class=\"headerlink\" title=\"Linux内核信号捕捉机制详细解析\"></a>Linux内核信号捕捉机制详细解析</h2><p><strong>1. 信号的产生和递送</strong></p>\n<p>信号可以由多种事件产生，内核在生成信号后，会使用 <code>send_signal()</code> 将其添加到目标进程的信号队列中。</p>\n<p><strong>2. 检查信号阻塞状态</strong></p>\n<p>内核会使用<code>isig_deliver()</code>检查目标进程的信号掩码 (signal mask)。递送没有被阻塞的信号。如果目标进程阻塞了信号，内核会将信号添加到进程的未决信号集中，等待信号解除阻塞后再递送。</p>\n<p><strong>3. 选择信号递送时机</strong></p>\n<p>内核在以下情况下使用<code>handle_signal()</code>将信号递送给进程：</p>\n<ul>\n<li><strong>进程从内核态返回用户态时：</strong> 这是最常见的信号递送时机。当进程执行完系统调用、中断处理程序等内核代码，准备返回用户态执行用户代码时，内核会检查进程的信号队列，并将未阻塞的信号递送给进程。</li>\n<li><strong>进程处于可中断睡眠状态时：</strong> 如果进程正在等待某个事件发生（例如等待IO完成），并且该等待是可中断的，则内核可以在此时递送信号，唤醒进程。</li>\n</ul>\n<p><strong>4. 信号处理函数的执行</strong></p>\n<p>当内核决定将信号递送给进程时，<code>setup_sigcontext()</code>会像中断一样保存进程的上下文，然后执行信号处理函数。</p>\n<p><strong>5. 从信号处理函数返回</strong></p>\n<p>当信号处理函数执行完成后，会执行 <code>sys_sigreturn()</code> 系统调用。该系统调用会通知内核信号处理函数已经执行完毕。内核会执行以下操作：</p>\n<ul>\n<li><strong>恢复进程上下文：</strong>  <code>restore_sigcontext()</code>内核从内核栈中恢复进程之前保存的执行状态，包括寄存器的值、程序计数器等。</li>\n<li><strong>清理用户态堆栈：</strong>  内核会清理掉之前为执行信号处理函数创建的栈帧。</li>\n<li><strong>恢复进程执行：</strong>  进程恢复执行被信号中断前的代码。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>是说这两个玩意是不是和中断处理有点像？</p></blockquote>\n<h1 id=\"signal函数\"><a href=\"#signal函数\" class=\"headerlink\" title=\"signal函数\"></a>signal函数</h1><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;signal.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">typedef</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> (*</span><span style=\"color: #4EC9B0\">sighandler_t</span><span style=\"color: #D4D4D4\">)(</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">sighandler_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">signal</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">signum</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #4EC9B0\">sighandler_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">handler</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>signal()</code> 函数将信号 <code>signum</code> 的处理方式设置为 <code>handler</code>，<code>handler</code> 可以是 <code>SIG_IGN</code>、<code>SIG_DFL</code> 或程序员定义的函数（即“信号处理程序”）的地址。</p>\n<p>如果信号 <code>signum</code> 被递送到进程，则会发生以下情况之一：</p>\n<ul>\n<li>如果处理方式设置为 <code>SIG_IGN</code>，则忽略该信号。</li>\n<li>如果处理方式设置为 <code>SIG_DFL</code>，则执行与该信号关联的默认操作（参见 signal(7)）。</li>\n<li>如果处理方式设置为一个函数，则首先将处理方式重置为 <code>SIG_DFL</code>，或者阻塞该信号（参见下文的“可移植性”），然后使用参数 <code>signum</code> 调用 <code>handler</code>。如果调用 <code>handler</code> 导致信号被阻塞，则在从 <code>handler</code> 返回时解除对该信号的阻塞。</li>\n</ul>\n<p><code>SIGKILL</code> 和 <code>SIGSTOP</code> 信号不能被捕获或忽略。</p>\n<div class=\"custom-quote danger\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M19.76 5.23C15.84 5.23 12 2 12 2C12 2 8.15996 5.23 4.23996 5.23C4.23996 5.23 1.86996 16.99 12 22C22.13 16.99 19.76 5.23 19.76 5.23Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 16H12\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">特别注意</p>\n<p>在一些系统上（特别是较旧的Unix系统），信号处理函数默认在信号处理期间被重置为 <code>SIG_DFL</code>，这意味着在处理信号后必须再次设置信号处理函数。这种行为确保信号处理函数不会重复调用，但也需要在每次处理完信号后重新设置信号处理函数。</p>\n<p>在现代系统中（如POSIX兼容系统），可以使用 <code>sigaction</code> 来设置信号处理函数。<code>sigaction</code> 提供了更多的控制选项，包括在处理函数执行期间不重置信号处理函数，也可以指定信号在处理期间是否阻塞。</p>\n<ul>\n<li>将处理方式重置为 <code>SIG_DFL</code> 会导致信号在处理函数返回后按照默认方式处理。</li>\n<li>阻塞该信号可以防止处理函数被同一信号的多个实例中断，并在处理函数返回后解除阻塞。</li>\n</ul>\n\n</div>\n<h1 id=\"sigaction函数\"><a href=\"#sigaction函数\" class=\"headerlink\" title=\"sigaction函数\"></a>sigaction函数</h1><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;signal.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> sigaction {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\">     (*sa_handler)(</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\">);</span><span style=\"color: #6A9955\">//SIG_DFL SIG_IGN 指向信号处理函数的指针</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /*如果在 sa_flags 中指定了 SA_SIGINFO，则 </span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    sa_sigaction（而不是 sa_handler）指定 signum 的信号处理函数。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\">     (*sa_sigaction)(</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #4EC9B0\">siginfo_t</span><span style=\"color: #D4D4D4\"> *, </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">sigset_t</span><span style=\"color: #D4D4D4\">   sa_mask;</span><span style=\"color: #6A9955\">//指定在执行信号处理程序期间应阻塞的信号掩码</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\">        sa_flags;</span><span style=\"color: #6A9955\">//指定一组修改信号行为的标志</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\">     (*sa_restorer)(</span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\">);</span><span style=\"color: #6A9955\">//不推荐使用</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">sigaction</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">signum</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">              </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> sigaction *_Nullable </span><span style=\"color: #569CD6\">restrict</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">act</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">              </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> sigaction *_Nullable </span><span style=\"color: #569CD6\">restrict</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">oldact</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>sigaction()</code> 系统调用用于更改进程在接收到特定信号时采取的操作。（有关信号的概述，请参见 signal(7)</p>\n<p><code>signum</code> 指定信号，并且可以是除 <code>SIGKILL</code> 和 <code>SIGSTOP</code> 以外的任何有效信号。</p>\n<p>如果 <code>act</code> 不为空，则将从 <code>act</code> 安装信号 <code>signum</code> 的新操作。 如果 <code>oldact</code> 不为空，则将先前操作保存在 <code>oldact</code> 中。</p>\n<p><code>sigaction()</code> 函数成功时返回 0；出错时返回 -1，并将 <code>errno</code> 设置为指示错误。</p>\n<p><code>sa_flags</code> 可以是以下标志的按位或（一般最常用的是0）：</p>\n<table>\n<thead>\n<tr>\n<th>标志位</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SA_NOCLDSTOP</td>\n<td>如果 signum 是 SIGCHLD，当子进程停止（即接收到 SIGSTOP、SIGTSTP、SIGTTIN 或 SIGTTOU 之一）或恢复（即接收到 SIGCONT）时，不接收通知（参见 wait(2)）。此标志仅在为 SIGCHLD 建立处理程序时才有意义。</td>\n</tr>\n<tr>\n<td>SA_NOCLDWAIT (Linux 2.6 起)</td>\n<td>如果 signum 是 SIGCHLD，当子进程终止时，不要将其转换为僵尸进程。另请参阅 waitpid(2)。此标志仅在为 SIGCHLD 建立处理程序或将该信号的处理方式设置为 SIG_DFL 时才有意义。<br>如果在为 SIGCHLD 建立处理程序时设置了 SA_NOCLDWAIT 标志，则 POSIX.1 未指定当子进程终止时是否生成 SIGCHLD 信号。在 Linux 上，在这种情况下会生成 SIGCHLD 信号；在其他一些实现中则不会。</td>\n</tr>\n<tr>\n<td>SA_NODEFER</td>\n<td>在处理程序执行期间，不要将信号添加到线程的信号掩码中，除非在 act.sa_mask 中指定了该信号。因此，在处理程序执行期间，可能会将该信号的另一个实例传递给线程。此标志仅在建立信号处理程序时才有意义。<br>SA_NOMASK 是此标志的已过时且非标准的同义词。</td>\n</tr>\n<tr>\n<td>SA_ONSTACK</td>\n<td>在 sigaltstack(2) 提供的备用信号堆栈上调用信号处理程序。如果没有可用的备用堆栈，则将使用默认堆栈。此标志仅在建立信号处理程序时才有意义。</td>\n</tr>\n<tr>\n<td>SA_RESETHAND</td>\n<td>在进入信号处理程序时，将信号操作恢复为默认值。此标志仅在建立信号处理程序时才有意义。<br>SA_ONESHOT 是此标志的已过时且非标准的同义词。</td>\n</tr>\n<tr>\n<td>SA_RESTART</td>\n<td>通过使某些系统调用在信号之间可重新启动，提供与 BSD 信号语义兼容的行为。此标志仅在建立信号处理程序时才有意义。有关系统调用重新启动的讨论，请参阅 signal(7)。</td>\n</tr>\n<tr>\n<td>SA_RESTORER</td>\n<td>不适用于应用程序。C 库使用此标志来指示 sa_restorer 字段包含“信号蹦床”的地址。有关更多详细信息，请参阅 sigreturn(2)。</td>\n</tr>\n<tr>\n<td>SA_SIGINFO (Linux 2.2 起)</td>\n<td>信号处理程序接受三个参数，而不是一个。在这种情况下，应该设置 sa_sigaction 而不是 sa_handler。此标志仅在建立信号处理程序时才有意义。</td>\n</tr>\n<tr>\n<td>SA_UNSUPPORTED (Linux 5.11 起)</td>\n<td>用于动态探测标志位支持。<br>如果尝试注册处理程序时，在 act-&gt;sa_flags 中设置了此标志以及内核可能不支持的其他标志，并且紧接着调用 sigaction()（指定相同的信号编号并且 oldact 参数为非 NULL）会在 oldact-&gt;sa_flags 中清除 SA_UNSUPPORTED，则可以使用 oldact-&gt;sa_flags 作为位掩码，描述实际上支持哪些可能不受支持的标志。有关更多详细信息，请参阅下面的“动态探测标志位支持”部分。</td>\n</tr>\n<tr>\n<td>SA_EXPOSE_TAGBITS (Linux 5.11 起)</td>\n<td>通常，在传递信号时，会从 siginfo_t 的 si_addr 字段中清除一组特定于体系结构的标记位。如果设置了此标志，则将在 si_addr 中保留特定于体系结构的标记位子集。</td>\n</tr>\n</tbody></table>\n<h1 id=\"kill函数\"><a href=\"#kill函数\" class=\"headerlink\" title=\"kill函数\"></a>kill函数</h1><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;sys/types.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;signal.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">kill</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">pid_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pid</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">sig</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>kill()</code> 系统调用可用于向任何进程组或进程发送任何信号。</p>\n<p>如果 <code>pid</code> 为正数，则信号 <code>sig</code> 会被发送到 ID 为 <code>pid</code> 的进程。</p>\n<p>如果 <code>pid</code> 等于 0，则 <code>sig</code> 会被发送到调用进程所在进程组中的每个进程。</p>\n<p>如果 <code>pid</code> 等于 -1，则 <code>sig</code> 会被发送到调用进程有权发送信号的每个进程，但进程 1（init）除外，详情请参阅下文。</p>\n<p>如果 <code>pid</code> 小于 -1，则 <code>sig</code> 会被发送到 ID 为 <code>-pid</code> 的进程组中的每个进程。</p>\n<p>如果 <code>sig</code> 为 0，则不发送任何信号，但仍然会执行存在性和权限检查；这可用于检查调用方有权发送信号的进程 ID 或进程组 ID 是否存在。</p>\n<p>进程要获得发送信号的权限，它必须是特权进程（在 Linux 下：在目标进程的用户命名空间中拥有 CAP_KILL 功能），或者发送进程的真实或有效用户 ID 必须等于目标进程的真实或保存设置用户 ID。对于 SIGCONT 信号，如果发送进程和接收进程属于同一个会话，则满足条件。（历史上，规则有所不同；请参阅“注释”部分。）</p>\n<p>成功发送至少一个信号后，返回 0。发生错误时，返回 -1，并将 <code>errno</code> 设置为指示错误的原因。</p>\n<p>子进程杀死父进程：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;signal.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;stdio.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;unistd.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">() {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">pid_t</span><span style=\"color: #D4D4D4\"> pid = </span><span style=\"color: #DCDCAA\">fork</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">(pid==</span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">){</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">sleep</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"kill parent</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">kill</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #DCDCAA\">getppid</span><span style=\"color: #D4D4D4\">(), SIGKILL);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #C586C0\">else</span><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"parent</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">sleep</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">20</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><h1 id=\"alarm函数\"><a href=\"#alarm函数\" class=\"headerlink\" title=\"alarm函数\"></a>alarm函数</h1><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;unistd.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">unsigned</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">alarm</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">unsigned</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">seconds</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>alarm()</code> 函数安排在 <code>seconds</code> 秒后向调用进程发送一个 SIGALRM 信号。</p>\n<p>如果 <code>seconds</code> 为零，则取消任何挂起的闹钟。</p>\n<p>无论如何，任何先前设置的 <code>alarm()</code> 都将被取消。</p>\n<p><code>alarm()</code> 返回距离任何先前设置的闹钟被递送剩余的秒数，如果没有先前设置的闹钟，则返回零。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><p><code>alarm()</code> 和 setitimer(2) 共享同一个定时器；对其中一个函数的调用会干扰另一个函数的使用。</p>\n<p>由 <code>alarm()</code> 创建的闹钟在 execve(2) 系统调用之后仍然保留，但不会被 fork(2) 创建的子进程继承。</p>\n<p>sleep(3) 的实现可能使用了 <code>SIGALRM</code> 信号；因此，混合调用 <code>alarm()</code> 和 sleep(3) 并不可取。</p>\n<p>与以往一样，调度延迟会导致进程执行延迟任意时间。</p>\n</p>\n</div>\n<p>这是一个使用 <code>alarm()</code> 函数的示例：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;stdlib.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;stdio.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;unistd.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;signal.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">// 信号处理函数</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">handle_alarm</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">sig</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"Alarm received! Signal number: </span><span style=\"color: #9CDCFE\">%d</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">, sig);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">exit</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">() {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #6A9955\">// 注册信号处理函数</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">signal</span><span style=\"color: #D4D4D4\">(SIGALRM, handle_alarm);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #6A9955\">// 设置闹钟，5秒后发送SIGALRM信号</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">alarm</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">5</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"Alarm set for 5 seconds.</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #6A9955\">// 无限循环等待信号</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">while</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #6A9955\">// 打印消息表示程序正在运行</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"Waiting for alarm...</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">sleep</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">);</span><span style=\"color: #6A9955\"> // 每秒钟打印一次</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><h1 id=\"getitimer-setitimer函数\"><a href=\"#getitimer-setitimer函数\" class=\"headerlink\" title=\"getitimer, setitimer函数\"></a>getitimer, setitimer函数</h1><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;sys/time.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> timeval</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #4EC9B0\">__time_t</span><span style=\"color: #D4D4D4\"> tv_sec;</span><span style=\"color: #6A9955\">\t\t/* Seconds.  */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #4EC9B0\">__suseconds_t</span><span style=\"color: #D4D4D4\"> tv_usec;</span><span style=\"color: #6A9955\">\t/* Microseconds.  */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> itimerval</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">  /* Value to put into `it_value' when the timer expires.  */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> timeval it_interval;</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">  /* Time to the next timer expiration.  */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> timeval it_value;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">getitimer</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">which</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> itimerval *</span><span style=\"color: #9CDCFE\">value</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">setitimer</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">which</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> itimerval *</span><span style=\"color: #569CD6\">restrict</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">value</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> itimerval *</span><span style=\"color: #569CD6\">restrict</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">ovalue</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>getitimer()</code> 函数应将 <code>which</code> 指定的计时器的当前值存储到 <code>value</code> 指向的结构体中。<code>setitimer()</code> 函数应将 <code>which</code> 指定的计时器设置为 <code>value</code> 指向的结构体中指定的值，如果 <code>ovalue</code> 不是空指针，则将计时器的先前值存储到 <code>ovalue</code> 指向的结构体中。</p>\n<p>计时器值由 <code>&lt;sys/time.h&gt;</code> 中指定的 <code>itimerval</code> 结构体定义。如果 <code>it_value</code> 非零，则它表示到下一次计时器到期的时间。如果 <code>it_interval</code> 非零，则它指定计时器到期时用于重新加载 <code>it_value</code> 的值。无论 <code>it_interval</code> 的值如何，将 <code>it_value</code> 设置为 0 都将禁用计时器。将 <code>it_interval</code> 设置为 0 将在下一次到期后禁用计时器（假设 <code>it_value</code> 非零）。</p>\n<p>实现可能会对计时器值的粒度施加限制。对于每个间隔计时器，如果请求的计时器值需要的粒度比实现支持的粒度更精细，则实际计时器值应向上舍入到下一个支持的值。</p>\n<p>符合 XSI 标准的实现至少为每个进程提供三个间隔计时器，这些计时器由 <code>which</code> 参数指示：</p>\n<p><code>ITIMER_PROF</code> 在进程虚拟时间和系统代表进程运行时递减。它旨在供解释器在统计分析解释程序的执行情况时使用。每次 ITIMER_PROF 计时器到期时，都会发送 <code>SIGPROF</code> 信号。</p>\n<p><code>ITIMER_REAL</code> 实时递减。当此计时器到期时，将发送 <code>SIGALRM</code> 信号。</p>\n<p><code>ITIMER_VIRTUAL</code> 在进程虚拟时间内递减。它仅在进程执行时运行。当它到期时，将发送 <code>SIGVTALRM</code> 信号。</p>\n<p><code>setitimer()</code> 与 <code>alarm()</code> 或 <code>sleep()</code> 之间的交互未指定。</p>\n<p>当 <code>getitimer()</code> 或 <code>setitimer()</code> 函数成功执行完成后，返回值为 0；否则，返回值为 -1，并将 <code>errno</code> 设置为相应的错误码。</p>\n<p>这是一个使用 <code>setitimer()</code> 函数的示例：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;stdio.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;stdlib.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;signal.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;sys/time.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;unistd.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">timer_handler</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">signum</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> count = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"Timer expired </span><span style=\"color: #9CDCFE\">%d</span><span style=\"color: #CE9178\"> times</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">, ++count);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">() {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> sigaction sa;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> itimerval timer;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #6A9955\">// Install timer_handler as the signal handler for SIGALRM.</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">sa</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">sa_handler</span><span style=\"color: #D4D4D4\"> = &amp;timer_handler;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">sa</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">sa_flags</span><span style=\"color: #D4D4D4\"> = SA_RESTART;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">sigemptyset</span><span style=\"color: #D4D4D4\">(&amp;</span><span style=\"color: #9CDCFE\">sa</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">sa_mask</span><span style=\"color: #D4D4D4\">);</span><span style=\"color: #6A9955\">//initial signal set to empty</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #DCDCAA\">sigaction</span><span style=\"color: #D4D4D4\">(SIGALRM, &amp;sa, </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\">) == -</span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">perror</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"sigaction\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">exit</span><span style=\"color: #D4D4D4\">(EXIT_FAILURE);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #6A9955\">// Configure the timer to expire after 1 sec... </span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">timer</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">it_value</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">tv_sec</span><span style=\"color: #D4D4D4\"> = </span><span style=\"color: #B5CEA8\">3</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">timer</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">it_value</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">tv_usec</span><span style=\"color: #D4D4D4\"> = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #6A9955\">// ... and every 1 sec after that.</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">timer</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">it_interval</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">tv_sec</span><span style=\"color: #D4D4D4\"> = </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">timer</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">it_interval</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">tv_usec</span><span style=\"color: #D4D4D4\"> = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #6A9955\">// Start a virtual timer. It counts down whenever this process is executing.</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #DCDCAA\">setitimer</span><span style=\"color: #D4D4D4\">(ITIMER_REAL, &amp;timer, </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\">) == -</span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">perror</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"setitimer\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">exit</span><span style=\"color: #D4D4D4\">(EXIT_FAILURE);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #6A9955\">// Do busy work. </span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">while</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">pause</span><span style=\"color: #D4D4D4\">();</span><span style=\"color: #6A9955\"> // Wait for signals.</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><h1 id=\"信号集操作函数\"><a href=\"#信号集操作函数\" class=\"headerlink\" title=\"信号集操作函数\"></a>信号集操作函数</h1><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;signal.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">sigemptyset</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">sigset_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">set</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">sigfillset</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">sigset_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">set</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">sigaddset</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">sigset_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">set</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">signum</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">sigdelset</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">sigset_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">set</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">signum</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">sigismember</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">sigset_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">set</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">signum</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p>这些函数允许操作 POSIX 信号集。</p>\n<p><code>sigemptyset()</code> 函数将由 <code>set</code> 指定的信号集初始化为空，排除所有信号。</p>\n<p><code>sigfillset()</code> 函数将 <code>set</code> 初始化为满，包含所有信号。</p>\n<p><code>sigaddset()</code> 和 <code>sigdelset()</code> 函数分别将信号 <code>signum</code> 添加到 <code>set</code> 和从 <code>set</code> 中删除。</p>\n<p><code>sigismember()</code> 函数测试 <code>signum</code> 是否是 <code>set</code> 的成员。</p>\n<p><code>sigemptyset()</code>、<code>sigfillset()</code>、<code>sigaddset()</code> 和 <code>sigdelset()</code> 成功时返回 0，出错时返回 -1。</p>\n<p><strong>返回值</strong>：</p>\n<p>如果 <code>signum</code> 是 set 的成员，则 <code>sigismember()</code> 返回 1；如果 <code>signum</code> 不是 <code>set</code> 的成员，则返回 0；出错时返回 -1。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><code>sigset_t</code> 类型的对象在传递给函数 <code>sigaddset()</code>、<code>sigdelset()</code> 和 <code>sigismember()</code> 或下述 glibc 附加函数（sigisemptyset()、sigandset() 和 sigorset()）之前，必须通过调用 <code>sigemptyset()</code> 或 <code>sigfillset()</code> 进行初始化。 否则，结果将不确定。</p>\n\n</div>\n<h1 id=\"sigprocmask函数\"><a href=\"#sigprocmask函数\" class=\"headerlink\" title=\"sigprocmask函数\"></a>sigprocmask函数</h1><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;signal.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">/* Prototype for the glibc wrapper function */</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">sigprocmask</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">how</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">sigset_t</span><span style=\"color: #D4D4D4\"> *_Nullable </span><span style=\"color: #569CD6\">restrict</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">set</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                          </span><span style=\"color: #4EC9B0\">sigset_t</span><span style=\"color: #D4D4D4\"> *_Nullable </span><span style=\"color: #569CD6\">restrict</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">oldset</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>sigprocmask()</code> 函数用于获取和/或更改调用线程的信号掩码。信号掩码是指当前被调用者阻塞的一组信号（更多详细信息请参阅 signal(7)）。</p>\n<p>函数的行为取决于 <code>how</code> 的值，具体如下：</p>\n<ul>\n<li><code>SIG_BLOCK</code>：阻塞信号集是当前信号集和 set 参数的并集。</li>\n<li><code>SIG_UNBLOCK</code>：从当前阻塞信号集中移除 set 中的信号。允许尝试解除未被阻塞的信号的阻塞。</li>\n<li><code>SIG_SETMASK</code>：将阻塞信号集设置为 set 参数。</li>\n</ul>\n<p>如果 <code>oldset</code> 不为 <code>NULL</code>，则会将先前的信号掩码值存储在 <code>oldset</code> 中。<br>如果 <code>set</code> 为 <code>NULL</code>，则信号掩码保持不变（即忽略 <code>how</code> 参数），但当前的信号掩码值仍将返回到 <code>oldset</code> 中（如果它不为 <code>NULL</code>）。</p>\n<p>sigsetops(3) 中描述了一组用于修改和检查 <code>sigset_t</code> 类型变量（“信号集”）的函数。<br>在多线程进程中，<code>sigprocmask()</code> 的使用未指定；请参阅 pthread_sigmask(3)。</p>\n<p><code>sigprocmask()</code> 函数成功时返回 0。失败时返回 -1，并将 <code>errno</code> 设置为指示错误。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><p>在使用 <code>sigprocmask()</code> 函数时，<code>set</code> 和 <code>oldset</code> 不能是同一个变量。</p>\n</p>\n</div>\n<h1 id=\"sigpending函数\"><a href=\"#sigpending函数\" class=\"headerlink\" title=\"sigpending函数\"></a>sigpending函数</h1><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;signal.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">sigpending</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">sigset_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">set</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>sigpending()</code> 函数返回等待传递给调用线程的信号集（即，在阻塞时引发的信号）。未决信号掩码将在 set 中返回。</p>\n<p><code>sigpending()</code> 函数成功时返回 0。失败时返回 -1，并将 <code>errno</code> 设置为指示错误。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<ul>\n<li>有关操作信号集的详细信息，请参阅 sigsetops(3)。</li>\n<li>如果一个信号既被阻塞又设置为“忽略”处理，则在生成该信号时，它不会被添加到未决信号掩码中。</li>\n<li>线程的未决信号集是该线程的未决信号集与整个进程的未决信号集的并集；请参阅 signal(7)。</li>\n<li>通过 fork(2) 创建的子进程最初具有空的未决信号集；未决信号集在 execve(2) 中得以保留。</li>\n</ul>\n\n</div>\n<p>这是一个使用 <code>sigpending()</code> 函数的示例：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;stdio.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;stdlib.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;signal.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;unistd.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">// 信号处理函数</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">signal_handler</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">sig</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"Caught signal </span><span style=\"color: #9CDCFE\">%d</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">, sig);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">() {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">sigset_t</span><span style=\"color: #D4D4D4\"> set, oldset;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> sigaction sa;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #6A9955\">// 设置信号处理函数</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">sa</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">sa_handler</span><span style=\"color: #D4D4D4\"> = signal_handler;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">sa</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">sa_flags</span><span style=\"color: #D4D4D4\"> = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">sigemptyset</span><span style=\"color: #D4D4D4\">(&amp;</span><span style=\"color: #9CDCFE\">sa</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">sa_mask</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #DCDCAA\">sigaction</span><span style=\"color: #D4D4D4\">(SIGINT, &amp;sa, </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\">) == -</span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">perror</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"sigaction\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">exit</span><span style=\"color: #D4D4D4\">(EXIT_FAILURE);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">sigemptyset</span><span style=\"color: #D4D4D4\">(&amp;set);</span><span style=\"color: #6A9955\">// 初始化信号集为空</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">sigaddset</span><span style=\"color: #D4D4D4\">(&amp;set, SIGINT);</span><span style=\"color: #6A9955\">// 将SIGINT添加到信号集中</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #6A9955\">// 阻塞SIGINT信号，并保存旧的信号集</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #DCDCAA\">sigprocmask</span><span style=\"color: #D4D4D4\">(SIG_BLOCK, &amp;set, &amp;oldset) == -</span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">perror</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"sigprocmask\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">exit</span><span style=\"color: #D4D4D4\">(EXIT_FAILURE);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"SIGINT is blocked. Try pressing Ctrl+C now...</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">sleep</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">5</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #6A9955\">// 恢复原来的信号集，解除对SIGINT的阻塞</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #DCDCAA\">sigprocmask</span><span style=\"color: #D4D4D4\">(SIG_SETMASK, &amp;oldset, </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\">) == -</span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">perror</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"sigprocmask\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">exit</span><span style=\"color: #D4D4D4\">(EXIT_FAILURE);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"SIGINT is unblocked. Try pressing Ctrl+C now...</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">sleep</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">5</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><h1 id=\"sigsuspend函数\"><a href=\"#sigsuspend函数\" class=\"headerlink\" title=\"sigsuspend函数\"></a>sigsuspend函数</h1><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;signal.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">sigsuspend</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">sigset_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">mask</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>sigsuspend()</code> 函数会将调用线程的信号掩码临时替换为 <code>mask</code> 参数所指定的掩码，然后挂起该线程，直到传递来一个信号，该信号的动作是调用信号处理程序或终止进程。<br>如果信号终止了进程，那么 <code>sigsuspend()</code> 不会返回。如果信号被捕获，那么 <code>sigsuspend()</code> 会在信号处理程序返回后返回，并将信号掩码恢复到调用 <code>sigsuspend()</code> 之前的状态。<br>无法阻塞 <code>SIGKILL</code> 或 <code>SIGSTOP</code> 信号；在 <code>mask</code> 中指定这些信号对线程的信号掩码没有影响。</p>\n<p><code>sigsuspend()</code> 函数总是返回 -1，并将 <code>errno</code> 设置为相应的错误码（通常是 <code>EINTR</code>）。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>通常，<code>sigsuspend()</code> 会与 sigprocmask(2) 函数结合使用，以防止在执行关键代码段时传递信号。调用方首先使用 sigprocmask(2) 函数阻塞信号。当关键代码执行完毕后，调用方接着调用 <code>sigsuspend()</code> 函数，并将 sigprocmask(2) 函数返回的信号掩码（在 <code>oldset</code> 参数中）传递给它，以等待信号。</p>\n<p>父进程回收子进程资源：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;signal.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;stdio.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;stdlib.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;sys/wait.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;unistd.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">wait_child</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">sig</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"wait child</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> status;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">wait</span><span style=\"color: #D4D4D4\">(&amp;status);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">() {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #4EC9B0\">sigset_t</span><span style=\"color: #D4D4D4\"> sig, oldsig;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">sigemptyset</span><span style=\"color: #D4D4D4\">(&amp;sig);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">sigaddset</span><span style=\"color: #D4D4D4\">(&amp;sig, SIGCHLD);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">sigprocmask</span><span style=\"color: #D4D4D4\">(SIG_BLOCK, &amp;sig, &amp;oldsig);</span><span style=\"color: #6A9955\">// 在fork之前阻塞SIGCHLD信号，等到wait_child函数注册完成后解除阻塞</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">pid_t</span><span style=\"color: #D4D4D4\"> pid = </span><span style=\"color: #DCDCAA\">fork</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (pid == </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"here is child</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span><span style=\"color: #6A9955\">//子进程结束后会产生SIGCHLD信号</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  } </span><span style=\"color: #C586C0\">else</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #6A9955\">//这里的关键代码不会被SIGCHLD信号中断</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"parent setting sigmask</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> sigaction sa;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">sa</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">sa_flags</span><span style=\"color: #D4D4D4\"> = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">sa</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">sa_handler</span><span style=\"color: #D4D4D4\"> = wait_child;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">sigemptyset</span><span style=\"color: #D4D4D4\">(&amp;</span><span style=\"color: #9CDCFE\">sa</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">sa_mask</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">sigaction</span><span style=\"color: #D4D4D4\">(SIGCHLD, &amp;sa, </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">sigsuspend</span><span style=\"color: #D4D4D4\">(&amp;oldsig);</span><span style=\"color: #6A9955\"> //使用sigsuspend解除SIGINT信号阻塞 并挂起进程，直到收到信号</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #6A9955\">// sigprocmask(SIG_SETMASK, &amp;oldsig, NULL);//这样也行</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #6A9955\">// sleep(1);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div></p>\n</div>\n<h1 id=\"进程组（作业）\"><a href=\"#进程组（作业）\" class=\"headerlink\" title=\"进程组（作业）\"></a>进程组（作业）</h1><ul>\n<li>进程组是多个进程的集合，每个进程都属于一个进程组，以简化对多个进程的管理， <code>waitpid()</code> 函数和<code>kill</code> 函数的参数都可以对进程组进行操作。</li>\n<li>父进程创建子进程的时候默认父子进程属于同一进程组。当一个进程创建新的进程组时，它会自动成为该进程组的组长，并且其进程 ID 会被用作进程组 ID。</li>\n<li>即使组长进程终止，进程组依然存在，且进程组 ID 仍然保持不变，直到进程组中的所有进程都终止。在这期间进程组变成孤儿进程组，与任何终端会话分离，如果进程组中的某个进程试图执行需要终端的操作（例如调用 wait() 或 openpty()），则该进程将收到 <code>SIGHUP</code> 信号。</li>\n<li><code>kill -SIGKILL -&lt;进程组id&gt;</code> 杀掉整个进程组。</li>\n<li>一个进程可以为自己或子进程设置进程组 id。</li>\n</ul>\n<h1 id=\"进程组操作函数\"><a href=\"#进程组操作函数\" class=\"headerlink\" title=\"进程组操作函数\"></a>进程组操作函数</h1><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;unistd.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">setpgid</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">pid_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pid</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">pid_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pgid</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">pid_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">getpgid</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">pid_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pid</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>setpgid()</code> 函数将 <code>pid</code> 指定的进程的 PGID 设置为 <code>pgid</code>。如果 <code>pid</code> 为零，则使用调用进程的进程 ID。如果 <code>pgid</code> 为零，则将 <code>pid</code> 指定的进程的 PGID 设置为与其进程 ID 相同。如果使用 <code>setpgid()</code> 将进程从一个进程组移动到另一个进程组（例如某些 shell 在创建管道时所做的），则两个进程组必须属于同一个会话（参见 setsid(2) 和 credentials(7)）。在这种情况下，<code>pgid</code> 指定要加入的现有进程组，并且该组的会话 ID 必须与加入进程的会话 ID 相匹配。</p>\n<p><code>getpgid()</code> 函数返回 <code>pid</code> 指定的进程的 PGID。如果 <code>pid</code> 为零，则使用调用进程的进程 ID。</p>\n<p>如果成功，<code>setpgid()</code> 和 <code>setpgrp()</code> 返回零。如果出错，则返回 -1，并设置 <code>errno</code> 以指示错误。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>通过 fork(2) 创建的子进程会继承其父进程的进程组 ID。在执行 execve(2) 后，PGID 仍会被保留。</p>\n<p>每个进程组都是某个会话的成员，并且每个进程都是其进程组所属会话的成员。（参见 credentials(7)。）</p>\n<p>一个会话可以有一个控制终端。在任何时候，会话中只能有一个进程组是终端的前台进程组；其余进程组处于后台。如果从终端生成信号（例如，键入中断键以生成 SIGINT 信号），则该信号将发送到前台进程组。（有关生成信号的字符的说明，请参见 termios(3)。）只有前台进程组可以从终端读取数据 (read(2))；如果后台进程组尝试从终端读取数据 (read(2))，则会向该组发送 <code>SIGTTIN</code> 信号，从而将其挂起。 tcgetpgrp(3) 和 tcsetpgrp(3) 函数用于获取/设置控制终端的前台进程组。</p>\n<p><code>setpgid()</code> 和 <code>getpgrp()</code> 调用由 bash(1) 等程序用于创建进程组，以便实现 shell 作业控制。</p>\n<p>如果某个进程终止导致一个进程组变为孤儿进程组，并且如果新成为孤儿的进程组中的任何成员已停止，则会向新成为孤儿的进程组中的每个进程发送一个 <code>SIGHUP</code> 信号，然后再发送一个 <code>SIGCONT</code> 信号。孤儿进程组是指其中每个成员的父进程要么是该进程组本身的成员，要么是不同会话中某个进程组的成员（另请参见 credentials(7)）。</p>\n\n</div>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><p>可以使用<code>setpgid()</code>函数来将本进程添加到其他随便一个已有的进程组吗？</p>\n<p><code>setpgid()</code> 函数用于将一个进程加入到一个进程组中，但是并不能随意地将本进程加入到任何已有的进程组中。使用 <code>setpgid()</code> 时有一些限制：</p>\n<ol>\n<li>相同的会话：目标进程组和调用 <code>setpgid()</code> 的进程必须属于同一个会话（session）。会话是由 <code>setsid</code> 系统调用创建的，所有属于同一会话的进程共享一个会话 ID。</li>\n<li>权限要求：调用 <code>setpgid()</code> 的进程必须对目标进程组有适当的权限。通常，这意味着调用进程和目标进程组中的进程必须由同一个用户拥有，或者调用进程具有超级用户权限。</li>\n<li>进程组领导者的限制：如果一个进程是其自身进程组的组长（即其进程组 ID 等于其进程 ID），则不能改变其进程组。</li>\n</ol>\n</p>\n</div>\n<h1 id=\"会话\"><a href=\"#会话\" class=\"headerlink\" title=\"会话\"></a>会话</h1><p>在 Linux 系统内部，会话是一个更抽象的概念，它代表一组拥有相同控制终端的进程。</p>\n<p>每个会话都拥有一个唯一的 会话 ID (Session ID, SID)。</p>\n<p>一个会话可以包含多个 进程组 (Process Group)，每个进程组也拥有一个唯一的 进程组 ID (Process Group ID, PGID)。</p>\n<p>会话首进程 (session leader) 的进程 ID 就是会话 ID。</p>\n<h1 id=\"setsid函数\"><a href=\"#setsid函数\" class=\"headerlink\" title=\"setsid函数\"></a>setsid函数</h1><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;unistd.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">pid_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">setsid</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>setsid()</code> 函数会在<strong>调用进程不是进程组组长</strong>的情况下创建一个新的会话。调用进程会成为新会话的首进程 (也就是说，其会话 ID 会被设置为与其进程 ID 相同)。调用进程同时也会成为该会话中一个新的进程组的组长进程 (也就是说，其进程组 ID 会被设置为与其进程 ID 相同)。</p>\n<p>调用进程将成为新的进程组和新会话中唯一的进程。</p>\n<p>新会话初始时没有控制终端。关于会话如何获取控制终端的详细信息，请参阅 credentials(7)。</p>\n<p>若调用成功，则返回调用进程的（新）会话 ID。若调用失败，则返回 (pid_t) -1，并将 <code>errno</code> 设置为指示错误的值。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这是创建守护进程的常用方法之一。首先调用 <code>fork()</code> 创建一个子进程，父进程随后退出。在子进程中调用 <code>setsid()</code>创建新的会话，即可使其脱离该终端的控制，且其ppid变为1。 </p></blockquote>\n<h1 id=\"pthread-create函数\"><a href=\"#pthread-create函数\" class=\"headerlink\" title=\"pthread_create函数\"></a>pthread_create函数</h1><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;pthread.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">pthread_create</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">pthread_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #569CD6\">restrict</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">thread</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">pthread_attr_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #569CD6\">restrict</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">attr</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *(*start_routine)(</span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *),</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #569CD6\">restrict</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">arg</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>pthread_create()</code> 函数用于在调用进程中创建一个新线程。新线程将通过调用 <code>start_routine()</code> 函数开始执行；<code>arg</code> 将作为 <code>start_routine()</code> 函数的唯一参数被传递。</p>\n<p>新线程可以通过以下几种方式终止：</p>\n<ul>\n<li>调用 pthread_exit(3) 函数，并指定一个退出状态码。该状态码可由同一进程中调用 pthread_join(3) 函数的其它线程获取。</li>\n<li>从 <code>start_routine()</code> 函数返回。这等效于调用 pthread_exit(3) 函数，并使用 return 语句中提供的值作为退出状态码。</li>\n<li>被取消 (参见 pthread_cancel(3))。</li>\n<li>进程中的任何线程调用 exit(3) 函数，或 <strong>主线程从 main() 函数返回</strong> 。这将导致进程中所有线程终止。</li>\n</ul>\n<p><code>attr</code> 参数指向一个 <code>pthread_attr_t</code> 结构体，该结构体的内容将在线程创建时用于确定新线程的属性；可以使用 pthread_attr_init(3) 函数及相关函数对该结构体进行初始化。如果 <code>attr</code> 为 <code>NULL</code>，则将使用默认属性创建线程。</p>\n<p>如果 <code>pthread_create()</code> 函数调用成功，它将在返回之前将新线程的 ID 存储到 <code>thread</code> 指向的缓冲区中；该标识符可在后续调用其它 pthreads 函数时用于引用该线程。</p>\n<p>新线程将继承创建线程的信号掩码副本 (pthread_sigmask(3))。新线程的未决信号集为空 (sigpending(2))。新线程不会继承创建线程的备用信号栈 (sigaltstack(2))。</p>\n<p>新线程将继承调用线程的浮点环境 (fenv(3))。</p>\n<p>新线程的 CPU 时间计数器的初始值为 0 (参见 pthread_getcpuclockid(3))。</p>\n<p>如果 <code>pthread_create()</code> 函数调用成功，将返回 0；如果发生错误，将返回一个错误码，并且 *thread 的内容将是未定义的。</p>\n<h1 id=\"pthread-exit函数\"><a href=\"#pthread-exit函数\" class=\"headerlink\" title=\"pthread_exit函数\"></a>pthread_exit函数</h1><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;pthread.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">[[noreturn]] </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">pthread_exit</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">retval</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>pthread_exit()</code> 函数终止调用线程，并通过 <code>retval</code> 返回一个值（如果该线程是可连接的），该值可由同一进程中调用 pthread_join(3) 函数的另一个线程获取。</p>\n<p>所有已建立但尚未被弹出的、由 pthread_cleanup_push(3) 函数设置的清理处理程序都将被弹出（顺序与压入顺序相反）并执行。如果线程有任何线程私有数据，则在清理处理程序执行完毕后，将以未指定的顺序调用相应的析构函数。</p>\n<p>当线程终止时，进程共享资源（例如，互斥量、条件变量、信号量和文件描述符）不会被释放，并且使用 atexit(3) 函数注册的函数也不会被调用。</p>\n<p>在进程中的最后一个线程终止后，该进程将像调用 exit(3) 函数并传入退出状态 0 一样终止；因此，进程共享资源会被释放，并且使用 atexit(3) 函数注册的函数会被调用。</p>\n<p>该函数不会返回到调用者。</p>\n<h1 id=\"pthread-join函数\"><a href=\"#pthread-join函数\" class=\"headerlink\" title=\"pthread_join函数\"></a>pthread_join函数</h1><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;pthread.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">pthread_join</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">pthread_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">thread</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> **</span><span style=\"color: #9CDCFE\">retval</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>pthread_join()</code> 函数等待由 <code>thread</code> 指定的线程终止。如果该线程已经终止，则 <code>pthread_join()</code> 会立即返回。由 <code>thread</code> 指定的线程必须是可连接的。</p>\n<p>如果 <code>retval</code> 不为 <code>NULL</code>，则 <code>pthread_join()</code> 会将目标线程的退出状态（即目标线程提供给 pthread_exit(3) 的值）复制到 <code>retval</code> 指向的位置。如果目标线程被取消，则 <code>PTHREAD_CANCELED</code> 将被放置到 <code>retval</code> 指向的位置。</p>\n<p>如果多个线程同时尝试连接到同一个线程，则结果将是未定义的。如果调用 <code>pthread_join()</code> 的线程被取消，则目标线程将保持可连接状态（即它不会被分离）。</p>\n<h1 id=\"pthread-cancel函数\"><a href=\"#pthread-cancel函数\" class=\"headerlink\" title=\"pthread_cancel函数\"></a>pthread_cancel函数</h1><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;pthread.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">pthread_cancel</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">pthread_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">thread</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>pthread_cancel()</code> 函数向 <code>thread</code> 线程发送一个取消请求。目标线程是否以及何时响应取消请求取决于该线程控制下的两个属性：可取消状态和取消类型。</p>\n<p>线程的可取消状态由 <code>pthread_setcancelstate(3)</code> 确定，可以启用（新线程的默认设置）或禁用。如果线程禁用了取消，则取消请求将一直排队，直到线程启用取消。如果线程启用了取消，则其取消类型将决定何时发生取消。</p>\n<p>线程的取消类型由 <code>pthread_setcanceltype(3)</code> 确定，可以是异步的或延迟的（新线程的默认设置）。异步取消意味着线程可以随时被取消（通常是立即取消，但系统不保证这一点）。<strong>延迟取消意味着取消将被延迟，直到线程下次调用一个取消点函数。<code>pthreads(7)</code> 中提供了一个可取消点函数列表。</strong></p>\n<p>当取消请求被执行时，<code>thread</code> 线程将按以下顺序执行以下步骤：</p>\n<ol>\n<li>取消清理处理程序将被弹出（顺序与压入顺序相反）并被调用。（参见 <code>pthread_cleanup_push(3)</code>）。</li>\n<li>线程私有数据析构函数将以未指定的顺序被调用。（参见 <code>pthread_key_create(3)</code>）。</li>\n<li>线程被终止。（参见 <code>pthread_exit(3)</code>）。</li>\n</ol>\n<p>以上步骤相对于 <code>pthread_cancel()</code> 调用是异步发生的；<code>pthread_cancel()</code> 的返回值仅通知调用者取消请求是否已成功排队。</p>\n<p>在一个被取消的线程终止后，使用 <code>pthread_join(3)</code> 与该线程进行连接将会获得 <code>PTHREAD_CANCELED</code> 作为线程的退出状态。（与线程连接是知道取消已完成的唯一方法）。</p>\n<p>如果 <code>pthread_cancel()</code> 函数调用成功，将返回 0；如果发生错误，将返回一个非零错误码。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>线程在执行某些系统调用（如I/O操作、锁操作等）时，会进入内核态。这些系统调用本身就是取消点，即在这些系统调用的过程中，线程会检查是否有取消请求并作出响应。如果一个线程从未进行任何系统调用（即从未进入内核态），它就不会遇到这些默认的取消点，从而不会响应取消请求,为了确保这种线程也能响应取消请求，需要手动设置取消点。这可以通过调用<code>pthread_testcancel()</code>函数来实现。<code>pthread_testcancel()</code>是一个显式的取消点，当线程调用它时，会检查是否有取消请求。如果有，它会响应取消请求并终止线程。</p>\n\n</div>\n<h1 id=\"pthread-detach函数\"><a href=\"#pthread-detach函数\" class=\"headerlink\" title=\"pthread_detach函数\"></a>pthread_detach函数</h1><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;pthread.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">pthread_detach</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">pthread_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">thread</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>pthread_detach()</code> 函数将由 <code>thread</code> 标识的线程标记为分离线程。当分离线程终止时，它的资源会自动释放回系统，而不需要其他线程与该终止线程进行连接。</p>\n<p>尝试分离一个已经分离的线程将导致未指定的行为。</p>\n<p>如果 <code>pthread_detach()</code> 函数调用成功，将返回 0；如果发生错误，将返回一个错误码。</p>\n<h1 id=\"线程属性设置\"><a href=\"#线程属性设置\" class=\"headerlink\" title=\"线程属性设置\"></a>线程属性设置</h1><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #DCDCAA\">pthread_attr_init</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">3</span><span style=\"color: #D4D4D4\">)</span><span style=\"color: #6A9955\">//初始化线程属性对象</span></span>\n<span class=\"line\"><span style=\"color: #DCDCAA\">pthread_attr_setaffinity_np</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">3</span><span style=\"color: #D4D4D4\">)</span><span style=\"color: #6A9955\">//设置线程的亲和性</span></span>\n<span class=\"line\"><span style=\"color: #DCDCAA\">pthread_attr_setdetachstate</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">3</span><span style=\"color: #D4D4D4\">)</span><span style=\"color: #6A9955\">//设置线程的分离状态</span></span>\n<span class=\"line\"><span style=\"color: #DCDCAA\">pthread_attr_setguardsize</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">3</span><span style=\"color: #D4D4D4\">)</span><span style=\"color: #6A9955\">//设置线程的警戒缓冲区大小</span></span>\n<span class=\"line\"><span style=\"color: #DCDCAA\">pthread_attr_setinheritsched</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">3</span><span style=\"color: #D4D4D4\">)</span><span style=\"color: #6A9955\">//设置线程的继承调度策略</span></span>\n<span class=\"line\"><span style=\"color: #DCDCAA\">pthread_attr_setschedparam</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">3</span><span style=\"color: #D4D4D4\">)</span><span style=\"color: #6A9955\">//设置线程的调度参数</span></span>\n<span class=\"line\"><span style=\"color: #DCDCAA\">pthread_attr_setschedpolicy</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">3</span><span style=\"color: #D4D4D4\">)</span><span style=\"color: #6A9955\">//设置线程的调度策略</span></span>\n<span class=\"line\"><span style=\"color: #DCDCAA\">pthread_attr_setscope</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">3</span><span style=\"color: #D4D4D4\">)</span><span style=\"color: #6A9955\">//设置线程的作用域</span></span>\n<span class=\"line\"><span style=\"color: #DCDCAA\">pthread_attr_setsigmask_np</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">3</span><span style=\"color: #D4D4D4\">)</span><span style=\"color: #6A9955\">//设置线程的信号掩码</span></span>\n<span class=\"line\"><span style=\"color: #DCDCAA\">pthread_attr_setstack</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">3</span><span style=\"color: #D4D4D4\">)</span><span style=\"color: #6A9955\">//设置线程的栈</span></span>\n<span class=\"line\"><span style=\"color: #DCDCAA\">pthread_attr_setstackaddr</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">3</span><span style=\"color: #D4D4D4\">)</span><span style=\"color: #6A9955\">//设置线程的栈地址</span></span>\n<span class=\"line\"><span style=\"color: #DCDCAA\">pthread_attr_setstacksize</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">3</span><span style=\"color: #D4D4D4\">)</span><span style=\"color: #6A9955\">//设置线程的栈大小</span></span></code></pre></div><p>示例程序：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;err.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;errno.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;pthread.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;stdio.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;stdlib.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;unistd.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">display_pthread_attr</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">pthread_attr_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">attr</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">char</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">prefix</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> s, i;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> v;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *stkaddr;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> sched_param sp;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  s = </span><span style=\"color: #DCDCAA\">pthread_attr_getdetachstate</span><span style=\"color: #D4D4D4\">(attr, &amp;i);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #9CDCFE\">%s</span><span style=\"color: #CE9178\">Detach state        = </span><span style=\"color: #9CDCFE\">%s</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">, prefix,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">         (i == PTHREAD_CREATE_DETACHED)   ? </span><span style=\"color: #CE9178\">\"PTHREAD_CREATE_DETACHED\"</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">         : (i == PTHREAD_CREATE_JOINABLE) ? </span><span style=\"color: #CE9178\">\"PTHREAD_CREATE_JOINABLE\"</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                                          : </span><span style=\"color: #CE9178\">\"???\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  s = </span><span style=\"color: #DCDCAA\">pthread_attr_getscope</span><span style=\"color: #D4D4D4\">(attr, &amp;i);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #9CDCFE\">%s</span><span style=\"color: #CE9178\">Scope               = </span><span style=\"color: #9CDCFE\">%s</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">, prefix,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">         (i == PTHREAD_SCOPE_SYSTEM)    ? </span><span style=\"color: #CE9178\">\"PTHREAD_SCOPE_SYSTEM\"</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">         : (i == PTHREAD_SCOPE_PROCESS) ? </span><span style=\"color: #CE9178\">\"PTHREAD_SCOPE_PROCESS\"</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                                        : </span><span style=\"color: #CE9178\">\"???\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  s = </span><span style=\"color: #DCDCAA\">pthread_attr_getinheritsched</span><span style=\"color: #D4D4D4\">(attr, &amp;i);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #9CDCFE\">%s</span><span style=\"color: #CE9178\">Inherit scheduler   = </span><span style=\"color: #9CDCFE\">%s</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">, prefix,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">         (i == PTHREAD_INHERIT_SCHED)    ? </span><span style=\"color: #CE9178\">\"PTHREAD_INHERIT_SCHED\"</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">         : (i == PTHREAD_EXPLICIT_SCHED) ? </span><span style=\"color: #CE9178\">\"PTHREAD_EXPLICIT_SCHED\"</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                                         : </span><span style=\"color: #CE9178\">\"???\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  s = </span><span style=\"color: #DCDCAA\">pthread_attr_getschedpolicy</span><span style=\"color: #D4D4D4\">(attr, &amp;i);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #9CDCFE\">%s</span><span style=\"color: #CE9178\">Scheduling policy   = </span><span style=\"color: #9CDCFE\">%s</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">, prefix,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">         (i == SCHED_OTHER)  ? </span><span style=\"color: #CE9178\">\"SCHED_OTHER\"</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">         : (i == SCHED_FIFO) ? </span><span style=\"color: #CE9178\">\"SCHED_FIFO\"</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">         : (i == SCHED_RR)   ? </span><span style=\"color: #CE9178\">\"SCHED_RR\"</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                             : </span><span style=\"color: #CE9178\">\"???\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  s = </span><span style=\"color: #DCDCAA\">pthread_attr_getschedparam</span><span style=\"color: #D4D4D4\">(attr, &amp;sp);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #9CDCFE\">%s</span><span style=\"color: #CE9178\">Scheduling priority = </span><span style=\"color: #9CDCFE\">%d</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">, prefix, </span><span style=\"color: #9CDCFE\">sp</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">sched_priority</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  s = </span><span style=\"color: #DCDCAA\">pthread_attr_getguardsize</span><span style=\"color: #D4D4D4\">(attr, &amp;v);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #9CDCFE\">%s</span><span style=\"color: #CE9178\">Guard size          = </span><span style=\"color: #9CDCFE\">%zu</span><span style=\"color: #CE9178\"> bytes</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">, prefix, v);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  s = </span><span style=\"color: #DCDCAA\">pthread_attr_getstack</span><span style=\"color: #D4D4D4\">(attr, &amp;stkaddr, &amp;v);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #9CDCFE\">%s</span><span style=\"color: #CE9178\">Stack address       = </span><span style=\"color: #9CDCFE\">%p</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">, prefix, stkaddr);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #9CDCFE\">%s</span><span style=\"color: #CE9178\">Stack size          = </span><span style=\"color: #9CDCFE\">%#zx</span><span style=\"color: #CE9178\"> bytes</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">, prefix, v);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #DCDCAA\">thread_start</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">arg</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> s;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">pthread_attr_t</span><span style=\"color: #D4D4D4\"> gattr;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">  /* pthread_getattr_np() is a non-standard GNU extension that</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">     retrieves the attributes of the thread specified in its</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">     first argument. */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  s = </span><span style=\"color: #DCDCAA\">pthread_getattr_np</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #DCDCAA\">pthread_self</span><span style=\"color: #D4D4D4\">(), &amp;gattr);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"Thread attributes:</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">display_pthread_attr</span><span style=\"color: #D4D4D4\">(&amp;gattr, </span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D7BA7D\">\\t</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">exit</span><span style=\"color: #D4D4D4\">(EXIT_SUCCESS);</span><span style=\"color: #6A9955\"> /* Terminate all threads */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">argc</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">char</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">argv</span><span style=\"color: #569CD6\">[]</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">pthread_t</span><span style=\"color: #D4D4D4\"> thr;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">pthread_attr_t</span><span style=\"color: #D4D4D4\"> attr;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">pthread_attr_t</span><span style=\"color: #D4D4D4\"> *attrp;</span><span style=\"color: #6A9955\"> /* NULL or &amp;attr */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> s;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  attrp = </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">  /* If a command-line argument was supplied, use it to set the</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">     stack-size attribute and set a few other thread attributes,</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">     and set attrp pointing to thread attributes object. */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (argc &gt; </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> stack_size;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *sp;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    attrp = &amp;attr;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    s = </span><span style=\"color: #DCDCAA\">pthread_attr_init</span><span style=\"color: #D4D4D4\">(&amp;attr);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    s = </span><span style=\"color: #DCDCAA\">pthread_attr_setdetachstate</span><span style=\"color: #D4D4D4\">(&amp;attr, PTHREAD_CREATE_DETACHED);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    s = </span><span style=\"color: #DCDCAA\">pthread_attr_setinheritsched</span><span style=\"color: #D4D4D4\">(&amp;attr, PTHREAD_EXPLICIT_SCHED);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    stack_size = </span><span style=\"color: #DCDCAA\">strtoul</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #9CDCFE\">argv</span><span style=\"color: #D4D4D4\">[</span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">], </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    s = </span><span style=\"color: #DCDCAA\">posix_memalign</span><span style=\"color: #D4D4D4\">(&amp;sp, </span><span style=\"color: #DCDCAA\">sysconf</span><span style=\"color: #D4D4D4\">(_SC_PAGESIZE), stack_size);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"posix_memalign() allocated at </span><span style=\"color: #9CDCFE\">%p</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">, sp);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    s = </span><span style=\"color: #DCDCAA\">pthread_attr_setstack</span><span style=\"color: #D4D4D4\">(&amp;attr, sp, stack_size);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  s = </span><span style=\"color: #DCDCAA\">pthread_create</span><span style=\"color: #D4D4D4\">(&amp;thr, attrp, &amp;thread_start, </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (attrp != </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    s = </span><span style=\"color: #DCDCAA\">pthread_attr_destroy</span><span style=\"color: #D4D4D4\">(attrp);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">pause</span><span style=\"color: #D4D4D4\">();</span><span style=\"color: #6A9955\"> /* Terminates when other thread calls exit() */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><h1 id=\"pthread-mutex-init函数\"><a href=\"#pthread-mutex-init函数\" class=\"headerlink\" title=\"pthread_mutex_init函数\"></a>pthread_mutex_init函数</h1><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;pthread.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">pthread_mutex_destroy</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">pthread_mutex_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">mutex</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">pthread_mutex_init</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">pthread_mutex_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #569CD6\">restrict</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">mutex</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">pthread_mutexattr_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #569CD6\">restrict</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">attr</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">pthread_mutex_t</span><span style=\"color: #D4D4D4\"> mutex = PTHREAD_MUTEX_INITIALIZER;</span></span></code></pre></div><p><code>pthread_mutex_destroy()</code> 函数应销毁 <code>mutex</code> 引用的互斥锁对象；实际上，该互斥锁对象将变为未初始化状态。实现可能导致 <code>pthread_mutex_destroy()</code> 将 <code>mutex</code> 引用的对象设置为无效值。</p>\n<p>可以使用 <code>pthread_mutex_init()</code> 重新初始化已销毁的互斥锁对象；在销毁后以其他方式引用该对象的结果是未定义的。</p>\n<p>销毁已初始化且已解锁的互斥锁应该是安全的。尝试销毁已锁定的互斥锁，或其他线程正在尝试锁定的互斥锁，或其他线程正在 <code>pthread_cond_timedwait()</code> 或 <code>pthread_cond_wait()</code> 调用中使用的互斥锁，将导致未定义行为。</p>\n<p><code>pthread_mutex_init()</code> 函数应使用 <code>attr</code> 指定的属性初始化 mutex 引用的互斥锁。如果 <code>attr</code> 为 <code>NULL</code>，则使用默认的互斥锁属性；其效果应与传递默认互斥锁属性对象的地址相同。成功初始化后，互斥锁的状态将变为已初始化和已解锁。</p>\n<p>尝试初始化已初始化的互斥锁将导致未定义行为。</p>\n<p>如果默认互斥锁属性适用，则可以使用宏 <code>PTHREAD_MUTEX_INITIALIZER</code> 来初始化互斥锁。其效果应等效于通过调用 <code>pthread_mutex_init()</code> 并将参数 <code>attr</code> 指定为 <code>NULL</code> 进行动态初始化，但不会执行错误检查。</p>\n<p>如果成功，<code>pthread_mutex_destroy()</code> 和 <code>pthread_mutex_init()</code> 函数应返回零；否则，将返回一个错误号以指示错误。</p>\n<h1 id=\"pthread-mutex-lock函数\"><a href=\"#pthread-mutex-lock函数\" class=\"headerlink\" title=\"pthread_mutex_lock函数\"></a>pthread_mutex_lock函数</h1><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;pthread.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">pthread_mutex_lock</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">pthread_mutex_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">mutex</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">pthread_mutex_trylock</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">pthread_mutex_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">mutex</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">pthread_mutex_unlock</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">pthread_mutex_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">mutex</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p>调用 <code>pthread_mutex_lock()</code> 函数并返回零或 <code>EOWNERDEAD</code> 时，应锁定 <code>mutex</code> 引用的互斥锁对象。如果该互斥锁已被其他线程锁定，则调用线程应阻塞，直到该互斥锁可用。此操作应在互斥锁对象处于锁定状态且调用线程作为其所有者时返回，该互斥锁对象由 <code>mutex</code> 引用。如果某个线程尝试重新锁定其已锁定的互斥锁，则 <code>pthread_mutex_lock()</code> 的行为应如以下表格的“重新锁定”列中所述。如果某个线程尝试解锁 不是这个线程锁定的互斥锁 或 已解锁的互斥锁 ，则 <code>pthread_mutex_unlock()</code> 的行为应如以下表格的“非所有者解锁”列中所述。</p>\n<table>\n<thead>\n<tr>\n<th>互斥锁类型</th>\n<th>稳健性</th>\n<th>重新锁定</th>\n<th>非所有者解锁</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>NORMAL</code></td>\n<td>非稳健</td>\n<td>死锁</td>\n<td>未定义行为</td>\n</tr>\n<tr>\n<td><code>NORMAL</code></td>\n<td>稳健</td>\n<td>死锁</td>\n<td>返回错误</td>\n</tr>\n<tr>\n<td><code>ERRORCHECK</code></td>\n<td>非稳健或稳健</td>\n<td>返回错误</td>\n<td>返回错误</td>\n</tr>\n<tr>\n<td><code>RECURSIVE</code></td>\n<td>非稳健或稳健</td>\n<td>递归（见下文）</td>\n<td>返回错误</td>\n</tr>\n<tr>\n<td><code>DEFAULT</code></td>\n<td>非稳健</td>\n<td>未定义行为†</td>\n<td>未定义行为†</td>\n</tr>\n<tr>\n<td><code>DEFAULT</code></td>\n<td>稳健</td>\n<td>未定义行为†</td>\n<td>返回错误</td>\n</tr>\n</tbody></table>\n<p>† 如果互斥锁类型为 <code>PTHREAD_MUTEX_DEFAULT</code>，则 <code>pthread_mutex_lock()</code> 的行为可能与上表中所述的三种其他标准互斥锁类型之一相对应。如果它与这三种类型都不相对应，则对于标记为 † 的情况，其行为未定义。</p>\n<p>如果表格显示递归行为，则互斥锁应维护锁计数的概念。当线程首次成功获取互斥锁时，锁计数应设置为 1。每次线程重新锁定此互斥锁时，锁计数应递增 1。每次线程解锁互斥锁时，锁计数应递减 1。当锁计数达到零时，该互斥锁应可供其他线程获取。</p>\n<p><code>pthread_mutex_trylock()</code> 函数应等效于 <code>pthread_mutex_lock()</code>，不同之处在于，如果 mutex 引用的互斥锁对象当前已锁定（由任何线程锁定，包括当前线程），则调用应立即返回。如果互斥锁类型为 <code>PTHREAD_MUTEX_RECURSIVE</code> 且互斥锁当前由调用线程拥有，则互斥锁计数应递增 1，并且 <code>pthread_mutex_trylock()</code> 函数应立即返回成功。</p>\n<p><code>pthread_mutex_unlock()</code> 函数应释放 <code>mutex</code> 引用的互斥锁对象。互斥锁的释放方式取决于互斥锁的类型属性。如果在调用 <code>pthread_mutex_unlock()</code> 时有线程阻塞在 <code>mutex</code> 引用的互斥锁对象上，导致该互斥锁变为可用，则调度策略应决定哪个线程应获取该互斥锁。</p>\n<p>（对于 <code>PTHREAD_MUTEX_RECURSIVE</code> 互斥锁，当计数达到零且调用线程不再拥有此互斥锁上的任何锁时，该互斥锁应变为可用。）</p>\n<p>如果向等待互斥锁的线程发送信号，则从信号处理程序返回后，该线程应继续等待该互斥锁，如同未被中断一样。</p>\n<p>如果 <code>mutex</code> 是稳健的互斥锁，并且包含拥有线程的进程在持有互斥锁时终止，则对 <code>pthread_mutex_lock()</code> 的调用应返回错误值 <code>EOWNERDEAD</code>。如果 <code>mutex</code> 是稳健的互斥锁，并且拥有线程在持有互斥锁时终止，则即使拥有线程所在的进程尚未终止，对 <code>pthread_mutex_lock()</code> 的调用也可能返回错误值 <code>EOWNERDEAD</code>。在这些情况下，互斥锁由线程锁定，但其保护的状态被标记为不一致。应用程序应确保该状态一致以供重用，并在完成后调用 <code>pthread_mutex_consistent()</code>。如果应用程序无法恢复状态，则应在不事先调用 <code>pthread_mutex_consistent()</code> 的情况下解锁互斥锁，之后该互斥锁将被标记为永久不可用。</p>\n<p>如果 <code>mutex</code> 未引用已初始化的互斥锁对象，则 <code>pthread_mutex_lock()</code>、<code>pthread_mutex_trylock()</code> 和 <code>pthread_mutex_unlock()</code> 的行为未定义。</p>\n<p>如果成功，<code>pthread_mutex_lock()</code>、<code>pthread_mutex_trylock()</code> 和 <code>pthread_mutex_unlock()</code> 函数应返回0；否则，将返回一个错误号以指示错误。</p>\n<p>示例程序：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;pthread.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;stdio.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;stdlib.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #DCDCAA\">thread_function</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">arg</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">pthread_mutex_t</span><span style=\"color: #D4D4D4\"> *mutex = (</span><span style=\"color: #569CD6\">pthread_mutex_t</span><span style=\"color: #D4D4D4\"> *)arg;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">pthread_mutex_lock</span><span style=\"color: #D4D4D4\">(mutex);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"Thread acquired lock once.</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">pthread_mutex_lock</span><span style=\"color: #D4D4D4\">(mutex);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"Thread acquired lock twice.</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">pthread_mutex_unlock</span><span style=\"color: #D4D4D4\">(mutex);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"Thread released lock once.</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">pthread_mutex_unlock</span><span style=\"color: #D4D4D4\">(mutex);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"Thread released lock twice.</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">() {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">pthread_mutexattr_t</span><span style=\"color: #D4D4D4\"> attr;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">pthread_mutex_t</span><span style=\"color: #D4D4D4\"> mutex;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">pthread_t</span><span style=\"color: #D4D4D4\"> thread;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">pthread_mutexattr_init</span><span style=\"color: #D4D4D4\">(&amp;attr);</span><span style=\"color: #6A9955\">// Initialize mutex attribute</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">pthread_mutexattr_settype</span><span style=\"color: #D4D4D4\">(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><span style=\"color: #6A9955\">// Set mutex type to recursive</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">pthread_mutex_init</span><span style=\"color: #D4D4D4\">(&amp;mutex, &amp;attr);</span><span style=\"color: #6A9955\">// Initialize mutex with attribute</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">pthread_create</span><span style=\"color: #D4D4D4\">(&amp;thread, </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\">, thread_function, (</span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *)&amp;mutex);</span><span style=\"color: #6A9955\">// Create a thread</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">pthread_join</span><span style=\"color: #D4D4D4\">(thread, </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\">);</span><span style=\"color: #6A9955\">// Wait for thread to finish</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #6A9955\">// Destroy mutex and attribute</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">pthread_mutex_destroy</span><span style=\"color: #D4D4D4\">(&amp;mutex);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">pthread_mutexattr_destroy</span><span style=\"color: #D4D4D4\">(&amp;attr);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><h1 id=\"pthread-rwlock-init函数\"><a href=\"#pthread-rwlock-init函数\" class=\"headerlink\" title=\"pthread_rwlock_init函数\"></a>pthread_rwlock_init函数</h1><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;pthread.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">pthread_rwlock_destroy</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">pthread_rwlock_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">rwlock</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">pthread_rwlock_init</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">pthread_rwlock_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #569CD6\">restrict</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">rwlock</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">pthread_rwlockattr_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #569CD6\">restrict</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">attr</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">pthread_rwlock_t</span><span style=\"color: #D4D4D4\"> rwlock = PTHREAD_RWLOCK_INITIALIZER;</span></span></code></pre></div><p><code>pthread_rwlock_destroy()</code> 函数应销毁 <code>rwlock</code> 引用的读写锁对象，并释放该锁使用的任何资源。在通过再次调用 <code>pthread_rwlock_init()</code> 重新初始化该锁之前，后续使用该锁的效果是未定义的。实现可能导致 <code>pthread_rwlock_destroy()</code> 将 <code>rwlock</code> 引用的对象设置为无效值。如果在任何线程持有 <code>rwlock</code> 时调用 <code>pthread_rwlock_destroy()</code>，则结果未定义。尝试销毁未初始化的读写锁将导致未定义行为。</p>\n<p><code>pthread_rwlock_init()</code> 函数应分配使用 <code>rwlock</code> 引用的读写锁所需的任何资源，并将该锁初始化为具有 <code>attr</code> 引用的属性的解锁状态。如果 <code>attr</code> 为 <code>NULL</code>，则应使用默认的读写锁属性；其效果与传递默认读写锁属性对象的地址相同。初始化后，该锁可以使用任意次数，而无需重新初始化。如果在指定已初始化的读写锁时调用 <code>pthread_rwlock_init()</code>，则结果未定义。如果在未先初始化读写锁的情况下使用它，则结果未定义。</p>\n<p>如果 <code>pthread_rwlock_init()</code> 函数失败，则 <code>rwlock</code> 不应初始化，并且 <code>rwlock</code> 的内容未定义。</p>\n<p>如果默认读写锁属性适用，则可以使用宏 <code>PTHREAD_RWLOCK_INITIALIZER</code> 来初始化读写锁。其效果应等效于通过调用 <code>pthread_rwlock_init()</code> 并将 <code>attr</code> 参数指定为 <code>NULL</code> 进行动态初始化，但不会执行错误检查。</p>\n<p>如果传递给 <code>pthread_rwlock_init()</code> 的 <code>attr</code> 参数指定的值未引用已初始化的读写锁属性对象，则行为未定义。</p>\n<p>如果成功，<code>pthread_rwlock_destroy()</code> 和 <code>pthread_rwlock_init()</code> 函数应返回0；否则，将返回一个错误号以指示错误。</p>\n<h1 id=\"pthread-rwlock-rdlock函数\"><a href=\"#pthread-rwlock-rdlock函数\" class=\"headerlink\" title=\"pthread_rwlock_rdlock函数\"></a>pthread_rwlock_rdlock函数</h1><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;pthread.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">pthread_rwlock_rdlock</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">pthread_rwlock_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">rwlock</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">pthread_rwlock_tryrdlock</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">pthread_rwlock_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">rwlock</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">pthread_rwlock_wrlock</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">pthread_rwlock_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">rwlock</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">pthread_rwlock_trywrlock</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">pthread_rwlock_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">rwlock</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">pthread_rwlock_unlock</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">pthread_rwlock_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">rwlock</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p>如果成功，函数应返回0；否则，将返回一个错误号以指示错误。</p>\n<h1 id=\"pthread-cond-init函数\"><a href=\"#pthread-cond-init函数\" class=\"headerlink\" title=\"pthread_cond_init函数\"></a>pthread_cond_init函数</h1><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;pthread.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">pthread_cond_t</span><span style=\"color: #D4D4D4\"> cond = PTHREAD_COND_INITIALIZER;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">pthread_cond_init</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">pthread_cond_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">cond</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                      </span><span style=\"color: #569CD6\">pthread_condattr_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">cond_attr</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">pthread_cond_signal</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">pthread_cond_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">cond</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">pthread_cond_broadcast</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">pthread_cond_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">cond</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">pthread_cond_wait</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">pthread_cond_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">cond</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">pthread_mutex_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">mutex</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">pthread_cond_timedwait</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">pthread_cond_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">cond</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">pthread_mutex_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">mutex</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                      </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> timespec *</span><span style=\"color: #9CDCFE\">abstime</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">pthread_cond_destroy</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">pthread_cond_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">cond</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p>条件（“条件变量”的缩写）是一种同步机制，允许线程挂起执行并放弃处理器，直到满足共享数据上的某个谓词为止。条件的基本操作是：发出条件信号（当谓词变为真时）和等待条件，挂起线程执行，直到另一个线程发出条件信号。</p>\n<p>条件变量必须始终与互斥锁相关联，以避免出现竞争条件，即一个线程准备等待条件变量，而另一个线程恰好在第一个线程实际等待之前发出条件信号。</p>\n<p><code>pthread_cond_init()</code> 使用 <code>cond_attr</code> 中指定的条件属性初始化条件变量 <code>cond</code>，如果 <code>cond_attr</code> 为 <code>NULL</code>，则使用默认属性。<strong>LinuxThreads 实现不支持条件的属性，因此实际上会忽略 <code>cond_attr</code> 参数。</strong></p>\n<p><code>pthread_cond_t</code> 类型的变量也可以使用常量 <code>PTHREAD_COND_INITIALIZER</code> 进行静态初始化。</p>\n<p><code>pthread_cond_signal()</code> 重新启动正在等待条件变量 <code>cond</code> 的其中一个线程。如果没有线程在 <code>cond</code> 上等待，则不会发生任何事情。如果有几个线程在 <code>cond</code> 上等待，则只有一个线程会重新启动，但没有指定是哪个线程。</p>\n<p><code>pthread_cond_broadcast()</code> 重新启动所有正在等待条件变量 <code>cond</code> 的线程。如果没有线程在 <code>cond</code> 上等待，则不会发生任何事情。</p>\n<p><code>pthread_cond_wait()</code> 原子地解锁互斥锁（根据 <code>pthread_unlock_mutex()</code>）并等待条件变量 <code>cond</code> 被发出信号。线程执行被挂起，并且在条件变量被发出信号之前不会消耗任何 CPU 时间。在进入 <code>pthread_cond_wait()</code> 时，调用线程必须锁定互斥锁。在返回到调用线程之前，<code>pthread_cond_wait()</code> 会重新获取互斥锁（根据 <code>pthread_lock_mutex()</code>）。</p>\n<p>解锁互斥锁和在条件变量上挂起是原子地完成的。因此，如果所有线程总是在发出条件信号之前获取互斥锁，则可以保证在某个线程锁定互斥锁的时间与它等待条件变量的时间之间不会发出条件信号（从而被忽略）。</p>\n<p><code>pthread_cond_timedwait()</code> 原子地解锁互斥锁并在 <code>cond</code> 上等待，就像 <code>pthread_cond_wait()</code> 一样，但它也限制了等待的持续时间。如果在 <code>abstime</code> 指定的时间量内没有发出 <code>cond</code> 信号，则会重新获取互斥锁 <code>mutex</code>，并且 <code>pthread_cond_timedwait()</code> 返回错误 <code>ETIMEDOUT</code>。<code>abstime</code> 参数指定一个绝对时间，其起点与 time(2) 和 gettimeofday(2) 相同：<code>abstime</code> 为 0 对应于 1970 年 1 月 1 日 GMT 时间 00:00:00。</p>\n<p><code>pthread_cond_destroy()</code> 销毁一个条件变量，释放它可能持有的资源。在进入 <code>pthread_cond_destroy()</code> 时，任何线程都不得在条件变量上等待。在 LinuxThreads 实现中，没有与条件变量关联的资源，因此 <code>pthread_cond_destroy()</code> 实际上除了检查条件是否没有等待线程之外什么也不做。</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;stdio.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;stdlib.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;pthread.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;unistd.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#define</span><span style=\"color: #569CD6\"> NUM_THREADS </span><span style=\"color: #B5CEA8\">3</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">pthread_mutex_t</span><span style=\"color: #D4D4D4\"> mutex;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">pthread_cond_t</span><span style=\"color: #D4D4D4\"> cond;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> count = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">// 线程函数，等待条件变量</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #DCDCAA\">thread_function</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">arg</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> thread_id = *(</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> *)arg;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"线程 </span><span style=\"color: #9CDCFE\">%d</span><span style=\"color: #CE9178\"> 启动，即将进入临界区...</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">, thread_id);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">pthread_mutex_lock</span><span style=\"color: #D4D4D4\">(&amp;mutex);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"线程 </span><span style=\"color: #9CDCFE\">%d</span><span style=\"color: #CE9178\"> 进入临界区，等待条件变量的同时解除互斥锁</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">, thread_id);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #6A9955\">// 等待条件变量，同时释放互斥锁</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">pthread_cond_wait</span><span style=\"color: #D4D4D4\">(&amp;cond, &amp;mutex);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #6A9955\">// 条件满足后，重新获取互斥锁</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"线程 </span><span style=\"color: #9CDCFE\">%d</span><span style=\"color: #CE9178\"> 被唤醒，count = </span><span style=\"color: #9CDCFE\">%d</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">, thread_id, count);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">pthread_mutex_unlock</span><span style=\"color: #D4D4D4\">(&amp;mutex);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">pthread_exit</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">() {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">pthread_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">threads</span><span style=\"color: #D4D4D4\">[NUM_THREADS];</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">thread_args</span><span style=\"color: #D4D4D4\">[NUM_THREADS];</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #6A9955\">// 初始化互斥锁和条件变量</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">pthread_mutex_init</span><span style=\"color: #D4D4D4\">(&amp;mutex, </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">pthread_cond_init</span><span style=\"color: #D4D4D4\">(&amp;cond, </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #6A9955\">// 创建线程</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> i = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">; i &lt; NUM_THREADS; i++) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">thread_args</span><span style=\"color: #D4D4D4\">[i] = i;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">pthread_create</span><span style=\"color: #D4D4D4\">(&amp;</span><span style=\"color: #9CDCFE\">threads</span><span style=\"color: #D4D4D4\">[i], </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\">, thread_function, &amp;</span><span style=\"color: #9CDCFE\">thread_args</span><span style=\"color: #D4D4D4\">[i]);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #6A9955\">// 等待一段时间，确保线程已经进入等待状态</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">sleep</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">2</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #6A9955\">// 修改条件并发送信号</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">pthread_mutex_lock</span><span style=\"color: #D4D4D4\">(&amp;mutex);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  count = </span><span style=\"color: #B5CEA8\">10</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"主线程修改条件，发送信号...</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #6A9955\">// 选择使用 pthread_cond_signal 或 pthread_cond_broadcast</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #6A9955\">//pthread_cond_signal(&amp;cond); // 只唤醒一个线程</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">pthread_cond_broadcast</span><span style=\"color: #D4D4D4\">(&amp;cond);</span><span style=\"color: #6A9955\"> // 唤醒所有线程</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">pthread_mutex_unlock</span><span style=\"color: #D4D4D4\">(&amp;mutex);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #6A9955\">// 等待线程结束</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> i = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">; i &lt; NUM_THREADS; i++) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">pthread_join</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #9CDCFE\">threads</span><span style=\"color: #D4D4D4\">[i], </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #6A9955\">// 销毁互斥锁和条件变量</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">pthread_mutex_destroy</span><span style=\"color: #D4D4D4\">(&amp;mutex);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">pthread_cond_destroy</span><span style=\"color: #D4D4D4\">(&amp;cond);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><h1 id=\"sem-init函数\"><a href=\"#sem-init函数\" class=\"headerlink\" title=\"sem_init函数\"></a>sem_init函数</h1><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;semaphore.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">sem_init</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">sem_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">sem</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pshared</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">unsigned</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">value</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">sem_destroy</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">sem_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">sem</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>sem_init()</code> 函数用于初始化位于 <code>sem</code> 指向地址的<strong>未命名信号量</strong>。<code>value</code> 参数指定信号量的初始值。</p>\n<p><code>pshared</code> 参数指示该信号量是在进程的线程之间共享，还是在进程之间共享。</p>\n<ul>\n<li><p>如果 <code>pshared</code> 的值为 0，则该信号量在进程的线程之间共享，并且应该位于所有线程都可以看到的某个地址（例如，全局变量或在堆上动态分配的变量）。</p>\n</li>\n<li><p>如果 <code>pshared</code> 不为零，则该信号量在进程之间共享，并且应该位于共享内存区域中（请参阅 shm_open(3)、mmap(2) 和 shmget(2)）。（由于 fork(2) 创建的子进程会继承其父进程的内存映射，因此它也可以访问该信号量。）任何可以访问该共享内存区域的进程都可以使用 sem_post(3)、sem_wait(3) 等操作该信号量。</p>\n</li>\n</ul>\n<p>初始化已经初始化过的信号量将导致未定义行为。</p>\n<p><code>sem_destroy()</code> 函数销毁由 <code>sem</code> 指向的未命名信号量。</p>\n<ul>\n<li>只有使用 sem_init(3) 初始化的信号量才能使用 <code>sem_destroy()</code> 销毁。</li>\n<li>销毁其他进程或线程当前阻塞（在 sem_wait(3) 中）的信号量会导致未定义行为。</li>\n<li>使用已被销毁的信号量会产生未定义的结果，直到使用 sem_init(3) 重新初始化该信号量。</li>\n</ul>\n<p>这两个函数成功返回0，失败返回-1，并设置 <code>errno</code> 以指示错误。</p>\n<h1 id=\"sem-wait函数\"><a href=\"#sem-wait函数\" class=\"headerlink\" title=\"sem_wait函数\"></a>sem_wait函数</h1><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;semaphore.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">sem_wait</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">sem_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">sem</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">sem_trywait</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">sem_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">sem</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">sem_timedwait</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">sem_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #569CD6\">restrict</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">sem</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                  </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> timespec *</span><span style=\"color: #569CD6\">restrict</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">abs_timeout</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>sem_wait()</code> 函数对由 <code>sem</code> 指向的信号量进行减1操作（加锁）。如果信号量的值大于零，则进行减1操作，函数立即返回。如果信号量的值当前为零，则调用将阻塞，直到可以执行减1操作（即信号量值大于零）或信号处理程序中断调用为止。</p>\n<p><code>sem_trywait()</code> 函数与 <code>sem_wait()</code> 函数相同，区别在于如果无法立即执行减1操作，则调用将返回错误（<code>errno</code> 设置为 <code>EAGAIN</code>），而不是阻塞。</p>\n<p><code>sem_timedwait()</code> 函数与 <code>sem_wait()</code> 函数相同，区别在于 <code>abs_timeout</code> 指定了如果无法立即执行减1操作，则调用应阻塞的最长时间。<code>abs_timeout</code> 参数指向一个 <code>timespec(3)</code> 结构体，该结构体指定了自 Epoch（1970-01-01 00:00:00 +0000 (UTC)）以来的秒数和纳秒数的绝对超时时间。</p>\n<p>如果在调用时超时已过期，并且无法立即锁定信号量，则 <code>sem_timedwait()</code> 函数失败并返回超时错误（<code>errno</code> 设置为 <code>ETIMEDOUT</code>）。</p>\n<p>如果可以立即执行操作，则无论 <code>abs_timeout</code> 的值如何，<code>sem_timedwait()</code> 函数都不会返回超时错误。此外，在这种情况下，不会检查 <code>abs_timeout</code> 的有效性。</p>\n<p>这些函数在成功时都返回 0；如果出错，则信号量的值保持不变，返回 -1，并设置 <code>errno</code> 以指示错误。</p>\n<h1 id=\"sem-post函数\"><a href=\"#sem-post函数\" class=\"headerlink\" title=\"sem_post函数\"></a>sem_post函数</h1><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;semaphore.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">sem_post</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">sem_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">sem</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p><code>sem_post()</code> 函数对由 <code>sem</code> 指向的信号量进行加1操作（解锁）。如果信号量的值因此变得大于零，则在 <code>sem_wait(3)</code> 调用中阻塞的另一个进程或线程将被唤醒并继续锁定该信号量。</p>\n<p><code>sem_post()</code> 函数在成功时返回 0；如果出错，则信号量的值保持不变，返回 -1，并设置 <code>errno</code> 以指示错误。</p>\n","feature":true,"text":"信号信号概述在Linux操作系统中，信号（Signal）是一种用于进程间通信的机制，可以用来通知进程某些事件的发生。信号的主要作用是让操作系统或其他进程可以向进...","permalink":"/post/Linux系统编程（信号与多线程）","photos":[],"count_time":{"symbolsCount":"34k","symbolsTime":"31 mins."},"categories":[{"name":"Linux","slug":"Linux","count":8,"path":"api/categories/Linux.json"}],"tags":[{"name":"Linux","slug":"Linux","count":8,"path":"api/tags/Linux.json"},{"name":"C++","slug":"C","count":12,"path":"api/tags/C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BF%A1%E5%8F%B7\"><span class=\"toc-text\">信号</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BF%A1%E5%8F%B7%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">信号概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BF%A1%E5%8F%B7%E5%B1%8F%E8%94%BD%E5%AD%97%EF%BC%88Signal-Mask%EF%BC%89\"><span class=\"toc-text\">信号屏蔽字（Signal Mask）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%AA%E5%86%B3%E4%BF%A1%E5%8F%B7%E9%9B%86%EF%BC%88Pending-Signals%EF%BC%89\"><span class=\"toc-text\">未决信号集（Pending Signals）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Linux%E5%86%85%E6%A0%B8%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E6%9C%BA%E5%88%B6%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">Linux内核信号捕捉机制详细解析</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#signal%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">signal函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#sigaction%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">sigaction函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#kill%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">kill函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#alarm%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">alarm函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#getitimer-setitimer%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">getitimer, setitimer函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BF%A1%E5%8F%B7%E9%9B%86%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">信号集操作函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#sigprocmask%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">sigprocmask函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#sigpending%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">sigpending函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#sigsuspend%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">sigsuspend函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E7%BB%84%EF%BC%88%E4%BD%9C%E4%B8%9A%EF%BC%89\"><span class=\"toc-text\">进程组（作业）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E7%BB%84%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">进程组操作函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BC%9A%E8%AF%9D\"><span class=\"toc-text\">会话</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#setsid%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">setsid函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pthread-create%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">pthread_create函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pthread-exit%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">pthread_exit函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pthread-join%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">pthread_join函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pthread-cancel%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">pthread_cancel函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pthread-detach%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">pthread_detach函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE\"><span class=\"toc-text\">线程属性设置</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pthread-mutex-init%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">pthread_mutex_init函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pthread-mutex-lock%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">pthread_mutex_lock函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pthread-rwlock-init%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">pthread_rwlock_init函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pthread-rwlock-rdlock%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">pthread_rwlock_rdlock函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pthread-cond-init%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">pthread_cond_init函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#sem-init%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">sem_init函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#sem-wait%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">sem_wait函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#sem-post%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">sem_post函数</span></a></li></ol>","author":{"name":"Ac-Accelerator","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一位计算机技术爱好者，大学在读，目前正在学习C++、Python、Java和计算机系统以及计算机视觉深度学习等相关知识，欢迎交流","socials":{"github":"https://github.com/Ac-Accelerator","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_31702515?spm=1000.2115.3001.5343","juejin":"","customs":{"qq":{"icon":"/svg/QQ.svg","link":"http://tool.gljlw.com/qq/?qq=2583832841"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"Linux网络编程（TCP）","uid":"b7ae202389bc9c445e0505a76dbc19f8","slug":"Linux网络编程（TCP）","date":"2024-07-11T12:26:18.000Z","updated":"2024-07-17T12:22:48.817Z","comments":true,"path":"api/articles/Linux网络编程（TCP）.json","keywords":"C++,Pyhton,Java,算法","cover":"img/linux.jpeg","text":"数据的大端和小端所谓的字节序，指的是超过一个字节的数据在内存中的存储顺序。如果一个数据只占用一个字节，则字节序的问题就不存在了。 数据的大端存储比较贴近我们人类...","permalink":"/post/Linux网络编程（TCP）","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"Linux","slug":"Linux","count":8,"path":"api/categories/Linux.json"}],"tags":[{"name":"Linux","slug":"Linux","count":8,"path":"api/tags/Linux.json"},{"name":"C++","slug":"C","count":12,"path":"api/tags/C.json"}],"author":{"name":"Ac-Accelerator","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一位计算机技术爱好者，大学在读，目前正在学习C++、Python、Java和计算机系统以及计算机视觉深度学习等相关知识，欢迎交流","socials":{"github":"https://github.com/Ac-Accelerator","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_31702515?spm=1000.2115.3001.5343","juejin":"","customs":{"qq":{"icon":"/svg/QQ.svg","link":"http://tool.gljlw.com/qq/?qq=2583832841"}}}},"feature":true},"next_post":{"title":"Linux系统编程（进程）","uid":"68c10486ec2cc89517f4c1626fec120f","slug":"Linux系统编程（进程）","date":"2024-07-04T01:36:23.000Z","updated":"2024-07-05T05:19:31.200Z","comments":true,"path":"api/articles/Linux系统编程（进程）.json","keywords":"C++,Pyhton,Java,算法","cover":"img/linux.jpeg","text":"PCB进程控制块cstruct task_struct { unsigned int __state; /* 进程状态：运行、等待、停止等 */ pid_t p...","permalink":"/post/Linux系统编程（进程）","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"17 mins."},"categories":[{"name":"Linux","slug":"Linux","count":8,"path":"api/categories/Linux.json"}],"tags":[{"name":"Linux","slug":"Linux","count":8,"path":"api/tags/Linux.json"},{"name":"C++","slug":"C","count":12,"path":"api/tags/C.json"}],"author":{"name":"Ac-Accelerator","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一位计算机技术爱好者，大学在读，目前正在学习C++、Python、Java和计算机系统以及计算机视觉深度学习等相关知识，欢迎交流","socials":{"github":"https://github.com/Ac-Accelerator","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_31702515?spm=1000.2115.3001.5343","juejin":"","customs":{"qq":{"icon":"/svg/QQ.svg","link":"http://tool.gljlw.com/qq/?qq=2583832841"}}}},"feature":true}}