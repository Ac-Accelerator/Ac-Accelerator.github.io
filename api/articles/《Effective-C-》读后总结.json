{"title":"《Effective C++》笔记","uid":"45eea3793f995e9782f39b2b3ca183ab","slug":"《Effective-C-》读后总结","date":"2024-02-03T08:12:24.000Z","updated":"2024-02-15T16:39:23.632Z","comments":true,"path":"api/articles/《Effective-C-》读后总结.json","keywords":"C++,Pyhton,Java,算法","cover":"/img/effectiveC++.jpeg","content":"<p>读完《Effective C++》后，确实感到收益匪浅。但因为目前是学生，平时实践并不多，恐怕很多知识点会忘记。所以，我打算写一篇读后总结，以便日后复习，用电子版的方式也方便进行检索。</p>\n<h1 id=\"一、让自己习惯C\"><a href=\"#一、让自己习惯C\" class=\"headerlink\" title=\"一、让自己习惯C++\"></a>一、让自己习惯C++</h1><h2 id=\"1-视C-为一个语言联邦\"><a href=\"#1-视C-为一个语言联邦\" class=\"headerlink\" title=\"1 视C++为一个语言联邦\"></a>1 视C++为一个语言联邦</h2><p>C++是一个多重范型的语言，虽然功能强大且灵活，但是却导致其不存在一个通用的程序设计守则和通例。为了能够获得简单直观的程序设计守则和通例，需要对C++语言的不同特性进行划分，总的来说可以C++划分为4个子语言，分别是C、Object-Oriented C++、Template C++和STL。不同的子语言有不同的程序设计守则和通例。因此，C++程序员最好视C++为一个语言联邦，而不是一个单一的语言。</p>\n<h2 id=\"2-尽量以const、enum、inline替换-define\"><a href=\"#2-尽量以const、enum、inline替换-define\" class=\"headerlink\" title=\"2 尽量以const、enum、inline替换#define\"></a>2 尽量以const、enum、inline替换#define</h2><p>总而言之是：能让编译器做的别让预处理器做。</p>\n<p><strong>对于单纯的常量，最好使用const对象或者enum，而不是#define</strong></p>\n<p>原因如下：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#define</span><span style=\"color: #569CD6\"> ASPECT_RATIO 1.653 // 不会进入符号表</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">double</span><span style=\"color: #D4D4D4\"> AspectRatio = </span><span style=\"color: #B5CEA8\">1.653</span><span style=\"color: #D4D4D4\">;</span><span style=\"color: #6A9955\"> // 会进入符号表</span></span></code></pre></div><p>当编译报错的时候，前者只会显示1.653（不直观），而后者会显示AspectRatio（直观）。且使用#define可能会导致代码膨胀。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><p>用const替换#define时，要注意的是如果对象是指针的话，要将指针本身也声明为const。</p>\n<p>对于类的专属常量，例如下面的NumTurns作为数组的大小在编译的时候要被使用，如何避免使用#define ：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">GamePlayer</span><span style=\"color: #D4D4D4\"> {</span><span style=\"color: #6A9955\">//放在头文件中</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">private:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> NumTurns = </span><span style=\"color: #B5CEA8\">5</span><span style=\"color: #D4D4D4\">; </span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">scores</span><span style=\"color: #D4D4D4\">[NumTurns];</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">GamePlayer</span><span style=\"color: #D4D4D4\">::NumTurns;</span><span style=\"color: #6A9955\">//放在实现文件中，如果编译器不要求提供定义，则可以忽略。</span></span></code></pre></div><p>上述做法可能不起作用，因为老旧的编译器可能不允许static成员在声明时获得初始值，所以可以使用enum hack：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">GamePlayer</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">private:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">enum</span><span style=\"color: #D4D4D4\"> { </span><span style=\"color: #4FC1FF\">NumTurns</span><span style=\"color: #D4D4D4\"> = </span><span style=\"color: #B5CEA8\">5</span><span style=\"color: #D4D4D4\"> };</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">scores</span><span style=\"color: #D4D4D4\">[NumTurns];</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div></p>\n</div>\n<p><strong>对于形似函数的宏，最好使用inline函数替换</strong></p>\n<p>原因如下：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#define</span><span style=\"color: #569CD6\"> CALL_WITH_MAX(</span><span style=\"color: #9CDCFE\">a</span><span style=\"color: #569CD6\">, </span><span style=\"color: #9CDCFE\">b</span><span style=\"color: #569CD6\">) func((a)&gt;(b)?(a):(b))</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> a = </span><span style=\"color: #B5CEA8\">5</span><span style=\"color: #D4D4D4\">, b = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #DCDCAA\">CALL_WITH_MAX</span><span style=\"color: #D4D4D4\">(++a, b);</span><span style=\"color: #6A9955\"> // a被累加两次！</span></span>\n<span class=\"line\"><span style=\"color: #DCDCAA\">CALL_WITH_MAX</span><span style=\"color: #D4D4D4\">(++a, b+</span><span style=\"color: #B5CEA8\">10</span><span style=\"color: #D4D4D4\">);</span><span style=\"color: #6A9955\"> // a被累加一次！</span></span></code></pre></div><p>假设有这样一个宏，则会发生离谱的事情！这时候就需要使用inline函数：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">template</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #569CD6\">typename</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">T</span><span style=\"color: #D4D4D4\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">inline</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">callWithMax</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">T</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">a</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">T</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">b</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">func</span><span style=\"color: #D4D4D4\">(a&gt;b?a:b);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>因此，预处理器扮演编译控制即可，其他的事情交给编译器。</p>\n<h2 id=\"3-尽量使用const\"><a href=\"#3-尽量使用const\" class=\"headerlink\" title=\"3 尽量使用const\"></a>3 尽量使用const</h2><p>让编译器来进行语义约束！</p>\n<p><strong>将某些东西声明为const可以帮助编译器侦测出错误用法。const可以被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</strong></p>\n<p>原因如下，这是一个用const避免错误用法的一个例子：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Rational</span><span style=\"color: #D4D4D4\"> { ... };</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Rational</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #C586C0\">operator*</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Rational</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #9CDCFE\">lhs</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Rational</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">rhs</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">Rational a, b, c;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">(a * b) = c;</span><span style=\"color: #6A9955\">//编译器可检查出这种错误</span></span></code></pre></div><p><strong>编译器强制实施bitwise constness，但是程序员必须实施conceptual constness。</strong></p>\n<p>原因如下，bitwise constness指的是const成员函数不能更改任何成员变量，这对编译器来说容易检测。然而通过bitwise并不代表该函数具有常量性质，例如：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">TextBlock</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    //const char&amp; operator[](std::size_t position) const //正确举例！！</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">char&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #C586C0\">operator[]</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">position</span><span style=\"color: #D4D4D4\">) </span><span style=\"color: #569CD6\">const</span><span style=\"color: #6A9955\">//错误举例，未能保证conceptual constness</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">text</span><span style=\"color: #D4D4D4\">[position];</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">private:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">char</span><span style=\"color: #D4D4D4\"> *text;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">TextBlock</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">tb</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"Hello\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #9CDCFE\">tb</span><span style=\"color: #D4D4D4\">[</span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">] = </span><span style=\"color: #CE9178\">'x'</span><span style=\"color: #D4D4D4\">;</span><span style=\"color: #6A9955\">//编译器不会报错,但是tb已经被修改了，失去了常量的意义</span></span>\n<span class=\"line\"></span></code></pre></div><p>与bitwise constness相对的conceptual constness指的是一个函数在逻辑上是const的，但是在bitwise上却不必然如此。但是编译器却是强制实施bitwise constness的，这时候可以使用mutable来修饰，跳过bitwise检测，例如：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">TextBlock</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">length</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (!lengthIsValid) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            lengthIsValid = </span><span style=\"color: #569CD6\">true</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            textLength = </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">strlen</span><span style=\"color: #D4D4D4\">(text);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> textLength;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">private:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">char</span><span style=\"color: #D4D4D4\"> *text;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">mutable</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> textLength;</span><span style=\"color: #6A9955\"> //使用mutable来修饰，跳过bitwise检测</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">mutable</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">bool</span><span style=\"color: #D4D4D4\"> lengthIsValid;</span><span style=\"color: #6A9955\"> //使用mutable来修饰，跳过bitwise检测</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span></code></pre></div><p><strong>当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可以避免代码重复。</strong></p>\n<p>单纯为了避免代码重复，提高代码的可维护性，做法如下：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">TextBlock</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">char&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #C586C0\">operator[]</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">position</span><span style=\"color: #D4D4D4\">) </span><span style=\"color: #569CD6\">const</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">text</span><span style=\"color: #D4D4D4\">[position];</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">char&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #C586C0\">operator[]</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">position</span><span style=\"color: #D4D4D4\">)</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span><span style=\"color: #6A9955\">   //进行类型转换，调用const版本</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">const_cast</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #569CD6\">char</span><span style=\"color: #D4D4D4\"> &amp;&gt;(</span><span style=\"color: #569CD6\">static_cast</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> TextBlock&amp;&gt;(*</span><span style=\"color: #569CD6\">this</span><span style=\"color: #D4D4D4\">)[position]);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span></code></pre></div><h2 id=\"4-确保对象被使用前已被初始化\"><a href=\"#4-确保对象被使用前已被初始化\" class=\"headerlink\" title=\"4 确保对象被使用前已被初始化\"></a>4 确保对象被使用前已被初始化</h2><p>将对象初始化的工作，C++在不同的环境下会有不同的表现。如果使用C part of C++ ,则不保证发生初始化，而如果使用non-C parts of C++，则规则会改变。因此，最好的做法是：手动初始化对象。</p>\n<p>因此：<strong>为内置型对象进行手工初始化，因为C++不保证初始化内置型对象。</strong></p>\n<p><strong>构造函数最好使用成员初值列，而不是在函数里面进行赋值操作。初值列列出的成员变量，其排列顺序应该和它们在class中的声明顺序相同。</strong></p>\n<p>在构造函数中，成员变量的初始化发生在进入构造函数本体之前，在函数里面进行赋值操作就浪费了之前的初始化过程，降低了效率。尽管内置类型的初始化和赋值的成本相同，为了一致性，也最好使用成员初值列。如果某些成员变量在“成员初值列”中没有指定初值，那么编译器会对用户自定义的类型的成员变量调用默认构造函数，对内置类型的成员变量则不会进行初始化（危险），因此，最好在“成员初值列”中列出所有的成员变量，以免忘记初始化。</p>\n<p>此外，C++总是以成员声明的次序来进行成员初始化，和构造函数的成员初值列的顺序无关，因此最好将成员初值列的顺序和成员声明的顺序保持一致。</p>\n<p><strong>为免除“跨编译单元之初始化次序问题”，请以local static对象替换non-local static对象。</strong></p>\n<p>原因如下，假设有两个源码文件：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #6A9955\">//源码文件1</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">FileSystem</span><span style=\"color: #D4D4D4\"> { </span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">numDisks</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\">; </span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">extern</span><span style=\"color: #D4D4D4\"> FileSystem tfs;</span><span style=\"color: #6A9955\">//non-local static对象</span></span></code></pre></div><div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #6A9955\">//源码文件2</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Directory</span><span style=\"color: #D4D4D4\"> { </span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">Directory</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">params</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">Directory</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">Directory</span><span style=\"color: #D4D4D4\">(params)</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> disks = </span><span style=\"color: #9CDCFE\">tfs</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">numDisks</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">Directory</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">tempDir</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">params</span><span style=\"color: #D4D4D4\">);</span></span></code></pre></div><p>可以看到，源码文件2中的Directory构造函数依赖于源码文件1中的tfs对象，但是C++不保证tfs对象能在Directory构造函数之前被初始化，可能会导致问题。解决的方法是使用单例模式：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #6A9955\">//源码文件1</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">FileSystem</span><span style=\"color: #D4D4D4\"> {...};</span></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">FileSystem</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">tfs</span><span style=\"color: #D4D4D4\">(){</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> FileSystem fs;</span><span style=\"color: #6A9955\">//local static对象</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> fs;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Directory</span><span style=\"color: #D4D4D4\"> {...};</span></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">Directory</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">Directory</span><span style=\"color: #D4D4D4\">(params)</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> disks = </span><span style=\"color: #DCDCAA\">tfs</span><span style=\"color: #D4D4D4\">().</span><span style=\"color: #DCDCAA\">numDisks</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p>任何一种non-const static对象，不论是local还是non-local，在多线程系统中都可能引发问题，一种做法是在单线程启动阶段手工调用所有的reference-returning函数，以消除“竞速形式”</p>\n\n</div>\n<h1 id=\"二、构造-析构-赋值运算\"><a href=\"#二、构造-析构-赋值运算\" class=\"headerlink\" title=\"二、构造/析构/赋值运算\"></a>二、构造/析构/赋值运算</h1><h2 id=\"5-了解C-默默编写并调用的函数\"><a href=\"#5-了解C-默默编写并调用的函数\" class=\"headerlink\" title=\"5 了解C++默默编写并调用的函数\"></a>5 了解C++默默编写并调用的函数</h2><p><strong>编译器可以暗自为class创建default构造函数、copy构造函数、copy assignment操作符和析构函数。</strong></p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Empty</span><span style=\"color: #D4D4D4\">{};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">Empty e1;</span><span style=\"color: #6A9955\">       //只要构造了对象，则会创建default构造函数和析构函数</span></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">Empty</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">e2</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">e1</span><span style=\"color: #D4D4D4\">);</span><span style=\"color: #6A9955\">   //只要执行这个操作，则会创建copy构造函数</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">e2 = e1;</span><span style=\"color: #6A9955\">        //只要用了赋值操作，则会创建copy assignment操作符</span></span></code></pre></div><p>只有当这些函数被需要的时候，编译器才会创建这些函数。</p>\n<p>编译器产生的析构函数是个non-virtual，除非它的base class中声明了一个virtual析构函数。</p>\n<p>编译器产生的copy构造函数会调用所有base classes以及成员变量的copy构造函数或拷贝操作进行拷贝。</p>\n<p>编译器产生的copy assignment操作符和copy构造函数的工作是一样的，但是如果成员变量有引用或者常量的话，亦或是其base class的copy assignment操作符是private的话，编译器就不会自行产生copy assignment操作符。</p>\n<h2 id=\"6-若不想使用编译器自动生成的函数，就该明确拒绝\"><a href=\"#6-若不想使用编译器自动生成的函数，就该明确拒绝\" class=\"headerlink\" title=\"6 若不想使用编译器自动生成的函数，就该明确拒绝\"></a>6 若不想使用编译器自动生成的函数，就该明确拒绝</h2><p><strong>为驳回编译器自动提供的机能，可将相应的成员函数声明为private并且不予实现。使用像Uncopyable这样的base class也是一种做法。</strong></p>\n<p>为了防止编译器自动生成的函数被客户调用，产生不可预期的行为，因此应该明确提示编译器不要生成这些函数。声明为private是一种方法，还有一种方法是使用Uncopyable这样的base class：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Uncopyable</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">protected:</span><span style=\"color: #D4D4D4\"> </span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">Uncopyable</span><span style=\"color: #D4D4D4\">() {} </span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">~Uncopyable</span><span style=\"color: #D4D4D4\">() {} </span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">private:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">Uncopyable</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Uncopyable</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">Uncopyable</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #C586C0\">operator=</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Uncopyable</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Money</span><span style=\"color: #D4D4D4\">: </span><span style=\"color: #569CD6\">private</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Uncopyable</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span></code></pre></div><p>C++11后，可以使用delete关键字来阻止编译器自动生成的函数：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Money</span><span style=\"color: #D4D4D4\">: </span><span style=\"color: #569CD6\">private</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Uncopyable</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">Money</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Money</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\">) = </span><span style=\"color: #569CD6\">delete</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span></code></pre></div><h2 id=\"7-为多态基类声明virtual析构函数\"><a href=\"#7-为多态基类声明virtual析构函数\" class=\"headerlink\" title=\"7 为多态基类声明virtual析构函数\"></a>7 为多态基类声明virtual析构函数</h2><p><strong>polyrmophic base classes应该声明一个virtual析构函数。如果class带有任何virtual函数（代表会有多态性），它就应该拥有一个virtual析构函数。</strong></p>\n<p>原因如下：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">TimeKeeper</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">TimeKeeper</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">~TimeKeeper</span><span style=\"color: #D4D4D4\">();</span><span style=\"color: #6A9955\">//non-virtual析构函数</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    //virtual ~TimeKeeper();//正确做法</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">AtomicClock</span><span style=\"color: #D4D4D4\">: </span><span style=\"color: #569CD6\">public</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">TimeKeeper</span><span style=\"color: #D4D4D4\"> {...};</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">WaterClock</span><span style=\"color: #D4D4D4\">: </span><span style=\"color: #569CD6\">public</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">TimeKeeper</span><span style=\"color: #D4D4D4\"> {...};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">TimeKeeper</span><span style=\"color: #569CD6\">*</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">getTimeKeeper</span><span style=\"color: #D4D4D4\">(){</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #C586C0\">new</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">AtomicClock</span><span style=\"color: #D4D4D4\">(...);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">TimeKeeper* ptk = </span><span style=\"color: #DCDCAA\">getTimeKeeper</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #C586C0\">delete</span><span style=\"color: #D4D4D4\"> ptk;</span><span style=\"color: #6A9955\">//只会调用TimeKeeper的析构函数，不会调用AtomicClock的析构函数</span></span></code></pre></div><p>这会产生一个局部销毁的对象，带来巨大的风险！</p>\n<p><strong>Class的设计目的如果不是作为base class使用，或不是为了具备多态性，就不应该声明virtual析构函数。</strong></p>\n<p>原因如下：如果某个类有virtual函数，内存中则会有一个vptr指针指向虚函数表，这不仅会增加内存开销，还使得和该类不再和其他语言内的相同声明有一样的结构，失去移植性。</p>\n<p>不声明virtual析构函数也通常意味着不希望该类被继承（并不绝对），因此在继承的时候需要小心的判断。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><p>即使class中完全没有virtual函数，也会出现这种情况，仅注意：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">StringClass</span><span style=\"color: #D4D4D4\">: </span><span style=\"color: #569CD6\">public</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">string</span><span style=\"color: #D4D4D4\"> {...};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">StringClass* psc = </span><span style=\"color: #C586C0\">new</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">StringClass</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"hello world\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::string* ps = psc;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">...</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">delete</span><span style=\"color: #D4D4D4\"> ps;</span></span></code></pre></div><p>std::string类不含virtual函数，这样的类被继承后，如果delete基类指针，会产生问题。同理所有的STL容器都是如此。</p>\n</p>\n</div>\n<p>“给base class声明一个virtual析构函数”这个规则只适用于带多态的base class上。</p>\n<h2 id=\"8-别让异常逃离析构函数\"><a href=\"#8-别让异常逃离析构函数\" class=\"headerlink\" title=\"8 别让异常逃离析构函数\"></a>8 别让异常逃离析构函数</h2><p><strong>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。</strong></p>\n<p>析构是内存操作，在析构发生异常后离开析构函数，可能会导致内存泄漏问题，或者产生不明确的行为，因此应该尽量避免异常离开析构函数。</p>\n<p>该怎么做：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">DBConnection</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">DBConnection</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">create</span><span style=\"color: #D4D4D4\">();</span><span style=\"color: #6A9955\">//返回DBConnection对象</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">close</span><span style=\"color: #D4D4D4\">();</span><span style=\"color: #6A9955\">//关闭链接,可能产生异常</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">DBConn</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">~DBConn</span><span style=\"color: #D4D4D4\">()</span><span style=\"color: #6A9955\">//析构函数</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">try</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">db</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">close</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">catch</span><span style=\"color: #D4D4D4\"> (...) {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            //记录异常，不传播</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            ...</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            // std::abort();//如果需要，则停止程序</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">private:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    DBConnection db;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span><span style=\"color: #6A9955\">//用户程序</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    DBConn </span><span style=\"color: #DCDCAA\">dbc</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">DBConnection</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">create</span><span style=\"color: #D4D4D4\">());</span><span style=\"color: #6A9955\">//获得数据库连接</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    //没有手动销毁</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span><span style=\"color: #6A9955\">//离开区块调用析构函数</span></span></code></pre></div><p>这种方法虽然可以避免异常离开析构函数，使得对象内存正常销毁，但是无法对产生的异常做出反应。因此另一种解决方法是将close的责任交给用户：</p>\n<p><strong>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。</strong></p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">DBConn</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">close</span><span style=\"color: #D4D4D4\">()</span><span style=\"color: #6A9955\">//给用户关闭的机会</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">db</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">close</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        closed = </span><span style=\"color: #569CD6\">true</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">~DBConn</span><span style=\"color: #D4D4D4\">()</span><span style=\"color: #6A9955\">//析构函数</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (!closed) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">try</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #9CDCFE\">db</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">close</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">catch</span><span style=\"color: #D4D4D4\"> (...) {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                //记录异常，不传播</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                ...</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                // std::abort();//如果需要，则停止程序</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">private:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    DBConnection db;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">bool</span><span style=\"color: #D4D4D4\"> closed;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span></code></pre></div><p>转移责任，让用户自己处理异常，析构函数的close仅用作双保险。</p>\n<h2 id=\"9-绝不在构造和析构过程中调用virtual函数\"><a href=\"#9-绝不在构造和析构过程中调用virtual函数\" class=\"headerlink\" title=\"9 绝不在构造和析构过程中调用virtual函数\"></a>9 绝不在构造和析构过程中调用virtual函数</h2><p><strong>在构造和析构期间不要调用virtual函数，因为这类调用从不下降至derived class。</strong></p>\n<p>在base class构造期间，virtual函数不是virtual函数！为什么C++有这个特性呢？由于base class的构造函数早于derived class的构造函数执行，如果此时调用virtual函数下降到derived class，那么derived class的构造函数还没有执行，这样就会导致不明确的行为，因此C++不会将virtual函数调用下降到derived class，而是保持在base class的版本。</p>\n<p>同理析构函数。</p>\n<p>例子如下：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Transaction</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">Transaction</span><span style=\"color: #D4D4D4\">(){ </span><span style=\"color: #DCDCAA\">init</span><span style=\"color: #D4D4D4\">(); }</span><span style=\"color: #6A9955\">//编译器和连接器都不会报错，运行时系统终止</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">virtual</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">logTransaction</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span><span style=\"color: #6A9955\">//纯虚函数</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">private:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">init</span><span style=\"color: #D4D4D4\">() { </span><span style=\"color: #DCDCAA\">logTransaction</span><span style=\"color: #D4D4D4\">(); }</span><span style=\"color: #6A9955\">//调用纯虚函数</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span></code></pre></div><p>在这个例子中，在构造函数中间接调用纯虚函数，连接器则不会报错，但是运行时系统会终止。如果直接调用了纯虚函数，那么连接器则会报错。如果直接调用了非纯虚函数，那么连接器则不会报错，但是会调用base class的版本。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p>注意是“在构造和析构期间”，因此需要递归地检查所有的构造函数和析构函数，以及它们调用的函数，确保不违反这一准则。</p>\n\n</div>\n<p>那如何达到原本的目的呢？可以使用non-virtual interface（NVI）,既然无法使用virtual函数从base class下降到derived class，那就在构造期间令derived class将必要的构造信息传递给base class。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Transaction</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">explicit</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">Transaction</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">string</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">logInfo</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">logTransaction</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">string</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">logInfo</span><span style=\"color: #D4D4D4\">) </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">Transaction</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">Transaction</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::string&amp; logInfo)</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">logTransaction</span><span style=\"color: #D4D4D4\">(logInfo);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">BuyTransaction</span><span style=\"color: #D4D4D4\">: </span><span style=\"color: #569CD6\">public</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Transaction</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">BuyTransaction</span><span style=\"color: #D4D4D4\">(...): </span><span style=\"color: #DCDCAA\">Transaction</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #DCDCAA\">createLogString</span><span style=\"color: #D4D4D4\">(...)) {...}</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">private:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">string</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">createLogString</span><span style=\"color: #D4D4D4\">(...);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span></code></pre></div><h2 id=\"10-令operator-返回一个reference-to-this\"><a href=\"#10-令operator-返回一个reference-to-this\" class=\"headerlink\" title=\"10 令operator=返回一个reference to *this\"></a>10 令operator=返回一个reference to *this</h2><p>*<em>令operator=返回一个reference to <em>this。</em></em></p>\n<p>这是为了支持连锁赋值，例如：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> x, y, z;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">x = y = z = </span><span style=\"color: #B5CEA8\">15</span><span style=\"color: #D4D4D4\">;</span></span></code></pre></div><p>这个准则不仅适用于标准的赋值形式，也适用于+=、-=、*=、/=等运算符。</p>\n<p>但是这个守则并无强制性，不遵守也不会产生什么问题，仅仅是不方便。</p>\n<h2 id=\"11-在operator-中处理“自我赋值”\"><a href=\"#11-在operator-中处理“自我赋值”\" class=\"headerlink\" title=\"11 在operator=中处理“自我赋值”\"></a>11 在operator=中处理“自我赋值”</h2><p><strong>确保当对象自我赋值时operator=有良好的行为。其中技术包括比较来源对象和目标对象的地址、精心周到的语句顺序、以及copy-and-swap。</strong></p>\n<p>自我赋值是指将一个对象赋值给自己。</p>\n<p>例如：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Bitmap</span><span style=\"color: #D4D4D4\"> {...};</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">Bitmap b;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">b = b;</span><span style=\"color: #6A9955\">//明显的自我赋值</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">a</span><span style=\"color: #D4D4D4\">[</span><span style=\"color: #B5CEA8\">10</span><span style=\"color: #D4D4D4\">],x=</span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">,y=</span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #9CDCFE\">a</span><span style=\"color: #D4D4D4\">[x] = </span><span style=\"color: #9CDCFE\">a</span><span style=\"color: #D4D4D4\">[y];</span><span style=\"color: #6A9955\">//不明显的自我赋值</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> * px = a+</span><span style=\"color: #B5CEA8\">3</span><span style=\"color: #D4D4D4\">, * py = a+</span><span style=\"color: #B5CEA8\">3</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">*px = *py;</span><span style=\"color: #6A9955\">//不明显的自我赋值</span></span></code></pre></div><p>这里重点记录copy-and-swap技术：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Widget</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">Widget</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #C586C0\">operator=</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Widget</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">rhs</span><span style=\"color: #D4D4D4\">)</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        Widget </span><span style=\"color: #DCDCAA\">temp</span><span style=\"color: #D4D4D4\">(rhs);</span><span style=\"color: #6A9955\">//调用拷贝构造函数</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">swap</span><span style=\"color: #D4D4D4\">(temp,*</span><span style=\"color: #569CD6\">this</span><span style=\"color: #D4D4D4\">);</span><span style=\"color: #6A9955\">//调用swap函数</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #569CD6\">this</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Object</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">Object</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #C586C0\">operator=</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">Object</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">rhs</span><span style=\"color: #D4D4D4\">)</span><span style=\"color: #6A9955\">//传值调用，调用拷贝构造函数</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">swap</span><span style=\"color: #D4D4D4\">(rhs,*</span><span style=\"color: #569CD6\">this</span><span style=\"color: #D4D4D4\">);</span><span style=\"color: #6A9955\">//调用swap函数</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #569CD6\">this</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span></code></pre></div><p><strong>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。</strong></p>\n<h2 id=\"12-复制对象时勿忘其每一个成分\"><a href=\"#12-复制对象时勿忘其每一个成分\" class=\"headerlink\" title=\"12 复制对象时勿忘其每一个成分\"></a>12 复制对象时勿忘其每一个成分</h2><p><strong>Copying函数应该确保复制“对象内的所有成员变量”及“所有base class成分”。</strong></p>\n<p>当编写Copying函数的时候，检查以下两点：</p>\n<ol>\n<li>复制所有的local成员变量</li>\n<li>调用所有的base class的Copying函数（容易忽视）</li>\n</ol>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> B extends </span><span style=\"color: #4EC9B0\">A</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">B</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #C586C0\">operator=</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">B</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">rhs</span><span style=\"color: #D4D4D4\">)</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #4EC9B0\">A</span><span style=\"color: #D4D4D4\">::operator=(rhs);</span><span style=\"color: #6A9955\">//调用base class的Copying函数</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #569CD6\">this</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">B</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">B</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">rhs</span><span style=\"color: #D4D4D4\">):</span><span style=\"color: #DCDCAA\">A</span><span style=\"color: #D4D4D4\">(rhs)</span><span style=\"color: #6A9955\">//调用base class的Copying函数</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span></code></pre></div><p><strong>不要尝试以某个copy函数实现另一个copy函数。应该将共同机能放进第三个函数，然后由两个copy函数共同调用它。</strong></p>\n<h1 id=\"三、资源管理\"><a href=\"#三、资源管理\" class=\"headerlink\" title=\"三、资源管理\"></a>三、资源管理</h1><p>一旦用了资源，在将来必须还给系统。</p>\n<h2 id=\"13-以对象管理资源\"><a href=\"#13-以对象管理资源\" class=\"headerlink\" title=\"13 以对象管理资源\"></a>13 以对象管理资源</h2><p><strong>为了防止资源泄漏，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。</strong></p>\n<p>通过谨慎地编写代码，确保资源在任何情况下都会被释放。这不但要消耗精力，而且还要软件开始接受维护被修改时常常会使得这种保证失效。因此需要通过把资源放到对象中，然后依赖C++的析构函数来确保资源被释放。</p>\n<p>以对象管理资源的两个关键想法：</p>\n<ol>\n<li>获得资源后立刻放进管理对象内。</li>\n<li>管理对象运用析构函数确保资源被释放。（请确保遵守条款8）</li>\n</ol>\n<p><strong>两个常见的RAII class分别是std::shared_ptr和std::unique_ptr,前者通常是较佳选择，因为其copy行为比较直观。若选择std::unique_ptr，则需要使用std::move来进行转移。</strong></p>\n<h2 id=\"14-在资源管理类中小心copying行为\"><a href=\"#14-在资源管理类中小心copying行为\" class=\"headerlink\" title=\"14 在资源管理类中小心copying行为\"></a>14 在资源管理类中小心copying行为</h2><p>并非所有的资源都是heap-based，对于那种资源来说，智能指针可能不是最佳选择。在某些时候，需要创建资源管理类。</p>\n<p><strong>复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。</strong></p>\n<p>当一个RAII对象被复制时，有哪些做法？</p>\n<ol>\n<li>禁止复制（不应该被复制）</li>\n<li>施行引用计数（保有资源直到最后一个引用者被销毁）</li>\n<li>复制底部资源（不再需要资源时进行释放）</li>\n<li>转移底部资源的拥有权（只希望有一个对象指向对应的资源）</li>\n</ol>\n<p><strong>普遍而常见的RAII class copying行为是：抑制copying、施行引用计数、转移底部资源的ownership。</strong></p>\n<h2 id=\"15-在资源管理类中提供对原始资源的访问\"><a href=\"#15-在资源管理类中提供对原始资源的访问\" class=\"headerlink\" title=\"15 在资源管理类中提供对原始资源的访问\"></a>15 在资源管理类中提供对原始资源的访问</h2><p><strong>APIs往往要求访问原始资源，所以每一个RAII class都应该提供一个“取得其所管理之资源”的方法。</strong></p>\n<p><strong>对原始资源的访问可能经由显式转换或隐式转换。一般而言，显式转换比较安全，但是隐式转换对客户比较方便。</strong></p>\n<p>提供显式转换还是隐式转换，主要取决于RAII class被设计执行的特定工作，以及它被使用的情况。提供对原始资源的访问，看似破坏了封装性，但其实RAII class的目的并不是为了封装，而是为了使资源释放一定会发生，因此提供对原始资源的访问是合理的。</p>\n<h2 id=\"16-成对使用new和delete时要采取相同形式\"><a href=\"#16-成对使用new和delete时要采取相同形式\" class=\"headerlink\" title=\"16 成对使用new和delete时要采取相同形式\"></a>16 成对使用new和delete时要采取相同形式</h2><p><strong>如果你在new后面使用[]，就要在delete后面使用[]；如果你在new后面不使用[]，就不要在delete后面使用[]。</strong></p>\n<p>编译器需要知道，即将被删除的那个指针，指向的是一个对象，还是一个对象数组。单一对象的内存布局和数组对象的内存布局是不同的，数组一般有一个“数组大小记录”，因此需要告诉编译器，如何理解这段内存。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><p>尽量不要对数组形式做typedefs动作，因为这样会使得确定delete形式变得困难且易出错。</p>\n</p>\n</div>\n<h2 id=\"17-以独立语句将newed对象置入智能指针\"><a href=\"#17-以独立语句将newed对象置入智能指针\" class=\"headerlink\" title=\"17 以独立语句将newed对象置入智能指针\"></a>17 以独立语句将newed对象置入智能指针</h2><p><strong>以独立语句将newed对象置入智能指针。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄漏。</strong></p>\n<p>原因如下：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">priority</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">processWidget</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">shared_ptr</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #4EC9B0\">Widget</span><span style=\"color: #D4D4D4\">&gt; </span><span style=\"color: #9CDCFE\">pw</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">priority</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">//调用processWidget</span></span>\n<span class=\"line\"><span style=\"color: #DCDCAA\">processWidget</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">shared_ptr</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #4EC9B0\">Widget</span><span style=\"color: #D4D4D4\">&gt;(</span><span style=\"color: #C586C0\">new</span><span style=\"color: #D4D4D4\"> Widget), </span><span style=\"color: #DCDCAA\">priority</span><span style=\"color: #D4D4D4\">());</span><span style=\"color: #6A9955\">//可能会导致资源泄漏！！！</span></span></code></pre></div><p>调用processWidget的时候，编译器要做3件事：</p>\n<ol>\n<li>调用new Widget</li>\n<li>调用std::shared_ptr的构造函数</li>\n<li>调用priority</li>\n</ol>\n<p>可以确定new Widget的过程一定发生在std::shared_ptr构造函数之前。但是priority的调用时间在C++中并没有明确的规定。假设以这样的顺序调用：</p>\n<ol>\n<li>调用new Widget</li>\n<li>调用priority</li>\n<li>调用std::shared_ptr的构造函数</li>\n</ol>\n<p>万一priority抛出异常，那么new Widget产生的对象就会泄漏！！！因此，最好的做法是,将这个操作独立出来：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">shared_ptr</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #4EC9B0\">Widget</span><span style=\"color: #D4D4D4\">&gt; </span><span style=\"color: #DCDCAA\">pw</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #C586C0\">new</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">Widget</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #DCDCAA\">processWidget</span><span style=\"color: #D4D4D4\">(pw, </span><span style=\"color: #DCDCAA\">priority</span><span style=\"color: #D4D4D4\">());</span></span></code></pre></div><h1 id=\"四、设计与声明\"><a href=\"#四、设计与声明\" class=\"headerlink\" title=\"四、设计与声明\"></a>四、设计与声明</h1><h2 id=\"18-让接口容易被正确使用，不易被误用\"><a href=\"#18-让接口容易被正确使用，不易被误用\" class=\"headerlink\" title=\"18 让接口容易被正确使用，不易被误用\"></a>18 让接口容易被正确使用，不易被误用</h2><p>理想上，如果客户调用了你的接口而没有获得预期的结果，那么这个代码就不该通过编译。如果代码通过了编译，它的作为就是客户想要的。</p>\n<p><strong>好的接口容易被正确使用，不易被误用。你应该在你的所有接口中努力达成这些性质。</strong></p>\n<p><strong>“促进正确使用”的帮法包括接口的一致性，以及与内置类型的行为兼容。</strong></p>\n<p><strong>“阻止误用”的手法包括建立新类型、限制类型上的操作、束缚对象值以及消除客户的资源管理责任。</strong></p>\n<p><strong>std::shared_ptr支持定制型删除器。这可防范DLL问题，可被用来自动解除互斥锁。</strong></p>\n<h2 id=\"19-设计class犹如设计type\"><a href=\"#19-设计class犹如设计type\" class=\"headerlink\" title=\"19 设计class犹如设计type\"></a>19 设计class犹如设计type</h2><p><strong>class的设计就是type的设计。在定义一个新type之前，请确定你已经考虑过本条款覆盖的所有讨论主题</strong></p>\n<ol>\n<li>新type的对象应该如何被创建和销毁</li>\n<li>对象的初始化和对象的赋值应该有什么样的差别</li>\n<li>新type的对象如果被passed by value，意味着什么（拷贝构造函数的实现）</li>\n<li>什么是新type的“合法值”</li>\n<li>你的新type需要配合某个继承体系吗</li>\n<li>你的新type需要什么样的转换</li>\n<li>什么样的操作符和函数对你的新type是合理的</li>\n<li>什么样的标准函数应该被驳回</li>\n<li>谁该取用新type的成员</li>\n<li>什么是新type的“未声明接口”</li>\n<li>你的新type有多么一般化？（class或class template）</li>\n<li>你真的需要一个新type吗？</li>\n</ol>\n<h2 id=\"20-宁以pass-by-reference-to-const替换pass-by-value\"><a href=\"#20-宁以pass-by-reference-to-const替换pass-by-value\" class=\"headerlink\" title=\"20 宁以pass-by-reference-to-const替换pass-by-value\"></a>20 宁以pass-by-reference-to-const替换pass-by-value</h2><p><strong>尽量以pass-by-reference-to-const替换pass-by-value。前者通常比较高效，而且可以避免切割问题。</strong></p>\n<p>原因如下，pass-by-value会导致对象的拷贝，会增加在函数中会招致额外的构造和析构成本。相比之下，pass-by-reference-to-const仅仅传递指针。同时，by-reference方式传递参数，可以避免切割问题：当一个derived class对象以by-value方式传递给一个base class对象时，base class的构造函数被调用，导致derived class对象被切割，损失其多态特性！！！</p>\n<p>其次，某些编译器的实现对待“内置类型”和“用户自定义类型”的态度截然不同（只把指针和内置类型放到寄存器内），保险起见，更应该使用pass-by-reference来传递对象来获得更好的性能。</p>\n<p><strong>以上规则不适用于内置类型和STL迭代器和函数对象。对他们而言，pass-by-value往往比较合适。</strong></p>\n<p>对于内置类型而言，pass-by-value比pass-by-reference效率高。STL也是如此，因为它们都被设计为pass-by-value。</p>\n<h2 id=\"21-必须返回对象时，不要妄想返回reference\"><a href=\"#21-必须返回对象时，不要妄想返回reference\" class=\"headerlink\" title=\"21 必须返回对象时，不要妄想返回reference\"></a>21 必须返回对象时，不要妄想返回reference</h2><p><strong>绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象，或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。条款4已经为“在单线程环境中合理返回reference指向一个local static对象”提供了一个实例。</strong></p>\n<p>如果返回一个指向local stack对象，那么该对象在函数退出时就已经被销毁。如果返回一个指向heap-allocated对象，那么谁来保证能释放这个对象？如果返回一个指向local static对象，不仅会导致线程安全问题，更加深层的问题是这个：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Rational</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #C586C0\">operator*</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Rational</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">lhs</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Rational</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">rhs</span><span style=\"color: #D4D4D4\">)</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> Rational result;</span><span style=\"color: #6A9955\">//local static对象</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    result = </span><span style=\"color: #9CDCFE\">lhs</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">value</span><span style=\"color: #D4D4D4\">() * </span><span style=\"color: #9CDCFE\">rhs</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">value</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> result;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">Rational a, b, c, d;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">...</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> ((a * b) == (c * d)) {...}</span><span style=\"color: #6A9955\">//该表达式永远为true！</span></span></code></pre></div><p>如果返回reference只是为了逃避必要的构造和析构的开销，那么其带来的后果比起这些开销要严重得多！况且在编译器的优化下，返回值的构造和析构的开销都有可能被消除，你的工作只有编写出行为正确的代码，返回值开销问题请交给编译器。</p>\n<h2 id=\"22-将成员变量声明为private\"><a href=\"#22-将成员变量声明为private\" class=\"headerlink\" title=\"22 将成员变量声明为private\"></a>22 将成员变量声明为private</h2><p><strong>切记将成员变量声明为private。这可赋予客户访问数据的一致性，可细微划分访问控制，许诺约束条件获得保证，并提供class作者以充分的实现弹性。</strong></p>\n<p>为什么不采用public成员变量呢？</p>\n<ol>\n<li>语法一致性：如果成员变量不是public，那么唯一能访问对象的就是成员函数。这样遵循了条款18。</li>\n<li>比起public成员变量，使用成员函数可以更精确的控制成员变量的处理，进行访问控制。</li>\n<li>保持了封装性，为“所有可能的实现”提供了弹性，维护了class的约束条件，修改实现时不会影响客户。</li>\n</ol>\n<p><strong>protected并不比public更具封装性。</strong></p>\n<h2 id=\"23-宁以non-member、non-friend替换member函数\"><a href=\"#23-宁以non-member、non-friend替换member函数\" class=\"headerlink\" title=\"23 宁以non-member、non-friend替换member函数\"></a>23 宁以non-member、non-friend替换member函数</h2><p><strong>宁可拿non-member、non-friend函数替换member函数。这样做可以增加封装性、包裹弹性和机能扩充性。</strong></p>\n<p>原因如下：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">WebBrowser</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">clearCache</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">clearHistory</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">removeCookies</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">clearEverything</span><span style=\"color: #D4D4D4\">();</span><span style=\"color: #6A9955\">//member函数实现，调用上述三个函数</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">clearBrowser</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">WebBrowser</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">wb</span><span style=\"color: #D4D4D4\">)</span><span style=\"color: #6A9955\">//non-member函数实现</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">wb</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">clearCache</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">wb</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">clearHistory</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">wb</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">removeCookies</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>都是清理浏览器的操作，member实现和non-member,non-friend实现到底哪个好呢？面向对象的规则要求我们将数据和操作放在一起，使得一些人误以为member实现更加符合面向对象的规则，其实不然。在封装性上，non-member,non-friend实现能比member实现有更好的封装性！</p>\n<p>越少的代码可以访问数据，封装性就越好。那么如何测量“可以访问数据的代码”这一指标呢？作为一个粗糙的测量：越多的函数可以访问它，数据的封装性越低。因此，在提供相同功能的member和non-member,non-friend函数中做选择，导致较大封装性的一定是non-member,non-friend函数。</p>\n<p>此外，提供non-member函数可允许对WebBrowser相关的机能有较大的包裹弹性，导致较低的编译相依度，增加了WebBrowser的机能扩充性。</p>\n<p>对于上述例子，C++比较自然的做法是让clearBrowser这样的便利函数成为一个non-member,non-friend函数并位于WebBrowser的同一个namespace中。</p>\n<h2 id=\"24-若所有参数皆需类型转换，请为此采用non-member函数\"><a href=\"#24-若所有参数皆需类型转换，请为此采用non-member函数\" class=\"headerlink\" title=\"24 若所有参数皆需类型转换，请为此采用non-member函数\"></a>24 若所有参数皆需类型转换，请为此采用non-member函数</h2><p><strong>如果你需要为某个函数的所有参数（包括被this指针所指的那个隐喻对象）进行类型转换，那么这个函数必须是个non-member函数。</strong></p>\n<p>这在操作符重载中尤为重要。只有参数被位于参数列内，这个参数才是隐式转换的合格参与者，而this对象则不会被隐式转换！！！</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p>太多C++程序员假设，如果一个“与某class相关”的函数不是member函数，就该是个friend函数。但是其实没有必要一定是friend函数：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Rational</span><span style=\"color: #D4D4D4\"> {...};</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Rational</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #C586C0\">operator*</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Rational</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">lhs</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Rational</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">rhs</span><span style=\"color: #D4D4D4\">){</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">Rational</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #9CDCFE\">lhs</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">numerator</span><span style=\"color: #D4D4D4\">()*</span><span style=\"color: #9CDCFE\">rhs</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">numerator</span><span style=\"color: #D4D4D4\">(),</span><span style=\"color: #9CDCFE\">lhs</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">denominator</span><span style=\"color: #D4D4D4\">()*</span><span style=\"color: #9CDCFE\">rhs</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">denominator</span><span style=\"color: #D4D4D4\">());</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>不论何时，如果你可以避免friend函数，就该避免。虽然有时候friend函数是有需要的，但不能只因函数不该成为member，就自动将它变成friend。</p>\n\n</div>\n<h2 id=\"25-考虑写出一个不抛异常的swap函数\"><a href=\"#25-考虑写出一个不抛异常的swap函数\" class=\"headerlink\" title=\"25 考虑写出一个不抛异常的swap函数\"></a>25 考虑写出一个不抛异常的swap函数</h2><p><strong>当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常</strong></p>\n<p>std::swap函数是一个模板函数，调用的过程会导致一次拷贝构造和两次赋值操作。对于某些对象而言，这样的操作是不必要的，因此可以自己提供一个swap成员函数，以提高效率。由于swap的一个最好的应用是帮助class（和class templates）提供强烈的异常安全性保障，因此swap函数绝对不应该抛出异常，该约束只施行于成员版，不施行于非成员版，因为swap的缺省版是以copy构造函数和copy assignment操作符来实现的，这两者都允许抛出异常。</p>\n<p><strong>如果你提供一个member swap，也该提供一个non-member swap用来调用前者。对于classes（而非templates），也特化一个std::swap。</strong></p>\n<p>为了让他人调用swap的时候总是能取得我们提供的较高效的特定版本，这种做法不仅可以通过编译，还与STL容器具有一致性。因为STL容器也都提供有public swap成员函数和std::swap的特化版本（用以调用前者）。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Widget</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">swap</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">Widget</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">other</span><span style=\"color: #D4D4D4\">){</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">using</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::swap;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">swap</span><span style=\"color: #D4D4D4\">(impl,</span><span style=\"color: #9CDCFE\">other</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">impl</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">private:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    WidgetImpl* impl;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">swap</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">Widget</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">a</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #4EC9B0\">Widget</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">b</span><span style=\"color: #D4D4D4\">)</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">a</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">swap</span><span style=\"color: #D4D4D4\">(b);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">//因为Widget是一个class不是一个class template，所以需要特化std::swap。</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">//如果是个class template，那就不必考虑特化std::swap的事了（编译不可能通过）</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">//因为C++不能对function template进行偏特化，std::swap也不建议被重载，因为其行为是不确定的。</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">namespace</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">template</span><span style=\"color: #D4D4D4\">&lt;&gt;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">swap</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #4EC9B0\">Widget</span><span style=\"color: #D4D4D4\">&gt;(Widget&amp; a, Widget&amp; b)</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">a</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">swap</span><span style=\"color: #D4D4D4\">(b);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p><strong>调用swap的时候，应该针对std::swap使用using声明式，然后调用swap并且不带任何命名空间修饰。</strong></p>\n<p>站在用户的角度，假设正在写一个templete函数，那么调用swap的时候，如何确保能够在T的专属版本存在的情况下调用T的专属版本，在T的专属版本不存在的情况下调用std::swap的一般化版本呢？</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">template</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #569CD6\">typename</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">T</span><span style=\"color: #D4D4D4\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">doSomething</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">T</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">lhs</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #4EC9B0\">T</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">rhs</span><span style=\"color: #D4D4D4\">)</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">using</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::swap;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">swap</span><span style=\"color: #D4D4D4\">(lhs,rhs);</span><span style=\"color: #6A9955\">//自动调用合适的版本</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>在这种情况下，如果T有专属版本的swap，那么C++能够查到global作用域或T所在命名空间内的任何T专属swap版本。如果没有，那么C++会调用std::swap。即使如此，std::swap的T专属特化版的优先级也比std::swap的一般化版本高。</p>\n<p><strong>为“用户定义类型”进行std templates全特化是好的，但是千万不要尝试在std命名空间内增加对std而言全新的东西（如重载std::swap）。</strong></p>\n<h1 id=\"五、实现\"><a href=\"#五、实现\" class=\"headerlink\" title=\"五、实现\"></a>五、实现</h1><p>写出定义和声明是花费心思最多的事，实现通常不会太花心思，然而：太快定义变量可能造成效率上的拖延，过度使用转型可能导致代码又慢又难以维护，返回对象handle可能会破坏封装并留给客户虚吊的号码牌。未考虑异常带来的冲击则可能导致资源泄漏和数据败坏，而过度使用inline可能导致代码膨胀，过度耦合可能导致冗长的编译时间。</p>\n<h2 id=\"26-尽可能延后变量定义式的出现时间\"><a href=\"#26-尽可能延后变量定义式的出现时间\" class=\"headerlink\" title=\"26 尽可能延后变量定义式的出现时间\"></a>26 尽可能延后变量定义式的出现时间</h2><p><strong>尽可能延后变量定义式的出现时间。这样做可增加程序清晰度并提高效率。</strong></p>\n<p>一个变量被定义，通常意味着增加了构造和析构的成本。如果程序在 一个变量定义之后，使用之前 的过程中抛出了异常，那么这个变量就没有被使用，致使白白增加了构造和析构的成本。因此，尽可能延后变量定义式的出现时间，直到非得使用变量的前一刻为止，<em>甚至延后到能给这份定义一个初值的时候（使用构造函数传递）</em>。</p>\n<p>循环怎么办？下列两种写法：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #D4D4D4\">Widget w;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> i = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">; i &lt; n; ++i){</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    w = 取决于i的某个值；</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> i = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">; i &lt; n; ++i){</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    Widget </span><span style=\"color: #DCDCAA\">w</span><span style=\"color: #D4D4D4\">(取决于i的某个值)；</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>从成本上看，第一种做法的成本是：1个构造函数+1个析构函数+n个赋值操作；第二种做法的成本是n个构造函数+n个析构函数。在这种情况下要精心计算成本来进行选择。但是第一种做法会使得w的作用域变大，从而降低可理解性和易维护性。因此除非你知道赋值成本小于“构造+析构”成本，或是处理效率高度敏感的部分，否则应该使用第二种做法。</p>\n<h2 id=\"27-尽量少做转型动作\"><a href=\"#27-尽量少做转型动作\" class=\"headerlink\" title=\"27 尽量少做转型动作\"></a>27 尽量少做转型动作</h2><p><strong>如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_cast。如果有个设计需要转型动作，试着发展出一个不需要转型的设计。</strong></p>\n<p>原因如下，我们有可能写出下面这个看似正确的代码（在其他语言中还真有可能是对的），SpecialWindow的onResize要先调用Window的onResize，以此修改该对象的base class部分：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Window</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">virtual</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">onResize</span><span style=\"color: #D4D4D4\">() {...}</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">SpecialWindow</span><span style=\"color: #D4D4D4\">: </span><span style=\"color: #569CD6\">public</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Window</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">virtual</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">onResize</span><span style=\"color: #D4D4D4\">() {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #569CD6\">static_cast</span><span style=\"color: #D4D4D4\">&lt;Window&gt;(*</span><span style=\"color: #569CD6\">this</span><span style=\"color: #D4D4D4\">).</span><span style=\"color: #DCDCAA\">onResize</span><span style=\"color: #D4D4D4\">();</span><span style=\"color: #6A9955\">//调用了*this的bass class成分的副本的onResize！！！错误的做法</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        //Window::onResize();//正确的做法</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span></code></pre></div><p>Window::onResize的功能修改了一些成员变量，但其实其改动的只是一个副本！！！</p>\n<p>再说dynamic_cast，它的许多实现效率非常低下（对class名字进行字符串比较）（因为要支持动态链接嘛）。而之所以dynamic_cast被需要，是因为想在你认定为derived class的对象上执行derived class的操作，但是手头上只有base class的指针。这种情况下，如何避免使用dynamic_cast呢？</p>\n<ol>\n<li>消除“通过base class接口处理对象”的需要。使用容器并在其中存放指向derived class对象的指针（通常是智能指针）。</li>\n<li>提供virtual函数来处理你想对各个派生类做的事。</li>\n</ol>\n<p><strong>宁可以用C++-style转型，不要使用旧式转型，前者很容易被识别出来，而且也比较有着分门别类的职掌。</strong></p>\n<p>转型动作分为3种：C风格的转型、函数风格的转型、C++风格的转型。前两者形式基本上除了括号的位置，没有什么区别，称为旧式转型。C++提供了4种新式转型：</p>\n<ol>\n<li>const_cast，用来移除const性</li>\n<li>dynamic_cast，用来进行安全的向下转型</li>\n<li>reinterpret_cast，用来进行低级转型（不可移植）</li>\n<li>static_cast，用来进行隐式转型</li>\n</ol>\n<p>新的转型由于有固定的关键字因此易被找到，而且转型动作的目标更窄化，编译器也可以介入检查。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><p>“转型其实什么都没做，只是告诉编译器把某种类型视为另一种类型”是一个错误的观念！！！任何一个类型转换往往真的令编译器编译出运行期间执行的代码。如将int转换成double的操作，又如下面这种操作：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Window</span><span style=\"color: #D4D4D4\"> { ... };</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">SpecialWindow</span><span style=\"color: #D4D4D4\">: </span><span style=\"color: #569CD6\">public</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Window</span><span style=\"color: #D4D4D4\"> { ... };</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">SpecialWindow ps;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">Window* pw = &amp;ps;</span><span style=\"color: #6A9955\">//隐喻地将SpecialWindow*转换成Window*</span></span></code></pre></div><p>注意，这里在C++中存在ps的值和pw的值不一致的情况！！！有一个偏移量被施加在了ps的值上用于得到pw的值。<em>单一对象可能拥有多个地址</em>，一旦使用多重继承，这件事几乎一直发生着（单一继承也有可能会）。<em>因此也不应该以知道“对象在C++中如何布局”为前提，执行任何转型动作。</em></p>\n</p>\n</div>\n<p><strong>如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需要自己执行转型。</strong></p>\n<h2 id=\"28-避免返回handles指向对象内部成分\"><a href=\"#28-避免返回handles指向对象内部成分\" class=\"headerlink\" title=\"28 避免返回handles指向对象内部成分\"></a>28 避免返回handles指向对象内部成分</h2><p><strong>避免返回handles（包括references、指针、迭代器）指向对象内部。遵守这个条款可以增加封装性，帮助const成员函数的行为像个const，并将发生“虚吊号码牌”问题的机会减至最低。</strong></p>\n<p>原因如下，返回handles指向对象内部，可能导致成员变量的封装性降低，因为成员变量的封装性最多等于“返回其reference的函数的封装性”。也可能导致“虽然调用const成员函数却造成对象状态被更改”。最后的关键在于，有一个handle被传出去了，是的代码暴露在“handle比其所指对象的寿命更长”的风险之下。</p>\n<h2 id=\"29-为“异常安全”而努力是值得的\"><a href=\"#29-为“异常安全”而努力是值得的\" class=\"headerlink\" title=\"29 为“异常安全”而努力是值得的\"></a>29 为“异常安全”而努力是值得的</h2><p><strong>异常安全函数即使发生异常也不会泄露资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型。</strong></p>\n<ol>\n<li>基本型，如果异常被抛出，程序内的任何事物仍然保持在有效状态（但是对程序现实状态没有要求）。</li>\n<li>强烈型，如果异常被抛出，程序状态不会改变（让人联想到“事务”）</li>\n<li>不抛异常型，一定能完成它的工作，不会抛出异常。（作用在内置类型身上的所有操作都能提供该保证）</li>\n</ol>\n<p>可能的话，最好提供“不抛异常型”的保证，但是大部分函数而言，往往只能在“基本型”和“强烈型”中选择。</p>\n<p><strong>“强烈保证”往往能够以copy-and-swap实现出来，但“强烈保证”并非对所有函数都可实现或具备现实意义。</strong></p>\n<p>copy一个副本并在副本上进行修改，然后swap副本和源对象。但是总有一些函数是无法实现“强烈保证”，除去copy-and-swap过程带来的效率问题，还有下面这种“连带影响”的问题导致的困难：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">doSomething</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">changeDataBase</span><span style=\"color: #D4D4D4\">(...);</span><span style=\"color: #6A9955\">//修改外部的数据库</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">changeLocal</span><span style=\"color: #D4D4D4\">(...);</span><span style=\"color: #6A9955\">//修改本地数据</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>如果在changeDataBase的动作送出之后（即修改了非局部数据），一旦changeLocal抛出异常，没有什么办法恢复数据库的旧观（因为可能其他客户已经拿到这一笔新数据）。因此，这种情况下，只能提供“基本型”保证。</p>\n<p><strong>函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。</strong></p>\n<p>就像上述代码，假设changeDataBase不提供任何异常安全保证，那么doSomething也不可能提供任何异常安全保证。</p>\n<h2 id=\"30-透彻了解inlining的里里外外\"><a href=\"#30-透彻了解inlining的里里外外\" class=\"headerlink\" title=\"30 透彻了解inlining的里里外外\"></a>30 透彻了解inlining的里里外外</h2><p><strong>将大多数inlining限制于小型、经常调用的函数上。这可使日后的调试过程和二进制升级更加容易，也能使潜在的代码膨胀问题的影响减至最低，使程序速度提升机会最大化。</strong></p>\n<p>如果inline函数的本体很小，编译器针对函数本体所产生的代码可能比函数调用产生的代码还要小。因此，inline确实可能导致较小的目标码，和较高的指令cache命中率。但是inline只是对编译器的一个申请，并不是强制命令。</p>\n<p>另外，如果有一个inline函数在日后被修改，那么所有调用这个函数的地方都需要重新编译。而非inline函数只需要重新链接。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>虽然有时候编译器有意愿inline一个函数，但可能还是会给这个函数生成一个函数本体。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">inline</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">func</span><span style=\"color: #D4D4D4\">(){...}</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> (*</span><span style=\"color: #9CDCFE\">pf</span><span style=\"color: #D4D4D4\">)() = f;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #DCDCAA\">f</span><span style=\"color: #D4D4D4\">();</span><span style=\"color: #6A9955\">//将被inline</span></span>\n<span class=\"line\"><span style=\"color: #DCDCAA\">pf</span><span style=\"color: #D4D4D4\">();</span><span style=\"color: #6A9955\">//或许不被inline，而是转移到函数本体执行</span></span></code></pre></div><p>此外，构造和析构函数不适合inline。构造函数有可能调用别的构造函数，且所做的工作偏多，一旦构造函数被inline，可能会导致代码膨胀。</p>\n\n</div>\n<p><strong>不要只因为function template被定义在头文件中，就为它们声明为inline。</strong></p>\n<p>Template的具象化和inline无关。除非你认为所有根据此template生成的函数都应该被inline，否则不要为它们声明为inline（否则遭致不必要的成本）。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>总而言之，一开始先不要将任何函数声明为inline，慎重使用inline是对日后使用调试器带来帮助。作为开发者，需要找出可以有效增进程序整体效率的代码然后inline。</p>\n</p>\n</div>\n<h2 id=\"31-将文件间的编译依存关系降至最低\"><a href=\"#31-将文件间的编译依存关系降至最低\" class=\"headerlink\" title=\"31 将文件间的编译依存关系降至最低\"></a>31 将文件间的编译依存关系降至最低</h2><p><strong>支持“编译依存关系最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是Handle class和Interface class。</strong></p>\n<p>如果修改了一个class的定义式，那么所有依赖于这个class的文件都需要重新编译，为升级和维护带来巨大的影响。因此，我们需要将文件间的编译依存关系降至最低。</p>\n<p>Handle class的构想是“将对象的实现细目隐藏于一个指针背后”，对于一个样例Person而言，需要两个类来实现，一个用来提供接口，一个用来实现该接口。这样的话，就算PersonImpl的定义式发生了变化，使用了Person类的源文件也不需要重新编译：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #6A9955\">//Person.h</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;memory&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;string&gt;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">PersonImpl</span><span style=\"color: #D4D4D4\">;</span><span style=\"color: #6A9955\">   //前置声明</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Person</span><span style=\"color: #D4D4D4\"> {</span><span style=\"color: #6A9955\">      //handle class</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">Person</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">string</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">name</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">age</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">~Person</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">string</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">name</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">age</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">id</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">private:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::unique_ptr&lt;PersonImpl&gt; pImpl;</span><span style=\"color: #6A9955\">//指向PersonImpl的指针</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">//PersonImpl.h</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;string&gt;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">PersonImpl</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">PersonImpl</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">string</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #9CDCFE\">name</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">age</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">~PersonImpl</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">string</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">name</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">age</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">id</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">private:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::string name_;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> age_;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> id_;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">//Person.cpp</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">\"Person.h\"</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">\"PersonImpl.h\"</span></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">Person</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">Person</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::string &amp;name, </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> age) : </span><span style=\"color: #DCDCAA\">pImpl</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #C586C0\">new</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">PersonImpl</span><span style=\"color: #D4D4D4\">(name, age)) {}</span></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">Person</span><span style=\"color: #D4D4D4\">::~</span><span style=\"color: #DCDCAA\">Person</span><span style=\"color: #D4D4D4\">() = </span><span style=\"color: #C586C0\">default</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">string</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Person</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">name</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> { </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pImpl</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #DCDCAA\">name</span><span style=\"color: #D4D4D4\">(); }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Person</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">age</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> { </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pImpl</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #DCDCAA\">age</span><span style=\"color: #D4D4D4\">(); }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Person</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">id</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> { </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pImpl</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #DCDCAA\">id</span><span style=\"color: #D4D4D4\">(); }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">//PersonImpl.cpp</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">\"PersonImpl.h\"</span></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">string</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">PersonImpl</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">name</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> { </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> name_; }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">PersonImpl</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">age</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> { </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> age_; }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">PersonImpl</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">id</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> { </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> id_; }</span></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">PersonImpl</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">PersonImpl</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::string &amp;name, </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> age) : </span><span style=\"color: #DCDCAA\">name_</span><span style=\"color: #D4D4D4\">(name), </span><span style=\"color: #DCDCAA\">age_</span><span style=\"color: #D4D4D4\">(age) {}</span></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">PersonImpl</span><span style=\"color: #D4D4D4\">::~</span><span style=\"color: #DCDCAA\">PersonImpl</span><span style=\"color: #D4D4D4\">() = </span><span style=\"color: #C586C0\">default</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">//main.cpp</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;iostream&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;Person.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">(){</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  Person </span><span style=\"color: #DCDCAA\">p</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"Scott\"</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #B5CEA8\">25</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cout &lt;&lt; </span><span style=\"color: #CE9178\">\"name: \"</span><span style=\"color: #D4D4D4\"> &lt;&lt; </span><span style=\"color: #9CDCFE\">p</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">name</span><span style=\"color: #D4D4D4\">() &lt;&lt; </span><span style=\"color: #CE9178\">\" age: \"</span><span style=\"color: #D4D4D4\"> &lt;&lt; </span><span style=\"color: #9CDCFE\">p</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">age</span><span style=\"color: #D4D4D4\">() &lt;&lt; </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::endl;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>编译依存性最小化的本质是：现实中让头文件尽可能自我满足，万一做不到，则让它与其他文件内的声明式（非定义式）相依。其他每一件事都源自于这个简单的策略：</p>\n<ol>\n<li>如果使用object reference或object pointer可以完成任务，那么就不要使用object。</li>\n<li>如果能够，尽量以class声明式替换class定义式。</li>\n<li>为声明式和定义式提供不同的文件。（标准库中只含声明式的那个头文件名称以fwd结尾）</li>\n</ol>\n\n</div>\n<p>简而言之，假设你想定义一个Person类，Handle class的用法是：</p>\n<ol>\n<li>将Person的定义式放在Person.h中（class PersonImpl;）</li>\n<li>将PersonImpl的定义式放在PersonImpl.h中</li>\n<li>将Person成员函数的实现放在Person.cpp中（#include “PersonImpl.h”,#include “Person.h”）</li>\n<li>将PersonImpl成员函数的实现放在PersonImpl.cpp中（#include “PersonImpl.h”）</li>\n<li>客户使用Person功能的时候，只需要#include “Person.h”即可。</li>\n</ol>\n<p>Interface class的构想是实现想Java那样的Interfaces，Person的实现看起来像这样：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #6A9955\">//Person.h</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;memory&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;string&gt;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Person</span><span style=\"color: #D4D4D4\"> {</span><span style=\"color: #6A9955\">      //Interface class</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">virtual</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">~Person</span><span style=\"color: #D4D4D4\">(){};</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">virtual</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">string</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">name</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">virtual</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">age</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">virtual</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">id</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">unique_ptr</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #4EC9B0\">Person</span><span style=\"color: #D4D4D4\">&gt; </span><span style=\"color: #DCDCAA\">create</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">string</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #9CDCFE\">name</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">age</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">//PersonImpl.h</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;Person.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;string&gt;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">PersonImpl</span><span style=\"color: #D4D4D4\"> : </span><span style=\"color: #569CD6\">public</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Person</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">PersonImpl</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">string</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #9CDCFE\">name</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">age</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">~PersonImpl</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">string</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">name</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">age</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">id</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">private:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::string name_;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> age_;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> id_u;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">//Person.cpp</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;PersonImpl.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">unique_ptr</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #4EC9B0\">Person</span><span style=\"color: #D4D4D4\">&gt; </span><span style=\"color: #4EC9B0\">Person</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">create</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">string</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #9CDCFE\">name</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">age</span><span style=\"color: #D4D4D4\">) {</span><span style=\"color: #6A9955\">//工厂函数</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">unique_ptr</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #4EC9B0\">Person</span><span style=\"color: #D4D4D4\">&gt;(</span><span style=\"color: #C586C0\">new</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">PersonImpl</span><span style=\"color: #D4D4D4\">(name, age));</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">//PersonImpl.cpp</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">\"PersonImpl.h\"</span></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">string</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">PersonImpl</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">name</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> { </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> name_; }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">PersonImpl</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">age</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> { </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> age_; }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">PersonImpl</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">id</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> { </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> id_u; }</span></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">PersonImpl</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">PersonImpl</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::string &amp;name, </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> age) : </span><span style=\"color: #DCDCAA\">name_</span><span style=\"color: #D4D4D4\">(name), </span><span style=\"color: #DCDCAA\">age_</span><span style=\"color: #D4D4D4\">(age) {}</span></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">PersonImpl</span><span style=\"color: #D4D4D4\">::~</span><span style=\"color: #DCDCAA\">PersonImpl</span><span style=\"color: #D4D4D4\">() {}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">//main.cpp</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;Person.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;iostream&gt;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">(){</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::unique_ptr&lt;Person&gt; </span><span style=\"color: #DCDCAA\">p</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">Person</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">create</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"Scott\"</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #B5CEA8\">25</span><span style=\"color: #D4D4D4\">));</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cout &lt;&lt; </span><span style=\"color: #CE9178\">\"name: \"</span><span style=\"color: #D4D4D4\"> &lt;&lt; </span><span style=\"color: #9CDCFE\">p</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #DCDCAA\">name</span><span style=\"color: #D4D4D4\">() &lt;&lt; </span><span style=\"color: #CE9178\">\" age: \"</span><span style=\"color: #D4D4D4\"> &lt;&lt; </span><span style=\"color: #9CDCFE\">p</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #DCDCAA\">age</span><span style=\"color: #D4D4D4\">() &lt;&lt; </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::endl;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>简而言之，假设你想定义一个Person类，Interface class的用法是：</p>\n<ol>\n<li>将Person的定义式放在Person.h中</li>\n<li>PersonImpl public继承Person，定义式放在PersonImpl.h中（#include “Person.h”）</li>\n<li>将Person的工厂函数放在Person.cpp中（#include “PersonImpl.h”）</li>\n<li>将PersonImpl成员函数的实现放在PersonImpl.cpp中（#include “PersonImpl.h”）</li>\n<li>客户使用Person功能的时候，只需要#include “Person.h”即可。</li>\n</ol>\n<p><strong>程序库头文件应该以“完全且仅有声明式”的形式存在。这种做法不论是否涉及template都适用。</strong></p>\n<p>例如C++标准库文件中的&lt;iosfwd&gt;，它只包含了iostream各组件的声明式，其对应的定义式则在&lt;iostream&gt;中。当你在某些 只需要 这些类声明，而不需要定义的地方（例如：自定义的头文件中），就可以简单的include这个头文件！我们写的库也应该提供这个文件。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p><strong>关于缺点：</strong></p>\n<p>在Handle class中，每个函数调用都需要间接调用带来了效率问题，每个对象消耗的内存也会多一个指针的大小，还有动态内存分配以及释放的开销，以及遭遇bad_alloc的风险。</p>\n<p>在Interface class中，每次函数调用将多一个间接跳跃的成本，vptr也可能会增加对象的大小（如果除了Interface class之外有其他的virtual函数来源）。</p>\n<p>Handle classes或Interface classes，都不能充分利用inline函数。</p>\n<p>这些缺点看似是的本条款是个bad idea，但是实际上，在程序发展的时候使用Handle classes或Interface classes来降低实现码有所变化时对客户码的影响。当它们真正导致难以调和的速度或大小的问题时，再以具象类替换之。</p>\n</p>\n</div>\n<h1 id=\"六、继承与面向对象设计\"><a href=\"#六、继承与面向对象设计\" class=\"headerlink\" title=\"六、继承与面向对象设计\"></a>六、继承与面向对象设计</h1><h2 id=\"32-确定你的public继承塑模出is-a关系\"><a href=\"#32-确定你的public继承塑模出is-a关系\" class=\"headerlink\" title=\"32 确定你的public继承塑模出is-a关系\"></a>32 确定你的public继承塑模出is-a关系</h2><p><strong>“public继承”意味着is-a。适用于base class对象的地方必然适用于derived class对象，因为derived class对象就是base class对象。</strong></p>\n<p>C++对于“public”继承严格奉行上述见解。如果你令“penguin”public继承“bird”，或是令“square”public继承“rectangle”，如果你发现你的代码中有“penguin”对象无法适用于“bird”对象的地方，例如“penguin”不会飞，而“bird”又有fly函数，那么它们之间就不适用于public关系。在这种情况下，即使编译器不报错，可能也会带来不正确的程序行为。</p>\n<h2 id=\"33-避免遮掩继承而来的名称\"><a href=\"#33-避免遮掩继承而来的名称\" class=\"headerlink\" title=\"33 避免遮掩继承而来的名称\"></a>33 避免遮掩继承而来的名称</h2><p><strong>derived class内的名称会遮掩base class内的名称。在public继承下从来没有人希望如此。</strong></p>\n<p>derived class的作用域包裹在base class内，所以只要是derived class内与base class<strong>同名</strong>的就会覆盖掉。假设你要覆写的成员函数在基类有重载，则在覆写的时候会一并失去那些重载！如果使用public继承而又不继承那些重载函数，那就违反了“public继承意味着is-a”的原则。</p>\n<p><strong>为了让遮掩的名称再次见诸世面，可以使用using声明式或转交函数。</strong></p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Base</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">mf1</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">mf1</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\">)</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">mf2</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Derived</span><span style=\"color: #D4D4D4\"> : </span><span style=\"color: #569CD6\">public</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Base</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">using</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Base</span><span style=\"color: #D4D4D4\">::mf1;</span><span style=\"color: #6A9955\">    //如果没有这一行，Derived将没有mf1(int)函数</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">mf1</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">mf2</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">mf3</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span></code></pre></div><p>在public继承下，你必须继承所有的base class函数。然而在private继承下，你可以选择性的继承base class的函数，这种情况下，using声明式并不适用。这时应该使用转交函数：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Derived</span><span style=\"color: #D4D4D4\"> : </span><span style=\"color: #569CD6\">private</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Base</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">mf1</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">x</span><span style=\"color: #D4D4D4\">) { </span><span style=\"color: #4EC9B0\">Base</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">mf1</span><span style=\"color: #D4D4D4\">(x); }</span><span style=\"color: #6A9955\">//转交函数</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span></code></pre></div><div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p>当继承结合templates，又会面对“继承名称被遮掩的”新问题，关于“角括号定界”的所有问题见条款43。</p>\n\n</div>\n<h2 id=\"34-区分接口继承和实现继承\"><a href=\"#34-区分接口继承和实现继承\" class=\"headerlink\" title=\"34 区分接口继承和实现继承\"></a>34 区分接口继承和实现继承</h2><p><strong>接口继承和实现继承不同，在public继承之下，derived class总是继承base class的接口。</strong></p>\n<p><strong>pure virtual函数只具体指定接口继承。</strong></p>\n<p><strong>简朴的（非纯）impure virtual函数具体指定接口继承及缺省实现继承。</strong></p>\n<p>上述是一般的缺省情况，有的时候我们希望为子类提供一个通用的接口函数但是不希望它是缺省的实现。并且在子类忘记定义该函数的时候使编译器提出警告。这就需要切断“virtual 函数接口”和其“缺省实现”之间的连接，下面是一种做法：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Airplane</span><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">virtual</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">fly</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Airport</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">destination</span><span style=\"color: #D4D4D4\">) = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\"> ;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">protected:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">defaultFly</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Airport</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">destination</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Airplane</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">defaultFly</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Airport</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">destination</span><span style=\"color: #D4D4D4\">){</span><span style=\"color: #6A9955\">//通用的接口</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p><strong>non-virtual函数具体指定接口继承及强制实现继承。</strong></p>\n<p>任何derived class的non-virtual函数都不应该尝试改变bass class的行为。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><p>class设计者的两个认知错误：</p>\n<ol>\n<li>将可能作为base class的所有函数声明为non-virtual，使得derived class难以进行特化</li>\n<li>将所有成员函数声明为virtual（有时候是对的），可能某些函数就是不该在derived class中被重新定义。</li>\n</ol>\n</p>\n</div>\n<h2 id=\"35-考虑virtual函数以外的选择\"><a href=\"#35-考虑virtual函数以外的选择\" class=\"headerlink\" title=\"35 考虑virtual函数以外的选择\"></a>35 考虑virtual函数以外的选择</h2><p><strong>当你为解决问题而寻找某个设计方法时，不妨考虑virtual函数的替代方案。</strong></p>\n<ol>\n<li>使用NVI手法，以public non-virtual成员函数包裹较低访问性（protected或private）的virtual函数。</li>\n<li>将virtual函数替换为函数指针。</li>\n<li>将virtual函数替换为tr1::function对象。</li>\n<li>将继承体系内的virtual函数替换为另一个继承体系内的virtual函数。</li>\n</ol>\n<p>它们各有各的优点，在设计的时候，请将它们和虚函数的方案一同考虑。</p>\n<h2 id=\"36-绝不重新定义继承而来的non-virtual函数\"><a href=\"#36-绝不重新定义继承而来的non-virtual函数\" class=\"headerlink\" title=\"36 绝不重新定义继承而来的non-virtual函数\"></a>36 绝不重新定义继承而来的non-virtual函数</h2><p>non-virtual函数是静态绑定，而virtual函数是动态绑定。如果你重新定义了一个non-virtual函数，那么就会导致“继承体系内的函数行为不一致”。</p>\n<h2 id=\"37-绝不重新定义继承而来的缺省参数值\"><a href=\"#37-绝不重新定义继承而来的缺省参数值\" class=\"headerlink\" title=\"37 绝不重新定义继承而来的缺省参数值\"></a>37 绝不重新定义继承而来的缺省参数值</h2><p><strong>继承而来的缺省参数值在编译期间就已经确定了，而virtual函数的调用却是在运行期间决定的。</strong></p>\n<p>你只能继承virtual函数和non-virtual函数，而条款36已经说了不要重新定义non-virtual函数。因此，讨论的问题是如何继承一个带有缺省参数值的virtual函数。</p>\n<p>编译器为了效率，函数的缺省值会在编译期决定。有可能造成这样的结果，调用一个定义在derived class中的函数，却使用了base class中的缺省值！</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p>如果你的设计需要定义一个带有缺省参数值的virtual函数，那么你的设计可能有问题。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Shape</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">enum</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">ShapeColor</span><span style=\"color: #D4D4D4\"> {</span><span style=\"color: #4FC1FF\">Red</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #4FC1FF\">Green</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #4FC1FF\">Blue</span><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">virtual</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">draw</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">ShapeColor</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">color</span><span style=\"color: #D4D4D4\"> = Red) </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Rectangle</span><span style=\"color: #D4D4D4\"> : </span><span style=\"color: #569CD6\">public</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Shape</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">virtual</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">draw</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">ShapeColor</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">color</span><span style=\"color: #D4D4D4\"> = Red) </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span></code></pre></div><p>这个设计似乎遵守了本条款，但是它的问题在于，代码冗余且耦合性高。何不尝试下面的NVI设计：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Shape</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">enum</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">ShapeColor</span><span style=\"color: #D4D4D4\"> {</span><span style=\"color: #4FC1FF\">Red</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #4FC1FF\">Green</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #4FC1FF\">Blue</span><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">draw</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">ShapeColor</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">color</span><span style=\"color: #D4D4D4\"> = Red) </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> { </span><span style=\"color: #DCDCAA\">doDraw</span><span style=\"color: #D4D4D4\">(color); }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">private:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">virtual</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">doDraw</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">ShapeColor</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">color</span><span style=\"color: #D4D4D4\">) </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Rectangle</span><span style=\"color: #D4D4D4\"> : </span><span style=\"color: #569CD6\">public</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Shape</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">private:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">virtual</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">doDraw</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">ShapeColor</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">color</span><span style=\"color: #D4D4D4\">) </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span></code></pre></div>\n</div>\n<h2 id=\"38-通过复合塑模出has-a或“根据某物实现出”\"><a href=\"#38-通过复合塑模出has-a或“根据某物实现出”\" class=\"headerlink\" title=\"38 通过复合塑模出has-a或“根据某物实现出”\"></a>38 通过复合塑模出has-a或“根据某物实现出”</h2><p><strong>复合的意义和public继承的意义是完全不同的。</strong></p>\n<p>复合是类型之间的一种关系，表现为某种类型的对象内含另一种类型的对象。</p>\n<p><strong>在应用域，复合意味has-a。在实现域，复合意味“根据某物实现出”。</strong></p>\n<p>比如说一个person类，有一个string类的名字，这就是has-a的关系；假设你在使用list来实现set，你不能用public继承来塑模他们，因为这样的话你会继承list的所有接口，你应该将list作为set的一个成员来复合，这就是“根据某物实现出”。</p>\n<h2 id=\"39-明智而审慎地使用private继承\"><a href=\"#39-明智而审慎地使用private继承\" class=\"headerlink\" title=\"39 明智而审慎地使用private继承\"></a>39 明智而审慎地使用private继承</h2><p><strong>private继承意味着is-implemented-in-terms-of。它通常比复合的级别低。但是当derived class需要访问protected base class的成员，或需要重新定义继承而来的virtual函数时，private继承是合适的。</strong></p>\n<p>如果class之间的继承关系是private，编译器不会自动将一个derived class对象转换为base class对象。并且由private继承而来的成员在derived class中的访问级别是private的。</p>\n<p>因此，private继承意味着“is-implemented-in-terms-of”，意思是derived class对象的实现依赖于base class对象的实现。private继承在软件的“设计”层面没有意义，它只有在软件的“实现”层面才有意义。</p>\n<p>既然private继承和复合的意义相似（is-implemented-in-terms-of），如何在这两者之间取舍呢？答案是：尽可能使用复合，必要时使用private继承。何时必要呢：当derived class需要访问protected base class的成员，或需要重新定义继承而来的virtual函数时！</p>\n<p><strong>和复合不同，private继承可以造成empty base class最优化。这对致力于“对象尺寸最小化”的程序库开发者来说是个重要的考量。</strong></p>\n<p>面对一个大小为0的独立（非附属）对象，C++官方默认安插一个char到空对象内，以确保每个对象在内存中的地址都是独一无二的。这样的话无疑对内存敏感的程序库开发者来说是个问题。使用private继承来实现，可以避免这个问题，也就是所谓的EBO。</p>\n<h2 id=\"40-明智而审慎地使用多重继承\"><a href=\"#40-明智而审慎地使用多重继承\" class=\"headerlink\" title=\"40 明智而审慎地使用多重继承\"></a>40 明智而审慎地使用多重继承</h2><p><strong>多重继承比单一继承更复杂。它可能导致新的歧义性，以及对virtual继承的需要。</strong></p>\n<p>歧义自不必说，virtual继承是怎么回事呢？假设你有一个class D，它public继承了两个class B和C，而B和C又public继承了A。那么D中就会有两个A的副本，这就是所谓的“菱形继承”。为了解决这个问题，C++提供了virtual继承，这样的话，D中就只有一个A的副本了。这样的关系在标准库的basic_ios、basic_istream、basic_ostream、basic_iostream之间就有体现。</p>\n<p><strong>virtual继承会增加大小、速度、初始化复杂度。如果virtual base class不带任何数据，将是最具实用价值的情况。</strong></p>\n<p>然而为了避免继承得来的成员变量重复，编译器会做出幕后工作。这种virtual继承同时也伴随着内存和速度的损失，且初始化也非常不直观。因此，不必要的时候不要使用virtual base。平常请使用non-virtual继承，如果必须使用virtual base class，请确保它不带任何数据。</p>\n<p><strong>多重继承的常见用途有：为“public继承”塑模出“接口继承”和private继承某个协助实现的class的两相组合。</strong></p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Iperson</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">virtual</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">~Iperson</span><span style=\"color: #D4D4D4\">() ;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">virtual</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">string</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">name</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">virtual</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">string</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">birthDate</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">DatabaseID</span><span style=\"color: #D4D4D4\"> {...};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">PersonInfo</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">explicit</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">PersonInfo</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">DatabaseID</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pid</span><span style=\"color: #D4D4D4\">) : </span><span style=\"color: #DCDCAA\">pid_</span><span style=\"color: #D4D4D4\">(pid) {}</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">virtual</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">~PersonInfo</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">virtual</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">char</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">*</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">theName</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> ;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">virtual</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">char</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">*</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">theBirthDate</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> ;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">virtual</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">char</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">*</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">valueDelimOpen</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> ;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">virtual</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">char</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">*</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">valueDelimClose</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> ;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Cperson</span><span style=\"color: #D4D4D4\"> : </span><span style=\"color: #569CD6\">public</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Iperson</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">private</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">PersonInfo</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">explicit</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">Cperson</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">DatabaseID</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pid</span><span style=\"color: #D4D4D4\">) : </span><span style=\"color: #DCDCAA\">PersonInfo</span><span style=\"color: #D4D4D4\">(pid) {};</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">virtual</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">string</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">name</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\">{</span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">PersonInfo</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">name</span><span style=\"color: #D4D4D4\">();}</span><span style=\"color: #6A9955\">//实现必要的Iperson成员函数</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">virtual</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">string</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">birthDate</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\">{</span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">PersonInfo</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">birthDate</span><span style=\"color: #D4D4D4\">();}</span><span style=\"color: #6A9955\">//实现必要的Iperson成员函数</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">private:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">char</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">*</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">valueDelimOpen</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> {</span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #CE9178\">\"&lt;\"</span><span style=\"color: #D4D4D4\">;}</span><span style=\"color: #6A9955\">//重新定义继承而来的virtual“界限函数”</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">char</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">*</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">valueDelimClose</span><span style=\"color: #D4D4D4\">() </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> {</span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #CE9178\">\"&gt;\"</span><span style=\"color: #D4D4D4\">;}</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span></code></pre></div><h1 id=\"七、模板与泛型编程\"><a href=\"#七、模板与泛型编程\" class=\"headerlink\" title=\"七、模板与泛型编程\"></a>七、模板与泛型编程</h1><h2 id=\"41-了解隐式接口和编译期多态\"><a href=\"#41-了解隐式接口和编译期多态\" class=\"headerlink\" title=\"41 了解隐式接口和编译期多态\"></a>41 了解隐式接口和编译期多态</h2><p><strong>classes和templates都支持接口和多态。</strong></p>\n<p>class的接口在源码中可见，可谓显式接口。而templates的接口则是隐式的。class的多态发生在运行期（运行期多态），而templates的多态发生在编译期（编译期多态）。</p>\n<p><strong>对classes而言，接口是显式的，以函数签名为中心。多态则是通过virtual函数发生在运行期。</strong></p>\n<p>显式接口由函数签名式（函数名称、参数类型、返回类型）构成。</p>\n<p><strong>对template参数而言，接口是隐式的，奠基于有效表达式。多态则是通过template具现化和函数重载解析发生在编译期。</strong></p>\n<p>隐式接口基于有效表达式，这些有效表达式需要在template中找到并确保其有效性。</p>\n<h2 id=\"42-了解typename的双重意义\"><a href=\"#42-了解typename的双重意义\" class=\"headerlink\" title=\"42 了解typename的双重意义\"></a>42 了解typename的双重意义</h2><p><strong>声明template参数时，class和typename没有区别</strong></p>\n<p><strong>请使用关键字typename标识嵌套从属类型名称；但不得在base class list或member initialization list内以它作为base class修饰符。</strong></p>\n<h2 id=\"43-学习处理模板化基类内的名称\"><a href=\"#43-学习处理模板化基类内的名称\" class=\"headerlink\" title=\"43 学习处理模板化基类内的名称\"></a>43 学习处理模板化基类内的名称</h2><p><strong>可在derived class template中通过“this-&gt;”指涉base class template内的成员名称。或籍由一个明白的base class名称指涉该名称。</strong></p>\n<p>面对“指涉base class member”之无效references，编译器的诊断时间可能发生在早期（当解析derived class template的定义式时），也可能发生在晚期（当那些templates被特定之template实参具现化时）。C++的政策宁愿是早诊断，因此当“base class从template中被具现化时”，它假设它对那些base class的内容毫无所悉。</p>\n<h2 id=\"44-将与参数无关的代码移出templates\"><a href=\"#44-将与参数无关的代码移出templates\" class=\"headerlink\" title=\"44 将与参数无关的代码移出templates\"></a>44 将与参数无关的代码移出templates</h2><p><strong>template生成多个classes和多个函数，所以在任何template代码都不该于某个造成膨胀的template参数产生相依关系。</strong></p>\n<p>看如下代码：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">template</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #569CD6\">typename</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">T</span><span style=\"color: #D4D4D4\"> , </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">n</span><span style=\"color: #D4D4D4\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">SquareMatrix</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">invert</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span></code></pre></div><p>这个类的invert函数的实现可能会依赖于n的值，这样就会导致代码膨胀。因此，我们应该将invert函数的实现移出template。</p>\n<p><strong>因非类型模板参数而产生的代码膨胀，往往可以被消除，做法是以函数参数或class成员变量替换template参数。</strong></p>\n<p><strong>因类型参数而产生的代码膨胀，往往可以被降低，做法是让带有完全相同二进制表述的具现类型共享一个实现码。</strong></p>\n<h2 id=\"45-运用成员函数模板接受所有兼容类型\"><a href=\"#45-运用成员函数模板接受所有兼容类型\" class=\"headerlink\" title=\"45 运用成员函数模板接受所有兼容类型\"></a>45 运用成员函数模板接受所有兼容类型</h2><p><strong>请使用member function templates生成“可接受所有兼容类型”的函数。</strong></p>\n<p><strong>如果你声明member templates 用于“泛化copy构造”或“泛化assignment操作”，你还是需要声明一个正常的copy构造函数和copy assignment操作符。</strong></p>\n<h2 id=\"46-需要类型转换时请为模板定义非成员函数\"><a href=\"#46-需要类型转换时请为模板定义非成员函数\" class=\"headerlink\" title=\"46 需要类型转换时请为模板定义非成员函数\"></a>46 需要类型转换时请为模板定义非成员函数</h2><p><strong>当我们编写一个class template，而它所提供之“与此template相关的”函数支持“所有参数之隐式类型转换”时，请将那些函数定义为“class template内部的friend函数”。</strong></p>\n<h2 id=\"47-请使用traits-classes表现类型信息\"><a href=\"#47-请使用traits-classes表现类型信息\" class=\"headerlink\" title=\"47 请使用traits classes表现类型信息\"></a>47 请使用traits classes表现类型信息</h2><p><strong>traits class 使得“类型相关信息”在编译期可用。它们以templates和“templates特化”完成实现。</strong></p>\n<p><strong>整合重载技术（overloading）后，traits class有可能在编译期对类型执行if…else测试。</strong></p>\n<h2 id=\"48-认识template-元编程\"><a href=\"#48-认识template-元编程\" class=\"headerlink\" title=\"48 认识template 元编程\"></a>48 认识template 元编程</h2><p><strong>template metaprogramming可以将工作由运行期移往编译期，因而得以实现早期错误侦测和更高的性能。</strong></p>\n<p><strong>TMP可被用来生成“基于政策选择组合”的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码</strong></p>\n<h1 id=\"八、定制new和delete\"><a href=\"#八、定制new和delete\" class=\"headerlink\" title=\"八、定制new和delete\"></a>八、定制new和delete</h1><h2 id=\"49-了解new-handler的行为\"><a href=\"#49-了解new-handler的行为\" class=\"headerlink\" title=\"49 了解new-handler的行为\"></a>49 了解new-handler的行为</h2><p><strong>set_new_handler允许客户指定一个函数,在内存分配无法获得满足时被调用。</strong></p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">outOfMem</span><span style=\"color: #D4D4D4\">(){</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cerr &lt;&lt; </span><span style=\"color: #CE9178\">\"Unable to satisfy request for memory</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">abort</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">(){</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">set_new_handler</span><span style=\"color: #D4D4D4\">(outOfMem);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> *pBigDataArray = </span><span style=\"color: #C586C0\">new</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\">[</span><span style=\"color: #B5CEA8\">100000000L</span><span style=\"color: #D4D4D4\">];</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>c++中，new-handler是一个错误处理函数，默认值是null，即不做任何处理并抛出异常。通过set_new_handler可以设置一个新的new-handler，当内存分配失败时，会反复调用这个函数直到申请成功。一个设计良好的new-handler必须做到以下几点：</p>\n<ol>\n<li>让更多内存可用（一个做法是：程序开始执行的时候就分配一大块内存，调用new-handler时，释放这部分内存）</li>\n<li>安装另一个new-handler（本new-handler无法处理时，可能的话，交给另一个new-handler）</li>\n<li>卸除new-handler（如果new-handler处理不了，则卸除。这将在new无法分配内存时抛出异常）</li>\n<li>抛出bad_alloc异常（这样的异常不会被new捕获，会被传播到内存索取处）</li>\n<li>不返回（abort或者exit）</li>\n</ol>\n<p>有的时候我们希望不同的类在内存分配失败的时候调用特定的new-handler，这该如何实现呢？</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">NewHandlerHolder</span><span style=\"color: #D4D4D4\"> {</span><span style=\"color: #6A9955\">//基于RAII的new-handler管理类</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">explicit</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">NewHandlerHolder</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">new_handler</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">nh</span><span style=\"color: #D4D4D4\">) : </span><span style=\"color: #DCDCAA\">handler</span><span style=\"color: #D4D4D4\">(nh) {}</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">~NewHandlerHolder</span><span style=\"color: #D4D4D4\">() { </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">set_new_handler</span><span style=\"color: #D4D4D4\">(handler); }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">private:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::new_handler handler;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">NewHandlerHolder</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">NewHandlerHolder</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">NewHandlerHolder</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #C586C0\">operator=</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">NewHandlerHolder</span><span style=\"color: #569CD6\">&amp;</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Widget</span><span style=\"color: #D4D4D4\"> {</span><span style=\"color: #6A9955\">//要特化new-handler的类</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">new_handler</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">set_new_handler</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">new_handler</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">p</span><span style=\"color: #D4D4D4\">) </span><span style=\"color: #C586C0\">throw</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">*</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #C586C0\">operator</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #C586C0\">new</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">size</span><span style=\"color: #D4D4D4\">) </span><span style=\"color: #C586C0\">throw</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">bad_alloc</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">private:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::new_handler currentHandler;</span><span style=\"color: #6A9955\">//用于保存当前new-handler，静态成员将在class外定义</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::new_handler </span><span style=\"color: #4EC9B0\">Widget</span><span style=\"color: #D4D4D4\">::currentHandler = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span><span style=\"color: #6A9955\">//静态成员将在class外定义</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">new_handler</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Widget</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">set_new_handler</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">new_handler</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">p</span><span style=\"color: #D4D4D4\">) </span><span style=\"color: #C586C0\">throw</span><span style=\"color: #D4D4D4\">() {</span><span style=\"color: #6A9955\">//用于设置class专属的new-handler</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::new_handler oldHandler = currentHandler;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    currentHandler = p;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> oldHandler;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">*</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Widget</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #C586C0\">operator</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #C586C0\">new</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">size</span><span style=\"color: #D4D4D4\">) </span><span style=\"color: #C586C0\">throw</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">bad_alloc</span><span style=\"color: #D4D4D4\">) {</span><span style=\"color: #6A9955\">//运算符new重载</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    NewHandlerHolder </span><span style=\"color: #DCDCAA\">h</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">set_new_handler</span><span style=\"color: #D4D4D4\">(currentHandler));</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> ::operator </span><span style=\"color: #C586C0\">new</span><span style=\"color: #D4D4D4\">(size);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>上述方法是一种。然而我们还可以设计一个“mixin”风格的基类，让所有继承该基类的类都能够有上述的功能（特化自己的new-handler）。被称为“怪异的循环模板模式”。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">template</span><span style=\"color: #D4D4D4\"> &lt;</span><span style=\"color: #569CD6\">typename</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">T</span><span style=\"color: #D4D4D4\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">NewHandlerSupport</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">new_handler</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">set_new_handler</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">new_handler</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">p</span><span style=\"color: #D4D4D4\">) </span><span style=\"color: #C586C0\">throw</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">*</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #C586C0\">operator</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #C586C0\">new</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">size</span><span style=\"color: #D4D4D4\">) </span><span style=\"color: #C586C0\">throw</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">bad_alloc</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">private:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::new_handler currentHandler;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">template</span><span style=\"color: #D4D4D4\"> &lt;</span><span style=\"color: #569CD6\">typename</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">T</span><span style=\"color: #D4D4D4\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">new_handler</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">NewHandlerSupport</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #4EC9B0\">T</span><span style=\"color: #D4D4D4\">&gt;::</span><span style=\"color: #DCDCAA\">set_new_handler</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">new_handler</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">p</span><span style=\"color: #D4D4D4\">) </span><span style=\"color: #C586C0\">throw</span><span style=\"color: #D4D4D4\">() {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::new_handler oldHandler = currentHandler;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    currentHandler = p;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> oldHandler;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">template</span><span style=\"color: #D4D4D4\"> &lt;</span><span style=\"color: #569CD6\">typename</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">T</span><span style=\"color: #D4D4D4\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">*</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">NewHandlerSupport</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #4EC9B0\">T</span><span style=\"color: #D4D4D4\">&gt;::</span><span style=\"color: #C586C0\">operator</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #C586C0\">new</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">size</span><span style=\"color: #D4D4D4\">) </span><span style=\"color: #C586C0\">throw</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">bad_alloc</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    NewHandlerHolder </span><span style=\"color: #DCDCAA\">h</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">set_new_handler</span><span style=\"color: #D4D4D4\">(currentHandler));</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> ::operator </span><span style=\"color: #C586C0\">new</span><span style=\"color: #D4D4D4\">(size);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">template</span><span style=\"color: #D4D4D4\"> &lt;</span><span style=\"color: #569CD6\">typename</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">T</span><span style=\"color: #D4D4D4\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::new_handler </span><span style=\"color: #4EC9B0\">NewHandlerSupport</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #4EC9B0\">T</span><span style=\"color: #D4D4D4\">&gt;::currentHandler = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Widget</span><span style=\"color: #D4D4D4\"> : </span><span style=\"color: #569CD6\">public</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">NewHandlerSupport</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #4EC9B0\">Widget</span><span style=\"color: #D4D4D4\">&gt; {</span><span style=\"color: #6A9955\">//令Widget继承NewHandlerSupport，即可获得特化new-handler的能力</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span></code></pre></div><p>上述代码可能有一个疑问，NewHandlerSupport中并没有用到类型T，那么为什么要用模板呢？这是因为我们希望每个继承自NewHandlerSupport的类都有互异的NewHandlerSupport附件，而不是共享一个。template机制会为每一个参数T生成一份currentHandler！！！</p>\n<p><strong>Nothrow new是一个颇为局限的工具，因为它只适用于内存分配；后继的构造函数调用却可能抛出异常。所以没有运用Nothrow new的需要</strong></p>\n<h2 id=\"50-了解new和delete的合理替换时机\"><a href=\"#50-了解new和delete的合理替换时机\" class=\"headerlink\" title=\"50 了解new和delete的合理替换时机\"></a>50 了解new和delete的合理替换时机</h2><p>为什么要写个自定的new和delete呢？</p>\n<p><strong>有多个理由需要写个自定的new和delete，包括改善效能、对heap的错误使用进行调试、收集heap使用统计资料等等</strong></p>\n<p>理由如下：</p>\n<ol>\n<li>检测运用上的错误</li>\n<li>收集动态分配内存之使用统计信息</li>\n<li>增加分配和归还的速度</li>\n<li>降低缺省内存管理器带来的空间额外开销</li>\n<li>弥补缺省分配器中的非最佳对齐位</li>\n<li>将相关对象成簇集中</li>\n<li>获得非传统行为</li>\n</ol>\n<h2 id=\"51-编写new和delete时需固守常规\"><a href=\"#51-编写new和delete时需固守常规\" class=\"headerlink\" title=\"51 编写new和delete时需固守常规\"></a>51 编写new和delete时需固守常规</h2><p>如果要写自定的new和delete，那么应该遵循什么规则呢？</p>\n<p><strong>operator new应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足需求，就该调用new-handler。它也应该有能力处理0 byte的请求，Class专属版本则还应该处理“比正确大小更大的（错误）申请”。</strong></p>\n<p>一个示例的operator new：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">class</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Base</span><span style=\"color: #D4D4D4\"> {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">public:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">*</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #C586C0\">operator</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #C586C0\">new</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">size</span><span style=\"color: #D4D4D4\">) </span><span style=\"color: #C586C0\">throw</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">bad_alloc</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ...</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">*</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Base</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #C586C0\">operator</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #C586C0\">new</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">size</span><span style=\"color: #D4D4D4\">) </span><span style=\"color: #C586C0\">throw</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">bad_alloc</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">using</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">namespace</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (size != </span><span style=\"color: #569CD6\">sizeof</span><span style=\"color: #D4D4D4\">(Base))</span><span style=\"color: #6A9955\">//判断是否被用来初始化derived class对象（顺便判断是否0-byte请求）</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> ::operator </span><span style=\"color: #C586C0\">new</span><span style=\"color: #D4D4D4\">(size);</span><span style=\"color: #6A9955\">//使用std的operator new</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">while</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #569CD6\">true</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /*尝试分配内存*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #6A9955\">/*分配成功*/</span><span style=\"color: #D4D4D4\">) </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> mem;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        //分配失败，调用new-handler</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        new_handler globalHandler = </span><span style=\"color: #DCDCAA\">set_new_handler</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">set_new_handler</span><span style=\"color: #D4D4D4\">(globalHandler);</span><span style=\"color: #6A9955\">//多线程条件下，视情况加锁</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (globalHandler) (*globalHandler)();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">else</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #C586C0\">throw</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">bad_alloc</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>如果要写一个operator new[],那么要做的仅仅是分配一块未加工的内存。还要考虑包含额外的空间用来存放数组的长度。</p>\n<p><strong>operator delete应该在收到null指针时不做任何事。Class的专属版本则还应该处理“比正确大小更大的（错误）申请”。</strong></p>\n<p>一个示例的operator delete：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">Base</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #C586C0\">operator</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #C586C0\">delete</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">*</span><span style=\"color: #9CDCFE\">rawMemory</span><span style=\"color: #D4D4D4\">) </span><span style=\"color: #C586C0\">throw</span><span style=\"color: #D4D4D4\">() {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (rawMemory == </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">) </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\">;</span><span style=\"color: #6A9955\">//空指针不做任何事</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (size != </span><span style=\"color: #569CD6\">sizeof</span><span style=\"color: #D4D4D4\">(Base))</span><span style=\"color: #6A9955\">//判断是否被用来初始化derived class对象</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ::operator </span><span style=\"color: #C586C0\">delete</span><span style=\"color: #D4D4D4\">(rawMemory);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /*释放内存*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><p>如果即将被删除的对象派生自某个base class，而后者缺乏一个virtual析构函数，那么C++传给operator delete函数的参数的值就不对，可能会导致程序行为不正常。务必遵守条款7！！！</p>\n</p>\n</div>\n<h2 id=\"52-写了placement-new也要写placement-delete\"><a href=\"#52-写了placement-new也要写placement-delete\" class=\"headerlink\" title=\"52 写了placement new也要写placement delete\"></a>52 写了placement new也要写placement delete</h2><p><strong>当你写一个placement operator new时，请确定也写出了对应的placement operator delete。如果没有这样做，你的程序可能会发生隐微而时断时续的内存泄漏。</strong></p>\n<p>看看这个语句：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #D4D4D4\">Widget *pw = </span><span style=\"color: #C586C0\">new</span><span style=\"color: #D4D4D4\"> Widget;</span></span></code></pre></div><p>首先调用了operator new，然后调用了Widget的构造函数。如果Widget的构造函数抛出异常，那么C++的运行期系统会自动调用参数个数和类型都与operator new相同的operator delete来释放内存，如果没有找到合适的operator delete，则什么都不做，这就会导致内存泄漏。因此，务必写出对应的placement operator delete。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p>注意下面这种写法可能被忽视：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #D4D4D4\">Widget *pw = </span><span style=\"color: #C586C0\">new</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cout) Widget;</span><span style=\"color: #6A9955\">//调用了placement operator new</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">delete</span><span style=\"color: #D4D4D4\"> pw;</span><span style=\"color: #6A9955\">//没有调用placement operator delete，可能导致内存泄漏</span></span></code></pre></div>\n</div>\n<p><strong>当你声明placement new和placement delete时，请确定不要无意识（非故意）地遮掩了它们的正常版本。</strong></p>\n<p>参考条款33</p>\n<h1 id=\"九、杂项\"><a href=\"#九、杂项\" class=\"headerlink\" title=\"九、杂项\"></a>九、杂项</h1><h2 id=\"53-不要轻易忽视编译器的警告\"><a href=\"#53-不要轻易忽视编译器的警告\" class=\"headerlink\" title=\"53 不要轻易忽视编译器的警告\"></a>53 不要轻易忽视编译器的警告</h2><p><strong>严肃对待编译器发出的警告信息，努力在你的编译器的最高警告级别下争取“无任何警告”的荣誉。</strong></p>\n<p><strong>不要过度依赖编译器的警告信息，因为不同编译器对待事情的态度不同，一旦移植到另一个编译器上，可能就没警告了。</strong></p>\n<h2 id=\"54-让自己熟悉包括TR1在内的标准程序库\"><a href=\"#54-让自己熟悉包括TR1在内的标准程序库\" class=\"headerlink\" title=\"54 让自己熟悉包括TR1在内的标准程序库\"></a>54 让自己熟悉包括TR1在内的标准程序库</h2><p><strong>C++标准组件库的主要机能由STL、iostreams、locales组成。并包含C99标准查询库。</strong></p>\n<p><strong>TR1增加了许多新的组件，包括智能指针、一般化函数指针、hash-base容器、正则表达式以及另外10个组件。</strong></p>\n<p><strong>TR1自身只是一个规范。为获得TR1提供的好处，你需要一个份实物，如Boost。</strong></p>\n<h2 id=\"55-让自己熟悉Boost\"><a href=\"#55-让自己熟悉Boost\" class=\"headerlink\" title=\"55 让自己熟悉Boost\"></a>55 让自己熟悉Boost</h2>","feature":true,"text":"读完《Effective C++》后，确实感到收益匪浅。但因为目前是学生，平时实践并不多，恐怕很多知识点会忘记。所以，我打算写一篇读后总结，以便日后复习，用电子...","permalink":"/post/《Effective-C-》读后总结","photos":[],"count_time":{"symbolsCount":"38k","symbolsTime":"35 mins."},"categories":[{"name":"C++","slug":"C","count":4,"path":"api/categories/C.json"}],"tags":[{"name":"C++进阶","slug":"C-进阶","count":4,"path":"api/tags/C-进阶.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC\"><span class=\"toc-text\">一、让自己习惯C++</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E8%A7%86C-%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6\"><span class=\"toc-text\">1 视C++为一个语言联邦</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%B0%BD%E9%87%8F%E4%BB%A5const%E3%80%81enum%E3%80%81inline%E6%9B%BF%E6%8D%A2-define\"><span class=\"toc-text\">2 尽量以const、enum、inline替换#define</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8const\"><span class=\"toc-text\">3 尽量使用const</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E7%A1%AE%E4%BF%9D%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">4 确保对象被使用前已被初始化</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E6%9E%84%E9%80%A0-%E6%9E%90%E6%9E%84-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">二、构造&#x2F;析构&#x2F;赋值运算</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E4%BA%86%E8%A7%A3C-%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">5 了解C++默默编写并调用的函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D\"><span class=\"toc-text\">6 若不想使用编译器自动生成的函数，就该明确拒绝</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8Evirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">7 为多态基类声明virtual析构函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">8 别让异常逃离析构函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">9 绝不在构造和析构过程中调用virtual函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-%E4%BB%A4operator-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAreference-to-this\"><span class=\"toc-text\">10 令operator&#x3D;返回一个reference to *this</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-%E5%9C%A8operator-%E4%B8%AD%E5%A4%84%E7%90%86%E2%80%9C%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E2%80%9D\"><span class=\"toc-text\">11 在operator&#x3D;中处理“自我赋值”</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#12-%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%8B%BF%E5%BF%98%E5%85%B6%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%88%90%E5%88%86\"><span class=\"toc-text\">12 复制对象时勿忘其每一个成分</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">三、资源管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90\"><span class=\"toc-text\">13 以对象管理资源</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#14-%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83copying%E8%A1%8C%E4%B8%BA\"><span class=\"toc-text\">14 在资源管理类中小心copying行为</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#15-%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE\"><span class=\"toc-text\">15 在资源管理类中提供对原始资源的访问</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#16-%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8new%E5%92%8Cdelete%E6%97%B6%E8%A6%81%E9%87%87%E5%8F%96%E7%9B%B8%E5%90%8C%E5%BD%A2%E5%BC%8F\"><span class=\"toc-text\">16 成对使用new和delete时要采取相同形式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#17-%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86newed%E5%AF%B9%E8%B1%A1%E7%BD%AE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88\"><span class=\"toc-text\">17 以独立语句将newed对象置入智能指针</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E\"><span class=\"toc-text\">四、设计与声明</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#18-%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%AE%B9%E6%98%93%E8%A2%AB%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8D%E6%98%93%E8%A2%AB%E8%AF%AF%E7%94%A8\"><span class=\"toc-text\">18 让接口容易被正确使用，不易被误用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#19-%E8%AE%BE%E8%AE%A1class%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1type\"><span class=\"toc-text\">19 设计class犹如设计type</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#20-%E5%AE%81%E4%BB%A5pass-by-reference-to-const%E6%9B%BF%E6%8D%A2pass-by-value\"><span class=\"toc-text\">20 宁以pass-by-reference-to-const替换pass-by-value</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#21-%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E4%B8%8D%E8%A6%81%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9Ereference\"><span class=\"toc-text\">21 必须返回对象时，不要妄想返回reference</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#22-%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BAprivate\"><span class=\"toc-text\">22 将成员变量声明为private</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#23-%E5%AE%81%E4%BB%A5non-member%E3%80%81non-friend%E6%9B%BF%E6%8D%A2member%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">23 宁以non-member、non-friend替换member函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#24-%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8non-member%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">24 若所有参数皆需类型转换，请为此采用non-member函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#25-%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">25 考虑写出一个不抛异常的swap函数</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">五、实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#26-%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E7%9A%84%E5%87%BA%E7%8E%B0%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">26 尽可能延后变量定义式的出现时间</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#27-%E5%B0%BD%E9%87%8F%E5%B0%91%E5%81%9A%E8%BD%AC%E5%9E%8B%E5%8A%A8%E4%BD%9C\"><span class=\"toc-text\">27 尽量少做转型动作</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#28-%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9Ehandles%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86\"><span class=\"toc-text\">28 避免返回handles指向对象内部成分</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#29-%E4%B8%BA%E2%80%9C%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E2%80%9D%E8%80%8C%E5%8A%AA%E5%8A%9B%E6%98%AF%E5%80%BC%E5%BE%97%E7%9A%84\"><span class=\"toc-text\">29 为“异常安全”而努力是值得的</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#30-%E9%80%8F%E5%BD%BB%E4%BA%86%E8%A7%A3inlining%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96\"><span class=\"toc-text\">30 透彻了解inlining的里里外外</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#31-%E5%B0%86%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB%E9%99%8D%E8%87%B3%E6%9C%80%E4%BD%8E\"><span class=\"toc-text\">31 将文件间的编译依存关系降至最低</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%AD%E3%80%81%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">六、继承与面向对象设计</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#32-%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84public%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BAis-a%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">32 确定你的public继承塑模出is-a关系</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#33-%E9%81%BF%E5%85%8D%E9%81%AE%E6%8E%A9%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0\"><span class=\"toc-text\">33 避免遮掩继承而来的名称</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#34-%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">34 区分接口继承和实现继承</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#35-%E8%80%83%E8%99%91virtual%E5%87%BD%E6%95%B0%E4%BB%A5%E5%A4%96%E7%9A%84%E9%80%89%E6%8B%A9\"><span class=\"toc-text\">35 考虑virtual函数以外的选择</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#36-%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84non-virtual%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">36 绝不重新定义继承而来的non-virtual函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#37-%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%80%BC\"><span class=\"toc-text\">37 绝不重新定义继承而来的缺省参数值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#38-%E9%80%9A%E8%BF%87%E5%A4%8D%E5%90%88%E5%A1%91%E6%A8%A1%E5%87%BAhas-a%E6%88%96%E2%80%9C%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA%E2%80%9D\"><span class=\"toc-text\">38 通过复合塑模出has-a或“根据某物实现出”</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#39-%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8private%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">39 明智而审慎地使用private继承</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#40-%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">40 明智而审慎地使用多重继承</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%83%E3%80%81%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">七、模板与泛型编程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#41-%E4%BA%86%E8%A7%A3%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81\"><span class=\"toc-text\">41 了解隐式接口和编译期多态</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#42-%E4%BA%86%E8%A7%A3typename%E7%9A%84%E5%8F%8C%E9%87%8D%E6%84%8F%E4%B9%89\"><span class=\"toc-text\">42 了解typename的双重意义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#43-%E5%AD%A6%E4%B9%A0%E5%A4%84%E7%90%86%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%9F%BA%E7%B1%BB%E5%86%85%E7%9A%84%E5%90%8D%E7%A7%B0\"><span class=\"toc-text\">43 学习处理模板化基类内的名称</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#44-%E5%B0%86%E4%B8%8E%E5%8F%82%E6%95%B0%E6%97%A0%E5%85%B3%E7%9A%84%E4%BB%A3%E7%A0%81%E7%A7%BB%E5%87%BAtemplates\"><span class=\"toc-text\">44 将与参数无关的代码移出templates</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#45-%E8%BF%90%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%8E%A5%E5%8F%97%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">45 运用成员函数模板接受所有兼容类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#46-%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%97%B6%E8%AF%B7%E4%B8%BA%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">46 需要类型转换时请为模板定义非成员函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#47-%E8%AF%B7%E4%BD%BF%E7%94%A8traits-classes%E8%A1%A8%E7%8E%B0%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">47 请使用traits classes表现类型信息</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#48-%E8%AE%A4%E8%AF%86template-%E5%85%83%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">48 认识template 元编程</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%AB%E3%80%81%E5%AE%9A%E5%88%B6new%E5%92%8Cdelete\"><span class=\"toc-text\">八、定制new和delete</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#49-%E4%BA%86%E8%A7%A3new-handler%E7%9A%84%E8%A1%8C%E4%B8%BA\"><span class=\"toc-text\">49 了解new-handler的行为</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#50-%E4%BA%86%E8%A7%A3new%E5%92%8Cdelete%E7%9A%84%E5%90%88%E7%90%86%E6%9B%BF%E6%8D%A2%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">50 了解new和delete的合理替换时机</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#51-%E7%BC%96%E5%86%99new%E5%92%8Cdelete%E6%97%B6%E9%9C%80%E5%9B%BA%E5%AE%88%E5%B8%B8%E8%A7%84\"><span class=\"toc-text\">51 编写new和delete时需固守常规</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#52-%E5%86%99%E4%BA%86placement-new%E4%B9%9F%E8%A6%81%E5%86%99placement-delete\"><span class=\"toc-text\">52 写了placement new也要写placement delete</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B9%9D%E3%80%81%E6%9D%82%E9%A1%B9\"><span class=\"toc-text\">九、杂项</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#53-%E4%B8%8D%E8%A6%81%E8%BD%BB%E6%98%93%E5%BF%BD%E8%A7%86%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E8%AD%A6%E5%91%8A\"><span class=\"toc-text\">53 不要轻易忽视编译器的警告</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#54-%E8%AE%A9%E8%87%AA%E5%B7%B1%E7%86%9F%E6%82%89%E5%8C%85%E6%8B%ACTR1%E5%9C%A8%E5%86%85%E7%9A%84%E6%A0%87%E5%87%86%E7%A8%8B%E5%BA%8F%E5%BA%93\"><span class=\"toc-text\">54 让自己熟悉包括TR1在内的标准程序库</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#55-%E8%AE%A9%E8%87%AA%E5%B7%B1%E7%86%9F%E6%82%89Boost\"><span class=\"toc-text\">55 让自己熟悉Boost</span></a></li></ol></li></ol>","author":{"name":"Ac-Accelerator","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一位计算机技术爱好者，大学在读，目前正在学习C++、Python、Java和计算机系统以及计算机视觉深度学习等相关知识，欢迎交流","socials":{"github":"https://github.com/Ac-Accelerator","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_31702515?spm=1000.2115.3001.5343","juejin":"","customs":{"qq":{"icon":"/svg/QQ.svg","link":"http://tool.gljlw.com/qq/?qq=2583832841"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"Linux系统编程（文件操作）","uid":"e27fddc9922de42aba7a0e5c52964723","slug":"Linux系统编程（文件操作）","date":"2024-07-03T01:58:46.000Z","updated":"2024-07-03T17:39:23.429Z","comments":true,"path":"api/articles/Linux系统编程（文件操作）.json","keywords":"C++,Pyhton,Java,算法","cover":"img/linux.jpeg","text":"getopt函数c#include &lt;unistd.h&gt; int getopt(int argc, char * const argv[], con...","permalink":"/post/Linux系统编程（文件操作）","photos":[],"count_time":{"symbolsCount":"22k","symbolsTime":"20 mins."},"categories":[{"name":"Linux","slug":"Linux","count":2,"path":"api/categories/Linux.json"}],"tags":[{"name":"Linux","slug":"Linux","count":2,"path":"api/tags/Linux.json"},{"name":"C++","slug":"C","count":6,"path":"api/tags/C.json"}],"author":{"name":"Ac-Accelerator","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一位计算机技术爱好者，大学在读，目前正在学习C++、Python、Java和计算机系统以及计算机视觉深度学习等相关知识，欢迎交流","socials":{"github":"https://github.com/Ac-Accelerator","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_31702515?spm=1000.2115.3001.5343","juejin":"","customs":{"qq":{"icon":"/svg/QQ.svg","link":"http://tool.gljlw.com/qq/?qq=2583832841"}}}},"feature":true},"next_post":{"title":"Spring Boot","uid":"cee75310a6ad538e1f2e1c9426d13379","slug":"Spring-Boot","date":"2023-11-01T14:25:33.000Z","updated":"2023-11-05T06:23:47.294Z","comments":true,"path":"api/articles/Spring-Boot.json","keywords":"C++,Pyhton,Java,算法","cover":"/img/spring.jpeg","text":"Spring BootSpring Boot是什么上文关于Spring的介绍中提过，Spring是一个开发的生态圈，它提供了若干个项目，每个项目可以完成独立的功...","permalink":"/post/Spring-Boot","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[{"name":"Java","slug":"Java","count":6,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"Web开发","slug":"Web开发","count":3,"path":"api/tags/Web开发.json"},{"name":"Spring","slug":"Spring","count":2,"path":"api/tags/Spring.json"}],"author":{"name":"Ac-Accelerator","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一位计算机技术爱好者，大学在读，目前正在学习C++、Python、Java和计算机系统以及计算机视觉深度学习等相关知识，欢迎交流","socials":{"github":"https://github.com/Ac-Accelerator","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_31702515?spm=1000.2115.3001.5343","juejin":"","customs":{"qq":{"icon":"/svg/QQ.svg","link":"http://tool.gljlw.com/qq/?qq=2583832841"}}}},"feature":true}}