{"title":"C++ RAII与智能指针","uid":"182933b43edb5a2e2aab1a699c004ce0","slug":"C-RAII与智能指针","date":"2022-11-06T04:22:00.000Z","updated":"2023-09-25T16:37:57.933Z","comments":true,"path":"api/articles/C-RAII与智能指针.json","keywords":"C++,Pyhton,Java,算法","cover":"/img/CPPcover.webp","content":"<p>这是观看一位大佬<a href=\"https://space.bilibili.com/263032155\">双笙子佯谬</a>的视频后写的笔记。</p>\n<h3 id=\"RAII（Resource-Acquisition-Is-Initialization）\"><a href=\"#RAII（Resource-Acquisition-Is-Initialization）\" class=\"headerlink\" title=\"RAII（Resource Acquisition Is Initialization）\"></a>RAII（Resource Acquisition Is Initialization）</h3><p>资源获取视为初始化，反之，资源释放视为销毁<br><br>C++ 除了用于初始化的构造函数（constructor）<br><br>还包括了用于销毁的析构函数（destructor）</p>\n<p>传统内存管理</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;stdlib.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;stdio.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> nv = </span><span style=\"color: #B5CEA8\">4</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> *v = (</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> *)</span><span style=\"color: #DCDCAA\">malloc</span><span style=\"color: #D4D4D4\">(nv * </span><span style=\"color: #569CD6\">sizeof</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\">));</span><span style=\"color: #6A9955\">//分配内存得到一个指针</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">v</span><span style=\"color: #D4D4D4\">[</span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">] = </span><span style=\"color: #B5CEA8\">4</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">v</span><span style=\"color: #D4D4D4\">[</span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">] = </span><span style=\"color: #B5CEA8\">3</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">v</span><span style=\"color: #D4D4D4\">[</span><span style=\"color: #B5CEA8\">2</span><span style=\"color: #D4D4D4\">] = </span><span style=\"color: #B5CEA8\">2</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">v</span><span style=\"color: #D4D4D4\">[</span><span style=\"color: #B5CEA8\">3</span><span style=\"color: #D4D4D4\">] = </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> sum = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> i = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">; i &lt; nv; i++)</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        sum += </span><span style=\"color: #9CDCFE\">v</span><span style=\"color: #D4D4D4\">[i];</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #9CDCFE\">%d</span><span style=\"color: #CE9178\"> </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">, sum);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">free</span><span style=\"color: #D4D4D4\">(v);</span><span style=\"color: #6A9955\">//需要手动释放指针所对应的内存</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>RAII的内存管理</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;iostream&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;vector&gt;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::vector&lt;</span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\">&gt; </span><span style=\"color: #DCDCAA\">v</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">4</span><span style=\"color: #D4D4D4\">);</span><span style=\"color: #6A9955\">//调用构造函数获得对象的同时即可自动分配内存</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">v</span><span style=\"color: #D4D4D4\">[</span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">] = </span><span style=\"color: #B5CEA8\">4</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">v</span><span style=\"color: #D4D4D4\">[</span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">] = </span><span style=\"color: #B5CEA8\">3</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">v</span><span style=\"color: #D4D4D4\">[</span><span style=\"color: #B5CEA8\">2</span><span style=\"color: #D4D4D4\">] = </span><span style=\"color: #B5CEA8\">2</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">v</span><span style=\"color: #D4D4D4\">[</span><span style=\"color: #B5CEA8\">3</span><span style=\"color: #D4D4D4\">] = </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> sum = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> i = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">; i &lt; </span><span style=\"color: #9CDCFE\">v</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">size</span><span style=\"color: #D4D4D4\">(); i++)</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        sum += </span><span style=\"color: #9CDCFE\">v</span><span style=\"color: #D4D4D4\">[i];</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::cout &lt;&lt; sum;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span><span style=\"color: #6A9955\">//离开大括号作用域时自动调用析构函数释放内存</span></span>\n<span class=\"line\"></span></code></pre></div><p>乍一看C语言的内存管理也只是有一点点不方便而已啊，只要留点心就好了啊。但是看下面这个例子，每个带有返回的分支都要手动释放所有之前的资源，如果分支很多很复杂，就很容易造成疏忽。</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;fstream&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;vector&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;cstdio&gt;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    std::ifstream </span><span style=\"color: #DCDCAA\">f1</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"1.txt\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #DCDCAA\">checkFileContent</span><span style=\"color: #D4D4D4\">(f1))</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"bad file 1!</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">f1</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">close</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    std::ifstream </span><span style=\"color: #DCDCAA\">f2</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"2.txt\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #DCDCAA\">checkFileContent</span><span style=\"color: #D4D4D4\">(f2))</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"bad file 2!</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">f1</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">close</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">f2</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">close</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    std::vector&lt;std::ifstream&gt; files;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">files</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">push_back</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #DCDCAA\">std::ifstream</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"3.txt\"</span><span style=\"color: #D4D4D4\">));</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">files</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">push_back</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #DCDCAA\">std::ifstream</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"4.txt\"</span><span style=\"color: #D4D4D4\">));</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">files</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">push_back</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #DCDCAA\">std::ifstream</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"5.txt\"</span><span style=\"color: #D4D4D4\">));</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\"> (auto &amp;file : files)</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">file</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">close</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">f1</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">close</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">f2</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">close</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>可见RAII的思想可以帮助我们及时释放不再使用的内存，避免了手动内存管理可能导致的内存泄漏问题。</p>\n<p>与 Java，Python 等垃圾回收语言不同，C++ 的析构函数是显式的，离开作用域自动销毁，毫不含糊（有好处也有坏处，对高性能计算而言利大于弊）</p>\n<p>其次，C++ 标准保证当异常发生时，会调用已创建对象的析构函数。</p>\n<h3 id=\"类设计规则：三五法则\"><a href=\"#类设计规则：三五法则\" class=\"headerlink\" title=\"类设计规则：三五法则\"></a>类设计规则：三五法则</h3><ol>\n<li>如果一个类定义了<strong>析构函数</strong>，那么您必须同时定义或删除<strong>拷贝构造函数</strong>和<strong>拷贝赋值运算符</strong>，否则出错。</li>\n<li>如果一个类定义了<strong>拷贝构造函数</strong>，那么您必须同时定义或删除<strong>拷贝赋值运算符</strong>，否则出错，删除可导致低效。</li>\n<li>如果一个类定义了<strong>移动构造函数</strong>，那么您必须同时定义或删除<strong>移动赋值运算符</strong>，否则出错，删除可导致低效。</li>\n<li>如果一个类定义了<strong>拷贝构造函数</strong>或<strong>拷贝赋值运算符</strong>，那么您必须最好同时定义<strong>移动构造函数</strong>或<strong>移动赋值运算符</strong>，否则低效。</li>\n</ol>\n<h3 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h3><p>智能指针类重载了operator -&gt; ,使它的对象的行为看上去像是一个指针。</p>\n<h4 id=\"unique-ptr\"><a href=\"#unique-ptr\" class=\"headerlink\" title=\"unique_ptr:\"></a>unique_ptr:</h4><p>智能指针类unique_ptr，他的解构函数中会调用 delete，因此当对象生命周期结束的时候能够自动释放对象的内存，避免了<br>这里 make_unique&lt;C&gt;(…) 可以理解为和之前的 new C(…) 等价，括号里也可以有其他构造函数的参数。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;cstdio&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;memory&gt;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">C</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">C</span><span style=\"color: #D4D4D4\">() { </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"分配内存! </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">); };</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">~C</span><span style=\"color: #D4D4D4\">() { </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"释放内存! </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">); };</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::unique_ptr&lt;C&gt; p = </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">make_unique</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #4EC9B0\">C</span><span style=\"color: #D4D4D4\">&gt;();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\"> + </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\"> == </span><span style=\"color: #B5CEA8\">2</span><span style=\"color: #D4D4D4\">)</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"出了点小状况.......n \"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        //  自动释放p</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    // 自动释放p</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>在旧时代 C++ 里，常常听到这样的说法：<br><br>“释放一个指针后，必须把这个指针设为 nullptr，防止空悬指针！”<br><br>delete p;<br><br>p = nullptr;<br><br>unique_ptr 则把他们封装成一个操作：只需要<br><br>p = nullptr;      // 等价于：p.reset()<br><br>即可。将其设为空指针的同时释放资源，体现了面向对象“封装：不变性”的思想。<br></p>\n<p><strong>unique_ptr禁止拷贝:</strong><br>这是因为 unique_ptr 删除了拷贝构造函数导致的。为什么他要删除拷贝构造函数？<del>（unique指针不unique是吧）</del>,<br>原因还是三五法则，如果拷贝了指针，那么就会出现重复释放的问题。</p>\n<p>那么这个unique_ptr我们该怎么使用呢？看看下面这两个函数。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">func1</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">C</span><span style=\"color: #569CD6\">*</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">p</span><span style=\"color: #D4D4D4\">)</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">p</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #DCDCAA\">do_something</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">func2</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">unique_ptr</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #4EC9B0\">C</span><span style=\"color: #D4D4D4\">&gt;</span><span style=\"color: #9CDCFE\">p</span><span style=\"color: #D4D4D4\">)</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">p</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #DCDCAA\">do_something</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>func1传入一个传统的指针，我们在调用的时候使用p.get()获得一个传统的指针，没有接过掌管对象生命周期的大权。</p>\n<p>func2传入一个智能指针对象，我们在调用的时候需要使用std::move(p)将智能指针转换为右值（因为没有拷贝构造函数，必须调用移动构造函数），于是原智能指针指向对象的生命周期将交给func中的智能指针对象管理。</p>\n<p><em>移交控制权后仍希望访问到 p 指向的对象怎么办</em>？如果还是用 p 去访问的话，因为被移动构造函数转移了，p 已经变成空指针，从而出错。最简单的办法是，在移交控制权给 func2 前，提前通过 p.get() 获取原始指针raw_p;不过你得保证 raw_p 的存在时间不超过 p 的生命周期，否则会出现危险的空悬指针。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::unique_ptr&lt;C&gt; p = </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">make_unique</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #4EC9B0\">C</span><span style=\"color: #D4D4D4\">&gt;();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    C *raw_p = </span><span style=\"color: #9CDCFE\">p</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">get</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">raw_p</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #DCDCAA\">do_something</span><span style=\"color: #D4D4D4\">();</span><span style=\"color: #6A9955\"> // 正常执行</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">func2</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">move</span><span style=\"color: #D4D4D4\">(p));</span><span style=\"color: #6A9955\">   // 随着func2的结束，对象生命周期结束。</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">raw_p</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #DCDCAA\">do_something</span><span style=\"color: #D4D4D4\">();</span><span style=\"color: #6A9955\"> //错误！raw_p已经是悬垂指针了。</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><h4 id=\"shared-ptr\"><a href=\"#shared-ptr\" class=\"headerlink\" title=\"shared_ptr\"></a>shared_ptr</h4><p>unique_ptr使用起来很困难的原因，在于 unique_ptr 解决重复释放的方式是禁止拷贝，这样虽然有效率高的优势，但导致使用困难，容易犯错等。<br>相比之下， 牺牲效率换来自由度的 shared_ptr 则允许拷贝，他解决重复释放的方式是通过引用计数：<br>当一个 shared_ptr 初始化时，将计数器设为1。<br>当一个 shared_ptr 被拷贝时，计数器加1。<br>当一个 shared_ptr 被解构时，计数器减1。减到0时，则自动销毁他指向的对象。<br>从而可以保证，只要还有存在哪怕一个指针指向该对象，就不会被解构。  </p>\n<p>所以shared_ptr是可以被拷贝的。</p>\n<p><strong>shared_ptr循环引用导致内存泄漏</strong></p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;memory&gt;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">C</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::shared_ptr&lt;C&gt; m_child;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::shared_ptr&lt;C&gt; m_parent;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">auto</span><span style=\"color: #D4D4D4\"> parent = </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">make_shared</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #4EC9B0\">C</span><span style=\"color: #D4D4D4\">&gt;();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">auto</span><span style=\"color: #D4D4D4\"> child = </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">make_shared</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #4EC9B0\">C</span><span style=\"color: #D4D4D4\">&gt;();</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    // 建立相互引用∶</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">parent</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">m_child</span><span style=\"color: #D4D4D4\"> = child;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">child</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">m_parent</span><span style=\"color: #D4D4D4\"> = parent;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    parent = </span><span style=\"color: #569CD6\">nullptr</span><span style=\"color: #D4D4D4\">;</span><span style=\"color: #6A9955\"> // parent不会被释放 !因为child还指向他 !</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    child = </span><span style=\"color: #569CD6\">nullptr</span><span style=\"color: #D4D4D4\">;</span><span style=\"color: #6A9955\">  // child也不会被释放 !因为parent还指向他 !</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><h4 id=\"week-ptr的概念\"><a href=\"#week-ptr的概念\" class=\"headerlink\" title=\"week_ptr的概念\"></a>week_ptr的概念</h4><p>为了解决循环引用的问题，引入了week_ptr。</p>\n<p>有时候我们希望维护一个 shared_ptr 的弱引用 weak_ptr，即：弱引用的拷贝与解构不影响其引用计数器。<br>之后有需要时，可以通过 lock() 随时产生一个新的 shared_ptr 作为强引用。但不 lock 的时候不影响计数。<br>如果失效（计数器归零）则 expired() 会返回 false，且 lock() 也会返回 nullptr。</p>\n<p>可以把 C * 理解为 unique_ptr 的弱引用。<br>weak_ptr 理解为 shared_ptr 的弱引用。<br>但 weak_ptr 能提供失效检测，更安全。  </p>\n<p>week_ptr示例：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;memory&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;vector&gt;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">C</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::shared_ptr&lt;C&gt; m_child;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::shared_ptr&lt;C&gt; m_parent;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::vector&lt;</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::shared_ptr&lt;C&gt;&gt; objlist;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">func3</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #4EC9B0\">shared_ptr</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #4EC9B0\">C</span><span style=\"color: #D4D4D4\">&gt; </span><span style=\"color: #9CDCFE\">p</span><span style=\"color: #D4D4D4\">)</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">p</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #DCDCAA\">do_something</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">objlist</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">push_back</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">move</span><span style=\"color: #D4D4D4\">(p));</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::shared_ptr&lt;C&gt; p = </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">make_shared</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #4EC9B0\">C</span><span style=\"color: #D4D4D4\">&gt;();</span><span style=\"color: #6A9955\"> //引用计数初始化为1</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"use count = </span><span style=\"color: #9CDCFE\">%ld</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #9CDCFE\">p</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">use_count</span><span style=\"color: #D4D4D4\">());</span><span style=\"color: #6A9955\">   // 1</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::weak_ptr&lt;C&gt; weak_p = p;</span><span style=\"color: #6A9955\">                  // 创建一个不影响计数器的弱引用</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"use count = </span><span style=\"color: #9CDCFE\">%ld</span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #9CDCFE\">p</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">use_count</span><span style=\"color: #D4D4D4\">());</span><span style=\"color: #6A9955\">   // 1</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">func3</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">move</span><span style=\"color: #D4D4D4\">(p));</span><span style=\"color: #6A9955\">                          //控制权转移，p变为null，引用计数加不变</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #9CDCFE\">weak_p</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">expired</span><span style=\"color: #D4D4D4\">())</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"错误︰弱引用已失效! \"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">weak_p</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">lock</span><span style=\"color: #D4D4D4\">()-&gt;</span><span style=\"color: #DCDCAA\">do_something</span><span style=\"color: #D4D4D4\">();</span><span style=\"color: #6A9955\"> //正常执行，p的生命周期仍被objlist延续着</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">objlist</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">clear</span><span style=\"color: #D4D4D4\">();</span><span style=\"color: #6A9955\">                   //刚刚p移交给func的生命周期结束了!引用计数减1，变成0了</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #9CDCFE\">weak_p</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">expired</span><span style=\"color: #D4D4D4\">())</span><span style=\"color: #6A9955\">              //因为shared_ptr指向的对象已释放，弱引用会失效</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"错误︰弱引用已失效! \"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">weak_p</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">lock</span><span style=\"color: #D4D4D4\">()-&gt;</span><span style=\"color: #DCDCAA\">do_something</span><span style=\"color: #D4D4D4\">();</span><span style=\"color: #6A9955\"> // 不会执行</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span><span style=\"color: #6A9955\">                          //到这里最后一个弱引用weak_p也被释放，他指向的“管理块”被释放</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p><em>循环引用：解决方案1</em> 用week_ptr和shared_ptr<br>只需要把其中逻辑上“不具有所属权”的那一个改成 weak_ptr 即可：<br>因为父窗口“拥有”子窗口是天经地义的，而子窗口并不“拥有”父窗口。<br>其实主要是一个父窗口可以有多个子窗口，只有规定子窗口从属于父窗口才能解决引用计数的问题……</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;memory&gt;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">C</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::shared_ptr&lt;C&gt; m_child;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::week_ptr&lt;C&gt; m_parent;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">auto</span><span style=\"color: #D4D4D4\"> parent = </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">make_shared</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #4EC9B0\">C</span><span style=\"color: #D4D4D4\">&gt;();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">auto</span><span style=\"color: #D4D4D4\"> child = </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">make_shared</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #4EC9B0\">C</span><span style=\"color: #D4D4D4\">&gt;();</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    // 建立相互引用∶</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">parent</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">m_child</span><span style=\"color: #D4D4D4\"> = child;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">child</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">m_parent</span><span style=\"color: #D4D4D4\"> = parent;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    parent = </span><span style=\"color: #569CD6\">nullptr</span><span style=\"color: #D4D4D4\">;</span><span style=\"color: #6A9955\"> // parent会被释放 !因为child指向他的是一个弱引用 !</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    child = </span><span style=\"color: #569CD6\">nullptr</span><span style=\"color: #D4D4D4\">;</span><span style=\"color: #6A9955\">  // child会被释放 !因为parent已经被释放 !</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p><em>循环引用：解决方案2</em><br>还有一种更适应“父子窗口”这一场景的解决方案。刚才提到原始指针的应用场景是“当该对象不属于我，但他释放前我必然被释放时”。这里我们可以发现父窗口的释放必然导致子窗口的释放。因此我们完全可以把 m_parent 变成原始指针。<br>这样也不需要 weak_ptr 判断是否 expired() 了。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;memory&gt;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">C</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::shared_ptr&lt;C&gt; m_child;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    C* m_parent;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">auto</span><span style=\"color: #D4D4D4\"> parent = </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">make_shared</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #4EC9B0\">C</span><span style=\"color: #D4D4D4\">&gt;();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">auto</span><span style=\"color: #D4D4D4\"> child = </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">make_shared</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #4EC9B0\">C</span><span style=\"color: #D4D4D4\">&gt;();</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    // 建立相互引用∶</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">parent</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">m_child</span><span style=\"color: #D4D4D4\"> = child;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">child</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">m_parent</span><span style=\"color: #D4D4D4\"> = </span><span style=\"color: #9CDCFE\">parent</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">get</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    parent = </span><span style=\"color: #569CD6\">nullptr</span><span style=\"color: #D4D4D4\">;</span><span style=\"color: #6A9955\"> // parent会被释放 !因为child指向他的是一个原始指针</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    child = </span><span style=\"color: #569CD6\">nullptr</span><span style=\"color: #D4D4D4\">;</span><span style=\"color: #6A9955\">  // child会被释放 !因为parent已经被释放 !</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>解决方案2还可以更好！就是用原始指针和unique_ptr<br>刚才提到 unique_ptr 的应用场景是“当该对象仅仅属于我时”。既然都用了原始指针（假定他释放前我必然被释放）。因为因此我们完全可以把 m_child 变成一个标志这“完全所有权”的 unique_ptr。<br>这样也不需要 shared_ptr 维护一个原子计数器的开销了。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;memory&gt;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">C</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::unique_ptr&lt;C&gt; m_child;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    C* m_parent;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">};</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">()</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">auto</span><span style=\"color: #D4D4D4\"> parent = </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">make_unique</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #4EC9B0\">C</span><span style=\"color: #D4D4D4\">&gt;();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">auto</span><span style=\"color: #D4D4D4\"> child = </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">make_unique</span><span style=\"color: #D4D4D4\">&lt;</span><span style=\"color: #4EC9B0\">C</span><span style=\"color: #D4D4D4\">&gt;();</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    // 建立相互引用∶</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">parent</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">m_child</span><span style=\"color: #D4D4D4\"> = </span><span style=\"color: #4EC9B0\">std</span><span style=\"color: #D4D4D4\">::</span><span style=\"color: #DCDCAA\">move</span><span style=\"color: #D4D4D4\">(child);</span><span style=\"color: #6A9955\">//移交所属权</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #9CDCFE\">child</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">m_parent</span><span style=\"color: #D4D4D4\"> = </span><span style=\"color: #9CDCFE\">parent</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #DCDCAA\">get</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    parent = </span><span style=\"color: #569CD6\">nullptr</span><span style=\"color: #D4D4D4\">;</span><span style=\"color: #6A9955\"> // parent会被释放 !因为child指向他的是一个原始指针</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    child = </span><span style=\"color: #569CD6\">nullptr</span><span style=\"color: #D4D4D4\">;</span><span style=\"color: #6A9955\">  // child会被释放 !因为parent已经被释放 !</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>综上所述：原始指针和unique_ptr是一对的，week_ptr和shared_ptr是一对的。我们在对性能要求比较高的时候使用原始指针和unique_ptr，这样是可以减小维护开销的。但是明显week_ptr和shared_ptr这一对安全性更高。</p>\n<h3 id=\"哪些类型是安全的\"><a href=\"#哪些类型是安全的\" class=\"headerlink\" title=\"哪些类型是安全的\"></a>哪些类型是安全的</h3><p><strong>三五法则：什么时候需要担心</strong><br>一般来说，可以认为符合三五法则的类型是安全的。<br><em>以下类型是安全的：</em><br>int id;                                        // 基础类型<br>std::vector&lt;int&gt; arr;                  // STL 容器<br>std::shared_ptr&lt;Object&gt; child; // 智能指针<br>Object *parent;                         // 原始指针，如果是从智能指针里 .get() 出来的  </p>\n<p><em>以下对象是不安全的：</em><br>char *ptr;                                   // 原始指针，如果是通过 malloc/free 或 new/    delete 分配的<br>GLint tex;                                  // 是基础类型 int，但是对应着某种资源<br>std::vector&lt;Object *&gt; objs;       // STL 容器，但存了不安全的对象  </p>\n<h4 id=\"成员都是安全的类型\"><a href=\"#成员都是安全的类型\" class=\"headerlink\" title=\"成员都是安全的类型\"></a>成员都是安全的类型</h4><p><strong>成员都是安全的类型：五大函数，一个也不用声明</strong><br>如果你的类所有成员，都是安全的类型，那么五大函数都无需声明（或声明为 = default），你的类自动就是安全的。<br>最好的判断方式是：如果你不需要自定义的解构函数，那么这个类就不需要担心。<br>因为如果用到了自定义解构函数，往往意味着你的类成员中，包含有不安全的类型。<br>一般无外乎两种情况：<br><em>你的类管理着资源。</em><br><em>你的类是数据结构。</em> </p>\n<h4 id=\"管理着资源\"><a href=\"#管理着资源\" class=\"headerlink\" title=\"管理着资源\"></a>管理着资源</h4><p><strong>管理着资源：删除拷贝函数，然后统一用智能指针管理</strong><br>这个类管理着某种资源，资源往往不能被“复制”。比如一个 OpenGL 的着色器，或是一个 Qt 的窗口。<br>如果你允许 GLShader 拷贝，就相当于把 glCreateShader 返回的 int 拷贝两遍，解构时就会出现重复释放 (double free) 错误。<br>你会想“那我是不是可以在 GLShader 里加一个引用计数器呢，这样就可以算拷贝次数避免重复释放了！”<br>可以，但是既然标准库已经提供了 shared_ptr，还不如用 shared_ptr&lt;GLShader&gt; 来管理，省的每个类实现一遍原子引用计数器。  </p>\n<h4 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h4><p><strong>是数据结构：如果可以，定义拷贝和移动</strong><br>这个类是你精心设计的数据结构，如果这些数据结构是可以支持拷贝的，你可能需要自己一个个定义。如果不支持，那就删除（= delete）。</p>\n<h3 id=\"函数参数类型优化规则\"><a href=\"#函数参数类型优化规则\" class=\"headerlink\" title=\"函数参数类型优化规则\"></a>函数参数类型优化规则</h3><p><strong>函数参数类型优化规则：按引用还是按值？</strong><br>如果是基础类型（比如 int，float）则按值传递：<br>float squareRoot(float val);<br>如果是原始指针（比如 int *，Object *）则按值传递：<br>void doSomethingWith(Object *ptr);<br>如果是数据容器类型（比如 vector，string）则按常引用传递：<br>int sumArray(std::vector &lt;int&gt; const &amp;arr);<br>如果数据容器不大（比如 tuple&lt;int, int&gt;），则其实可以按值传递：<br>glm::vec3 calculateGravityAt(glm::vec3 pos);<br>如果是智能指针（比如 shared_ptr），且需要生命周期控制权，则按值传递：<br>void addObject(std::shared_ptr&lt; Object &gt;obj);<br>如果是智能指针，但不需要生命周期，则通过 .get() 获取原始指针后，按值传递：<br>void modifyObject(Object *obj);</p>\n","feature":true,"text":"这是观看一位大佬双笙子佯谬的视频后写的笔记。 RAII（Resource Acquisition Is Initialization）资源获取视为初始化，反之，...","permalink":"/post/C-RAII与智能指针","photos":[],"count_time":{"symbolsCount":"9.1k","symbolsTime":"8 mins."},"categories":[{"name":"C++","slug":"C","count":3,"path":"api/categories/C.json"}],"tags":[{"name":"内存安全","slug":"内存安全","count":1,"path":"api/tags/内存安全.json"},{"name":"C++进阶","slug":"C-进阶","count":3,"path":"api/tags/C-进阶.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RAII%EF%BC%88Resource-Acquisition-Is-Initialization%EF%BC%89\"><span class=\"toc-text\">RAII（Resource Acquisition Is Initialization）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E8%AE%BE%E8%AE%A1%E8%A7%84%E5%88%99%EF%BC%9A%E4%B8%89%E4%BA%94%E6%B3%95%E5%88%99\"><span class=\"toc-text\">类设计规则：三五法则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88\"><span class=\"toc-text\">智能指针</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#unique-ptr\"><span class=\"toc-text\">unique_ptr:</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#shared-ptr\"><span class=\"toc-text\">shared_ptr</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#week-ptr%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">week_ptr的概念</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%AE%89%E5%85%A8%E7%9A%84\"><span class=\"toc-text\">哪些类型是安全的</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E9%83%BD%E6%98%AF%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">成员都是安全的类型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AE%A1%E7%90%86%E7%9D%80%E8%B5%84%E6%BA%90\"><span class=\"toc-text\">管理着资源</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">数据结构</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96%E8%A7%84%E5%88%99\"><span class=\"toc-text\">函数参数类型优化规则</span></a></li></ol>","author":{"name":"Ac-Accelerator","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一位计算机技术爱好者，大学在读，目前正在学习C++、Python、Java和计算机系统以及计算机视觉深度学习等相关知识，欢迎交流","socials":{"github":"https://github.com/Ac-Accelerator","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_31702515?spm=1000.2115.3001.5343","juejin":"","customs":{"qq":{"icon":"/svg/QQ.svg","link":"http://tool.gljlw.com/qq/?qq=2583832841"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"编译器优化","uid":"654198c9751861f6164cbde797aab0ed","slug":"编译器优化","date":"2022-11-08T09:13:00.000Z","updated":"2023-09-25T16:40:39.684Z","comments":true,"path":"api/articles/编译器优化.json","keywords":"C++,Pyhton,Java,算法","cover":"/img/CPPcover.webp","text":"这是观看一位大佬双笙子佯谬的视频后写的笔记。 汇编基础x64架构CPU寄存器模型 汇编语言 gcc编译器里函数的前6个参数：分别通过*di，*si，*dx，*c...","permalink":"/post/编译器优化","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"C++","slug":"C","count":3,"path":"api/categories/C.json"}],"tags":[{"name":"C++进阶","slug":"C-进阶","count":3,"path":"api/tags/C-进阶.json"},{"name":"编译器优化","slug":"编译器优化","count":1,"path":"api/tags/编译器优化.json"}],"author":{"name":"Ac-Accelerator","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一位计算机技术爱好者，大学在读，目前正在学习C++、Python、Java和计算机系统以及计算机视觉深度学习等相关知识，欢迎交流","socials":{"github":"https://github.com/Ac-Accelerator","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_31702515?spm=1000.2115.3001.5343","juejin":"","customs":{"qq":{"icon":"/svg/QQ.svg","link":"http://tool.gljlw.com/qq/?qq=2583832841"}}}},"feature":true},"next_post":{"title":"深度学习多模态：CLIP","uid":"deafe07fcf5e4e17bdc29bc3bc203d8e","slug":"深度学习多模态：CLIP","date":"2022-11-06T03:54:00.000Z","updated":"2023-07-13T18:11:07.954Z","comments":true,"path":"api/articles/深度学习多模态：CLIP.json","keywords":"C++,Pyhton,Java,算法","cover":"/img/ai.jpeg","text":"本篇章搬运自同校同学snowy的笔记。 什么是CLIPContrastive Language-Image Pre-Training—CLIP利用文本的监督信号...","permalink":"/post/深度学习多模态：CLIP","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"人工智能","slug":"人工智能","count":4,"path":"api/categories/人工智能.json"}],"tags":[{"name":"Transformer","slug":"Transformer","count":1,"path":"api/tags/Transformer.json"},{"name":"多模态学习","slug":"多模态学习","count":1,"path":"api/tags/多模态学习.json"}],"author":{"name":"Ac-Accelerator","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一位计算机技术爱好者，大学在读，目前正在学习C++、Python、Java和计算机系统以及计算机视觉深度学习等相关知识，欢迎交流","socials":{"github":"https://github.com/Ac-Accelerator","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_31702515?spm=1000.2115.3001.5343","juejin":"","customs":{"qq":{"icon":"/svg/QQ.svg","link":"http://tool.gljlw.com/qq/?qq=2583832841"}}}},"feature":true}}