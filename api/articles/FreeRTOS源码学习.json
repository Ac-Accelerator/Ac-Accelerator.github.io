{"title":"FreeRTOS源码学习","uid":"b7792344e86e32daf60ff27b68b40109","slug":"FreeRTOS源码学习","date":"2025-02-25T02:17:00.000Z","updated":"2025-03-01T07:18:15.566Z","comments":true,"path":"api/articles/FreeRTOS源码学习.json","keywords":"C++,Pyhton,Java,算法","cover":"img/freertos.png","content":"<h1 id=\"如何移植FreeRTOS到开发版上\"><a href=\"#如何移植FreeRTOS到开发版上\" class=\"headerlink\" title=\"如何移植FreeRTOS到开发版上\"></a>如何移植FreeRTOS到开发版上</h1><h2 id=\"FreeRTOS的目录结构\"><a href=\"#FreeRTOS的目录结构\" class=\"headerlink\" title=\"FreeRTOS的目录结构\"></a>FreeRTOS的目录结构</h2><div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #D4D4D4\">.</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">└── FreeRTOS</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    └── Source                              # FreeRTOS源码</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ├── CMSIS_RTOS_V2                   # CMSIS-RTOS V2 API</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── cmsis_os2.c</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── cmsis_os2.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── cmsis_os.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── freertos_mpool.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   └── freertos_os2.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ├── include                         # FreeRTOS 内核头文件</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── croutine.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── deprecated_definitions.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── event_groups.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── FreeRTOS.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── list.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── message_buffer.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── mpu_prototypes.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── mpu_wrappers.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── portable.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── projdefs.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── queue.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── semphr.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── stack_macros.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── StackMacros.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── stream_buffer.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── task.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   └── timers.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ├── portable                        # 移植层</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── GCC                         # GCC编译器</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   │   └── ARM_CM3                 # ARM Cortex-M3</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   │       ├── port.c</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   │       └── portmacro.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   └── MemMang                     # 内存管理</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │       └── heap_3.c</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ├── list.c                          # 链表管理（核心）</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ├── queue.c                         # 队列管理（核心）</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ├── tasks.c                         # 任务管理（核心）</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ├── croutine.c                      # 协程功能（可选）（弃用）</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ├── timers.c                        # 软件计时器功能（可选）</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ├── event_groups.c                  # 事件组功能（可选）</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ├── stream_buffer.c                 # 流缓冲区功能（可选）</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        └── LICENSE</span></span></code></pre></div><p>首先看到的是 <strong>CMSIS_RTOS_V2</strong> 目录，这个不包含在 FreeRTOS 的源码中，而是 FreeRTOS 为了支持 CMSIS-RTOS V2 API 而提供的一抽象层。ARM公司将各个RTOS的接口统一起来，作为CMSIS-RTOS接口，使用该接口编程可以提高代码的移植性（虽然我没用到就是了）</p>\n<p>此外还有 <strong>include</strong> 目录，放了 FreeRTOS 的头文件，要使用功能的时候包含这些头文件即可。</p>\n<p><strong>portable</strong> 目录是 FreeRTOS 的移植层，因为 freeRTOS 是一个高度抽象的操作系统（更准确来说是一个用于实现并行的库），因此在不同的平台上运行，需要为 freeRTOS 提供一些底层的支持。该目录下的文件包含了大量的宏和内联汇编代码，freeRTOS 通过统一的宏定义来调用这些底层的功能支持。<strong>MemMang</strong> 里面包含的是和内存管理策略相关的代码，FreeRTOS 提供了多种内存管理策略，可以根据需求随时更换。</p>\n<p>注意在 <strong>FreeRTOS.h</strong> 头文件中，引用了 <strong>FreeRTOSConfig.h</strong> 文件，请确保该文件能够被引用，这个文件包含一些用户定义的宏，用于为应用程序量身定制 RTOS 内核，所以位置应位于应用程序目录中，而不是 RTOS 内核源代码目录中（从项目架构角度看）。</p>\n<h2 id=\"移植\"><a href=\"#移植\" class=\"headerlink\" title=\"移植\"></a>移植</h2><p>前面讲到，FreeRTOS 是一个高度抽象的库，因此需要为 FreeRTOS 提供一些底层的支持。正常来说的话，如果不是太冷门的芯片，在 <strong>portable</strong> 目录下都能找到对应的移植文件，只需要将这些文件添加到工程中即可。 然后把 <strong>include</strong> 以及 核心文件 <strong>list.c</strong>、<strong>queue.c</strong>、<strong>tasks.c</strong> 添加到工程中，其他的文件根据需要添加。最后在 <strong>FreeRTOSConfig.h</strong> 中配置 FreeRTOS 的一些功能。</p>\n<p>在 <strong>FreeRTOSConfig.h</strong> 头文件的配置，可以参考<a href=\"https://www.freertos.org/zh-cn-cmn-s/Documentation/02-Kernel/03-Supported-devices/02-Customization\">官网的文档</a>或者示例。但是有几个点要注意一下：</p>\n<ol>\n<li>如果是使用了特定的处理器架构，除了配置 ‘config’ 和 ‘INCLUDE’ 开头的宏定义之外，还有一些中断相关的也要在这里配置，比如：<ul>\n<li>#define vPortSVCHandler    SVC_Handler</li>\n<li>#define xPortPendSVHandler  PendSV_Handler</li>\n<li>虽然有一个 xPortSysTickHandler ，但是先不在这里配置，因为有一些条件判断之类的。</li>\n</ul>\n</li>\n<li>configCHECK_HANDLER_INSTALLATION 宏定义，默认为 1 ，表示 FreeRTOS 会自动检查中断服务函数是否安装，如果没有安装则会无法通过 configASSERT 。所以如果忘了配置第一条，那么 FreeRTOS 会一直卡在那里，是一个保险措施哦。</li>\n<li>之前提到的 xPortSysTickHandler 呢？这个函数会递增 FreeRTOS 的系统时钟节拍，并检查是否需要进行任务切换。但是调用的时候要做一些条件判断，因此就在 SysTick_Handler 函数中调用 xPortSysTickHandler 函数，代码放在下面。</li>\n<li>如果定义了 configSUPPORT_STATIC_ALLOCATION 为 1 ，那么就要多定义两个函数了，代码也放在下面。</li>\n</ol>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>关于第一项的官网原文：</p>\n<p><strong>ARM Cortex-M 用户特别注意事项：</strong> ARM Cortex-M3、ARM Cortex-M4 和 ARM Cortex-M4F 移植要求 在 SysTick、PendSV 和 SVCCall 中断向量上安装 FreeRTOS 处理程序。</p>\n\n</div>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #6A9955\">//在 SysTick_Handler 函数中调用 xPortSysTickHandler 函数</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">extern</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">xPortSysTickHandler</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">SysTick_Handler</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">  /* Clear overflow flag */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #9CDCFE\">SysTick</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">CTRL</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #DCDCAA\">xTaskGetSchedulerState</span><span style=\"color: #D4D4D4\">() != taskSCHEDULER_NOT_STARTED) {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* Call tick handler */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">xPortSysTickHandler</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">//如果定义了 configSUPPORT_STATIC_ALLOCATION 为 1 ，那么就要多定义两个函数</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">vApplicationGetIdleTaskMemory</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #4EC9B0\">StaticTask_t</span><span style=\"color: #D4D4D4\"> **</span><span style=\"color: #9CDCFE\">ppxIdleTaskTCBBuffer</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #4EC9B0\">StackType_t</span><span style=\"color: #D4D4D4\"> **</span><span style=\"color: #9CDCFE\">ppxIdleTaskStackBuffer</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">uint32_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">pulIdleTaskStackSize</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">  /* Idle task control block and stack */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">StaticTask_t</span><span style=\"color: #D4D4D4\"> Idle_TCB;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">StackType_t</span><span style=\"color: #D4D4D4\">  </span><span style=\"color: #9CDCFE\">Idle_Stack</span><span style=\"color: #D4D4D4\">[configMINIMAL_STACK_SIZE];</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  *ppxIdleTaskTCBBuffer   = &amp;Idle_TCB;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  *ppxIdleTaskStackBuffer = &amp;</span><span style=\"color: #9CDCFE\">Idle_Stack</span><span style=\"color: #D4D4D4\">[</span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">];</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  *pulIdleTaskStackSize   = (</span><span style=\"color: #569CD6\">uint32_t</span><span style=\"color: #D4D4D4\">)configMINIMAL_STACK_SIZE;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">vApplicationGetTimerTaskMemory</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #4EC9B0\">StaticTask_t</span><span style=\"color: #D4D4D4\"> **</span><span style=\"color: #9CDCFE\">ppxTimerTaskTCBBuffer</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #4EC9B0\">StackType_t</span><span style=\"color: #D4D4D4\"> **</span><span style=\"color: #9CDCFE\">ppxTimerTaskStackBuffer</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">uint32_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">pulTimerTaskStackSize</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">  /* Timer task control block and stack */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">StaticTask_t</span><span style=\"color: #D4D4D4\"> Timer_TCB;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">StackType_t</span><span style=\"color: #D4D4D4\">  </span><span style=\"color: #9CDCFE\">Timer_Stack</span><span style=\"color: #D4D4D4\">[configTIMER_TASK_STACK_DEPTH];</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  *ppxTimerTaskTCBBuffer   = &amp;Timer_TCB;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  *ppxTimerTaskStackBuffer = &amp;</span><span style=\"color: #9CDCFE\">Timer_Stack</span><span style=\"color: #D4D4D4\">[</span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">];</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  *pulTimerTaskStackSize   = (</span><span style=\"color: #569CD6\">uint32_t</span><span style=\"color: #D4D4D4\">)configTIMER_TASK_STACK_DEPTH;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><h2 id=\"简单的使用\"><a href=\"#简单的使用\" class=\"headerlink\" title=\"简单的使用\"></a>简单的使用</h2><p>那就先创建两个任务，一个任务每隔 1s 打印一次 “Hello World1!” ，另一个任务每隔 0.5s 打印一次 “Hello World2!” 。</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;FreeRTOS.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;rcc.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;sram.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;stdio.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;task.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;uart1.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">TaskHandle_t</span><span style=\"color: #D4D4D4\"> xTask1Handle;</span></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">TaskHandle_t</span><span style=\"color: #D4D4D4\"> xTask2Handle;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">test1Task</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #C586C0\">while</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"Hello World1!</span><span style=\"color: #D7BA7D\">\\r\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">vTaskDelay</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">1000</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">test2Task</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #C586C0\">while</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"Hello World!2</span><span style=\"color: #D7BA7D\">\\r\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">vTaskDelay</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">500</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">() {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">RCC_config</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">uart1_init</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">sram_init</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">xTaskCreate</span><span style=\"color: #D4D4D4\">(test1Task, </span><span style=\"color: #CE9178\">\"Task1\"</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #B5CEA8\">128</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">, &amp;xTask1Handle);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">xTaskCreate</span><span style=\"color: #D4D4D4\">(test2Task, </span><span style=\"color: #CE9178\">\"Task2\"</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #B5CEA8\">128</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">, &amp;xTask2Handle);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">vTaskStartScheduler</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #C586C0\">while</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* code */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>FreeRTOS 应用程序与非 RTOS 应用程序的启动和执行方式在调用 vTaskStartScheduler() 之前没什么不同，vTaskStartScheduler() 通常从应用程序的 main() 函数调用。RTOS 仅控制 调用 vTaskStartScheduler() 后的执行顺序。</p>\n<h1 id=\"部分源码分析\"><a href=\"#部分源码分析\" class=\"headerlink\" title=\"部分源码分析\"></a>部分源码分析</h1><h2 id=\"核心全局变量\"><a href=\"#核心全局变量\" class=\"headerlink\" title=\"核心全局变量\"></a>核心全局变量</h2><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #6A9955\">/* 就绪和阻塞任务列表。 </span></span>\n<span class=\"line\"><span style=\"color: #6A9955\"> * xDelayedTaskList1 和 xDelayedTaskList2 可以移动到函数作用域内，但这样做会破坏一些内核感知调试器和依赖于删除</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\"> * static 限定符的调试器。 */</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">List_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pxReadyTasksLists</span><span style=\"color: #D4D4D4\">[ configMAX_PRIORITIES ];</span><span style=\"color: #6A9955\"> /**&lt; 优先级排序的就绪任务列表。 */</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">List_t</span><span style=\"color: #D4D4D4\"> xDelayedTaskList1;</span><span style=\"color: #6A9955\">                         /**&lt; 延迟任务列表。 */</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">List_t</span><span style=\"color: #D4D4D4\"> xDelayedTaskList2;</span><span style=\"color: #6A9955\">                         /**&lt; 延迟任务列表（使用了两个列表 - 一个用于延迟时间已超过当前 tick 计数的任务）。 */</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">List_t</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #569CD6\">volatile</span><span style=\"color: #D4D4D4\"> pxDelayedTaskList;</span><span style=\"color: #6A9955\">              /**&lt; 指向当前正在使用的延迟任务列表。 */</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">List_t</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #569CD6\">volatile</span><span style=\"color: #D4D4D4\"> pxOverflowDelayedTaskList;</span><span style=\"color: #6A9955\">      /**&lt; 指向当前正在使用的延迟任务列表，用于保存延迟时间已超过当前 tick 计数的任务。 */</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">List_t</span><span style=\"color: #D4D4D4\"> xPendingReadyList;</span><span style=\"color: #6A9955\">                         /**&lt; 在调度器挂起期间变为就绪的任务。当调度器恢复时，它们将被移动到就绪列表。 */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( INCLUDE_vTaskDelete </span><span style=\"color: #D4D4D4\">==</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #569CD6\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">List_t</span><span style=\"color: #D4D4D4\"> xTasksWaitingTermination;</span><span style=\"color: #6A9955\"> /**&lt; 已删除但其内存尚未释放的任务列表。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">volatile</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> uxDeletedTasksWaitingCleanUp = ( </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0U</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#endif</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( INCLUDE_vTaskSuspend </span><span style=\"color: #D4D4D4\">==</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #569CD6\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">List_t</span><span style=\"color: #D4D4D4\"> xSuspendedTaskList;</span><span style=\"color: #6A9955\"> /**&lt; 当前被挂起的任务列表。 */</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#endif</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">/* 全局 POSIX errno。它的值在上下文切换时更改，以匹配当前运行任务的 errno。 */</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( configUSE_POSIX_ERRNO </span><span style=\"color: #D4D4D4\">==</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #569CD6\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> FreeRTOS_errno = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#endif</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">/* 其他文件私有变量。 --------------------------------*/</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">volatile</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> uxCurrentNumberOfTasks = ( </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0U</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">volatile</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> xTickCount = ( </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> ) configINITIAL_TICK_COUNT;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">volatile</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> uxTopReadyPriority = tskIDLE_PRIORITY;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">volatile</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> xSchedulerRunning = pdFALSE;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">volatile</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> xPendedTicks = ( </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0U</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">volatile</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">xYieldPendings</span><span style=\"color: #D4D4D4\">[ configNUMBER_OF_CORES ] = { pdFALSE };</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">volatile</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> xNumOfOverflows = ( </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> uxTaskNumber = ( </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0U</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">volatile</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> xNextTaskUnblockTime = ( </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0U</span><span style=\"color: #D4D4D4\">;</span><span style=\"color: #6A9955\"> /* 在调度器启动之前初始化为 portMAX_DELAY。 */</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">TaskHandle_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">xIdleTaskHandles</span><span style=\"color: #D4D4D4\">[ configNUMBER_OF_CORES ];</span><span style=\"color: #6A9955\">       /**&lt; 保存空闲任务的句柄。空闲任务在调度器启动时自动创建。 */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">/* 改进对 OpenOCD 的支持。内核通过优先级列表跟踪就绪任务。</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\"> * 为了跟踪远程线程的状态，OpenOCD 使用 uxTopUsedPriority</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\"> * 来确定要从远程目标读取的优先级列表的数量。 */</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">volatile</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> uxTopUsedPriority = configMAX_PRIORITIES - </span><span style=\"color: #B5CEA8\">1U</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">/* 当调度器挂起时，上下文切换将被暂缓。此外，</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\"> * 如果调度器被挂起，中断不得操作 TCB 的 xStateListItem 或 xStateListItem 可以引用的任何列表。</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\"> * 如果中断需要在调度器挂起时解除阻塞任务，则它</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\"> * 将任务的事件列表项移动到 xPendingReadyList 中，以便</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\"> * 内核在调度器取消挂起时将任务从挂起就绪列表移动到真正的就绪列表中。</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\"> * 挂起就绪列表本身只能从临界区访问。</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\"> *</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\"> * 对 uxSchedulerSuspended 的更新必须同时受到任务锁和 ISR 锁的保护，并且不能在 ISR 中进行。</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\"> * 读取必须受到任一锁的保护，并且可以在 ISR 或任务中进行。*/</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">volatile</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> uxSchedulerSuspended = ( </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0U</span><span style=\"color: #D4D4D4\">;</span></span></code></pre></div><ul>\n<li>任务列表 (Task Lists):<ol>\n<li><code>pxReadyTasksLists[ configMAX_PRIORITIES ]</code> 就绪任务列表数组，每个列表对应一个优先级。当任务准备好运行时（就绪态），它会被添加到与其优先级对应的列表中。调度器会从这些列表中选择优先级最高的就绪任务来运行。在任务创建、任务优先级更改、任务从阻塞态变为就绪态时会被使用。</li>\n<li><code>xDelayedTaskList1</code>, <code>xDelayedTaskList2</code> 延迟任务列表，当任务被延迟（例如，通过 vTaskDelay 或 vTaskDelayUntil ）时，它们会被添加到这两个列表之一。</li>\n<li><code>xPendingReadyList</code> 挂起就绪列表，当调度器被挂起（例如，通过 vTaskSuspendAll ）时，如果中断服务例程 (ISR) 使一个任务变为就绪态，该任务不会直接添加到就绪列表中，而是先添加到 xPendingReadyList。当调度器恢复运行时，这些任务才会被移动到真正的就绪列表中。在调度器挂起期间的任务状态变更、调度器恢复运行时会被使用。</li>\n<li><code>xTasksWaitingTermination</code> 等待终止任务列表，当任务被删除（通过 vTaskDelete ）时，它会被添加到 xTasksWaitingTermination 列表。空闲任务会定期检查这个列表，并释放这些已删除任务占用的内存。在任务删除操作、空闲任务运行时会被使用。</li>\n<li><code>xSuspendedTaskList</code> 挂起任务列表，当任务被挂起（通过 vTaskSuspend ）时，它会被添加到 xSuspendedTaskList 列表。挂起的任务不会被调度器调度执行，直到被恢复（通过 vTaskResume ）。在任务挂起和恢复操作中会被使用。</li>\n</ol>\n</li>\n<li>其他私有变量<ol>\n<li><code>uxCurrentNumberOfTasks</code> 当前任务数量,在任务创建和删除时更新。在任务创建、任务删除、获取系统状态时会被使用。</li>\n<li><code>xTickCount</code> Tick 计数器，所有时间相关的操作，如任务延迟、超时等，都基于 xTickCount。在 tick 中断处理、任务延迟、超时管理中会被频繁使用。</li>\n<li><code>uxTopReadyPriority</code> 最高优先级就绪任务的优先级，用于优化任务调度。调度器可以快速找到最高优先级的就绪任务，而无需遍历所有优先级列表。在任务调度、任务优先级变更、任务状态变更时会被使用</li>\n<li><code>xSchedulerRunning</code> 调度器运行标志，用于控制调度器的启动和停止。在调度器启动和停止、任务创建时会被检查。</li>\n<li><code>xPendedTicks</code> 挂起的 Tick 计数，当调度器被挂起时，tick 中断仍然会发生，但不会立即处理。xPendedTicks 用于累积这些 tick 计数，并在调度器恢复运行时进行补偿处理。在调度器挂起和恢复、tick 中断处理中会被使用。</li>\n<li><code>xYieldPendings[ configNUMBER_OF_CORES ]</code> 核 Yield 请求标志数组，在 SMP 系统中，每个核都有一个标志，指示该核上是否有任务请求 yield (让出 CPU)。用于多核 (SMP) 系统中核间任务调度和同步。当一个核上的任务需要 yield 时，会设置对应核的标志。在 SMP 调度、任务 yield 操作中会被使用。</li>\n<li><code>xNumOfOverflows</code> Tick 计数器溢出次数，用于处理 tick 计数器溢出，确保延迟任务在 tick 计数器溢出后仍然能正确唤醒。在 tick 中断处理、延迟任务管理中会被使用。</li>\n<li><code>uxTaskNumber</code> 任务编号计数器（ 好像PID ），主要用于调试和跟踪任务。在任务创建时分配编号，方便在调试工具中识别任务。</li>\n<li><code>xNextTaskUnblockTime</code> 记录下一个将要从阻塞态变为就绪态的任务的唤醒时间 (tick count) ,用于优化 tickless idle 模式。内核可以根据 xNextTaskUnblockTime 计算出系统可以进入低功耗模式的最长时间，直到下一个任务需要唤醒。在 tick 中断处理、延迟任务管理、tickless idle 模式中会被使用。</li>\n<li><code>xIdleTaskHandles[ configNUMBER_OF_CORES ]</code> 空闲任务句柄数组，用于存储每个核上运行的空闲任务的任务句柄。在 SMP 系统中，每个核都需要一个空闲任务。在调度器启动、空闲任务管理中会被使用。</li>\n<li><code>uxTopUsedPriority</code> 最高使用优先级，用于 OpenOCD 调试器，指示系统中使用的最高优先级。</li>\n<li><code>uxSchedulerSuspended</code> 用于实现 vTaskSuspendAll 和 xTaskResumeAll 函数，允许多次嵌套挂起和恢复调度器。在调度器挂起和恢复操作中会被使用。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"FreeRTOS-的任务管理\"><a href=\"#FreeRTOS-的任务管理\" class=\"headerlink\" title=\"FreeRTOS 的任务管理\"></a>FreeRTOS 的任务管理</h2><h3 id=\"任务的创建\"><a href=\"#任务的创建\" class=\"headerlink\" title=\"任务的创建\"></a>任务的创建</h3><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">xTaskCreate</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #4EC9B0\">TaskFunction_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pxTaskCode</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                        </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">char</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pcName</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                        </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> configSTACK_DEPTH_TYPE </span><span style=\"color: #9CDCFE\">uxStackDepth</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                        </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pvParameters</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                        </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">uxPriority</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                        </span><span style=\"color: #4EC9B0\">TaskHandle_t</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pxCreatedTask</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">TCB_t</span><span style=\"color: #D4D4D4\"> * pxNewTCB;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> xReturn;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    pxNewTCB = </span><span style=\"color: #DCDCAA\">prvCreateTask</span><span style=\"color: #D4D4D4\">( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( pxNewTCB != </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">prvAddNewTaskToReadyList</span><span style=\"color: #D4D4D4\">( pxNewTCB );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        xReturn = pdPASS;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> xReturn;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>每个 FreeRTOS 任务都需要一个 TCB 结构体来存储任务的状态信息，因此该函数首先调用 prvCreateTask 函数创建一个已经初始化好的 TCB 结构体。然后将任务添加到就绪列表中，最后返回 pdPASS 表示创建成功。</p>\n<p>其中，prvCreateTask 函数的实现如下：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">TCB_t</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #DCDCAA\">prvCreateTask</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #4EC9B0\">TaskFunction_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pxTaskCode</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                              </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">char</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pcName</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                              </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> configSTACK_DEPTH_TYPE </span><span style=\"color: #9CDCFE\">uxStackDepth</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                              </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pvParameters</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                              </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">uxPriority</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                              </span><span style=\"color: #4EC9B0\">TaskHandle_t</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pxCreatedTask</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">TCB_t</span><span style=\"color: #D4D4D4\"> * pxNewTCB;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">StackType_t</span><span style=\"color: #D4D4D4\"> * pxStack;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    pxStack = </span><span style=\"color: #DCDCAA\">pvPortMallocStack</span><span style=\"color: #D4D4D4\">( ( ( ( </span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> ) uxStackDepth ) * </span><span style=\"color: #569CD6\">sizeof</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #4EC9B0\">StackType_t</span><span style=\"color: #D4D4D4\"> ) ) );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( pxStack != </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        pxNewTCB = ( </span><span style=\"color: #4EC9B0\">TCB_t</span><span style=\"color: #D4D4D4\"> * ) </span><span style=\"color: #DCDCAA\">pvPortMalloc</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #569CD6\">sizeof</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #4EC9B0\">TCB_t</span><span style=\"color: #D4D4D4\"> ) );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( pxNewTCB != </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            ( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #DCDCAA\">memset</span><span style=\"color: #D4D4D4\">( ( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> * ) pxNewTCB, </span><span style=\"color: #B5CEA8\">0x00</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">sizeof</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #4EC9B0\">TCB_t</span><span style=\"color: #D4D4D4\"> ) );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">pxNewTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">pxStack</span><span style=\"color: #D4D4D4\"> = pxStack;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">vPortFreeStack</span><span style=\"color: #D4D4D4\">( pxStack );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        pxNewTCB = </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( pxNewTCB != </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE </span><span style=\"color: #D4D4D4\">!=</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #569CD6\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">pxNewTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">ucStaticallyAllocated</span><span style=\"color: #D4D4D4\"> = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#endif</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">prvInitialiseNewTask</span><span style=\"color: #D4D4D4\">( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\"> );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> pxNewTCB;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>它分配了TCB结构体和栈空间，然后将栈空间的地址赋值给TCB的pxStack成员。最后调用了prvInitialiseNewTask 函数初始化了任务的各个成员。有意思的是，prvInitialiseNewTask 会调用 pxPortInitialiseStack 来构造的栈帧，使得新创建的任务能够以一种“自然”的方式启动，就好像它已经经历了一次上下文切换。</p>\n<p>那将任务添加到就绪列表中的 prvAddNewTaskToReadyList 又是如何实现的呢？</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">prvAddNewTaskToReadyList</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #4EC9B0\">TCB_t</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #9CDCFE\">pxNewTCB</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">taskENTER_CRITICAL</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        uxCurrentNumberOfTasks = ( </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> ) ( uxCurrentNumberOfTasks + </span><span style=\"color: #B5CEA8\">1U</span><span style=\"color: #D4D4D4\"> );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( pxCurrentTCB == </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            pxCurrentTCB = pxNewTCB;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( uxCurrentNumberOfTasks == ( </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #DCDCAA\">prvInitialiseTaskLists</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xSchedulerRunning == pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #9CDCFE\">pxCurrentTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">uxPriority</span><span style=\"color: #D4D4D4\"> &lt;= </span><span style=\"color: #9CDCFE\">pxNewTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">uxPriority</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    pxCurrentTCB = pxNewTCB;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        uxTaskNumber++;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( configUSE_TRACE_FACILITY </span><span style=\"color: #D4D4D4\">==</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #569CD6\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">pxNewTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">uxTCBNumber</span><span style=\"color: #D4D4D4\"> = uxTaskNumber;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#endif</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">prvAddTaskToReadyList</span><span style=\"color: #D4D4D4\">( pxNewTCB );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">taskEXIT_CRITICAL</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xSchedulerRunning != pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">taskYIELD_ANY_CORE_IF_USING_PREEMPTION</span><span style=\"color: #D4D4D4\">( pxNewTCB );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>首先是调用 taskENTER_CRITICAL 进入临界区，然后将任务计数器 uxCurrentNumberOfTasks 加 1。如果是系统中创建的第一个任务，那么此时任务列表还没有初始化，此时要做的是设置当前任务，并初始化任务列表。如果不是第一个任务，且有任务正在运行，那么就要判断新任务的优先级是否高于当前任务，如果是的话，就要设置当前任务为新任务。</p>\n<p>再就是为新任务分配一个唯一的编号 uxTCBNumber（PID之类的东西）。</p>\n<p>然后调用 prvAddTaskToReadyList 函数将任务添加到就绪列表中，该函数会更新 uxTopReadyPriority 用于调度优化，并使用 listINSERT_END 函数将任务控制块 pxTCB 的列表项 xStateListItem 插入到 pxReadyTasksLists 数组中对应优先级索引的就绪列表的末尾。</p>\n<p>最后调用 taskEXIT_CRITICAL 退出临界区，如果调度器正在运行，那么调用 taskYIELD_ANY_CORE_IF_USING_PREEMPTION 函数，这个函数会根据当前的调度策略来决定是否进行任务切换。</p>\n<p>xTaskCreateStatic 函数和 xTaskCreate 的区别在于，前者需要用户提供任务控制块和栈空间，而后者会自动分配，源代码上的区别就是 pxNewTCB 和 pxStack 的分配的不同，其他一致。</p>\n<h3 id=\"任务的调度\"><a href=\"#任务的调度\" class=\"headerlink\" title=\"任务的调度\"></a>任务的调度</h3><p>开始调度的函数是 vTaskStartScheduler ，看看怎么个事？</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">vTaskStartScheduler</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> xReturn;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    xReturn = </span><span style=\"color: #DCDCAA\">prvCreateIdleTasks</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">    </span><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( configUSE_TIMERS </span><span style=\"color: #D4D4D4\">==</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #569CD6\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xReturn == pdPASS )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            xReturn = </span><span style=\"color: #DCDCAA\">xTimerCreateTimerTask</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">    </span><span style=\"color: #C586C0\">#endif</span><span style=\"color: #6A9955\"> /* configUSE_TIMERS */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xReturn == pdPASS )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">portDISABLE_INTERRUPTS</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        xNextTaskUnblockTime = portMAX_DELAY;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        xSchedulerRunning = pdTRUE;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        xTickCount = ( </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> ) configINITIAL_TICK_COUNT;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">portCONFIGURE_TIMER_FOR_RUN_TIME_STATS</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #DCDCAA\">xPortStartScheduler</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>首先调用 prvCreateIdleTasks 函数创建空闲任务，然后根据配置是否创建软件定时器任务。</p>\n<p>如果创建成功，就会调用 portDISABLE_INTERRUPTS 关闭中断，因为要保证在 xPortStartScheduler 调用完成之前，不发生时钟中断。为什么呢？xPortStartScheduler 到底做了什么以至于要关闭中断呢？稍后再说。</p>\n<p>接下来是设置一些全局变量，比如 xNextTaskUnblockTime（） 、 xSchedulerRunning 、 xTickCount ，然后调用 xPortStartScheduler 函数启动调度器，代码如下：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">xPortStartScheduler</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    portNVIC_SHPR2_REG = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">vPortSetupTimerInterrupt</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    uxCriticalNesting = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">prvPortStartFirstTask</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* Should not get here! */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">vTaskSwitchContext</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">prvTaskExitError</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>xPortStartScheduler 首先将 PendSV 和 SysTick 的中断优先级设置为最低，SVCall 的优先级为最高，</p>\n<p>然后调用 vPortSetupTimerInterrupt 函数设置 SysTick 定时器的重装载值（根据configSYSTICK_CLOCK_HZ 和 configTICK_RATE_HZ 两个宏配置的值），清空当前计数器值，并使能 SysTick 定时器中断，开启定时器。</p>\n<p>重置临界区计数器 uxCriticalNesting 为 0 ，然后调用 prvPortStartFirstTask 函数，这个函数是一段内联汇编代码，用于启动第一个任务。</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">prvPortStartFirstTask</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    __asm </span><span style=\"color: #DCDCAA\">volatile</span><span style=\"color: #D4D4D4\"> (</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\" ldr r0, =0xE000ED08   </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 将 r0 设置为 NVIC 的向量表偏移寄存器地址 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\" ldr r0, [r0]          </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 读取向量表基地址 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\" ldr r0, [r0]          </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 读取向量表中的栈指针初始值（通常是主栈指针 MSP 的初始值） */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\" msr msp, r0           </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 将主栈指针（MSP）设置为初始值，为系统提供一个干净的栈环境 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\" cpsie i               </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 全局启用中断（清除 PRIMASK） */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\" cpsie f               </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 全局启用故障异常（清除 FAULTMASK） */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\" dsb                   </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 数据同步屏障，确保前面的指令完成 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\" isb                   </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 指令同步屏障，确保流水线刷新 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\" svc 0                 </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 触发 SVC（系统调用）异常，进入 vPortSVCHandler */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\" nop                   </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 占位符，无操作 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\" .ltorg                </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 确保文字池（literal pool）在此处生成 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>注意这里到将主栈指针（MSP）设置为初始值，意味着 FreeRTOS 调度器启动后， 只有 RTOS 任务和中断才有上下文，main() 的上下文将不复存在。出于此原因，绝对不要在 main() 使用的堆栈上分配 FreeRTOS 应用程序需要或能够以任何方式访问的变量或缓冲区， 因为它们很可能会被覆盖。</p>\n<p>在这里，将之前关闭的全局中断再次打开，最后自然是手动触发了一次SVC中断，进入中断服务函数 vPortSVCHandler</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">vPortSVCHandler</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    __asm </span><span style=\"color: #DCDCAA\">volatile</span><span style=\"color: #D4D4D4\"> (</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   ldr r3, =pxCurrentTCB           </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 将 r3 指向当前任务控制块（TCB）的指针 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   ldr r1, [r3]                    </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 获取 pxCurrentTCB 的地址 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   ldr r0, [r1]                    </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 获取任务栈顶地址（第一个 TCB 项是栈指针） */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   ldmia r0!, {r4-r11}             </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 从栈中弹出寄存器 r4-r11，并更新栈指针 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   msr psp, r0                     </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 将进程栈指针（PSP）设置为更新后的栈顶 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   isb                             </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 指令同步屏障 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   mov r0, #0                      </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 将 r0 清零 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   msr basepri, r0                 </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 清除 BASEPRI，允许所有优先级的中断 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   orr r14, #0xd                   </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 修改链接寄存器（LR），设置返回到 Thread 模式并使用 PSP */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   bx r14                          </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 通过 LR 返回，切换到任务执行 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"                                   </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   .ltorg                          </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 文字池 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>至此，第一个任务开始执行。</p>\n<p>那为什么要调用 portDISABLE_INTERRUPTS 关闭中断呢？还记得之前注册的 SysTick_Handler 函数吗？里面会调用 xTaskGetSchedulerState 函数判断任务调度器的状态，调度器启动完成之后，才能往下执行调用 xPortSysTickHandler 。</p>\n<p>关键在于这个 xPortSysTickHandler 函数会调用 xTaskIncrementTick 函数，这个函数不仅仅会增加系统时钟节拍，其返回值还决定了接下来 xPortSysTickHandler 是否要进行任务切换，代码如下：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">xPortSysTickHandler</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">portDISABLE_INTERRUPTS</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">xTaskIncrementTick</span><span style=\"color: #D4D4D4\">() != pdFALSE )</span><span style=\"color: #6A9955\">//需要任务切换</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #6A9955\">//触发 PendSV 异常，进入 vPortSVCHandler（是一个裸函数，会直接返回到任务上下文）</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">portENABLE_INTERRUPTS</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>试想如果不禁用中断，执行到 xSchedulerRunning = pdTRUE 这一行之后，来了一个 SysTick 中断（虽然 SysTick 中断是freeRTOS 负责配置的，但是万一用户提前配置的话。。。），此时，根据 xTaskGetSchedulerState 函数的实现，该分支的条件则会成立，调用 xPortSysTickHandler 函数，可是还有很多全局变量没有初始化呢，甚至连中断优先级都还没设置好，有可能 SysTick 的时间也不对，这样的话，xTaskIncrementTick 函数的返回值就不可预测了。</p>\n<p>那么平时任务是怎么切换的呢？ xTaskIncrementTick 为 pdTRUE 时，意味着任务切换的时机已经成熟，即可触发 PENDSV 中断，这里不妨再看一下 xPortSysTickHandler ：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">xPortPendSVHandler</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* This is a naked function. */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    __asm </span><span style=\"color: #569CD6\">volatile</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    (</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   mrs r0, psp                         </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 获取当前任务的进程栈指针（PSP） */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   isb                                 </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 指令同步屏障 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"                                       </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   ldr r3, =pxCurrentTCB               </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 将 r3 指向 pxCurrentTCB 的地址 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   ldr r2, [r3]                        </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 将 r2 设置为当前 TCB 的地址 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"                                       </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   stmdb r0!, {r4-r11}                 </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 保存 r4-r11 到当前任务栈 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   str r0, [r2]                        </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 更新 TCB 中的栈指针 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"                                       </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   stmdb sp!, {r3, r14}                </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 保存 r3 和 r14（LR）到主栈（MSP） */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   mov r0, </span><span style=\"color: #F44747\">%</span><span style=\"color: #CE9178\">0                          </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 将 r0 设置为 configMAX_SYSCALL_INTERRUPT_PRIORITY */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   msr basepri, r0                     </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 设置 BASEPRI，屏蔽低优先级中断 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   bl vTaskSwitchContext               </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 调用调度器切换任务 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   mov r0, #0                          </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 将 r0 清零 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   msr basepri, r0                     </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 清除 BASEPRI，重新启用所有中断 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   ldmia sp!, {r3, r14}                </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 从主栈恢复 r3 和 r14 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"                                       </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   ldr r1, [r3]                        </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 获取更新后的 pxCurrentTCB（新任务 TCB） */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   ldr r0, [r1]                        </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 获取新任务的栈顶地址 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   ldmia r0!, {r4-r11}                 </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 恢复新任务的 r4-r11 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   msr psp, r0                         </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 更新 PSP 为新任务的栈指针 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   isb                                 </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 指令同步屏障 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   bx r14                              </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 返回到新任务 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"                                       </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   .ltorg                              </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 文字池 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ::</span><span style=\"color: #CE9178\">\"i\"</span><span style=\"color: #D4D4D4\"> ( configMAX_SYSCALL_INTERRUPT_PRIORITY )</span><span style=\"color: #6A9955\"> /* 输入参数 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>可以看到，PendSV 中断处理函数的核心是 vTaskSwitchContext 函数，看看这个函数做了什么：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">vTaskSwitchContext</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( uxSchedulerSuspended != ( </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0U</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">xYieldPendings</span><span style=\"color: #D4D4D4\">[ </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\"> ] = pdTRUE;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">xYieldPendings</span><span style=\"color: #D4D4D4\">[ </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\"> ] = pdFALSE;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #6A9955\">// taskSELECT_HIGHEST_PRIORITY_TASK();//宏展开如下：                                                                       </span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> uxTopPriority = uxTopReadyPriority;                                  </span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* Find the highest priority queue that contains ready tasks. */</span><span style=\"color: #D4D4D4\">                 </span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">while</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">listLIST_IS_EMPTY</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxReadyTasksLists</span><span style=\"color: #D4D4D4\">[ uxTopPriority ] ) ) != pdFALSE ) </span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">configASSERT</span><span style=\"color: #D4D4D4\">( uxTopPriority );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            --uxTopPriority;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        * the  same priority get an equal share of the processor time. */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">listGET_OWNER_OF_NEXT_ENTRY</span><span style=\"color: #D4D4D4\">( pxCurrentTCB, &amp;( </span><span style=\"color: #9CDCFE\">pxReadyTasksLists</span><span style=\"color: #D4D4D4\">[ uxTopPriority ] ) );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        uxTopReadyPriority = uxTopPriority;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>首先判断调度器的状态，如果是 Suspended ，那么就不会发生调度，pxCurrentTCB原路返回。</p>\n<p>这是处理器核心数只有 1 的时候的状态，此时 taskSELECT_HIGHEST_PRIORITY_TASK 展开就像上面这样，如果大于一个核心，该宏定义会指向函数 prvSelectHighestPriorityTask 。</p>\n<p>总而言之， taskSELECT_HIGHEST_PRIORITY_TASK 会选取下一个要调度的任务放入 pxCurrentTCB ，之后返回 xPortPendSVHandler 之后，就可以通过该变量获得现在要调度的任务的 TCB ，从而实现任务的切换调度。</p>\n<p>等等，最重要的一点， xTaskIncrementTick 是如何判断任务切换的时机是否成熟的呢？这边也看看吧。</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">xTaskIncrementTick</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">TCB_t</span><span style=\"color: #D4D4D4\"> * pxTCB;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> xItemValue;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> xSwitchRequired = pdFALSE;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* Tick 递增发生在每个内核定时器事件上。Core 0 负责递增 tick</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">     * 如果调度器被挂起，则递增挂起的 tick。如果挂起的 tick</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">     * 大于零，则调用 xTaskResumeAll 的核心负责递增 tick。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( uxSchedulerSuspended == ( </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0U</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 小优化。在此块中，tick 计数不能更改。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> xConstTickCount = xTickCount + ( </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 递增 RTOS tick，如果它回绕到 0，则切换延迟列表和溢出的延迟列表。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        xTickCount = xConstTickCount;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xConstTickCount == ( </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0U</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">taskSWITCH_DELAYED_LISTS</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 查看此 tick 是否已使超时到期。任务按照它们的唤醒时间顺序存储在队列中，</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">         * 这意味着一旦找到一个任务其阻塞时间尚未到期，则无需再往下查看列表。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xConstTickCount &gt;= xNextTaskUnblockTime )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #6A9955\">// 有任务需要解除阻塞</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\">( ; ; )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">listLIST_IS_EMPTY</span><span style=\"color: #D4D4D4\">( pxDelayedTaskList ) != pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                    /* 延迟列表为空。将 xNextTaskUnblockTime 设置为最大可能值，因此极不可能</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                     * 下次通过时 if( xTickCount &gt;= xNextTaskUnblockTime ) 测试会通过。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    xNextTaskUnblockTime = portMAX_DELAY;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #C586C0\">break</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                    /* 延迟列表不为空，获取延迟列表头部的 ItemValue ，</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                     * 这是必须从阻塞状态中移除的任务的时间 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    pxTCB = </span><span style=\"color: #DCDCAA\">listGET_OWNER_OF_HEAD_ENTRY</span><span style=\"color: #D4D4D4\">( pxDelayedTaskList );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    xItemValue = </span><span style=\"color: #DCDCAA\">listGET_LIST_ITEM_VALUE</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xStateListItem</span><span style=\"color: #D4D4D4\"> ) );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xConstTickCount &lt; xItemValue )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                        /* 现在还不是解除阻塞此任务的时候，但是 xItemValue 是必须将阻塞列表头部的任务</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                         * 从阻塞状态中移除的时间 - 因此记录项目值在 xNextTaskUnblockTime 中。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                        xNextTaskUnblockTime = xItemValue;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                        </span><span style=\"color: #C586C0\">break</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                    /* 是时候从阻塞状态中移除项目了。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #DCDCAA\">listREMOVE_ITEM</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xStateListItem</span><span style=\"color: #D4D4D4\"> ) );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                    /* 该任务是否也在等待事件？如果是，则将其从事件列表中删除。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">listLIST_ITEM_CONTAINER</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xEventListItem</span><span style=\"color: #D4D4D4\"> ) ) != </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                        </span><span style=\"color: #DCDCAA\">listREMOVE_ITEM</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xEventListItem</span><span style=\"color: #D4D4D4\"> ) );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                    /* 将解除阻塞的任务放入适当的就绪列表中。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #DCDCAA\">prvAddTaskToReadyList</span><span style=\"color: #D4D4D4\">( pxTCB );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                    /* 如果关闭了抢占，则解除阻塞的任务不能导致立刻的上下文切换。 */</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">                    </span><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( configUSE_PREEMPTION </span><span style=\"color: #D4D4D4\">==</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #569CD6\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                        /* 抢占已打开，但只有在解除阻塞的任务优先级高于当前正在执行的</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                          * 任务时，才应执行上下文切换。同等优先级任务共享</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                          * 处理时间（当抢占和时间片都打开时发生）的情况在下面处理。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">uxPriority</span><span style=\"color: #D4D4D4\"> &gt; </span><span style=\"color: #9CDCFE\">pxCurrentTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">uxPriority</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                            xSwitchRequired = pdTRUE;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">                    </span><span style=\"color: #C586C0\">#endif</span><span style=\"color: #6A9955\"> /* #if ( configUSE_PREEMPTION == 1 ) */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 如果时间片和抢占都打开，则检查是否有相同优先级的任务需要运行。 */</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( ( configUSE_PREEMPTION </span><span style=\"color: #D4D4D4\">==</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #569CD6\"> ) </span><span style=\"color: #D4D4D4\">&amp;&amp;</span><span style=\"color: #569CD6\"> ( configUSE_TIME_SLICING </span><span style=\"color: #D4D4D4\">==</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #569CD6\"> ) )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">listCURRENT_LIST_LENGTH</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxReadyTasksLists</span><span style=\"color: #D4D4D4\">[ </span><span style=\"color: #9CDCFE\">pxCurrentTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">uxPriority</span><span style=\"color: #D4D4D4\"> ] ) ) &gt; </span><span style=\"color: #B5CEA8\">1U</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                xSwitchRequired = pdTRUE;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#endif</span><span style=\"color: #6A9955\"> /* #if ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configUSE_TIME_SLICING == 1 ) ) */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( configUSE_PREEMPTION </span><span style=\"color: #D4D4D4\">==</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #569CD6\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {   </span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /*xYieldPendings 数组是 FreeRTOS SMP 内核中用于延迟任务 yield 请求的标志数组*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #9CDCFE\">xYieldPendings</span><span style=\"color: #D4D4D4\">[ </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\"> ] != pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                xSwitchRequired = pdTRUE;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#endif</span><span style=\"color: #6A9955\"> /* #if ( configUSE_PREEMPTION == 1 ) */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        xPendedTicks += </span><span style=\"color: #B5CEA8\">1U</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> xSwitchRequired;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>这个函数有几个难以理解的地方：比如说为什么在 RTOS tick 计数器回绕到 0 时，需要切换延迟列表和溢出延迟列表。</p>\n<p>想象一下，如果只有一个延迟列表，并且 tick 计数器即将回绕。此时，如果一个任务被设置为在 tick 计数器回绕后的一段时间后唤醒，那么它的唤醒时间值将会比那些在回绕之前设置唤醒时间的任务的值要小。这将导致调度器错误地认为回绕后设置唤醒时间的任务应该更早被唤醒。为了解决这个问题，FreeRTOS 使用了两个延迟列表，用于存放唤醒时间在当前 tick 计数周期内的任务，一个用于存放唤醒时间已经溢出到下一个 tick 计数周期的任务。</p>\n<p>除此之外，该函数还负责解除任务的阻塞。</p>\n<p>FreeRTOS 将所有因延时或等待事件而进入阻塞状态的任务，按照唤醒时间升序排列在一个列表中，也就是延时任务列表。这意味着列表中排在前面的任务，它们的唤醒时间总是早于或等于排在后面的任务。所以，遍历到一个任务的唤醒时间大于当前 tick 时，就可以停止遍历了，因为后面的任务的唤醒时间都大于当前 tick 。</p>\n<p>总而言之，当有任务因为时间片到期需要进行上下文切换时，或当有更高优先级的任务被解除阻塞时，会返回 pdTRUE ，来指示需要进行任务切换了。</p>\n<h3 id=\"任务的删除\"><a href=\"#任务的删除\" class=\"headerlink\" title=\"任务的删除\"></a>任务的删除</h3><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">vTaskDelete</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #4EC9B0\">TaskHandle_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">xTaskToDelete</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">TCB_t</span><span style=\"color: #D4D4D4\"> * pxTCB;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> xDeleteTCBInIdleTask = pdFALSE;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> xTaskIsRunningOrYielding;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">taskENTER_CRITICAL</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 如果传入的参数是NULL，则表示要删除的是当前正在调用的任务。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        pxTCB = </span><span style=\"color: #DCDCAA\">prvGetTCBFromHandle</span><span style=\"color: #D4D4D4\">( xTaskToDelete );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 将任务从就绪/延迟列表中移除。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">uxListRemove</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xStateListItem</span><span style=\"color: #D4D4D4\"> ) ) == ( </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">taskRESET_READY_PRIORITY</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">uxPriority</span><span style=\"color: #D4D4D4\"> );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 任务是否也在等待事件？*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">listLIST_ITEM_CONTAINER</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xEventListItem</span><span style=\"color: #D4D4D4\"> ) ) != </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            ( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #DCDCAA\">uxListRemove</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xEventListItem</span><span style=\"color: #D4D4D4\"> ) );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 递增 uxTaskNumber，供第三方追踪代码使用,对运行无太大意义 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        uxTaskNumber++;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 这个任务的状态是什么？*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        xTaskIsRunningOrYielding = </span><span style=\"color: #DCDCAA\">taskTASK_IS_RUNNING_OR_SCHEDULED_TO_YIELD</span><span style=\"color: #D4D4D4\">( pxTCB );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 如果任务正在运行（或即将让出），必须将其添加到终止列表中，以便空闲任务可以在其不再运行时将其删除。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( ( xSchedulerRunning != pdFALSE ) &amp;&amp; ( xTaskIsRunningOrYielding != pdFALSE ) )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /*  删除正在运行的任务或计划让出的任务。</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">             *  当任务仍在核心上运行时，这无法完成，因此需要上下文切换到另一个任务。</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">             *  将任务放入终止列表。 空闲任务将检查终止列表并释放由调度程序为已删除任务的 TCB 和堆栈分配的任何内存。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">vListInsertEnd</span><span style=\"color: #D4D4D4\">( &amp;xTasksWaitingTermination, &amp;( </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xStateListItem</span><span style=\"color: #D4D4D4\"> ) );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /* 递增 uxDeletedTasksWaitingCleanUp 变量，以便空闲任务知道有一个任务已被删除，</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">             * 空闲任务就会检查 xTasksWaitingTermination 列表。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            ++uxDeletedTasksWaitingCleanUp;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /* 在空闲任务中删除任务 TCB。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            xDeleteTCBInIdleTask = pdTRUE;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">else</span><span style=\"color: #6A9955\"> //任务不在运行</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            --uxCurrentNumberOfTasks;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /* 重置下一个预期的解除阻塞时间，以防它引用了刚刚删除的任务。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">prvResetNextTaskUnblockTime</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">taskEXIT_CRITICAL</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* 如果任务不是删除自身，则从临界区外调用 prvDeleteTCB。</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">     *  如果任务删除自身，则在空闲任务中由 prvCheckTasksWaitingTermination 调用 prvDeleteTCB */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xDeleteTCBInIdleTask != pdTRUE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">prvDeleteTCB</span><span style=\"color: #D4D4D4\">( pxTCB );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* 如果刚刚删除的是当前正在运行的任务，则强制重新调度。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xSchedulerRunning != pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( pxTCB == pxCurrentTCB )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #6A9955\">//所以，任务自己删除自己的时候，调度器一定要开启，否则会出问题</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">configASSERT</span><span style=\"color: #D4D4D4\">( uxSchedulerSuspended == </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\"> );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">taskYIELD_WITHIN_API</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>这个 API 用于删除一个任务，这是当处理器核心数量为 1 的时候的过程，如果大于 1 的话，情况会复杂一点。总之，实现上大体分为两种情况：自己删自己和删其他的任务。对于删其他任务的情况，直接从列表中移除，删除TCB即可。但是对于自己删自己的情况，需要将任务添加到终止列表中，等待空闲任务来删除。空闲任务做了什么呢？</p>\n<p>首先，空闲任务在 vTaskStartScheduler 函数中被创建，它的任务函数是 prvIdleTask ，这个函数会一直循环，等待终止列表中有任务，然后释放任务的 TCB 和栈空间，看看代码：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">portTASK_FUNCTION</span><span style=\"color: #D4D4D4\">( prvIdleTask, pvParameters )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* Stop warnings. */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> ) pvParameters;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* 如果具有安全上下文的任务删除自身，在这种情况下，空闲任务负责删除任务的安全上下文（如果有）。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">portALLOCATE_SECURE_CONTEXT</span><span style=\"color: #D4D4D4\">( configMINIMAL_SECURE_STACK_SIZE );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\">( ; ; )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 检查是否有任务删除了自己 - 如果有，则空闲任务负责释放已删除任务的 TCB 和堆栈。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">prvCheckTasksWaitingTermination</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( configUSE_PREEMPTION </span><span style=\"color: #D4D4D4\">==</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #569CD6\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /* 如果没有使用抢占，那就不断强制进行任务切换，以查看是否有任何其他任务可用。</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">             * 如果使用抢占，则不需要这样做，因为任何变得可用的任务都会自动获得处理器。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">taskYIELD</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#endif</span><span style=\"color: #6A9955\"> /* configUSE_PREEMPTION */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( ( configUSE_PREEMPTION </span><span style=\"color: #D4D4D4\">==</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #569CD6\"> ) </span><span style=\"color: #D4D4D4\">&amp;&amp;</span><span style=\"color: #569CD6\"> ( configIDLE_SHOULD_YIELD </span><span style=\"color: #D4D4D4\">==</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #569CD6\"> ) )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /* 当使用抢占时，具有相同优先级的任务将被时间分片。</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">             * 如果一个与空闲优先级共享的任务准备好运行，那么空闲任务应该在时间片结束之前让出。</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">             *</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">             * 这里不需要临界区，因为只是从列表中读取，偶尔出现不正确的值无关紧要。</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">             * 如果空闲优先级的就绪列表包含的任务数量比空闲任务数量（等于配置的内核数量）多一个，</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">             * 那么除了空闲任务之外的任务已准备好执行。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">listCURRENT_LIST_LENGTH</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxReadyTasksLists</span><span style=\"color: #D4D4D4\">[ tskIDLE_PRIORITY ] ) ) &gt; ( </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> ) configNUMBER_OF_CORES )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #DCDCAA\">taskYIELD</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#endif</span><span style=\"color: #6A9955\"> /* ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configIDLE_SHOULD_YIELD == 1 ) ) */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 当用户定义的低功耗模式实现需要将 configUSE_TICKLESS_IDLE 设置为 0 以外的值时，</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">         * 调用 portSUPPRESS_TICKS_AND_SLEEP()。*/</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( configUSE_TICKLESS_IDLE </span><span style=\"color: #D4D4D4\">!=</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #569CD6\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> xExpectedIdleTime;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /* 不希望在空闲任务的每次迭代中都挂起然后恢复调度程序。</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">             * 因此，在没有调度程序挂起的情况下执行预期空闲时间的初步测试。</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">             * 此处的结果不一定有效。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            xExpectedIdleTime = </span><span style=\"color: #DCDCAA\">prvGetExpectedIdleTime</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xExpectedIdleTime &gt;= ( </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> ) configEXPECTED_IDLE_TIME_BEFORE_SLEEP )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #DCDCAA\">vTaskSuspendAll</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                    /* 现在调度程序已挂起，可以再次采样预期的空闲时间，这次可以使用它的值。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #DCDCAA\">configASSERT</span><span style=\"color: #D4D4D4\">( xNextTaskUnblockTime &gt;= xTickCount );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    xExpectedIdleTime = </span><span style=\"color: #DCDCAA\">prvGetExpectedIdleTime</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                    /* 定义以下宏，如果应用程序不希望调用 portSUPPRESS_TICKS_AND_SLEEP()，</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                     * 则将 xExpectedIdleTime 设置为 0。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #DCDCAA\">configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING</span><span style=\"color: #D4D4D4\">( xExpectedIdleTime );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xExpectedIdleTime &gt;= ( </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> ) configEXPECTED_IDLE_TIME_BEFORE_SLEEP )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                        </span><span style=\"color: #DCDCAA\">portSUPPRESS_TICKS_AND_SLEEP</span><span style=\"color: #D4D4D4\">( xExpectedIdleTime );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                ( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #DCDCAA\">xTaskResumeAll</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#endif</span><span style=\"color: #6A9955\"> /* configUSE_TICKLESS_IDLE */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">prvCheckTasksWaitingTermination</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">    </span><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( INCLUDE_vTaskDelete </span><span style=\"color: #D4D4D4\">==</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #569CD6\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #4EC9B0\">TCB_t</span><span style=\"color: #D4D4D4\"> * pxTCB;</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* uxDeletedTasksWaitingCleanUp 用于防止在空闲任务中过于频繁地调用 taskENTER_CRITICAL()。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">while</span><span style=\"color: #D4D4D4\">( uxDeletedTasksWaitingCleanUp &gt; ( </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0U</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">            </span><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( configNUMBER_OF_CORES </span><span style=\"color: #D4D4D4\">==</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #569CD6\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #DCDCAA\">taskENTER_CRITICAL</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    pxTCB = </span><span style=\"color: #DCDCAA\">listGET_OWNER_OF_HEAD_ENTRY</span><span style=\"color: #D4D4D4\">( ( &amp;xTasksWaitingTermination ) );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    ( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #DCDCAA\">uxListRemove</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xStateListItem</span><span style=\"color: #D4D4D4\"> ) );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    --uxCurrentNumberOfTasks;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    --uxDeletedTasksWaitingCleanUp;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #DCDCAA\">taskEXIT_CRITICAL</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #DCDCAA\">prvDeleteTCB</span><span style=\"color: #D4D4D4\">( pxTCB );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">    </span><span style=\"color: #C586C0\">#endif</span><span style=\"color: #6A9955\"> /* INCLUDE_vTaskDelete */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>可以看到，空闲任务会不断调用 prvCheckTasksWaitingTermination 来检查是否有任务被删除，如果有，就释放任务的 TCB 和栈空间。除此之外，还根据用户的配置来决定是否进行任务切换，以及是否进入低功耗模式。</p>\n<p>prvCheckTasksWaitingTermination 函数是通过检查在 vTaskDelete 中修改的变量 uxDeletedTasksWaitingCleanUp 来判断是否有任务被删除。</p>\n<h3 id=\"任务的延时\"><a href=\"#任务的延时\" class=\"headerlink\" title=\"任务的延时\"></a>任务的延时</h3><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">vTaskDelay</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">xTicksToDelay</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* 记录任务是否已经让出 CPU 控制权（yield）。初始值为 pdFALSE，表示未让出 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> xAlreadyYielded = pdFALSE;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* 如果延时时间为 0，则只进行任务调度（强制上下文切换），不进行实际延时 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xTicksToDelay &gt; ( </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0U</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">vTaskSuspendAll</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">configASSERT</span><span style=\"color: #D4D4D4\">( uxSchedulerSuspended == </span><span style=\"color: #B5CEA8\">1U</span><span style=\"color: #D4D4D4\"> );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /* 当调度器被挂起时，从事件列表中移除的任务将不会被放入就绪列表</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">             * 或从阻塞列表中移除，直到调度器恢复。</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">             * 此任务不能在事件列表中，因为它是当前正在执行的任务。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">prvAddCurrentTaskToDelayedList</span><span style=\"color: #D4D4D4\">( xTicksToDelay, pdFALSE );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* xTaskResumeAll() 函数在恢复任务时，如果因为存在高优先级任务就绪</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">         * 或处理挂起节拍在函数内部立即触发了任务切换，那么它会返回 pdTRUE。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        xAlreadyYielded = </span><span style=\"color: #DCDCAA\">xTaskResumeAll</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* 如果 xTaskResumeAll 还没有强制重新调度，则强制重新调度，可能已经让自己进入睡眠状态。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xAlreadyYielded == pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">taskYIELD_WITHIN_API</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>vTaskDelay 函数用于将任务延时一段时间，这个函数会将任务添加到延迟任务列表中，然后在 xTaskResumeAll 或 taskYIELD_WITHIN_API 这两个地方触发任务切换。另一个函数 xTaskDelayUntil 也是差不多的原理。</p>\n<p>看看 prvAddCurrentTaskToDelayedList 函数做了什么，到底是如何将任务添加到延迟任务列表中的，之前提到的 延迟列表 和 溢出延迟列表 在这里是如何处理的呢？</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">prvAddCurrentTaskToDelayedList</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">xTicksToWait</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                                            </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">xCanBlockIndefinitely</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> xTimeToWake;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> xConstTickCount = xTickCount;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">List_t</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> pxDelayedList = pxDelayedTaskList;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">List_t</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> pxOverflowDelayedList = pxOverflowDelayedTaskList;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* 从列表中移除当前任务（一定在列表中）。  */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">uxListRemove</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxCurrentTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xStateListItem</span><span style=\"color: #D4D4D4\"> ) ) == ( </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /*如果 configUSE_PORT_OPTIMISED_TASK_SELECTION 为 1 才生效，是对调度的一个优化 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">portRESET_READY_PRIORITY</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #9CDCFE\">pxCurrentTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">uxPriority</span><span style=\"color: #D4D4D4\">, uxTopReadyPriority );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( ( xTicksToWait == portMAX_DELAY ) &amp;&amp; ( xCanBlockIndefinitely != pdFALSE ) )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 如果要等待的时间是最大延迟时间，并且可以无限期阻塞，将任务添加到挂起任务列表</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">          * 而不是延迟任务列表，以确保它不会被定时事件唤醒。它将无限期地阻塞。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">listINSERT_END</span><span style=\"color: #D4D4D4\">( &amp;xSuspendedTaskList, &amp;( </span><span style=\"color: #9CDCFE\">pxCurrentTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xStateListItem</span><span style=\"color: #D4D4D4\"> ) );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 列表项将按唤醒时间顺序插入。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        xTimeToWake = xConstTickCount + xTicksToWait;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">listSET_LIST_ITEM_VALUE</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxCurrentTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xStateListItem</span><span style=\"color: #D4D4D4\"> ), xTimeToWake );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xTimeToWake &lt; xConstTickCount )</span><span style=\"color: #6A9955\">/* 如果唤醒时间溢出。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">vListInsert</span><span style=\"color: #D4D4D4\">( pxOverflowDelayedList, &amp;( </span><span style=\"color: #9CDCFE\">pxCurrentTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xStateListItem</span><span style=\"color: #D4D4D4\"> ) );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /* 唤醒时间没有溢出*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">vListInsert</span><span style=\"color: #D4D4D4\">( pxDelayedList, &amp;( </span><span style=\"color: #9CDCFE\">pxCurrentTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xStateListItem</span><span style=\"color: #D4D4D4\"> ) );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /* 如果进入阻塞状态的任务被放置在阻塞任务列表的头部，</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">              * 则 xNextTaskUnblockTime 也需要更新。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xTimeToWake &lt; xNextTaskUnblockTime )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                xNextTaskUnblockTime = xTimeToWake;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p><code>xTimeToWake = xConstTickCount + xTicksToWait;</code> 这一行的加法，可能会导致溢出，因此分为两种情况处理。</p>\n<p>此外，如果要等待的时间是最大延迟时间，则变成挂起状态。</p>\n<h2 id=\"FreeRTOS-的消息队列\"><a href=\"#FreeRTOS-的消息队列\" class=\"headerlink\" title=\"FreeRTOS 的消息队列\"></a>FreeRTOS 的消息队列</h2><p>消息队列的结构体如下：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">typedef</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> QueueDefinition</span><span style=\"color: #6A9955\"> /* The old naming convention is used to prevent breaking kernel aware debuggers. */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">int8_t</span><span style=\"color: #D4D4D4\"> * pcHead;</span><span style=\"color: #6A9955\">           /**&lt; 队列元素存储区的开始地址 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">int8_t</span><span style=\"color: #D4D4D4\"> * pcWriteTo;</span><span style=\"color: #6A9955\">        /**&lt; 队列尾指针，下一次写到这个位置 */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">union</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #4EC9B0\">QueuePointers_t</span><span style=\"color: #D4D4D4\"> xQueue;     </span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #4EC9B0\">SemaphoreData_t</span><span style=\"color: #D4D4D4\"> xSemaphore; </span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    } u;</span><span style=\"color: #6A9955\">                        /**&lt; 由此可见，这个结构体既可以实现队列，也可以实现信号量 */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">List_t</span><span style=\"color: #D4D4D4\"> xTasksWaitingToSend;</span><span style=\"color: #6A9955\">             /**&lt; 发送阻塞队列，按优先级排列 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">List_t</span><span style=\"color: #D4D4D4\"> xTasksWaitingToReceive;</span><span style=\"color: #6A9955\">          /**&lt; 接收阻塞队列，按优先级排列 */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">volatile</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> uxMessagesWaiting;</span><span style=\"color: #6A9955\"> /**&lt; 有多少个消息在队列中等待被接收 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> uxLength;</span><span style=\"color: #6A9955\">                   /**&lt; 队列的长度，能容纳元素的数量 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> uxItemSize;</span><span style=\"color: #6A9955\">                 /**&lt; 每个元素有多大 */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">volatile</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">int8_t</span><span style=\"color: #D4D4D4\"> cRxLock;</span><span style=\"color: #6A9955\">                /**&lt; 用于存储 当队列被锁定时，从队列中删除的项目 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">volatile</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">int8_t</span><span style=\"color: #D4D4D4\"> cTxLock;</span><span style=\"color: #6A9955\">                /**&lt; 用于存储 当队列被锁定时，向队列中添加的项目 */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">uint8_t</span><span style=\"color: #D4D4D4\"> ucStaticallyAllocated;</span><span style=\"color: #6A9955\"> /**&lt; 静态分配标志 */</span><span style=\"color: #D4D4D4\"> </span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> QueueDefinition * pxQueueSetContainer;</span><span style=\"color: #6A9955\">  /**&lt; 队列集的指针 */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> uxQueueNumber;</span><span style=\"color: #6A9955\"> /**&lt; 队列编号 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">uint8_t</span><span style=\"color: #D4D4D4\"> ucQueueType;</span><span style=\"color: #6A9955\"> /**&lt; 队列类型：队列或信号量 */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">} xQUEUE;</span></span></code></pre></div><h3 id=\"消息队列的创建\"><a href=\"#消息队列的创建\" class=\"headerlink\" title=\"消息队列的创建\"></a>消息队列的创建</h3><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #4EC9B0\">QueueHandle_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">xQueueGenericCreate</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">uxQueueLength</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                                    </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">uxItemSize</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                                    </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">uint8_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">ucQueueType</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">Queue_t</span><span style=\"color: #D4D4D4\"> * pxNewQueue = </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> xQueueSizeInBytes;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">uint8_t</span><span style=\"color: #D4D4D4\"> * pucQueueStorage;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* 如果队列长度大于0，检查 乘法溢出 和 加法溢出。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( ( uxQueueLength &gt; ( </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\"> ) &amp;&amp;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ( ( SIZE_MAX / uxQueueLength ) &gt;= uxItemSize ) &amp;&amp;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ( ( SIZE_MAX - </span><span style=\"color: #569CD6\">sizeof</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #4EC9B0\">Queue_t</span><span style=\"color: #D4D4D4\"> ) ) &gt;= ( </span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> ) ( uxQueueLength * uxItemSize ) ) )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 分配足够的空间来容纳队列中任何时候可能存在的最大数量的项目，如果队列用作信号量，uxItemSize为零是有效的。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        xQueueSizeInBytes = ( </span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> ) ( ( </span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> ) uxQueueLength * ( </span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> ) uxItemSize );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        pxNewQueue = ( </span><span style=\"color: #4EC9B0\">Queue_t</span><span style=\"color: #D4D4D4\"> * ) </span><span style=\"color: #DCDCAA\">pvPortMalloc</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #569CD6\">sizeof</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #4EC9B0\">Queue_t</span><span style=\"color: #D4D4D4\"> ) + xQueueSizeInBytes );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( pxNewQueue != </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /* 越过队列结构体，找到队列存储区域的位置。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            pucQueueStorage = ( </span><span style=\"color: #569CD6\">uint8_t</span><span style=\"color: #D4D4D4\"> * ) pxNewQueue;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            pucQueueStorage += </span><span style=\"color: #569CD6\">sizeof</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #4EC9B0\">Queue_t</span><span style=\"color: #D4D4D4\"> );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">            </span><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( configSUPPORT_STATIC_ALLOCATION </span><span style=\"color: #D4D4D4\">==</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #569CD6\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                /* 队列可以静态或动态创建，* 所以记录这个任务是动态创建的，以便后续删除时使用。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #9CDCFE\">pxNewQueue</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">ucStaticallyAllocated</span><span style=\"color: #D4D4D4\"> = pdFALSE;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">            </span><span style=\"color: #C586C0\">#endif</span><span style=\"color: #6A9955\"> /* configSUPPORT_STATIC_ALLOCATION */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">prvInitialiseNewQueue</span><span style=\"color: #D4D4D4\">( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> pxNewQueue;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>函数会进行参数校验，内存分配并初始化队列的状态，返回队列的句柄。</p>\n<h3 id=\"消息队列的发送\"><a href=\"#消息队列的发送\" class=\"headerlink\" title=\"消息队列的发送\"></a>消息队列的发送</h3><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">xQueueGenericSend</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #4EC9B0\">QueueHandle_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">xQueue</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                              </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pvItemToQueue</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                              </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">xTicksToWait</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                              </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">xCopyPosition</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> xEntryTimeSet = pdFALSE, xYieldRequired;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">TimeOut_t</span><span style=\"color: #D4D4D4\"> xTimeOut;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">Queue_t</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> pxQueue = xQueue;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\">( ; ; )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">taskENTER_CRITICAL</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">           /* 现在队列里有空间吗？运行任务必须是想要访问队列的最高优先级任务。</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            * 如果队列头部的项要被覆盖，那么队列是否已满就无关紧要了。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( ( </span><span style=\"color: #9CDCFE\">pxQueue</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">uxMessagesWaiting</span><span style=\"color: #D4D4D4\"> &lt; </span><span style=\"color: #9CDCFE\">pxQueue</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">uxLength</span><span style=\"color: #D4D4D4\"> ) || ( xCopyPosition == queueOVERWRITE ) )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> uxPreviousMessagesWaiting = </span><span style=\"color: #9CDCFE\">pxQueue</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">uxMessagesWaiting</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                xYieldRequired = </span><span style=\"color: #DCDCAA\">prvCopyDataToQueue</span><span style=\"color: #D4D4D4\">( pxQueue, pvItemToQueue, xCopyPosition );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #9CDCFE\">pxQueue</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">pxQueueSetContainer</span><span style=\"color: #D4D4D4\"> != </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( ( xCopyPosition == queueOVERWRITE ) &amp;&amp; ( uxPreviousMessagesWaiting != ( </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\"> ) )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                        /* 不要通知队列集，因为队列中已存在的项目被覆盖，所以队列中的项目数量没有改变。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #C586C0\">else</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">prvNotifyQueueSetContainer</span><span style=\"color: #D4D4D4\">( pxQueue ) != pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                        /* 队列是队列集的成员，并且向队列集发布数据导致更高优先级的任务解除阻塞。需要上下文切换。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                        </span><span style=\"color: #DCDCAA\">queueYIELD_IF_USING_PREEMPTION</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                    /* 如果有任务正在等待队列中有数据到达，则立即解除阻塞。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">listLIST_IS_EMPTY</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxQueue</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xTasksWaitingToReceive</span><span style=\"color: #D4D4D4\"> ) ) == pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">xTaskRemoveFromEventList</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxQueue</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xTasksWaitingToReceive</span><span style=\"color: #D4D4D4\"> ) ) != pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                            /* 解除阻塞的任务具有比我们更高的优先级，因此立即让出CPU。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                            </span><span style=\"color: #DCDCAA\">queueYIELD_IF_USING_PREEMPTION</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #C586C0\">else</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xYieldRequired != pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                        /* 此路径是一个特殊情况，只有在任务持有多个互斥锁，并且互斥锁的释放顺序与获取顺序不同时才会执行。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                        </span><span style=\"color: #DCDCAA\">queueYIELD_IF_USING_PREEMPTION</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> pdPASS;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xTicksToWait == ( </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                    /* 队列已满且未指定阻塞时间（或阻塞时间已过期），因此现在退出。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #DCDCAA\">taskEXIT_CRITICAL</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> errQUEUE_FULL;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">else</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xEntryTimeSet == pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                    /* 队列已满且指定了阻塞时间，因此配置超时结构。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #DCDCAA\">vTaskInternalSetTimeOutState</span><span style=\"color: #D4D4D4\">( &amp;xTimeOut );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    xEntryTimeSet = pdTRUE;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">taskEXIT_CRITICAL</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 中断和其他任务现在可以在退出临界区后向队列发送数据和从队列接收数据。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">vTaskSuspendAll</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">prvLockQueue</span><span style=\"color: #D4D4D4\">( pxQueue );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 更新超时状态，查看是否已过期。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">xTaskCheckForTimeOut</span><span style=\"color: #D4D4D4\">( &amp;xTimeOut, &amp;xTicksToWait ) == pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">prvIsQueueFull</span><span style=\"color: #D4D4D4\">( pxQueue ) != pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #DCDCAA\">vTaskPlaceOnEventList</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxQueue</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xTasksWaitingToSend</span><span style=\"color: #D4D4D4\"> ), xTicksToWait );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                /* 解锁队列意味着队列事件可能会影响事件列表。现在可能发生中断，再次将此任务从事件列表中移除 -</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                 * 但由于调度程序已挂起，任务将进入挂起就绪列表而不是实际的就绪列表。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #DCDCAA\">prvUnlockQueue</span><span style=\"color: #D4D4D4\">( pxQueue );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                /* 恢复调度程序会将任务从挂起的就绪列表移动到就绪列表 -</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                 * 因此，此任务在让出CPU之前已经进入就绪列表是可行的 -</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                 * 在这种情况下，除非挂起就绪列表中还有更高优先级的任务，否则让出CPU不会导致上下文切换。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">xTaskResumeAll</span><span style=\"color: #D4D4D4\">() == pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #DCDCAA\">taskYIELD_WITHIN_API</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">else</span><span style=\"color: #D4D4D4\"> </span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            {</span><span style=\"color: #6A9955\">   //队列未满</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #DCDCAA\">prvUnlockQueue</span><span style=\"color: #D4D4D4\">( pxQueue );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                ( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #DCDCAA\">xTaskResumeAll</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /* 超时已过期。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">prvUnlockQueue</span><span style=\"color: #D4D4D4\">( pxQueue );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            ( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #DCDCAA\">xTaskResumeAll</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> errQUEUE_FULL;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><h3 id=\"消息队列的接收\"><a href=\"#消息队列的接收\" class=\"headerlink\" title=\"消息队列的接收\"></a>消息队列的接收</h3><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">xQueueReceive</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #4EC9B0\">QueueHandle_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">xQueue</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                          </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pvBuffer</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                          </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">xTicksToWait</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> xEntryTimeSet = pdFALSE;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">TimeOut_t</span><span style=\"color: #D4D4D4\"> xTimeOut;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">Queue_t</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> pxQueue = xQueue;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\">( ; ; )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">taskENTER_CRITICAL</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> uxMessagesWaiting = </span><span style=\"color: #9CDCFE\">pxQueue</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">uxMessagesWaiting</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /* 队列中现在有数据吗？要运行，调用任务必须是想要访问队列的最高优先级任务。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( uxMessagesWaiting &gt; ( </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                /* 数据可用，移除一个项目。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #DCDCAA\">prvCopyDataFromQueue</span><span style=\"color: #D4D4D4\">( pxQueue, pvBuffer );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #9CDCFE\">pxQueue</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">uxMessagesWaiting</span><span style=\"color: #D4D4D4\"> = ( </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> ) ( uxMessagesWaiting - ( </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\"> );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                /* 队列中现在有空间了，是否有任务在等待向队列发布？如果是，则解除阻塞最高优先级的等待任务。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">listLIST_IS_EMPTY</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxQueue</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xTasksWaitingToSend</span><span style=\"color: #D4D4D4\"> ) ) == pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">xTaskRemoveFromEventList</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxQueue</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xTasksWaitingToSend</span><span style=\"color: #D4D4D4\"> ) ) != pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                        </span><span style=\"color: #DCDCAA\">queueYIELD_IF_USING_PREEMPTION</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #DCDCAA\">taskEXIT_CRITICAL</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> pdPASS;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xTicksToWait == ( </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                    /* 队列为空，并且未指定阻塞时间（或阻塞时间已过期），因此现在离开。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #DCDCAA\">taskEXIT_CRITICAL</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> errQUEUE_EMPTY;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">else</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xEntryTimeSet == pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                    /* 队列为空，并且指定了阻塞时间，因此配置超时结构。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #DCDCAA\">vTaskInternalSetTimeOutState</span><span style=\"color: #D4D4D4\">( &amp;xTimeOut );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    xEntryTimeSet = pdTRUE;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">taskEXIT_CRITICAL</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 中断和其他任务现在可以向队列发送和接收数据，因为临界区已退出。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">vTaskSuspendAll</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">prvLockQueue</span><span style=\"color: #D4D4D4\">( pxQueue );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 更新超时状态，查看是否已过期。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">xTaskCheckForTimeOut</span><span style=\"color: #D4D4D4\">( &amp;xTimeOut, &amp;xTicksToWait ) == pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /* 超时时间尚未过期。如果队列仍然为空，则将任务放在等待从队列接收任务的列表上。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">prvIsQueueEmpty</span><span style=\"color: #D4D4D4\">( pxQueue ) != pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #DCDCAA\">vTaskPlaceOnEventList</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxQueue</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xTasksWaitingToReceive</span><span style=\"color: #D4D4D4\"> ), xTicksToWait );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #DCDCAA\">prvUnlockQueue</span><span style=\"color: #D4D4D4\">( pxQueue );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">xTaskResumeAll</span><span style=\"color: #D4D4D4\">() == pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #DCDCAA\">taskYIELD_WITHIN_API</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                /* 队列再次包含数据。循环返回以尝试读取数据。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #DCDCAA\">prvUnlockQueue</span><span style=\"color: #D4D4D4\">( pxQueue );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                ( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #DCDCAA\">xTaskResumeAll</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /* 超时。如果队列中没有数据，则退出，否则循环返回并尝试读取数据。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">prvUnlockQueue</span><span style=\"color: #D4D4D4\">( pxQueue );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            ( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #DCDCAA\">xTaskResumeAll</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">prvIsQueueEmpty</span><span style=\"color: #D4D4D4\">( pxQueue ) != pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> errQUEUE_EMPTY;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><h3 id=\"消息队列的删除\"><a href=\"#消息队列的删除\" class=\"headerlink\" title=\"消息队列的删除\"></a>消息队列的删除</h3><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">vQueueDelete</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #4EC9B0\">QueueHandle_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">xQueue</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">Queue_t</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> pxQueue = xQueue;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">    </span><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( configQUEUE_REGISTRY_SIZE </span><span style=\"color: #D4D4D4\">&gt;</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #569CD6\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">vQueueUnregisterQueue</span><span style=\"color: #D4D4D4\">( pxQueue );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">    </span><span style=\"color: #C586C0\">#endif</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #9CDCFE\">pxQueue</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">ucStaticallyAllocated</span><span style=\"color: #D4D4D4\"> == ( </span><span style=\"color: #569CD6\">uint8_t</span><span style=\"color: #D4D4D4\"> ) pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">vPortFree</span><span style=\"color: #D4D4D4\">( pxQueue );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>这也太过简单了，只是释放了队列的内存。如果一个任务正好在 xQueueGenericSend 中，此时时间片到期，调度器会切换到另一个任务，另一个任务删除该队列，那么第一个任务切回来的话，就是访问了悬垂指针了，特别注意。</p>\n<h2 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h2><p>信号量在 FreeRTOS 中是通过消息队列来实现的，对于二值信号量，其实是一个长度为 1 的消息队列（但没有实际的用于保存项目的内存空间）。对于一个计数信号量，其实就是一个长度为 n 的消息队列（也没有实际的用于保存项目的内存空间）。</p>\n<p>照这么说，其实信号量只是消息队列的一个子集，又或是说，消息队列是由信号量实现的。</p>\n<p>信号量和消息队列唯一没有通用的函数就是 xQueueSemaphoreTake 函数，这个函数是用于获取信号量的，里面包含了有关 互斥信号量 优先级继承的逻辑。</p>\n<h2 id=\"队列集（IO多路复用）\"><a href=\"#队列集（IO多路复用）\" class=\"headerlink\" title=\"队列集（IO多路复用）\"></a>队列集（IO多路复用）</h2><p>队列集是一个用于管理多个队列的数据结构，原理有点像 epoll ，可以监听多个队列和信号量。</p>\n<p>有趣的是，队列集也是通过消息队列来实现的。</p>\n<p>把一个队列或者信号量加入到队列集中，其实是将其成员 pxQueueSetContainer 指向队列集的句柄。 上面可以看到 ，往消息队列中发送数据的时候，xQueueGenericSend 函数会检查 pxQueueSetContainer 是否指向某个 队列集 ，如果是的话，会调用 prvNotifyQueueSetContainer 函数来通知队列集，这个函数会将 消息队列 自身的句柄加入到队列集的消息队列中，然后检查队列集中是否有任务等待，如果有的话，会将其解除阻塞。这就是队列集的原理。同理信号量。</p>\n<h2 id=\"事件组\"><a href=\"#事件组\" class=\"headerlink\" title=\"事件组\"></a>事件组</h2><p>事件组的结构体如下：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">typedef</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">EventGroupDef_t</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">EventBits_t</span><span style=\"color: #D4D4D4\"> uxEventBits;</span><span style=\"color: #6A9955\">     /**&lt; 事件组的位图 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">List_t</span><span style=\"color: #D4D4D4\"> xTasksWaitingForBits;</span><span style=\"color: #6A9955\"> /**&lt; 等待事件组的任务列表 */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> uxEventGroupNumber;</span><span style=\"color: #6A9955\">  /**&lt; 事件组编号 */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">uint8_t</span><span style=\"color: #D4D4D4\"> ucStaticallyAllocated;</span><span style=\"color: #6A9955\"> /**&lt; 静态分配标志 */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">} </span><span style=\"color: #4EC9B0\">EventGroup_t</span><span style=\"color: #D4D4D4\">;</span></span></code></pre></div><p>从结构体可以看出，事件组是由一个位图和一个等待事件组的任务列表组成的。如果有任务要等待事件组的某个位被置位，那么这个任务会把自己加入到 xTasksWaitingForBits 中，并移出就绪列表。</p>\n<p>如果要向事件组传达某些事件的发生，只需要调用 xEventGroupSetBits 或其等效函数 将位图中对应的位设置为 1 即可。这个函数会遍历列表，检查是否有任务正在等待这些位被设置，如果有，则根据等待条件唤醒相应的任务（加入到就绪列表中）。</p>\n<p>与消息队列不同的是 vEventGroupDelete 函数，会唤醒所有正在等待这个事件组的任务，释放事件组所占用的内存（如果是动态分配的），所以还比较安全。</p>\n<h2 id=\"任务通知\"><a href=\"#任务通知\" class=\"headerlink\" title=\"任务通知\"></a>任务通知</h2><p>大多数任务间通信方法借助中间对象，如队列、信号量或 事件组。发送任务写入通信对象，而接收任务从 通信对象中读取。使用直接任务通知时，顾名思义，发送 任务直接向接收任务发送通知，无需借助中间对象。这是怎么做到的呢？</p>\n<p>每个任务都有一个通知数组。在此之前，每个任务只有一个通知。每个通知包含一个 32 位值和一个布尔状态，总共占用 5 字节的 RAM：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">volatile</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">uint32_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">ulNotifiedValue</span><span style=\"color: #D4D4D4\">[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">volatile</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">uint8_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">ucNotifyState</span><span style=\"color: #D4D4D4\">[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];</span></span></code></pre></div><h3 id=\"等待任务通知\"><a href=\"#等待任务通知\" class=\"headerlink\" title=\"等待任务通知\"></a>等待任务通知</h3><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">uint32_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">ulTaskGenericNotifyTake</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">uxIndexToWaitOn</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                                    </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">xClearCountOnExit</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                                    </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">xTicksToWait</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">uint32_t</span><span style=\"color: #D4D4D4\"> ulReturn;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> xAlreadyYielded, xShouldBlock = pdFALSE;</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* 首先检查当前任务在指定索引处的通知值是否为零。如果为零，且等待时间大于零，则准备进入阻塞状态 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( ( </span><span style=\"color: #9CDCFE\">pxCurrentTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">ulNotifiedValue</span><span style=\"color: #D4D4D4\">[ uxIndexToWaitOn ] == </span><span style=\"color: #B5CEA8\">0U</span><span style=\"color: #D4D4D4\"> ) &amp;&amp; ( xTicksToWait &gt; ( </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\"> ) )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 挂起调度器以防止在关键操作期间被切换 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">vTaskSuspendAll</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /* 进入临界区，再次检查通知值（双重检查模式），确保没有中断在此期间发送了通知 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">taskENTER_CRITICAL</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                /* 如果确认通知值仍为零，则将任务标记为\"等待通知\"状态，并设置阻塞标志 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #9CDCFE\">pxCurrentTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">ulNotifiedValue</span><span style=\"color: #D4D4D4\">[ uxIndexToWaitOn ] == </span><span style=\"color: #B5CEA8\">0U</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #9CDCFE\">pxCurrentTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">ucNotifyState</span><span style=\"color: #D4D4D4\">[ uxIndexToWaitOn ] = taskWAITING_NOTIFICATION;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    xShouldBlock = pdTRUE;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">taskEXIT_CRITICAL</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /* 退出临界区，但调度器仍处于挂起状态，这样才敢执行 prvAddCurrentTaskToDelayedList 来阻塞任务 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xShouldBlock == pdTRUE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #DCDCAA\">prvAddCurrentTaskToDelayedList</span><span style=\"color: #D4D4D4\">( xTicksToWait, pdTRUE );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 恢复调度器，如果没有自动触发任务切换且需要阻塞，则手动触发任务切换 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        xAlreadyYielded = </span><span style=\"color: #DCDCAA\">xTaskResumeAll</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( ( xShouldBlock == pdTRUE ) &amp;&amp; ( xAlreadyYielded == pdFALSE ) )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">taskYIELD_WITHIN_API</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* 在任务被唤醒后（无论是通过通知唤醒还是超时），函数进入第二阶段,检查通知值 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">taskENTER_CRITICAL</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">traceTASK_NOTIFY_TAKE</span><span style=\"color: #D4D4D4\">( uxIndexToWaitOn );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ulReturn = </span><span style=\"color: #9CDCFE\">pxCurrentTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">ulNotifiedValue</span><span style=\"color: #D4D4D4\">[ uxIndexToWaitOn ];</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( ulReturn != </span><span style=\"color: #B5CEA8\">0U</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xClearCountOnExit != pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #9CDCFE\">pxCurrentTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">ulNotifiedValue</span><span style=\"color: #D4D4D4\">[ uxIndexToWaitOn ] = ( </span><span style=\"color: #569CD6\">uint32_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0U</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #9CDCFE\">pxCurrentTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">ulNotifiedValue</span><span style=\"color: #D4D4D4\">[ uxIndexToWaitOn ] = ulReturn - ( </span><span style=\"color: #569CD6\">uint32_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">pxCurrentTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">ucNotifyState</span><span style=\"color: #D4D4D4\">[ uxIndexToWaitOn ] = taskNOT_WAITING_NOTIFICATION;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">taskEXIT_CRITICAL</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> ulReturn;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><h3 id=\"发送任务通知\"><a href=\"#发送任务通知\" class=\"headerlink\" title=\"发送任务通知\"></a>发送任务通知</h3><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">xTaskGenericNotify</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #4EC9B0\">TaskHandle_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">xTaskToNotify</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                                </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">uxIndexToNotify</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                                </span><span style=\"color: #569CD6\">uint32_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">ulValue</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                                eNotifyAction </span><span style=\"color: #9CDCFE\">eAction</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                                </span><span style=\"color: #569CD6\">uint32_t</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #9CDCFE\">pulPreviousNotificationValue</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">TCB_t</span><span style=\"color: #D4D4D4\"> * pxTCB;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> xReturn = pdPASS;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">uint8_t</span><span style=\"color: #D4D4D4\"> ucOriginalNotifyState;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    pxTCB = xTaskToNotify;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* 进入临界区，防止在修改任务控制块(TCB)期间被中断 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">taskENTER_CRITICAL</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 如果用户提供了存储位置，保存任务当前的通知值 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( pulPreviousNotificationValue != </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            *pulPreviousNotificationValue = </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">ulNotifiedValue</span><span style=\"color: #D4D4D4\">[ uxIndexToNotify ];</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 记录任务原始的通知状态 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ucOriginalNotifyState = </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">ucNotifyState</span><span style=\"color: #D4D4D4\">[ uxIndexToNotify ];</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 将任务通知状态标记为\"已接收\" */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">ucNotifyState</span><span style=\"color: #D4D4D4\">[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">switch</span><span style=\"color: #D4D4D4\">( eAction )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">case</span><span style=\"color: #D4D4D4\"> eSetBits:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">ulNotifiedValue</span><span style=\"color: #D4D4D4\">[ uxIndexToNotify ] |= ulValue;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">break</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">case</span><span style=\"color: #D4D4D4\"> eIncrement:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                ( pxTCB-&gt;</span><span style=\"color: #9CDCFE\">ulNotifiedValue</span><span style=\"color: #D4D4D4\">[ uxIndexToNotify ] )++;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">break</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">case</span><span style=\"color: #D4D4D4\"> eSetValueWithOverwrite:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">ulNotifiedValue</span><span style=\"color: #D4D4D4\">[ uxIndexToNotify ] = ulValue;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">break</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">case</span><span style=\"color: #D4D4D4\"> eSetValueWithoutOverwrite:</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">ulNotifiedValue</span><span style=\"color: #D4D4D4\">[ uxIndexToNotify ] = ulValue;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">else</span><span style=\"color: #6A9955\"> /* The value could not be written to the task. */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    xReturn = pdFAIL;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">break</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">case</span><span style=\"color: #D4D4D4\"> eNoAction:</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                /* The task is being notified without its notify value being</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                    * updated. */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">break</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">default</span><span style=\"color: #D4D4D4\">:</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                /* Should not get here */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">break</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 如果目标任务处于\"等待通知\"状态 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( ucOriginalNotifyState == taskWAITING_NOTIFICATION )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">listREMOVE_ITEM</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xStateListItem</span><span style=\"color: #D4D4D4\"> ) );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">prvAddTaskToReadyList</span><span style=\"color: #D4D4D4\">( pxTCB );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">            </span><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( configUSE_TICKLESS_IDLE </span><span style=\"color: #D4D4D4\">!=</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #569CD6\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                /* 如果支持无滴答空闲模式，重置下一个任务解除阻塞的时间 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #DCDCAA\">prvResetNextTaskUnblockTime</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">            </span><span style=\"color: #C586C0\">#endif</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /* 如果被通知任务具有更高的优先级，且系统使用抢占式调度，则触发任务切换 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">taskYIELD_ANY_CORE_IF_USING_PREEMPTION</span><span style=\"color: #D4D4D4\">( pxTCB );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">taskEXIT_CRITICAL</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> xReturn;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><h2 id=\"软件定时器\"><a href=\"#软件定时器\" class=\"headerlink\" title=\"软件定时器\"></a>软件定时器</h2><p>软件定时器是 FreeRTOS 中的一个模块，用于在任务中创建定时器，定时器到期时会调用一个回调函数。和定时器有关的变量包括：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">typedef</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">struct</span><span style=\"color: #D4D4D4\"> tmrTimerControl{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">char</span><span style=\"color: #D4D4D4\"> * pcTimerName;</span><span style=\"color: #6A9955\">  //定时器的名字</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">ListItem_t</span><span style=\"color: #D4D4D4\"> xTimerListItem;</span><span style=\"color: #6A9955\"> //定时器的链表节点</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> xTimerPeriodInTicks;</span><span style=\"color: #6A9955\">  //定时器的时间</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> * pvTimerID;</span><span style=\"color: #6A9955\">      // ID</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    portTIMER_CALLBACK_ATTRIBUTE </span><span style=\"color: #4EC9B0\">TimerCallbackFunction_t</span><span style=\"color: #D4D4D4\"> pxCallbackFunction;</span><span style=\"color: #6A9955\"> //定时器到期时的回调函数</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">uint8_t</span><span style=\"color: #D4D4D4\"> ucStatus;</span><span style=\"color: #6A9955\"> //是否静态分配，是否激活</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">} xTIMER;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">// 经典两个链表处理溢出情况</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">List_t</span><span style=\"color: #D4D4D4\"> xActiveTimerList1;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">List_t</span><span style=\"color: #D4D4D4\"> xActiveTimerList2;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">List_t</span><span style=\"color: #D4D4D4\"> * pxCurrentTimerList;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">List_t</span><span style=\"color: #D4D4D4\"> * pxOverflowTimerList;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">QueueHandle_t</span><span style=\"color: #D4D4D4\"> xTimerQueue = </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\">;</span><span style=\"color: #6A9955\">     //用于给定时器服务任务发送命令</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">TaskHandle_t</span><span style=\"color: #D4D4D4\"> xTimerTaskHandle = </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\">;</span><span style=\"color: #6A9955\"> //定时器服务任务的句柄</span></span></code></pre></div><p>软件定时器能够让回调函数 pxCallbackFunction 在 未来的设定时间执行。从定时器启动到其回调函数执行之间的时间 xTimerPeriodInTicks 被称为定时器的周期。当定时器的周期到期时，定时器的回调函数会被定时器服务任务 TimerTask 执行。<br>软件定时器的实现函数，一般使用 消息队列 向定时器服务任务 TimerTask 发送命令。用于 此目的的队列称为“定时器命令队列” xTimerQueue 。</p>\n<h3 id=\"定时器发送命令（从任务中）\"><a href=\"#定时器发送命令（从任务中）\" class=\"headerlink\" title=\"定时器发送命令（从任务中）\"></a>定时器发送命令（从任务中）</h3><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">xTimerGenericCommandFromTask</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #4EC9B0\">TimerHandle_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">xTimer</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                                            </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">xCommandID</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                                            </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">xOptionalValue</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                                            是最简单的实现方式。内存一经分配，它不允许内存再被释放。尽管如此，heap_1.c 还是适用于大量嵌入式应用程序。这是因为许多小型和深度嵌入的应用程序在系统启动时创建了所需的所有任务、队列、信号量等，并在程序的生命周期内使用所有这些对象（直到应用程序再次关闭或重新启动）。任何内容都不会被删除。</span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pxHigherPriorityTaskWoken</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                                            </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">xTicksToWait</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> xReturn = pdFAIL;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">DaemonTaskMessage_t</span><span style=\"color: #D4D4D4\"> xMessage;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> ) pxHigherPriorityTaskWoken;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* 确保定时器队列 xTimerQueue 已初始化 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xTimerQueue != </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 发送命令到定时器服务任务 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">xMessage</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">xMessageID</span><span style=\"color: #D4D4D4\"> = xCommandID;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">xMessage</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">u</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">xTimerParameters</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">xMessageValue</span><span style=\"color: #D4D4D4\"> = xOptionalValue;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">xMessage</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">u</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">xTimerParameters</span><span style=\"color: #D4D4D4\">.</span><span style=\"color: #9CDCFE\">pxTimer</span><span style=\"color: #D4D4D4\"> = xTimer;</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 验证命令ID小于 tmrFIRST_FROM_ISR_COMMAND，表示这是从任务上下文发出的命令而非中断上下文 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xCommandID &lt; tmrFIRST_FROM_ISR_COMMAND )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">xTaskGetSchedulerState</span><span style=\"color: #D4D4D4\">() == taskSCHEDULER_RUNNING )</span><span style=\"color: #6A9955\"> /* 如果调度器运行中，允许等待指定时长 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                xReturn = </span><span style=\"color: #DCDCAA\">xQueueSendToBack</span><span style=\"color: #D4D4D4\">( xTimerQueue, &amp;xMessage, xTicksToWait );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">else</span><span style=\"color: #6A9955\">                                                    /* 如果调度器未运行，不等待 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                xReturn = </span><span style=\"color: #DCDCAA\">xQueueSendToBack</span><span style=\"color: #D4D4D4\">( xTimerQueue, &amp;xMessage, tmrNO_DELAY );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> xReturn;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>该函数将定时器相关的命令（如启动、停止、更改周期等）发送到定时器服务任务的队列中。</p>\n<p>有一个比较难理解的点是，为什么要检查调度器是否运行，并根据调度器的状态来决定是否等待呢？<br>想想，如果调度器没有运行，万一 xQueueSendToBack 函数阻塞了怎么办？所以要立即返回。</p>\n<h3 id=\"定时器任务的执行\"><a href=\"#定时器任务的执行\" class=\"headerlink\" title=\"定时器任务的执行\"></a>定时器任务的执行</h3><p>先来看看定时器任务做了什么：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">portTASK_FUNCTION</span><span style=\"color: #D4D4D4\">( prvTimerTask, pvParameters )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> xNextExpireTime;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> xListWasEmpty;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\">( ;; )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 获得下一个定时器到期时间 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        xNextExpireTime = </span><span style=\"color: #DCDCAA\">prvGetNextExpireTime</span><span style=\"color: #D4D4D4\">( &amp;xListWasEmpty );</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 如果没有定时器到期，阻塞任务直到有定时器到期或有新的定时器添加 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">prvProcessTimerOrBlockTask</span><span style=\"color: #D4D4D4\">( xNextExpireTime, xListWasEmpty );</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 清空命令队列 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">prvProcessReceivedCommands</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>其中，prvGetNextExpireTime 函数会取出列表的头结点，即最早到期的定时器的时间。然后阻塞任务。如果有新的定时器添加，或者有定时器到期，任务会被唤醒并处理收到的命令。</p>\n<p>看看 prvProcessTimerOrBlockTask 函数：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">prvProcessTimerOrBlockTask</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">xNextExpireTime</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                                        </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">xListWasEmpty</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> xTimeNow;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> xTimerListsWereSwitched;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">vTaskSuspendAll</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 获取当前时间，同时检查是否应该切换定时器列表（当系统时钟溢出时就要切换） */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        xTimeNow = </span><span style=\"color: #DCDCAA\">prvSampleTimeNow</span><span style=\"color: #D4D4D4\">( &amp;xTimerListsWereSwitched );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xTimerListsWereSwitched == pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /* 如果定时器列表没有切换，继续检查定时器是否到期 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( ( xListWasEmpty == pdFALSE ) &amp;&amp; ( xNextExpireTime &lt;= xTimeNow ) )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                ( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #DCDCAA\">xTaskResumeAll</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #DCDCAA\">prvProcessExpiredTimer</span><span style=\"color: #D4D4D4\">( xNextExpireTime, xTimeNow );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                /* 当前没有定时器到期，又或是当前列表为空，看看溢出列表？ */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xListWasEmpty != pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    xListWasEmpty = </span><span style=\"color: #DCDCAA\">listLIST_IS_EMPTY</span><span style=\"color: #D4D4D4\">( pxOverflowTimerList );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                /* 将自己添加到 xTimerQueue 的等待列表中，等待下一个定时器添加</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                 * 如果两个列表都为空，将本任务添加到 suspend 队列中，否则添加到 delay 队列中 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #DCDCAA\">vQueueWaitForMessageRestricted</span><span style=\"color: #D4D4D4\">( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">xTaskResumeAll</span><span style=\"color: #D4D4D4\">() == pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                    /* 如果没有更高优先级的任务唤醒，手动触发任务切换，确保若在临界区</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                     * 退出与当前让出操作之间有命令到达，任务不会错过处理这些命令的机会 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #DCDCAA\">taskYIELD_WITHIN_API</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">else</span><span style=\"color: #6A9955\"> //什么都不做，等待下一个循环</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            ( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #DCDCAA\">xTaskResumeAll</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>剩下的一个 prvProcessReceivedCommands 函数比较复杂，它通过一个循环不断从定时器命令队列(xTimerQueue)中接收消息，直到队列为空为止。每条消息包含一个命令ID和相关参数，这些命令包括定时器操作命令或挂起的函数调用请求。</p>\n","feature":true,"text":"如何移植FreeRTOS到开发版上FreeRTOS的目录结构txt. └── FreeRTOS └── Source # FreeRTOS源码 ├── CMSI...","permalink":"/post/FreeRTOS源码学习","photos":[],"count_time":{"symbolsCount":"55k","symbolsTime":"50 mins."},"categories":[{"name":"C++","slug":"C","count":6,"path":"api/categories/C.json"},{"name":"操作系统","slug":"C/操作系统","count":1,"path":"api/categories/C/操作系统.json"},{"name":"嵌入式","slug":"C/操作系统/嵌入式","count":1,"path":"api/categories/C/操作系统/嵌入式.json"}],"tags":[{"name":"freeRTOS","slug":"freeRTOS","count":1,"path":"api/tags/freeRTOS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E7%A7%BB%E6%A4%8DFreeRTOS%E5%88%B0%E5%BC%80%E5%8F%91%E7%89%88%E4%B8%8A\"><span class=\"toc-text\">如何移植FreeRTOS到开发版上</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#FreeRTOS%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">FreeRTOS的目录结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A7%BB%E6%A4%8D\"><span class=\"toc-text\">移植</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">简单的使用</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\"><span class=\"toc-text\">部分源码分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%B8%E5%BF%83%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">核心全局变量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#FreeRTOS-%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">FreeRTOS 的任务管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">任务的创建</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">任务的调度</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">任务的删除</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%BB%B6%E6%97%B6\"><span class=\"toc-text\">任务的延时</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#FreeRTOS-%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97\"><span class=\"toc-text\">FreeRTOS 的消息队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">消息队列的创建</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%8F%91%E9%80%81\"><span class=\"toc-text\">消息队列的发送</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%8E%A5%E6%94%B6\"><span class=\"toc-text\">消息队列的接收</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">消息队列的删除</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BF%A1%E5%8F%B7%E9%87%8F\"><span class=\"toc-text\">信号量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%98%9F%E5%88%97%E9%9B%86%EF%BC%88IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%89\"><span class=\"toc-text\">队列集（IO多路复用）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E7%BB%84\"><span class=\"toc-text\">事件组</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5\"><span class=\"toc-text\">任务通知</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AD%89%E5%BE%85%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5\"><span class=\"toc-text\">等待任务通知</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%91%E9%80%81%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5\"><span class=\"toc-text\">发送任务通知</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8\"><span class=\"toc-text\">软件定时器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E6%97%B6%E5%99%A8%E5%8F%91%E9%80%81%E5%91%BD%E4%BB%A4%EF%BC%88%E4%BB%8E%E4%BB%BB%E5%8A%A1%E4%B8%AD%EF%BC%89\"><span class=\"toc-text\">定时器发送命令（从任务中）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">定时器任务的执行</span></a></li></ol></li></ol></li></ol>","author":{"name":"Ac-Accelerator","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一位计算机技术爱好者，大学在读，目前正在学习C++、Python、Java和计算机系统以及计算机视觉深度学习等相关知识，欢迎交流","socials":{"github":"https://github.com/Ac-Accelerator","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_31702515?spm=1000.2115.3001.5343","juejin":"","customs":{"qq":{"icon":"/svg/QQ.svg","link":"http://tool.gljlw.com/qq/?qq=2583832841"}}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"函数钩子原理初探","uid":"d7e80eeb35c73d4ee8de7a24a876423f","slug":"函数钩子原理初探","date":"2025-02-25T02:01:00.000Z","updated":"2025-02-25T02:50:23.947Z","comments":true,"path":"api/articles/函数钩子原理初探.json","keywords":"C++,Pyhton,Java,算法","cover":"img/函数钩子.png","text":"什么是函数钩子在Windows操作系统中，似乎可以通过一些方法，将某个进程的函数调用替换掉，从而实现破解或者内容修改等功能。这种技术就是函数钩子。在Linux中...","permalink":"/post/函数钩子原理初探","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"C++","slug":"C","count":6,"path":"api/categories/C.json"}],"tags":[{"name":"函数钩子","slug":"函数钩子","count":1,"path":"api/tags/函数钩子.json"}],"author":{"name":"Ac-Accelerator","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一位计算机技术爱好者，大学在读，目前正在学习C++、Python、Java和计算机系统以及计算机视觉深度学习等相关知识，欢迎交流","socials":{"github":"https://github.com/Ac-Accelerator","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_31702515?spm=1000.2115.3001.5343","juejin":"","customs":{"qq":{"icon":"/svg/QQ.svg","link":"http://tool.gljlw.com/qq/?qq=2583832841"}}}},"feature":true}}