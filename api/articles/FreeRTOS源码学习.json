{"title":"FreeRTOS源码学习","uid":"b7792344e86e32daf60ff27b68b40109","slug":"FreeRTOS源码学习","date":"2025-02-25T02:17:00.000Z","updated":"2025-02-27T06:57:48.451Z","comments":true,"path":"api/articles/FreeRTOS源码学习.json","keywords":"C++,Pyhton,Java,算法","cover":"img/freertos.png","content":"<h1 id=\"如何移植FreeRTOS到开发版上\"><a href=\"#如何移植FreeRTOS到开发版上\" class=\"headerlink\" title=\"如何移植FreeRTOS到开发版上\"></a>如何移植FreeRTOS到开发版上</h1><h2 id=\"FreeRTOS的目录结构\"><a href=\"#FreeRTOS的目录结构\" class=\"headerlink\" title=\"FreeRTOS的目录结构\"></a>FreeRTOS的目录结构</h2><div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #D4D4D4\">.</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">└── FreeRTOS</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    └── Source                              # FreeRTOS源码</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ├── CMSIS_RTOS_V2                   # CMSIS-RTOS V2 API</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── cmsis_os2.c</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── cmsis_os2.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── cmsis_os.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── freertos_mpool.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   └── freertos_os2.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ├── include                         # FreeRTOS 内核头文件</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── croutine.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── deprecated_definitions.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── event_groups.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── FreeRTOS.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── list.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── message_buffer.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── mpu_prototypes.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── mpu_wrappers.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── portable.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── projdefs.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── queue.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── semphr.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── stack_macros.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── StackMacros.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── stream_buffer.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── task.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   └── timers.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ├── portable                        # 移植层</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   ├── GCC                         # GCC编译器</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   │   └── ARM_CM3                 # ARM Cortex-M3</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   │       ├── port.c</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   │       └── portmacro.h</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │   └── MemMang                     # 内存管理</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        │       └── heap_3.c</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ├── list.c                          # 链表管理（核心）</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ├── queue.c                         # 队列管理（核心）</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ├── tasks.c                         # 任务管理（核心）</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ├── croutine.c                      # 协程功能（可选）（弃用）</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ├── timers.c                        # 软件计时器功能（可选）</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ├── event_groups.c                  # 事件组功能（可选）</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ├── stream_buffer.c                 # 流缓冲区功能（可选）</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        └── LICENSE</span></span></code></pre></div><p>首先看到的是 <strong>CMSIS_RTOS_V2</strong> 目录，这个不包含在 FreeRTOS 的源码中，而是 FreeRTOS 为了支持 CMSIS-RTOS V2 API 而提供的一抽象层。ARM公司将各个RTOS的接口统一起来，作为CMSIS-RTOS接口，使用该接口编程可以提高代码的移植性（虽然我没用到就是了）</p>\n<p>此外还有 <strong>include</strong> 目录，放了 FreeRTOS 的头文件，要使用功能的时候包含这些头文件即可。</p>\n<p><strong>portable</strong> 目录是 FreeRTOS 的移植层，因为 freeRTOS 是一个高度抽象的操作系统（更准确来说是一个用于实现并行的库），因此在不同的平台上运行，需要为 freeRTOS 提供一些底层的支持。该目录下的文件包含了大量的宏和内联汇编代码，freeRTOS 通过统一的宏定义来调用这些底层的功能支持。<strong>MemMang</strong> 里面包含的是和内存管理策略相关的代码，FreeRTOS 提供了多种内存管理策略，可以根据需求随时更换。</p>\n<p>注意在 <strong>FreeRTOS.h</strong> 头文件中，引用了 <strong>FreeRTOSConfig.h</strong> 文件，请确保该文件能够被引用，这个文件包含一些用户定义的宏，用于为应用程序量身定制 RTOS 内核，所以位置应位于应用程序目录中，而不是 RTOS 内核源代码目录中（从项目架构角度看）。</p>\n<h2 id=\"移植\"><a href=\"#移植\" class=\"headerlink\" title=\"移植\"></a>移植</h2><p>前面讲到，FreeRTOS 是一个高度抽象的库，因此需要为 FreeRTOS 提供一些底层的支持。正常来说的话，如果不是太冷门的芯片，在 <strong>portable</strong> 目录下都能找到对应的移植文件，只需要将这些文件添加到工程中即可。 然后把 <strong>include</strong> 以及 核心文件 <strong>list.c</strong>、<strong>queue.c</strong>、<strong>tasks.c</strong> 添加到工程中，其他的文件根据需要添加。最后在 <strong>FreeRTOSConfig.h</strong> 中配置 FreeRTOS 的一些功能。</p>\n<p>在 <strong>FreeRTOSConfig.h</strong> 头文件的配置，可以参考<a href=\"https://www.freertos.org/zh-cn-cmn-s/Documentation/02-Kernel/03-Supported-devices/02-Customization\">官网的文档</a>或者示例。但是有几个点要注意一下：</p>\n<ol>\n<li>如果是使用了特定的处理器架构，除了配置 ‘config’ 和 ‘INCLUDE’ 开头的宏定义之外，还有一些中断相关的也要在这里配置，比如：<ul>\n<li>#define vPortSVCHandler    SVC_Handler</li>\n<li>#define xPortPendSVHandler  PendSV_Handler</li>\n<li>虽然有一个 xPortSysTickHandler ，但是先不在这里配置，因为有一些条件判断之类的。</li>\n</ul>\n</li>\n<li>configCHECK_HANDLER_INSTALLATION 宏定义，默认为 1 ，表示 FreeRTOS 会自动检查中断服务函数是否安装，如果没有安装则会无法通过 configASSERT 。所以如果忘了配置第一条，那么 FreeRTOS 会一直卡在那里，是一个保险措施哦。</li>\n<li>之前提到的 xPortSysTickHandler 呢？这个函数会递增 FreeRTOS 的系统时钟节拍，并检查是否需要进行任务切换。但是调用的时候要做一些条件判断，因此就在 SysTick_Handler 函数中调用 xPortSysTickHandler 函数，代码放在下面。</li>\n<li>如果定义了 configSUPPORT_STATIC_ALLOCATION 为 1 ，那么就要多定义两个函数了，代码也放在下面。</li>\n</ol>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>关于第一项的官网原文：</p>\n<p><strong>ARM Cortex-M 用户特别注意事项：</strong> ARM Cortex-M3、ARM Cortex-M4 和 ARM Cortex-M4F 移植要求 在 SysTick、PendSV 和 SVCCall 中断向量上安装 FreeRTOS 处理程序。</p>\n\n</div>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #6A9955\">//在 SysTick_Handler 函数中调用 xPortSysTickHandler 函数</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">extern</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">xPortSysTickHandler</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">SysTick_Handler</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">  /* Clear overflow flag */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #9CDCFE\">SysTick</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">CTRL</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #DCDCAA\">xTaskGetSchedulerState</span><span style=\"color: #D4D4D4\">() != taskSCHEDULER_NOT_STARTED) {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* Call tick handler */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">xPortSysTickHandler</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">//如果定义了 configSUPPORT_STATIC_ALLOCATION 为 1 ，那么就要多定义两个函数</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">vApplicationGetIdleTaskMemory</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #4EC9B0\">StaticTask_t</span><span style=\"color: #D4D4D4\"> **</span><span style=\"color: #9CDCFE\">ppxIdleTaskTCBBuffer</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #4EC9B0\">StackType_t</span><span style=\"color: #D4D4D4\"> **</span><span style=\"color: #9CDCFE\">ppxIdleTaskStackBuffer</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">uint32_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">pulIdleTaskStackSize</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">  /* Idle task control block and stack */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">StaticTask_t</span><span style=\"color: #D4D4D4\"> Idle_TCB;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">StackType_t</span><span style=\"color: #D4D4D4\">  </span><span style=\"color: #9CDCFE\">Idle_Stack</span><span style=\"color: #D4D4D4\">[configMINIMAL_STACK_SIZE];</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  *ppxIdleTaskTCBBuffer   = &amp;Idle_TCB;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  *ppxIdleTaskStackBuffer = &amp;</span><span style=\"color: #9CDCFE\">Idle_Stack</span><span style=\"color: #D4D4D4\">[</span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">];</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  *pulIdleTaskStackSize   = (</span><span style=\"color: #569CD6\">uint32_t</span><span style=\"color: #D4D4D4\">)configMINIMAL_STACK_SIZE;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">vApplicationGetTimerTaskMemory</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #4EC9B0\">StaticTask_t</span><span style=\"color: #D4D4D4\"> **</span><span style=\"color: #9CDCFE\">ppxTimerTaskTCBBuffer</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #4EC9B0\">StackType_t</span><span style=\"color: #D4D4D4\"> **</span><span style=\"color: #9CDCFE\">ppxTimerTaskStackBuffer</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">uint32_t</span><span style=\"color: #D4D4D4\"> *</span><span style=\"color: #9CDCFE\">pulTimerTaskStackSize</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">  /* Timer task control block and stack */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">StaticTask_t</span><span style=\"color: #D4D4D4\"> Timer_TCB;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">StackType_t</span><span style=\"color: #D4D4D4\">  </span><span style=\"color: #9CDCFE\">Timer_Stack</span><span style=\"color: #D4D4D4\">[configTIMER_TASK_STACK_DEPTH];</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  *ppxTimerTaskTCBBuffer   = &amp;Timer_TCB;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  *ppxTimerTaskStackBuffer = &amp;</span><span style=\"color: #9CDCFE\">Timer_Stack</span><span style=\"color: #D4D4D4\">[</span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">];</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  *pulTimerTaskStackSize   = (</span><span style=\"color: #569CD6\">uint32_t</span><span style=\"color: #D4D4D4\">)configTIMER_TASK_STACK_DEPTH;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><h2 id=\"简单的使用\"><a href=\"#简单的使用\" class=\"headerlink\" title=\"简单的使用\"></a>简单的使用</h2><p>那就先创建两个任务，一个任务每隔 1s 打印一次 “Hello World1!” ，另一个任务每隔 0.5s 打印一次 “Hello World2!” 。</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;FreeRTOS.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;rcc.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;sram.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;stdio.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;task.h&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C586C0\">#include</span><span style=\"color: #569CD6\"> </span><span style=\"color: #CE9178\">&lt;uart1.h&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">TaskHandle_t</span><span style=\"color: #D4D4D4\"> xTask1Handle;</span></span>\n<span class=\"line\"><span style=\"color: #4EC9B0\">TaskHandle_t</span><span style=\"color: #D4D4D4\"> xTask2Handle;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">test1Task</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #C586C0\">while</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"Hello World1!</span><span style=\"color: #D7BA7D\">\\r\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">vTaskDelay</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">1000</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">test2Task</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #C586C0\">while</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">printf</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #CE9178\">\"Hello World!2</span><span style=\"color: #D7BA7D\">\\r\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">vTaskDelay</span><span style=\"color: #D4D4D4\">(</span><span style=\"color: #B5CEA8\">500</span><span style=\"color: #D4D4D4\">);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">int</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">main</span><span style=\"color: #D4D4D4\">() {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">RCC_config</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">uart1_init</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">sram_init</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">xTaskCreate</span><span style=\"color: #D4D4D4\">(test1Task, </span><span style=\"color: #CE9178\">\"Task1\"</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #B5CEA8\">128</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">, &amp;xTask1Handle);</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">xTaskCreate</span><span style=\"color: #D4D4D4\">(test2Task, </span><span style=\"color: #CE9178\">\"Task2\"</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #B5CEA8\">128</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">, &amp;xTask2Handle);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #DCDCAA\">vTaskStartScheduler</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  </span><span style=\"color: #C586C0\">while</span><span style=\"color: #D4D4D4\"> (</span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">) {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* code */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">  }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>FreeRTOS 应用程序与非 RTOS 应用程序的启动和执行方式在调用 vTaskStartScheduler() 之前没什么不同，vTaskStartScheduler() 通常从应用程序的 main() 函数调用。RTOS 仅控制 调用 vTaskStartScheduler() 后的执行顺序。</p>\n<h1 id=\"部分源码分析\"><a href=\"#部分源码分析\" class=\"headerlink\" title=\"部分源码分析\"></a>部分源码分析</h1><h2 id=\"FreeRTOS-的任务管理\"><a href=\"#FreeRTOS-的任务管理\" class=\"headerlink\" title=\"FreeRTOS 的任务管理\"></a>FreeRTOS 的任务管理</h2><h3 id=\"任务的创建\"><a href=\"#任务的创建\" class=\"headerlink\" title=\"任务的创建\"></a>任务的创建</h3><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">xTaskCreate</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #4EC9B0\">TaskFunction_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pxTaskCode</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                        </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">char</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pcName</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                        </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> configSTACK_DEPTH_TYPE </span><span style=\"color: #9CDCFE\">uxStackDepth</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                        </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pvParameters</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                        </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">uxPriority</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                        </span><span style=\"color: #4EC9B0\">TaskHandle_t</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pxCreatedTask</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">TCB_t</span><span style=\"color: #D4D4D4\"> * pxNewTCB;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> xReturn;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    pxNewTCB = </span><span style=\"color: #DCDCAA\">prvCreateTask</span><span style=\"color: #D4D4D4\">( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( pxNewTCB != </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">prvAddNewTaskToReadyList</span><span style=\"color: #D4D4D4\">( pxNewTCB );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        xReturn = pdPASS;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> xReturn;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>每个 FreeRTOS 任务都需要一个 TCB 结构体来存储任务的状态信息，因此该函数首先调用 prvCreateTask 函数创建一个已经初始化好的 TCB 结构体。然后将任务添加到就绪列表中，最后返回 pdPASS 表示创建成功。</p>\n<p>其中，prvCreateTask 函数的实现如下：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">TCB_t</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #DCDCAA\">prvCreateTask</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #4EC9B0\">TaskFunction_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pxTaskCode</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                              </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">char</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pcName</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                              </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> configSTACK_DEPTH_TYPE </span><span style=\"color: #9CDCFE\">uxStackDepth</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                              </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pvParameters</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                              </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">uxPriority</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                              </span><span style=\"color: #4EC9B0\">TaskHandle_t</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">pxCreatedTask</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">TCB_t</span><span style=\"color: #D4D4D4\"> * pxNewTCB;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">StackType_t</span><span style=\"color: #D4D4D4\"> * pxStack;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    pxStack = </span><span style=\"color: #DCDCAA\">pvPortMallocStack</span><span style=\"color: #D4D4D4\">( ( ( ( </span><span style=\"color: #569CD6\">size_t</span><span style=\"color: #D4D4D4\"> ) uxStackDepth ) * </span><span style=\"color: #569CD6\">sizeof</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #4EC9B0\">StackType_t</span><span style=\"color: #D4D4D4\"> ) ) );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( pxStack != </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        pxNewTCB = ( </span><span style=\"color: #4EC9B0\">TCB_t</span><span style=\"color: #D4D4D4\"> * ) </span><span style=\"color: #DCDCAA\">pvPortMalloc</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #569CD6\">sizeof</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #4EC9B0\">TCB_t</span><span style=\"color: #D4D4D4\"> ) );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( pxNewTCB != </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            ( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #DCDCAA\">memset</span><span style=\"color: #D4D4D4\">( ( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> * ) pxNewTCB, </span><span style=\"color: #B5CEA8\">0x00</span><span style=\"color: #D4D4D4\">, </span><span style=\"color: #569CD6\">sizeof</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #4EC9B0\">TCB_t</span><span style=\"color: #D4D4D4\"> ) );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">pxNewTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">pxStack</span><span style=\"color: #D4D4D4\"> = pxStack;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">vPortFreeStack</span><span style=\"color: #D4D4D4\">( pxStack );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        pxNewTCB = </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( pxNewTCB != </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE </span><span style=\"color: #D4D4D4\">!=</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #569CD6\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">pxNewTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">ucStaticallyAllocated</span><span style=\"color: #D4D4D4\"> = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#endif</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">prvInitialiseNewTask</span><span style=\"color: #D4D4D4\">( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\"> );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> pxNewTCB;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>它分配了TCB结构体和栈空间，然后将栈空间的地址赋值给TCB的pxStack成员。最后调用了prvInitialiseNewTask 函数初始化了任务的各个成员。有意思的是，prvInitialiseNewTask 会调用 pxPortInitialiseStack 来构造的栈帧，使得新创建的任务能够以一种“自然”的方式启动，就好像它已经经历了一次上下文切换。</p>\n<p>那将任务添加到就绪列表中的 prvAddNewTaskToReadyList 又是如何实现的呢？</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">prvAddNewTaskToReadyList</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #4EC9B0\">TCB_t</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #9CDCFE\">pxNewTCB</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">taskENTER_CRITICAL</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        uxCurrentNumberOfTasks = ( </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> ) ( uxCurrentNumberOfTasks + </span><span style=\"color: #B5CEA8\">1U</span><span style=\"color: #D4D4D4\"> );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( pxCurrentTCB == </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            pxCurrentTCB = pxNewTCB;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( uxCurrentNumberOfTasks == ( </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #DCDCAA\">prvInitialiseTaskLists</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xSchedulerRunning == pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #9CDCFE\">pxCurrentTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">uxPriority</span><span style=\"color: #D4D4D4\"> &lt;= </span><span style=\"color: #9CDCFE\">pxNewTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">uxPriority</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    pxCurrentTCB = pxNewTCB;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        uxTaskNumber++;</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( configUSE_TRACE_FACILITY </span><span style=\"color: #D4D4D4\">==</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #569CD6\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #9CDCFE\">pxNewTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">uxTCBNumber</span><span style=\"color: #D4D4D4\"> = uxTaskNumber;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#endif</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">prvAddTaskToReadyList</span><span style=\"color: #D4D4D4\">( pxNewTCB );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">taskEXIT_CRITICAL</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xSchedulerRunning != pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">taskYIELD_ANY_CORE_IF_USING_PREEMPTION</span><span style=\"color: #D4D4D4\">( pxNewTCB );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>首先是调用 taskENTER_CRITICAL 进入临界区，然后将任务计数器 uxCurrentNumberOfTasks 加 1。如果是系统中创建的第一个任务，那么此时任务列表还没有初始化，此时要做的是设置当前任务，并初始化任务列表。如果不是第一个任务，且有任务正在运行，那么就要判断新任务的优先级是否高于当前任务，如果是的话，就要设置当前任务为新任务。</p>\n<p>再就是为新任务分配一个唯一的编号 uxTCBNumber（PID之类的东西）。</p>\n<p>然后调用 prvAddTaskToReadyList 函数将任务添加到就绪列表中，该函数会更新 uxTopReadyPriority 用于调度优化，并使用 listINSERT_END 函数将任务控制块 pxTCB 的列表项 xStateListItem 插入到 pxReadyTasksLists 数组中对应优先级索引的就绪列表的末尾。</p>\n<p>最后调用 taskEXIT_CRITICAL 退出临界区，如果调度器正在运行，那么调用 taskYIELD_ANY_CORE_IF_USING_PREEMPTION 函数，这个函数会根据当前的调度策略来决定是否进行任务切换。</p>\n<p>xTaskCreateStatic 函数和 xTaskCreate 的区别在于，前者需要用户提供任务控制块和栈空间，而后者会自动分配，源代码上的区别就是 pxNewTCB 和 pxStack 的分配的不同，其他一致。</p>\n<h3 id=\"任务的调度\"><a href=\"#任务的调度\" class=\"headerlink\" title=\"任务的调度\"></a>任务的调度</h3><p>开始调度的函数是 vTaskStartScheduler ，看看怎么个事？</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">vTaskStartScheduler</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> xReturn;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    xReturn = </span><span style=\"color: #DCDCAA\">prvCreateIdleTasks</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">    </span><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( configUSE_TIMERS </span><span style=\"color: #D4D4D4\">==</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #569CD6\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xReturn == pdPASS )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            xReturn = </span><span style=\"color: #DCDCAA\">xTimerCreateTimerTask</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">    </span><span style=\"color: #C586C0\">#endif</span><span style=\"color: #6A9955\"> /* configUSE_TIMERS */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xReturn == pdPASS )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">portDISABLE_INTERRUPTS</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        xNextTaskUnblockTime = portMAX_DELAY;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        xSchedulerRunning = pdTRUE;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        xTickCount = ( </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> ) configINITIAL_TICK_COUNT;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">portCONFIGURE_TIMER_FOR_RUN_TIME_STATS</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #DCDCAA\">xPortStartScheduler</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>首先调用 prvCreateIdleTasks 函数创建空闲任务，然后根据配置是否创建软件定时器任务。</p>\n<p>如果创建成功，就会调用 portDISABLE_INTERRUPTS 关闭中断，因为要保证在 xPortStartScheduler 调用完成之前，不发生时钟中断。为什么呢？xPortStartScheduler 到底做了什么以至于要关闭中断呢？稍后再说。</p>\n<p>接下来是设置一些全局变量，比如 xNextTaskUnblockTime（） 、 xSchedulerRunning 、 xTickCount ，然后调用 xPortStartScheduler 函数启动调度器，代码如下：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">xPortStartScheduler</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    portNVIC_SHPR2_REG = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">vPortSetupTimerInterrupt</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    uxCriticalNesting = </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">prvPortStartFirstTask</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* Should not get here! */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">vTaskSwitchContext</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">prvTaskExitError</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>xPortStartScheduler 首先将 PendSV 和 SysTick 的中断优先级设置为最低，SVCall 的优先级为最高，</p>\n<p>然后调用 vPortSetupTimerInterrupt 函数设置 SysTick 定时器的重装载值（根据configSYSTICK_CLOCK_HZ 和 configTICK_RATE_HZ 两个宏配置的值），清空当前计数器值，并使能 SysTick 定时器中断，开启定时器。</p>\n<p>重置临界区计数器 uxCriticalNesting 为 0 ，然后调用 prvPortStartFirstTask 函数，这个函数是一段内联汇编代码，用于启动第一个任务。</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">prvPortStartFirstTask</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    __asm </span><span style=\"color: #DCDCAA\">volatile</span><span style=\"color: #D4D4D4\"> (</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\" ldr r0, =0xE000ED08   </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 将 r0 设置为 NVIC 的向量表偏移寄存器地址 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\" ldr r0, [r0]          </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 读取向量表基地址 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\" ldr r0, [r0]          </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 读取向量表中的栈指针初始值（通常是主栈指针 MSP 的初始值） */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\" msr msp, r0           </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 将主栈指针（MSP）设置为初始值，为系统提供一个干净的栈环境 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\" cpsie i               </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 全局启用中断（清除 PRIMASK） */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\" cpsie f               </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 全局启用故障异常（清除 FAULTMASK） */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\" dsb                   </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 数据同步屏障，确保前面的指令完成 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\" isb                   </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 指令同步屏障，确保流水线刷新 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\" svc 0                 </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 触发 SVC（系统调用）异常，进入 vPortSVCHandler */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\" nop                   </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 占位符，无操作 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\" .ltorg                </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 确保文字池（literal pool）在此处生成 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>注意这里到将主栈指针（MSP）设置为初始值，意味着 FreeRTOS 调度器启动后， 只有 RTOS 任务和中断才有上下文，main() 的上下文将不复存在。出于此原因，绝对不要在 main() 使用的堆栈上分配 FreeRTOS 应用程序需要或能够以任何方式访问的变量或缓冲区， 因为它们很可能会被覆盖。</p>\n<p>在这里，将之前关闭的全局中断再次打开，最后自然是手动触发了一次SVC中断，进入中断服务函数 vPortSVCHandler</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">vPortSVCHandler</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    __asm </span><span style=\"color: #DCDCAA\">volatile</span><span style=\"color: #D4D4D4\"> (</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   ldr r3, =pxCurrentTCB           </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 将 r3 指向当前任务控制块（TCB）的指针 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   ldr r1, [r3]                    </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 获取 pxCurrentTCB 的地址 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   ldr r0, [r1]                    </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 获取任务栈顶地址（第一个 TCB 项是栈指针） */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   ldmia r0!, {r4-r11}             </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 从栈中弹出寄存器 r4-r11，并更新栈指针 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   msr psp, r0                     </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 将进程栈指针（PSP）设置为更新后的栈顶 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   isb                             </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 指令同步屏障 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   mov r0, #0                      </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 将 r0 清零 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   msr basepri, r0                 </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 清除 BASEPRI，允许所有优先级的中断 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   orr r14, #0xd                   </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 修改链接寄存器（LR），设置返回到 Thread 模式并使用 PSP */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   bx r14                          </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 通过 LR 返回，切换到任务执行 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"                                   </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   .ltorg                          </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 文字池 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>至此，第一个任务开始执行。</p>\n<p>那为什么要调用 portDISABLE_INTERRUPTS 关闭中断呢？还记得之前注册的 SysTick_Handler 函数吗？里面会调用 xTaskGetSchedulerState 函数判断任务调度器的状态，调度器启动完成之后，才能往下执行调用 xPortSysTickHandler 。</p>\n<p>关键在于这个 xPortSysTickHandler 函数会调用 xTaskIncrementTick 函数，这个函数不仅仅会增加系统时钟节拍，其返回值还决定了接下来 xPortSysTickHandler 是否要进行任务切换，代码如下：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">xPortSysTickHandler</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">portDISABLE_INTERRUPTS</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">xTaskIncrementTick</span><span style=\"color: #D4D4D4\">() != pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #6A9955\">//触发 PendSV 异常，进入 vPortSVCHandler</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">portENABLE_INTERRUPTS</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>试想如果不禁用中断，执行到 xSchedulerRunning = pdTRUE 这一行之后，来了一个 SysTick 中断（虽然 SysTick 中断是freeRTOS 负责配置的，但是万一用户提前配置的话。。。），此时，根据 xTaskGetSchedulerState 函数的实现，该分支的条件则会成立，调用 xPortSysTickHandler 函数，可是还有很多全局变量没有初始化呢，甚至连中断优先级都还没设置好，有可能 SysTick 的时间也不对，这样的话，xTaskIncrementTick 函数的返回值就不可预测了。</p>\n<p>那么平时任务是怎么切换的呢？ xTaskIncrementTick 为 pdTRUE 时，意味着任务切换的时机已经成熟，即可触发 PENDSV 中断，这里不妨再看一下 xPortSysTickHandler ：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">xPortPendSVHandler</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* This is a naked function. */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    __asm </span><span style=\"color: #569CD6\">volatile</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    (</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   mrs r0, psp                         </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 获取当前任务的进程栈指针（PSP） */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   isb                                 </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 指令同步屏障 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"                                       </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   ldr r3, =pxCurrentTCB               </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 将 r3 指向 pxCurrentTCB 的地址 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   ldr r2, [r3]                        </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 将 r2 设置为当前 TCB 的地址 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"                                       </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   stmdb r0!, {r4-r11}                 </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 保存 r4-r11 到当前任务栈 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   str r0, [r2]                        </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 更新 TCB 中的栈指针 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"                                       </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   stmdb sp!, {r3, r14}                </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 保存 r3 和 r14（LR）到主栈（MSP） */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   mov r0, </span><span style=\"color: #F44747\">%</span><span style=\"color: #CE9178\">0                          </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 将 r0 设置为 configMAX_SYSCALL_INTERRUPT_PRIORITY */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   msr basepri, r0                     </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 设置 BASEPRI，屏蔽低优先级中断 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   bl vTaskSwitchContext               </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 调用调度器切换任务 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   mov r0, #0                          </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 将 r0 清零 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   msr basepri, r0                     </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 清除 BASEPRI，重新启用所有中断 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   ldmia sp!, {r3, r14}                </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 从主栈恢复 r3 和 r14 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"                                       </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   ldr r1, [r3]                        </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 获取更新后的 pxCurrentTCB（新任务 TCB） */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   ldr r0, [r1]                        </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 获取新任务的栈顶地址 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   ldmia r0!, {r4-r11}                 </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 恢复新任务的 r4-r11 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   msr psp, r0                         </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 更新 PSP 为新任务的栈指针 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   isb                                 </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 指令同步屏障 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   bx r14                              </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 返回到新任务 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"                                       </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #CE9178\">\"   .ltorg                              </span><span style=\"color: #D7BA7D\">\\n</span><span style=\"color: #CE9178\">\"</span><span style=\"color: #6A9955\"> /* 文字池 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        ::</span><span style=\"color: #CE9178\">\"i\"</span><span style=\"color: #D4D4D4\"> ( configMAX_SYSCALL_INTERRUPT_PRIORITY )</span><span style=\"color: #6A9955\"> /* 输入参数 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>可以看到，PendSV 中断处理函数的核心是 vTaskSwitchContext 函数，看看这个函数做了什么：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">vTaskSwitchContext</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( uxSchedulerSuspended != ( </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0U</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">xYieldPendings</span><span style=\"color: #D4D4D4\">[ </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\"> ] = pdTRUE;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #9CDCFE\">xYieldPendings</span><span style=\"color: #D4D4D4\">[ </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\"> ] = pdFALSE;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #6A9955\">// taskSELECT_HIGHEST_PRIORITY_TASK();//宏展开如下：                                                                       </span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> uxTopPriority = uxTopReadyPriority;                                  </span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* Find the highest priority queue that contains ready tasks. */</span><span style=\"color: #D4D4D4\">                 </span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">while</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">listLIST_IS_EMPTY</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxReadyTasksLists</span><span style=\"color: #D4D4D4\">[ uxTopPriority ] ) ) != pdFALSE ) </span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">configASSERT</span><span style=\"color: #D4D4D4\">( uxTopPriority );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            --uxTopPriority;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        * the  same priority get an equal share of the processor time. */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">listGET_OWNER_OF_NEXT_ENTRY</span><span style=\"color: #D4D4D4\">( pxCurrentTCB, &amp;( </span><span style=\"color: #9CDCFE\">pxReadyTasksLists</span><span style=\"color: #D4D4D4\">[ uxTopPriority ] ) );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        uxTopReadyPriority = uxTopPriority;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>首先判断调度器的状态，如果是 Suspended ，那么就不会发生调度，pxCurrentTCB原路返回。</p>\n<p>这是处理器核心数只有 1 的时候的状态，此时 taskSELECT_HIGHEST_PRIORITY_TASK 展开就像上面这样，如果大于一个核心，该宏定义会指向函数 prvSelectHighestPriorityTask 。</p>\n<p>总而言之， taskSELECT_HIGHEST_PRIORITY_TASK 会选取下一个要调度的任务放入 pxCurrentTCB ，之后返回 xPortPendSVHandler 之后，就可以通过该变量获得现在要调度的任务的 TCB ，从而实现任务的切换调度。</p>\n<p>等等，最重要的一点， xTaskIncrementTick 是如何判断任务切换的时机是否成熟的呢？这边也看看吧。</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">xTaskIncrementTick</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">TCB_t</span><span style=\"color: #D4D4D4\"> * pxTCB;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> xItemValue;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> xSwitchRequired = pdFALSE;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* Tick 递增发生在每个内核定时器事件上。Core 0 负责递增 tick</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">     * 如果调度器被挂起，则递增挂起的 tick。如果挂起的 tick</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">     * 大于零，则调用 xTaskResumeAll 的核心负责递增 tick。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( uxSchedulerSuspended == ( </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0U</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 小优化。在此块中，tick 计数不能更改。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> xConstTickCount = xTickCount + ( </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 递增 RTOS tick，如果它回绕到 0，则切换延迟列表和溢出的延迟列表。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        xTickCount = xConstTickCount;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xConstTickCount == ( </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0U</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">taskSWITCH_DELAYED_LISTS</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 查看此 tick 是否已使超时到期。任务按照它们的唤醒时间顺序存储在队列中，</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">         * 这意味着一旦找到一个任务其阻塞时间尚未到期，则无需再往下查看列表。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xConstTickCount &gt;= xNextTaskUnblockTime )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #6A9955\">// 有任务需要解除阻塞</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\">( ; ; )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">listLIST_IS_EMPTY</span><span style=\"color: #D4D4D4\">( pxDelayedTaskList ) != pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                    /* 延迟列表为空。将 xNextTaskUnblockTime 设置为最大可能值，因此极不可能</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                     * 下次通过时 if( xTickCount &gt;= xNextTaskUnblockTime ) 测试会通过。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    xNextTaskUnblockTime = portMAX_DELAY;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #C586C0\">break</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                    /* 延迟列表不为空，获取延迟列表头部的 ItemValue ，</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                     * 这是必须从阻塞状态中移除的任务的时间 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    pxTCB = </span><span style=\"color: #DCDCAA\">listGET_OWNER_OF_HEAD_ENTRY</span><span style=\"color: #D4D4D4\">( pxDelayedTaskList );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    xItemValue = </span><span style=\"color: #DCDCAA\">listGET_LIST_ITEM_VALUE</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xStateListItem</span><span style=\"color: #D4D4D4\"> ) );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xConstTickCount &lt; xItemValue )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                        /* 现在还不是解除阻塞此任务的时候，但是 xItemValue 是必须将阻塞列表头部的任务</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                         * 从阻塞状态中移除的时间 - 因此记录项目值在 xNextTaskUnblockTime 中。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                        xNextTaskUnblockTime = xItemValue;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                        </span><span style=\"color: #C586C0\">break</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                    /* 是时候从阻塞状态中移除项目了。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #DCDCAA\">listREMOVE_ITEM</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xStateListItem</span><span style=\"color: #D4D4D4\"> ) );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                    /* 该任务是否也在等待事件？如果是，则将其从事件列表中删除。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">listLIST_ITEM_CONTAINER</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xEventListItem</span><span style=\"color: #D4D4D4\"> ) ) != </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                        </span><span style=\"color: #DCDCAA\">listREMOVE_ITEM</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xEventListItem</span><span style=\"color: #D4D4D4\"> ) );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                    /* 将解除阻塞的任务放入适当的就绪列表中。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #DCDCAA\">prvAddTaskToReadyList</span><span style=\"color: #D4D4D4\">( pxTCB );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                    /* 如果关闭了抢占，则解除阻塞的任务不能导致立刻的上下文切换。 */</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">                    </span><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( configUSE_PREEMPTION </span><span style=\"color: #D4D4D4\">==</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #569CD6\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                        /* 抢占已打开，但只有在解除阻塞的任务优先级高于当前正在执行的</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                          * 任务时，才应执行上下文切换。同等优先级任务共享</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                          * 处理时间（当抢占和时间片都打开时发生）的情况在下面处理。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">uxPriority</span><span style=\"color: #D4D4D4\"> &gt; </span><span style=\"color: #9CDCFE\">pxCurrentTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">uxPriority</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                            xSwitchRequired = pdTRUE;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">                    </span><span style=\"color: #C586C0\">#endif</span><span style=\"color: #6A9955\"> /* #if ( configUSE_PREEMPTION == 1 ) */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 如果时间片和抢占都打开，则检查是否有相同优先级的任务需要运行。 */</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( ( configUSE_PREEMPTION </span><span style=\"color: #D4D4D4\">==</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #569CD6\"> ) </span><span style=\"color: #D4D4D4\">&amp;&amp;</span><span style=\"color: #569CD6\"> ( configUSE_TIME_SLICING </span><span style=\"color: #D4D4D4\">==</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #569CD6\"> ) )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">listCURRENT_LIST_LENGTH</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxReadyTasksLists</span><span style=\"color: #D4D4D4\">[ </span><span style=\"color: #9CDCFE\">pxCurrentTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">uxPriority</span><span style=\"color: #D4D4D4\"> ] ) ) &gt; </span><span style=\"color: #B5CEA8\">1U</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                xSwitchRequired = pdTRUE;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#endif</span><span style=\"color: #6A9955\"> /* #if ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configUSE_TIME_SLICING == 1 ) ) */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( configUSE_PREEMPTION </span><span style=\"color: #D4D4D4\">==</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #569CD6\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {   </span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /*xYieldPendings 数组是 FreeRTOS SMP 内核中用于延迟任务 yield 请求的标志数组*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #9CDCFE\">xYieldPendings</span><span style=\"color: #D4D4D4\">[ </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\"> ] != pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                xSwitchRequired = pdTRUE;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#endif</span><span style=\"color: #6A9955\"> /* #if ( configUSE_PREEMPTION == 1 ) */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        xPendedTicks += </span><span style=\"color: #B5CEA8\">1U</span><span style=\"color: #D4D4D4\">;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">return</span><span style=\"color: #D4D4D4\"> xSwitchRequired;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>这个函数有几个难以理解的地方：比如说为什么在 RTOS tick 计数器回绕到 0 时，需要切换延迟列表和溢出延迟列表。</p>\n<p>想象一下，如果只有一个延迟列表，并且 tick 计数器即将回绕。此时，如果一个任务被设置为在 tick 计数器回绕后的一段时间后唤醒，那么它的唤醒时间值将会比那些在回绕之前设置唤醒时间的任务的值要小。这将导致调度器错误地认为回绕后设置唤醒时间的任务应该更早被唤醒。为了解决这个问题，FreeRTOS 使用了两个延迟列表，用于存放唤醒时间在当前 tick 计数周期内的任务，一个用于存放唤醒时间已经溢出到下一个 tick 计数周期的任务。</p>\n<p>除此之外，该函数还负责解除任务的阻塞。</p>\n<p>FreeRTOS 将所有因延时或等待事件而进入阻塞状态的任务，按照唤醒时间升序排列在一个列表中，也就是延时任务列表。这意味着列表中排在前面的任务，它们的唤醒时间总是早于或等于排在后面的任务。所以，遍历到一个任务的唤醒时间大于当前 tick 时，就可以停止遍历了，因为后面的任务的唤醒时间都大于当前 tick 。</p>\n<p>总而言之，当有任务因为时间片到期需要进行上下文切换时，或当有更高优先级的任务被解除阻塞时，会返回 pdTRUE ，来指示需要进行任务切换了。</p>\n<h3 id=\"任务的删除\"><a href=\"#任务的删除\" class=\"headerlink\" title=\"任务的删除\"></a>任务的删除</h3><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">vTaskDelete</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #4EC9B0\">TaskHandle_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">xTaskToDelete</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">TCB_t</span><span style=\"color: #D4D4D4\"> * pxTCB;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> xDeleteTCBInIdleTask = pdFALSE;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> xTaskIsRunningOrYielding;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">taskENTER_CRITICAL</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 如果传入的参数是NULL，则表示要删除的是当前正在调用的任务。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        pxTCB = </span><span style=\"color: #DCDCAA\">prvGetTCBFromHandle</span><span style=\"color: #D4D4D4\">( xTaskToDelete );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 将任务从就绪/延迟列表中移除。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">uxListRemove</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xStateListItem</span><span style=\"color: #D4D4D4\"> ) ) == ( </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">taskRESET_READY_PRIORITY</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">uxPriority</span><span style=\"color: #D4D4D4\"> );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 任务是否也在等待事件？*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">listLIST_ITEM_CONTAINER</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xEventListItem</span><span style=\"color: #D4D4D4\"> ) ) != </span><span style=\"color: #569CD6\">NULL</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            ( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #DCDCAA\">uxListRemove</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xEventListItem</span><span style=\"color: #D4D4D4\"> ) );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 递增 uxTaskNumber，供第三方追踪代码使用,对运行无太大意义 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        uxTaskNumber++;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 这个任务的状态是什么？*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        xTaskIsRunningOrYielding = </span><span style=\"color: #DCDCAA\">taskTASK_IS_RUNNING_OR_SCHEDULED_TO_YIELD</span><span style=\"color: #D4D4D4\">( pxTCB );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 如果任务正在运行（或即将让出），必须将其添加到终止列表中，以便空闲任务可以在其不再运行时将其删除。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( ( xSchedulerRunning != pdFALSE ) &amp;&amp; ( xTaskIsRunningOrYielding != pdFALSE ) )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /*  删除正在运行的任务或计划让出的任务。</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">             *  当任务仍在核心上运行时，这无法完成，因此需要上下文切换到另一个任务。</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">             *  将任务放入终止列表。 空闲任务将检查终止列表并释放由调度程序为已删除任务的 TCB 和堆栈分配的任何内存。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">vListInsertEnd</span><span style=\"color: #D4D4D4\">( &amp;xTasksWaitingTermination, &amp;( </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xStateListItem</span><span style=\"color: #D4D4D4\"> ) );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /* 递增 uxDeletedTasksWaitingCleanUp 变量，以便空闲任务知道有一个任务已被删除，</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">             * 空闲任务就会检查 xTasksWaitingTermination 列表。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            ++uxDeletedTasksWaitingCleanUp;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /* 在空闲任务中删除任务 TCB。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            xDeleteTCBInIdleTask = pdTRUE;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">else</span><span style=\"color: #6A9955\"> //任务不在运行</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            --uxCurrentNumberOfTasks;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /* 重置下一个预期的解除阻塞时间，以防它引用了刚刚删除的任务。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">prvResetNextTaskUnblockTime</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">taskEXIT_CRITICAL</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* 如果任务不是删除自身，则从临界区外调用 prvDeleteTCB。</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">     *  如果任务删除自身，则在空闲任务中由 prvCheckTasksWaitingTermination 调用 prvDeleteTCB */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xDeleteTCBInIdleTask != pdTRUE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">prvDeleteTCB</span><span style=\"color: #D4D4D4\">( pxTCB );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* 如果刚刚删除的是当前正在运行的任务，则强制重新调度。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xSchedulerRunning != pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( pxTCB == pxCurrentTCB )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #6A9955\">//所以，任务自己删除自己的时候，调度器一定要开启，否则会出问题</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">configASSERT</span><span style=\"color: #D4D4D4\">( uxSchedulerSuspended == </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\"> );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">taskYIELD_WITHIN_API</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>这个 API 用于删除一个任务，这是当处理器核心数量为 1 的时候的过程，如果大于 1 的话，情况会复杂一点。总之，实现上大体分为两种情况：自己删自己和删其他的任务。对于删其他任务的情况，直接从列表中移除，删除TCB即可。但是对于自己删自己的情况，需要将任务添加到终止列表中，等待空闲任务来删除。空闲任务做了什么呢？</p>\n<p>首先，空闲任务在 vTaskStartScheduler 函数中被创建，它的任务函数是 prvIdleTask ，这个函数会一直循环，等待终止列表中有任务，然后释放任务的 TCB 和栈空间，看看代码：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">portTASK_FUNCTION</span><span style=\"color: #D4D4D4\">( prvIdleTask, pvParameters )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* Stop warnings. */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    ( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> ) pvParameters;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* 如果具有安全上下文的任务删除自身，在这种情况下，空闲任务负责删除任务的安全上下文（如果有）。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #DCDCAA\">portALLOCATE_SECURE_CONTEXT</span><span style=\"color: #D4D4D4\">( configMINIMAL_SECURE_STACK_SIZE );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">for</span><span style=\"color: #D4D4D4\">( ; ; )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 检查是否有任务删除了自己 - 如果有，则空闲任务负责释放已删除任务的 TCB 和堆栈。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">prvCheckTasksWaitingTermination</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( configUSE_PREEMPTION </span><span style=\"color: #D4D4D4\">==</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #569CD6\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /* 如果没有使用抢占，那就不断强制进行任务切换，以查看是否有任何其他任务可用。</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">             * 如果使用抢占，则不需要这样做，因为任何变得可用的任务都会自动获得处理器。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">taskYIELD</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#endif</span><span style=\"color: #6A9955\"> /* configUSE_PREEMPTION */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( ( configUSE_PREEMPTION </span><span style=\"color: #D4D4D4\">==</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #569CD6\"> ) </span><span style=\"color: #D4D4D4\">&amp;&amp;</span><span style=\"color: #569CD6\"> ( configIDLE_SHOULD_YIELD </span><span style=\"color: #D4D4D4\">==</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #569CD6\"> ) )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /* 当使用抢占时，具有相同优先级的任务将被时间分片。</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">             * 如果一个与空闲优先级共享的任务准备好运行，那么空闲任务应该在时间片结束之前让出。</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">             *</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">             * 这里不需要临界区，因为只是从列表中读取，偶尔出现不正确的值无关紧要。</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">             * 如果空闲优先级的就绪列表包含的任务数量比空闲任务数量（等于配置的内核数量）多一个，</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">             * 那么除了空闲任务之外的任务已准备好执行。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">listCURRENT_LIST_LENGTH</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxReadyTasksLists</span><span style=\"color: #D4D4D4\">[ tskIDLE_PRIORITY ] ) ) &gt; ( </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> ) configNUMBER_OF_CORES )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #DCDCAA\">taskYIELD</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#endif</span><span style=\"color: #6A9955\"> /* ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configIDLE_SHOULD_YIELD == 1 ) ) */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 当用户定义的低功耗模式实现需要将 configUSE_TICKLESS_IDLE 设置为 0 以外的值时，</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">         * 调用 portSUPPRESS_TICKS_AND_SLEEP()。*/</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( configUSE_TICKLESS_IDLE </span><span style=\"color: #D4D4D4\">!=</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #569CD6\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> xExpectedIdleTime;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /* 不希望在空闲任务的每次迭代中都挂起然后恢复调度程序。</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">             * 因此，在没有调度程序挂起的情况下执行预期空闲时间的初步测试。</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">             * 此处的结果不一定有效。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            xExpectedIdleTime = </span><span style=\"color: #DCDCAA\">prvGetExpectedIdleTime</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xExpectedIdleTime &gt;= ( </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> ) configEXPECTED_IDLE_TIME_BEFORE_SLEEP )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #DCDCAA\">vTaskSuspendAll</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                    /* 现在调度程序已挂起，可以再次采样预期的空闲时间，这次可以使用它的值。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #DCDCAA\">configASSERT</span><span style=\"color: #D4D4D4\">( xNextTaskUnblockTime &gt;= xTickCount );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    xExpectedIdleTime = </span><span style=\"color: #DCDCAA\">prvGetExpectedIdleTime</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                    /* 定义以下宏，如果应用程序不希望调用 portSUPPRESS_TICKS_AND_SLEEP()，</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">                     * 则将 xExpectedIdleTime 设置为 0。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #DCDCAA\">configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING</span><span style=\"color: #D4D4D4\">( xExpectedIdleTime );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xExpectedIdleTime &gt;= ( </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> ) configEXPECTED_IDLE_TIME_BEFORE_SLEEP )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                        </span><span style=\"color: #DCDCAA\">portSUPPRESS_TICKS_AND_SLEEP</span><span style=\"color: #D4D4D4\">( xExpectedIdleTime );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                ( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #DCDCAA\">xTaskResumeAll</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">        </span><span style=\"color: #C586C0\">#endif</span><span style=\"color: #6A9955\"> /* configUSE_TICKLESS_IDLE */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">prvCheckTasksWaitingTermination</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">    </span><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( INCLUDE_vTaskDelete </span><span style=\"color: #D4D4D4\">==</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #569CD6\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #4EC9B0\">TCB_t</span><span style=\"color: #D4D4D4\"> * pxTCB;</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* uxDeletedTasksWaitingCleanUp 用于防止在空闲任务中过于频繁地调用 taskENTER_CRITICAL()。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">while</span><span style=\"color: #D4D4D4\">( uxDeletedTasksWaitingCleanUp &gt; ( </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0U</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">            </span><span style=\"color: #C586C0\">#if</span><span style=\"color: #569CD6\"> ( configNUMBER_OF_CORES </span><span style=\"color: #D4D4D4\">==</span><span style=\"color: #569CD6\"> </span><span style=\"color: #B5CEA8\">1</span><span style=\"color: #569CD6\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #DCDCAA\">taskENTER_CRITICAL</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    pxTCB = </span><span style=\"color: #DCDCAA\">listGET_OWNER_OF_HEAD_ENTRY</span><span style=\"color: #D4D4D4\">( ( &amp;xTasksWaitingTermination ) );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    ( </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #DCDCAA\">uxListRemove</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xStateListItem</span><span style=\"color: #D4D4D4\"> ) );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    --uxCurrentNumberOfTasks;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                    --uxDeletedTasksWaitingCleanUp;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #DCDCAA\">taskEXIT_CRITICAL</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                </span><span style=\"color: #DCDCAA\">prvDeleteTCB</span><span style=\"color: #D4D4D4\">( pxTCB );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #569CD6\">    </span><span style=\"color: #C586C0\">#endif</span><span style=\"color: #6A9955\"> /* INCLUDE_vTaskDelete */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>可以看到，空闲任务会不断调用 prvCheckTasksWaitingTermination 来检查是否有任务被删除，如果有，就释放任务的 TCB 和栈空间。除此之外，还根据用户的配置来决定是否进行任务切换，以及是否进入低功耗模式。</p>\n<p>prvCheckTasksWaitingTermination 函数是通过检查在 vTaskDelete 中修改的变量 uxDeletedTasksWaitingCleanUp 来判断是否有任务被删除。</p>\n<h3 id=\"任务的延时\"><a href=\"#任务的延时\" class=\"headerlink\" title=\"任务的延时\"></a>任务的延时</h3><div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">vTaskDelay</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">xTicksToDelay</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* 记录任务是否已经让出 CPU 控制权（yield）。初始值为 pdFALSE，表示未让出 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> xAlreadyYielded = pdFALSE;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* 如果延时时间为 0，则只进行任务调度（强制上下文切换），不进行实际延时 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xTicksToDelay &gt; ( </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0U</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">vTaskSuspendAll</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">configASSERT</span><span style=\"color: #D4D4D4\">( uxSchedulerSuspended == </span><span style=\"color: #B5CEA8\">1U</span><span style=\"color: #D4D4D4\"> );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /* 当调度器被挂起时，从事件列表中移除的任务将不会被放入就绪列表</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">             * 或从阻塞列表中移除，直到调度器恢复。</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">             * 此任务不能在事件列表中，因为它是当前正在执行的任务。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">prvAddCurrentTaskToDelayedList</span><span style=\"color: #D4D4D4\">( xTicksToDelay, pdFALSE );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* xTaskResumeAll() 函数在恢复任务时，如果因为存在高优先级任务就绪</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">         * 或处理挂起节拍在函数内部立即触发了任务切换，那么它会返回 pdTRUE。*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        xAlreadyYielded = </span><span style=\"color: #DCDCAA\">xTaskResumeAll</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* 如果 xTaskResumeAll 还没有强制重新调度，则强制重新调度，可能已经让自己进入睡眠状态。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xAlreadyYielded == pdFALSE )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">taskYIELD_WITHIN_API</span><span style=\"color: #D4D4D4\">();</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p>vTaskDelay 函数用于将任务延时一段时间，这个函数会将任务添加到延迟任务列表中，然后在 xTaskResumeAll 或 taskYIELD_WITHIN_API 这两个地方触发任务切换。另一个函数 xTaskDelayUntil 也是差不多的原理。</p>\n<p>看看 prvAddCurrentTaskToDelayedList 函数做了什么，到底是如何将任务添加到延迟任务列表中的，之前提到的 延迟列表 和 溢出延迟列表 在这里是如何处理的呢？</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki dark-plus\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #569CD6\">static</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #569CD6\">void</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #DCDCAA\">prvAddCurrentTaskToDelayedList</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">xTicksToWait</span><span style=\"color: #D4D4D4\">,</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                                            </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">BaseType_t</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #9CDCFE\">xCanBlockIndefinitely</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">{</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> xTimeToWake;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> </span><span style=\"color: #4EC9B0\">TickType_t</span><span style=\"color: #D4D4D4\"> xConstTickCount = xTickCount;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">List_t</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> pxDelayedList = pxDelayedTaskList;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #4EC9B0\">List_t</span><span style=\"color: #D4D4D4\"> * </span><span style=\"color: #569CD6\">const</span><span style=\"color: #D4D4D4\"> pxOverflowDelayedList = pxOverflowDelayedTaskList;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">    /* 从列表中移除当前任务（一定在列表中）。  */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #DCDCAA\">uxListRemove</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxCurrentTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xStateListItem</span><span style=\"color: #D4D4D4\"> ) ) == ( </span><span style=\"color: #4EC9B0\">UBaseType_t</span><span style=\"color: #D4D4D4\"> ) </span><span style=\"color: #B5CEA8\">0</span><span style=\"color: #D4D4D4\"> )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /*如果 configUSE_PORT_OPTIMISED_TASK_SELECTION 为 1 才生效，是对调度的一个优化 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">portRESET_READY_PRIORITY</span><span style=\"color: #D4D4D4\">( </span><span style=\"color: #9CDCFE\">pxCurrentTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">uxPriority</span><span style=\"color: #D4D4D4\">, uxTopReadyPriority );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( ( xTicksToWait == portMAX_DELAY ) &amp;&amp; ( xCanBlockIndefinitely != pdFALSE ) )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 如果要等待的时间是最大延迟时间，并且可以无限期阻塞，将任务添加到挂起任务列表</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">          * 而不是延迟任务列表，以确保它不会被定时事件唤醒。它将无限期地阻塞。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">listINSERT_END</span><span style=\"color: #D4D4D4\">( &amp;xSuspendedTaskList, &amp;( </span><span style=\"color: #9CDCFE\">pxCurrentTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xStateListItem</span><span style=\"color: #D4D4D4\"> ) );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">        /* 列表项将按唤醒时间顺序插入。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        xTimeToWake = xConstTickCount + xTicksToWait;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #DCDCAA\">listSET_LIST_ITEM_VALUE</span><span style=\"color: #D4D4D4\">( &amp;( </span><span style=\"color: #9CDCFE\">pxCurrentTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xStateListItem</span><span style=\"color: #D4D4D4\"> ), xTimeToWake );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xTimeToWake &lt; xConstTickCount )</span><span style=\"color: #6A9955\">/* 如果唤醒时间溢出。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">vListInsert</span><span style=\"color: #D4D4D4\">( pxOverflowDelayedList, &amp;( </span><span style=\"color: #9CDCFE\">pxCurrentTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xStateListItem</span><span style=\"color: #D4D4D4\"> ) );</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        </span><span style=\"color: #C586C0\">else</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        {</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /* 唤醒时间没有溢出*/</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #DCDCAA\">vListInsert</span><span style=\"color: #D4D4D4\">( pxDelayedList, &amp;( </span><span style=\"color: #9CDCFE\">pxCurrentTCB</span><span style=\"color: #D4D4D4\">-&gt;</span><span style=\"color: #9CDCFE\">xStateListItem</span><span style=\"color: #D4D4D4\"> ) );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A9955\">            /* 如果进入阻塞状态的任务被放置在阻塞任务列表的头部，</span></span>\n<span class=\"line\"><span style=\"color: #6A9955\">              * 则 xNextTaskUnblockTime 也需要更新。 */</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">            </span><span style=\"color: #C586C0\">if</span><span style=\"color: #D4D4D4\">( xTimeToWake &lt; xNextTaskUnblockTime )</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">                xNextTaskUnblockTime = xTimeToWake;</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">        }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">    }</span></span>\n<span class=\"line\"><span style=\"color: #D4D4D4\">}</span></span></code></pre></div><p><code>xTimeToWake = xConstTickCount + xTicksToWait;</code> 这一行的加法，可能会导致溢出，因此分为两种情况处理。</p>\n<p>此外，如果要等待的时间是最大延迟时间，则变成挂起状态。</p>\n","feature":true,"text":"如何移植FreeRTOS到开发版上FreeRTOS的目录结构txt. └── FreeRTOS └── Source # FreeRTOS源码 ├── CMSI...","permalink":"/post/FreeRTOS源码学习","photos":[],"count_time":{"symbolsCount":"30k","symbolsTime":"27 mins."},"categories":[{"name":"C++","slug":"C","count":6,"path":"api/categories/C.json"},{"name":"操作系统","slug":"C/操作系统","count":1,"path":"api/categories/C/操作系统.json"},{"name":"嵌入式","slug":"C/操作系统/嵌入式","count":1,"path":"api/categories/C/操作系统/嵌入式.json"}],"tags":[{"name":"freeRTOS","slug":"freeRTOS","count":1,"path":"api/tags/freeRTOS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E7%A7%BB%E6%A4%8DFreeRTOS%E5%88%B0%E5%BC%80%E5%8F%91%E7%89%88%E4%B8%8A\"><span class=\"toc-text\">如何移植FreeRTOS到开发版上</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#FreeRTOS%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">FreeRTOS的目录结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A7%BB%E6%A4%8D\"><span class=\"toc-text\">移植</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">简单的使用</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\"><span class=\"toc-text\">部分源码分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#FreeRTOS-%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">FreeRTOS 的任务管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">任务的创建</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">任务的调度</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">任务的删除</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%BB%B6%E6%97%B6\"><span class=\"toc-text\">任务的延时</span></a></li></ol></li></ol></li></ol>","author":{"name":"Ac-Accelerator","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一位计算机技术爱好者，大学在读，目前正在学习C++、Python、Java和计算机系统以及计算机视觉深度学习等相关知识，欢迎交流","socials":{"github":"https://github.com/Ac-Accelerator","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_31702515?spm=1000.2115.3001.5343","juejin":"","customs":{"qq":{"icon":"/svg/QQ.svg","link":"http://tool.gljlw.com/qq/?qq=2583832841"}}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"函数钩子原理初探","uid":"d7e80eeb35c73d4ee8de7a24a876423f","slug":"函数钩子原理初探","date":"2025-02-25T02:01:00.000Z","updated":"2025-02-25T02:50:23.947Z","comments":true,"path":"api/articles/函数钩子原理初探.json","keywords":"C++,Pyhton,Java,算法","cover":"img/函数钩子.png","text":"什么是函数钩子在Windows操作系统中，似乎可以通过一些方法，将某个进程的函数调用替换掉，从而实现破解或者内容修改等功能。这种技术就是函数钩子。在Linux中...","permalink":"/post/函数钩子原理初探","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"C++","slug":"C","count":6,"path":"api/categories/C.json"}],"tags":[{"name":"函数钩子","slug":"函数钩子","count":1,"path":"api/tags/函数钩子.json"}],"author":{"name":"Ac-Accelerator","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一位计算机技术爱好者，大学在读，目前正在学习C++、Python、Java和计算机系统以及计算机视觉深度学习等相关知识，欢迎交流","socials":{"github":"https://github.com/Ac-Accelerator","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_31702515?spm=1000.2115.3001.5343","juejin":"","customs":{"qq":{"icon":"/svg/QQ.svg","link":"http://tool.gljlw.com/qq/?qq=2583832841"}}}},"feature":true}}