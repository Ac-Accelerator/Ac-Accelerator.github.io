{"title":"8086微机汇编语言","uid":"59fff721b35c430dcc2003c20536d30b","slug":"8086微机汇编语言","date":"2023-04-16T10:25:35.000Z","updated":"2023-06-06T06:53:13.516Z","comments":true,"path":"api/articles/8086微机汇编语言.json","keywords":"C++,Pyhton,Java,算法","cover":"/img/huibian.jpeg","content":"<p>在学校学习了汇编语言一课程，但是由于汇编指令繁多，而且在互联网上没有找到满足我要求的资料。同时书上的知识也比较分散，不好索引。所以我打算自己整理一份资料，方便自己以后查阅。同时也希望能帮助到其他人。</p>\n<h2 id=\"寄存器分类\"><a href=\"#寄存器分类\" class=\"headerlink\" title=\"寄存器分类\"></a>寄存器分类</h2><h3 id=\"通用寄存器\"><a href=\"#通用寄存器\" class=\"headerlink\" title=\"通用寄存器\"></a>通用寄存器</h3><table>\n<thead>\n<tr>\n<th>寄存器符号</th>\n<th>全称</th>\n<th></th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AX</td>\n<td>Accumulator</td>\n<td>累加寄存器</td>\n<td>通用寄存器，主要作为累加器使用，是算数运算的主要寄存器</td>\n</tr>\n<tr>\n<td>BX</td>\n<td>Base</td>\n<td>基址寄存器</td>\n<td>通用寄存器，一般用于存放基址</td>\n</tr>\n<tr>\n<td>CX</td>\n<td>Count</td>\n<td>计数寄存器</td>\n<td>通用寄存器，一般用于存放循环次数的寄存器</td>\n</tr>\n<tr>\n<td>DX</td>\n<td>Data</td>\n<td>数据寄存器</td>\n<td>通用寄存器，一般用于存储数据，在双精度算术运算中，和AX配合使用存放双字操作数，DX是高位寄存器，AX是低位寄存器</td>\n</tr>\n</tbody></table>\n<h3 id=\"地址寄存器\"><a href=\"#地址寄存器\" class=\"headerlink\" title=\"地址寄存器\"></a>地址寄存器</h3><table>\n<thead>\n<tr>\n<th>寄存器符号</th>\n<th>全称</th>\n<th></th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SI</td>\n<td>Source Index</td>\n<td>源变址寄存器</td>\n<td>可作为源变址寄存器使用，是存放源变址的寄存器</td>\n</tr>\n<tr>\n<td>DI</td>\n<td>Destination Index</td>\n<td>目的变址寄存器</td>\n<td>可用于存放目的缓冲区的偏移地址</td>\n</tr>\n<tr>\n<td>SP</td>\n<td>Stack Pointer</td>\n<td>堆栈指针寄存器</td>\n<td>用于指出堆栈顶端的偏移地址</td>\n</tr>\n<tr>\n<td>BP</td>\n<td>Base Pointer</td>\n<td>基址指针寄存器</td>\n<td>用于指出堆栈区某个单元的偏移地址</td>\n</tr>\n</tbody></table>\n<h3 id=\"段寄存器\"><a href=\"#段寄存器\" class=\"headerlink\" title=\"段寄存器\"></a>段寄存器</h3><table>\n<thead>\n<tr>\n<th>寄存器符号</th>\n<th>全称</th>\n<th></th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CS</td>\n<td>Code Segment</td>\n<td>代码段寄存器</td>\n<td>用于指出代码段的偏移地址</td>\n</tr>\n<tr>\n<td>DS</td>\n<td>Data Segment</td>\n<td>数据段寄存器</td>\n<td>用于指出数据段的偏移地址</td>\n</tr>\n<tr>\n<td>SS</td>\n<td>Stack Segment</td>\n<td>堆栈段寄存器</td>\n<td>用于指出堆栈段的偏移地址</td>\n</tr>\n<tr>\n<td>ES</td>\n<td>Extra Segment</td>\n<td>附加段寄存器</td>\n<td>用于指出附加段的偏移地址</td>\n</tr>\n</tbody></table>\n<h3 id=\"控制寄存器\"><a href=\"#控制寄存器\" class=\"headerlink\" title=\"控制寄存器\"></a>控制寄存器</h3><table>\n<thead>\n<tr>\n<th>寄存器符号</th>\n<th>全称</th>\n<th></th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>IP</td>\n<td>Instruction Pointer</td>\n<td>指令指针寄存器</td>\n<td>用于指出下一条指令的偏移地址</td>\n</tr>\n<tr>\n<td>FLAGS</td>\n<td>FLAGS</td>\n<td>标志寄存器</td>\n<td>用于存放各种标志位</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>标志码</th>\n<th>标志</th>\n<th>含义</th>\n<th>条件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CF</td>\n<td>Carry Flag</td>\n<td>进位标志</td>\n<td>当指令的执行结果的最高位向前进位时，CF=1，否则CF=0</td>\n</tr>\n<tr>\n<td>SF</td>\n<td>Sign Flag</td>\n<td>符号标志</td>\n<td>当指令的执行结果的最高位（符号位）为负数时，SF=1，否则SF=0</td>\n</tr>\n<tr>\n<td>ZF</td>\n<td>Zero Flag</td>\n<td>零标志</td>\n<td>当指令的执行结果为0时，ZF=1，否则ZF=0</td>\n</tr>\n<tr>\n<td>OF</td>\n<td>Overflow Flag</td>\n<td>溢出标志</td>\n<td>当指令的执行结果有溢出时（超出了表示的范围），OF=1，否则OF=0</td>\n</tr>\n<tr>\n<td>DF</td>\n<td>Direction Flag</td>\n<td>方向标志</td>\n<td>执行串操作时，若设置DF=1，储存单元地址自动减小，若设置DF=0时，储存单元地址自动增大</td>\n</tr>\n<tr>\n<td>IF</td>\n<td>Interrupt Flag</td>\n<td>中断标志</td>\n<td>IF=1时，允许CPU响应可屏蔽中断，IF=0时，禁止CPU响应中断请求</td>\n</tr>\n<tr>\n<td>PF</td>\n<td>Parity Flag</td>\n<td>奇偶标志</td>\n<td>当指令的执行结果的二进制数中1的个数为偶数时，PF=1，否则PF=0</td>\n</tr>\n<tr>\n<td>TF</td>\n<td>Trap Flag</td>\n<td>陷阱标志</td>\n<td>Debug时，若设置TF=1，执行单步调试指令，进入陷阱，TF=0时，正常执行指令</td>\n</tr>\n<tr>\n<td>AF</td>\n<td>Auxiliary Carry Flag</td>\n<td>辅助进位标志</td>\n<td>当指令的执行结果的第三位（半字节）向前进位时，AF=1，否则AF=0</td>\n</tr>\n</tbody></table>\n<p>8086标志位缩写形式</p>\n<table>\n<thead>\n<tr>\n<th>标志名称</th>\n<th>标志</th>\n<th>值为1</th>\n<th>值为0</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>进位标志</td>\n<td>CF</td>\n<td>CY</td>\n<td>NC</td>\n</tr>\n<tr>\n<td>符号标志</td>\n<td>SF</td>\n<td>NG</td>\n<td>PL</td>\n</tr>\n<tr>\n<td>零标志</td>\n<td>ZF</td>\n<td>ZR</td>\n<td>NZ</td>\n</tr>\n<tr>\n<td>溢出标志</td>\n<td>OF</td>\n<td>OV</td>\n<td>NV</td>\n</tr>\n<tr>\n<td>方向标志</td>\n<td>DF</td>\n<td>DN</td>\n<td>UP</td>\n</tr>\n<tr>\n<td>中断标志</td>\n<td>IF</td>\n<td>EI</td>\n<td>DI</td>\n</tr>\n<tr>\n<td>奇偶标志</td>\n<td>PF</td>\n<td>PE</td>\n<td>PO</td>\n</tr>\n<tr>\n<td>辅助进位标志</td>\n<td>AF</td>\n<td>AC</td>\n<td>NA</td>\n</tr>\n</tbody></table>\n<h2 id=\"指令分类\"><a href=\"#指令分类\" class=\"headerlink\" title=\"指令分类\"></a>指令分类</h2><h3 id=\"DOS功能调用\"><a href=\"#DOS功能调用\" class=\"headerlink\" title=\"DOS功能调用\"></a>DOS功能调用</h3><p>DOS功能调用采用中断指令INT 21H，功能号存放在AH寄存器，在其他的寄存器和存储单元中提供必须得参数和缓冲区地址，执行后系统在AL中放入返回参数。通常的DOS功能有5个：</p>\n<table>\n<thead>\n<tr>\n<th>功能号</th>\n<th>功能</th>\n<th>说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1H</td>\n<td>键盘输入一个字符</td>\n<td>将键盘输入的字符放入AL中</td>\n<td>MOV AH,1H<br>INT 21H</td>\n</tr>\n<tr>\n<td>8H</td>\n<td>键盘输入但不显示</td>\n<td>将键盘输入的字符放入AL中，不反映到在屏幕上</td>\n<td>MOV AH,8H<br>INT 21H</td>\n</tr>\n<tr>\n<td>2H</td>\n<td>显示一个字符</td>\n<td>将DL中的字符显示在屏幕上，并且将AL的值改为DL的值</td>\n<td>MOV AH,2H<br>INT 21H</td>\n</tr>\n<tr>\n<td>5H</td>\n<td>打印输出一个字符</td>\n<td>将DL中的字符发送到打印机，并且将AL的值改为DL的值</td>\n<td>MOV AH,5H<br>INT 21H</td>\n</tr>\n<tr>\n<td>9H</td>\n<td>显示字符串</td>\n<td>将DS:DX中的字符串显示在屏幕上，AL的值被修改为24H</td>\n<td>MOV AH,9H<br>LEA DX,STR<br>INT 21H</td>\n</tr>\n<tr>\n<td>0AH</td>\n<td>键盘输入一个字符串</td>\n<td>将键盘输入的字符串放入DS:DX中</td>\n<td>MOV AH,0AH<br>LEA DX,BUFF<br>INT 21H</td>\n</tr>\n<tr>\n<td>4CH</td>\n<td>结束程序</td>\n<td>结束程序</td>\n<td>MOV AH,4CH<br>INT 21H</td>\n</tr>\n</tbody></table>\n<h3 id=\"数据传送指令\"><a href=\"#数据传送指令\" class=\"headerlink\" title=\"数据传送指令\"></a>数据传送指令</h3><table>\n<thead>\n<tr>\n<th>指令</th>\n<th>格式</th>\n<th>作用</th>\n<th>说明</th>\n<th>举例</th>\n<th>注意</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>传输指令</td>\n<td>MOV DST,SRC</td>\n<td>(DST)←(SRC)</td>\n<td>将源操作数转移到目的操作数</td>\n<td>MOV AX, BX</td>\n<td>1.操作数类型要匹配<br>2.目的操作数不能是立即数<br>3.两个操作数不能同时是储存单元<br>4.目的操作数属性要确定<br>5.CS段寄存器不能作为目的操作数<br>6.段寄存器不能用立即数赋值</td>\n</tr>\n<tr>\n<td>数据交换指令</td>\n<td>XCHG OPR1,OPR2</td>\n<td>(OPR1)↔(OPR2)</td>\n<td>将两个操作数互换</td>\n<td>XCHG AX, BX</td>\n<td>1.操作数类型要匹配<br>2.两个操作数必须有一个是寄存器<br>3.操作数不能是立即数</td>\n</tr>\n<tr>\n<td>进栈指令</td>\n<td>PUSH SRC</td>\n<td>((SP+1),(SP))←(SRC)</td>\n<td>先将堆栈指针减2，再将操作数SRC入栈</td>\n<td>PUSH AX</td>\n<td>SRC必须是字</td>\n</tr>\n<tr>\n<td>出栈指令</td>\n<td>POP DST</td>\n<td>(DST)←((SP+1),(SP))</td>\n<td>将栈顶指针所指向的字单元的内容弹出到操作数DST中，再将SP加2</td>\n<td>POP AX</td>\n<td></td>\n</tr>\n<tr>\n<td>查表转换指令</td>\n<td>XLAT</td>\n<td>AL←(DS:BX+AL)</td>\n<td>将DS:BX+AL的内容送入AL,即把AL中位移量换成对应内容</td>\n<td>XLAT</td>\n<td></td>\n</tr>\n<tr>\n<td>有效地址传送指令</td>\n<td>LEA 寄存器,储存单元</td>\n<td>寄存器←储存单元</td>\n<td>将储存单元的有效地址传送给寄存器</td>\n<td>LEA BX TABLE</td>\n<td></td>\n</tr>\n<tr>\n<td>数据段地址传送指令</td>\n<td>LDS 寄存器,双字储存单元</td>\n<td>DS:寄存器←储存单元</td>\n<td>将双字单元的低字送入寄存器，高字传送给DS数据段寄存器</td>\n<td>LDS BX TABLE</td>\n<td></td>\n</tr>\n<tr>\n<td>附加段地址传送指令</td>\n<td>LES 寄存器,双字储存单元</td>\n<td>ES:寄存器←储存单元有效地址</td>\n<td>将双字单元的低字送入寄存器，高字传送给ES附加段寄存器</td>\n<td>LES BX TABLE</td>\n<td></td>\n</tr>\n<tr>\n<td>字节拓展为字指令</td>\n<td>CBW</td>\n<td>AX←sign-extend(AL)</td>\n<td>将AL拓展到AX。如果AL的符号位为0，则AH为0，如果AL的符号位为1，则AH为FFH</td>\n<td>CBW</td>\n<td></td>\n</tr>\n<tr>\n<td>字拓展为双字指令</td>\n<td>CWD</td>\n<td>DX:AX←sign-extend(AX)</td>\n<td>将AX拓展到DX。如果AX的符号位为0，则DX为0，如果AX的符号位为1，则DX为FFFFH</td>\n<td>CWD</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"算术运算指令\"><a href=\"#算术运算指令\" class=\"headerlink\" title=\"算术运算指令\"></a>算术运算指令</h3><table>\n<thead>\n<tr>\n<th>指令</th>\n<th>格式</th>\n<th>作用</th>\n<th>说明</th>\n<th>举例</th>\n<th>注意</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>加法指令</td>\n<td>ADD DST,SRC</td>\n<td>(DST)←(DST)+(SRC)</td>\n<td>SRC和DST相加，结果放入DST</td>\n<td>ADD AX, BX</td>\n<td></td>\n</tr>\n<tr>\n<td>带进位加法指令</td>\n<td>ADC DST,SRC</td>\n<td>(DST)←(DST)+(SRC)+CF</td>\n<td>将SRC加到DST再加上进位标志CF，结果放入DST</td>\n<td>ADC AX, BX</td>\n<td>一般用在双精度加法中，当低字相加后，两个高字相加时要考虑来自低字的进位</td>\n</tr>\n<tr>\n<td>加1指令</td>\n<td>INC OPR</td>\n<td>(OPR)←(OPR)+1</td>\n<td>将OPR加1，结果放入OPR</td>\n<td>INC AX</td>\n<td></td>\n</tr>\n<tr>\n<td>减法指令</td>\n<td>SUB DST,SRC</td>\n<td>(DST)←(DST)-(SRC)</td>\n<td>SRC减去DST，结果放入DST</td>\n<td>SUB AX, BX</td>\n<td></td>\n</tr>\n<tr>\n<td>带借位减法指令</td>\n<td>SBB DST,SRC</td>\n<td>(DST)←(DST)-(SRC)-CF</td>\n<td>将DST减去SRC再减去借位标志CF，结果放入DST</td>\n<td>SBB AX, BX</td>\n<td>一般用在双精度减法中，当低字相减后，两个高字相减时要考虑来自低字的借位</td>\n</tr>\n<tr>\n<td>减1指令</td>\n<td>DEC OPR</td>\n<td>(OPR)←(OPR)-1</td>\n<td>将OPR减1，结果放入OPR</td>\n<td>DEC AX</td>\n<td></td>\n</tr>\n<tr>\n<td>求补指令</td>\n<td>NEG OPR</td>\n<td>(OPR)←0-(OPR)</td>\n<td>将OPR求补，结果放入OPR</td>\n<td>NEG AX</td>\n<td></td>\n</tr>\n<tr>\n<td>比较指令</td>\n<td>CMP OPR1，OPR2</td>\n<td>(OPR1)-(OPR2)</td>\n<td>将OPR1减去OPR2，但不保存结果,改变标志位</td>\n<td>CMP AX, BX</td>\n<td>一般用于比较两个操作数的大小，不改变操作数的值</td>\n</tr>\n<tr>\n<td>无符号数乘法指令</td>\n<td>MUL SRC</td>\n<td>DX:AX←(AX) * (SRC)</td>\n<td>将AX乘以SRC（字），结果放入AX和DX</td>\n<td>MUL AX</td>\n<td>字节乘法是将AL乘以SRC（字节），结果放入AX</td>\n</tr>\n<tr>\n<td>带符号数乘法指令</td>\n<td>IMUL SRC</td>\n<td>DX:AX←(AX) * (SRC)</td>\n<td>将AX乘以SRC（字），结果放入AX和DX</td>\n<td>IMUL AX</td>\n<td>字节乘法是将AL乘以SRC（字节），结果放入AX</td>\n</tr>\n<tr>\n<td>无符号数除法指令</td>\n<td>DIV SRC</td>\n<td>AX←(DX:AX)/(SRC),DX←(DX:AX)%(SRC)</td>\n<td>将DX:AX除以SRC（字），结果放入AX，余数放入DX</td>\n<td>DIV AX</td>\n<td>字节除法是将AX除以SRC（字节），结果放入AL，余数放入AH</td>\n</tr>\n<tr>\n<td>带符号数除法指令</td>\n<td>IDIV SRC</td>\n<td>AX←(DX:AX)/(SRC),DX←(DX:AX)%(SRC)</td>\n<td>将DX:AX除以SRC（字），结果放入AX，余数放入DX</td>\n<td>IDIV AX</td>\n<td>字节除法是将AX除以SRC（字节），结果放入AL，余数放入AH</td>\n</tr>\n<tr>\n<td>压缩的BCD码加法调整</td>\n<td>DAA</td>\n<td>如果AL的低4位大于9，则将AL加6，并将AF置1，如果AL的高4位大于9（或等于9时AF为1），则将AL加60H，并将CF置1</td>\n<td></td>\n<td>DAA</td>\n<td></td>\n</tr>\n<tr>\n<td>压缩的BCD码减法调整</td>\n<td>DAS</td>\n<td>如果AF为1（AC），则将AL减6,AF置1。如果AL的高4位大于9，将AL减60H，并将CF置1</td>\n<td></td>\n<td>DAS</td>\n<td></td>\n</tr>\n<tr>\n<td>非压缩的BCD码加法调整</td>\n<td>AAA</td>\n<td>如果AL的低4位大于9，则将AL加6，AH加1，AL的高4位置0，CF和AF置1</td>\n<td></td>\n<td>AAA</td>\n<td></td>\n</tr>\n<tr>\n<td>非压缩的BCD码减法调整</td>\n<td>AAS</td>\n<td>如果AF为1（AC），则将AL减6，AH减1，AL高4位置0，CF置1</td>\n<td></td>\n<td>AAS</td>\n<td></td>\n</tr>\n<tr>\n<td>非压缩的BCD码乘法调整</td>\n<td>AAM</td>\n<td>AL除以0AH，得到的商送往AH，余数送往AL</td>\n<td>将乘积调整为两个非压缩的BCD码。</td>\n<td>AAM</td>\n<td></td>\n</tr>\n<tr>\n<td>非压缩的BCD码除法调整</td>\n<td>AAD</td>\n<td>AL+AH×0AH，结果送往AL，AH清零</td>\n<td>在做除法之前，将被除数AX中的两个非压缩的BCD码调整为二进制数</td>\n<td>AAD</td>\n<td></td>\n</tr>\n<tr>\n<td>算数左移</td>\n<td>SAL OPR,CNT</td>\n<td>(OPR)←(OPR)×2^(CNT)</td>\n<td>将OPR左移CNT位，结果放入OPR</td>\n<td>SAL AX, 1</td>\n<td>超过1位必须用CL寄存器指出位移位数</td>\n</tr>\n<tr>\n<td>算数右移</td>\n<td>SAR OPR,CNT</td>\n<td>(OPR)←(OPR)/2^(CNT)</td>\n<td>将OPR右移CNT位，结果放入OPR</td>\n<td>SAR AX, 1</td>\n<td>超过1位必须用CL寄存器指出位移位数</td>\n</tr>\n<tr>\n<td>循环左移</td>\n<td>ROL OPR,CNT</td>\n<td></td>\n<td>OPR左移，最高位进CF同时进最低位</td>\n<td>ROL AX, 1</td>\n<td>超过1位必须用CL寄存器指出位移位数</td>\n</tr>\n<tr>\n<td>循环右移</td>\n<td>ROR OPR,CNT</td>\n<td></td>\n<td>OPR右移，最低位进CF同时进最高位</td>\n<td>ROR AX, 1</td>\n<td>超过1位必须用CL寄存器指出位移位数</td>\n</tr>\n<tr>\n<td>带进位循环左移</td>\n<td>RCL OPR,CNT</td>\n<td></td>\n<td>OPR左移，CF移入最低位，最高位进CF</td>\n<td>RCL AX, 1</td>\n<td>超过1位必须用CL寄存器指出位移位数</td>\n</tr>\n<tr>\n<td>带进位循环右移</td>\n<td>RCR OPR,CNT</td>\n<td></td>\n<td>OPR右移，CF移入最高位，最低位进CF</td>\n<td>RCR AX, 1</td>\n<td>超过1位必须用CL寄存器指出位移位数</td>\n</tr>\n</tbody></table>\n<h3 id=\"逻辑运算指令\"><a href=\"#逻辑运算指令\" class=\"headerlink\" title=\"逻辑运算指令\"></a>逻辑运算指令</h3><table>\n<thead>\n<tr>\n<th>指令</th>\n<th>格式</th>\n<th>作用</th>\n<th>说明</th>\n<th>举例</th>\n<th>注意</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>逻辑与</td>\n<td>AND DST,SRC</td>\n<td>(DST)←(DST) AND (SRC)</td>\n<td>SRC和DST进行逻辑与，结果放入DST</td>\n<td>AND AX, BX</td>\n<td>自身相与结果不变但是改变标志位</td>\n</tr>\n<tr>\n<td>逻辑或</td>\n<td>OR DST,SRC</td>\n<td>(DST)←(DST) OR (SRC)</td>\n<td>SRC和DST进行逻辑或，结果放入DST</td>\n<td>OR AX, BX</td>\n<td></td>\n</tr>\n<tr>\n<td>逻辑非</td>\n<td>NOT OPR</td>\n<td>(OPR)←NOT (OPR)</td>\n<td>将OPR求逻辑非，结果放入OPR</td>\n<td>NOT AX</td>\n<td></td>\n</tr>\n<tr>\n<td>逻辑异或</td>\n<td>XOR DST,SRC</td>\n<td>(DST)←(DST) XOR (SRC)</td>\n<td>SRC和DST进行逻辑异或，结果放入DST</td>\n<td>XOR AX, BX</td>\n<td></td>\n</tr>\n<tr>\n<td>测试指令</td>\n<td>TEST DST,SRC</td>\n<td>(DST) AND (SRC)</td>\n<td>SRC和DST进行逻辑与，结果不放入DST，只改变标志位</td>\n<td>TEST AX, BX</td>\n<td></td>\n</tr>\n<tr>\n<td>逻辑左移</td>\n<td>SHL OPR,CNT</td>\n<td>(OPR)←(OPR)×2^(CNT)</td>\n<td>将OPR左移CNT位，结果放入OPR</td>\n<td>SHL AX, 1</td>\n<td>超过1位必须用CL寄存器指出位移位数</td>\n</tr>\n<tr>\n<td>逻辑右移</td>\n<td>SHR OPR,CNT</td>\n<td>(OPR)←(OPR)/2^(CNT)</td>\n<td>将OPR右移CNT位，结果放入OPR</td>\n<td>SHR AX, 1</td>\n<td>超过1位必须用CL寄存器指出位移位数</td>\n</tr>\n</tbody></table>\n<h3 id=\"串操作指令\"><a href=\"#串操作指令\" class=\"headerlink\" title=\"串操作指令\"></a>串操作指令</h3><table>\n<thead>\n<tr>\n<th>串处理指令</th>\n<th>格式</th>\n<th>作用</th>\n<th>说明</th>\n<th>举例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>串传送</td>\n<td>MOVS/MOVSB/MOVSW DST,SRC</td>\n<td>REP连用，以字或字节的形式重复传送，直到CX=0为止,源串偏移地址由SI指出，目的串的偏移地址由DI指出，传送次数由CX指出</td>\n<td>第一种格式的双操作数要显式地指出源和目的操作数的地址属性；后两种格式隐式地指出源和目的串的地址和属性，即指令中没有操作数只有操作码</td>\n<td>REP MOVS BYTE PTR ES:[SI],DS:[DI]<br>REP MOVSB</td>\n</tr>\n<tr>\n<td>串比较</td>\n<td>CMPS/CMPSB/CMPSW DST,SRC</td>\n<td>和REPZ等指令连用，以字或字节的形式重复比较，直到CX=0为止，并改变标志位,源串偏移地址由SI指出，目的串的偏移地址由DI指出，比较次数由CX指出</td>\n<td>第一种格式的双操作数要显式地指出源和目的操作数的地址属性；后两种格式隐式地指出源和目的串的地址和属性，即指令中没有操作数只有操作码</td>\n<td>REPNE CMPSW</td>\n</tr>\n<tr>\n<td>串扫描</td>\n<td>SCAS/SCASB/SCASW DST</td>\n<td>和REPZ等指令连用，在目的串中查找与AL或AX相等的字或字节，直到CX=0为止，并改变标志位,目的串在附加段中，偏移地址由DI指出，扫描次数由CX指出</td>\n<td>第一种格式的单操作数要显式地指出目的操作数的地址和属性；后两种格式隐式地指出目的串的地址和属性，即指令中没有操作数只有操作码</td>\n<td>REPNZ SCASB</td>\n</tr>\n<tr>\n<td>串获取</td>\n<td>LODS/LODSB/LODSW SRC</td>\n<td>从源串中取出一个字或字节放入AL或AX中,源串在数据段定义，源串偏移地址由SI指出。如果与REP连用则直到CX=0为止，取出次数由CX指出</td>\n<td>第一种格式的单操作数要显式地指出源操作数的地址和属性；后两种格式隐式地指出源串的地址和属性，即指令中没有操作数只有操作码</td>\n<td>REP LODSW</td>\n</tr>\n<tr>\n<td>串存入</td>\n<td>STOS/STOSB/STOSW DST</td>\n<td>将AL或AX中的字或字节存入目的串中,目的串在附加段定义，目的串偏移地址由DI指出。如果与REP连用则直到CX=0为止，存入次数由CX指出</td>\n<td>第一种格式的单操作数要显式地指出目的操作数的地址和属性；后两种格式隐式地指出目的串的地址和属性，即指令中没有操作数只有操作码</td>\n<td>REP STOSB</td>\n</tr>\n</tbody></table>\n<h3 id=\"控制与转移指令\"><a href=\"#控制与转移指令\" class=\"headerlink\" title=\"控制与转移指令\"></a>控制与转移指令</h3><table>\n<thead>\n<tr>\n<th>无条件转移指令</th>\n<th>用法</th>\n<th>说明</th>\n<th>举例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>段内直接短转移</td>\n<td>JMP SHORT OPR</td>\n<td>(IP)←(IP)+8位位移量OPR</td>\n<td>JMP SHORT HELLO</td>\n</tr>\n<tr>\n<td>段内直接近转移</td>\n<td>JMP NEAR OPR</td>\n<td>(IP)←(IP)+16位偏移量OPR</td>\n<td>JMP NEAR HELLO</td>\n</tr>\n<tr>\n<td>段内间接转移</td>\n<td>JMP WORD PTR OPR</td>\n<td>(IP)←(EA)</td>\n<td>JMP WORD PTR [BX+SI]</td>\n</tr>\n<tr>\n<td>段间直接转移</td>\n<td>JMP FAR OPR</td>\n<td>(CS):(IP)←(OPR)</td>\n<td>JMP FAR PTR HELLO</td>\n</tr>\n<tr>\n<td>段间间接转移</td>\n<td>JMP DWORD PTR OPR</td>\n<td>(IP)←(EA),(CS)←(EA+2)</td>\n<td>JMP DWORD PTR [BX]</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>条件标志转移指令</th>\n<th>转移条件</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JZ/JE</td>\n<td>ZF=1</td>\n<td>结果为0则转移</td>\n</tr>\n<tr>\n<td>JNZ/JNE</td>\n<td>ZF=0</td>\n<td>结果不为0则转移</td>\n</tr>\n<tr>\n<td>JC</td>\n<td>CF=1</td>\n<td>进位标志为1则转移</td>\n</tr>\n<tr>\n<td>JNC</td>\n<td>CF=0</td>\n<td>进位标志为0则转移</td>\n</tr>\n<tr>\n<td>JS</td>\n<td>SF=1</td>\n<td>符号标志为1则转移</td>\n</tr>\n<tr>\n<td>JNS</td>\n<td>SF=0</td>\n<td>符号标志为0则转移</td>\n</tr>\n<tr>\n<td>JO</td>\n<td>OF=1</td>\n<td>溢出标志为1则转移</td>\n</tr>\n<tr>\n<td>JNO</td>\n<td>OF=0</td>\n<td>溢出标志为0则转移</td>\n</tr>\n<tr>\n<td>JP</td>\n<td>PF=1</td>\n<td>奇偶标志为1则转移</td>\n</tr>\n<tr>\n<td>JNP</td>\n<td>PF=0</td>\n<td>奇偶标志为0则转移</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>无符号数比较转移指令</th>\n<th>转移条件</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JB/JNAE</td>\n<td>CF=1 AND ZF=0</td>\n<td>小于则转移</td>\n</tr>\n<tr>\n<td>JBE/JNA</td>\n<td>CF=1 OR ZF=1</td>\n<td>小于等于则转移</td>\n</tr>\n<tr>\n<td>JA/JNBE</td>\n<td>CF=0 AND ZF=0</td>\n<td>大于则转移</td>\n</tr>\n<tr>\n<td>JAE/JNB</td>\n<td>CF=0 OR ZF=1</td>\n<td>大于等于则转移</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>带符号数比较转移指令</th>\n<th>转移条件</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JL/JNGE</td>\n<td>SF≠OF AND ZF=0</td>\n<td>小于则转移</td>\n</tr>\n<tr>\n<td>JLE/JNG</td>\n<td>ZF=1 OR SF≠OF</td>\n<td>小于等于则转移</td>\n</tr>\n<tr>\n<td>JG/JNLE</td>\n<td>ZF=0 AND SF=OF</td>\n<td>大于则转移</td>\n</tr>\n<tr>\n<td>JGE/JNL</td>\n<td>SF=OF OR ZF=1</td>\n<td>大于等于则转移</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>CX转移</th>\n<th>转移条件</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JCSZ</td>\n<td>CX=0</td>\n<td>CX为0则转移</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>循环指令</th>\n<th>格式</th>\n<th>作用</th>\n<th>举例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>循环</td>\n<td>LOOP OPR</td>\n<td>(CX)←(CX)-1,若CX≠0，跳转到标号OPR处循环执行，若CX=0，退出循环并执行LOOP的下一条指令</td>\n<td>LOOP SS1</td>\n</tr>\n<tr>\n<td>循环</td>\n<td>LOOPZ/LOOPE OPR</td>\n<td>(CX)←(CX)-1,若CX≠0且ZF=1，跳转到标号OPR处循环执行，若CX=0或ZF=0，则执行LOOPZ的下一条指令</td>\n<td>LOOPZ SS1</td>\n</tr>\n<tr>\n<td>循环</td>\n<td>LOOPNZ/LOOPNE OPR</td>\n<td>(CX)←(CX)-1,若CX≠0且ZF=0，跳转到标号OPR处循环执行，若CX=0或ZF=1，则执行LOOPNZ的下一条指令</td>\n<td>LOOPNZ SS1</td>\n</tr>\n</tbody></table>\n<h3 id=\"处理机控制指令\"><a href=\"#处理机控制指令\" class=\"headerlink\" title=\"处理机控制指令\"></a>处理机控制指令</h3><table>\n<thead>\n<tr>\n<th>指令</th>\n<th>作用</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CLC</td>\n<td>CF=0</td>\n<td>清除进位标志</td>\n</tr>\n<tr>\n<td>STC</td>\n<td>CF=1</td>\n<td>设置进位标志</td>\n</tr>\n<tr>\n<td>CMC</td>\n<td>CF=NOT CF</td>\n<td>进位标志取反</td>\n</tr>\n<tr>\n<td>CLD</td>\n<td>DF=0</td>\n<td>清除方向标志</td>\n</tr>\n<tr>\n<td>STD</td>\n<td>DF=1</td>\n<td>设置方向标志</td>\n</tr>\n<tr>\n<td>CLI</td>\n<td>IF=0</td>\n<td>清除中断标志</td>\n</tr>\n<tr>\n<td>STI</td>\n<td>IF=1</td>\n<td>设置中断标志</td>\n</tr>\n<tr>\n<td>HLT</td>\n<td>停机</td>\n<td>停机</td>\n</tr>\n<tr>\n<td>NOP</td>\n<td>无操作</td>\n<td>占3个时钟周期</td>\n</tr>\n</tbody></table>\n","feature":true,"text":"在学校学习了汇编语言一课程，但是由于汇编指令繁多，而且在互联网上没有找到满足我要求的资料。同时书上的知识也比较分散，不好索引。所以我打算自己整理一份资料，方便自...","permalink":"/post/8086微机汇编语言","photos":[],"count_time":{"symbolsCount":"7.7k","symbolsTime":"7 mins."},"categories":[{"name":"汇编","slug":"汇编","count":1,"path":"api/categories/汇编.json"}],"tags":[{"name":"汇编","slug":"汇编","count":1,"path":"api/tags/汇编.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">寄存器分类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">通用寄存器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">地址寄存器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">段寄存器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">控制寄存器</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8C%87%E4%BB%A4%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">指令分类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#DOS%E5%8A%9F%E8%83%BD%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">DOS功能调用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">数据传送指令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">算术运算指令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">逻辑运算指令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%B2%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">串操作指令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%A7%E5%88%B6%E4%B8%8E%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">控制与转移指令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%84%E7%90%86%E6%9C%BA%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">处理机控制指令</span></a></li></ol></li></ol>","author":{"name":"Ac-Accelerator","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一位计算机技术爱好者，大学在读，目前正在学习C++、Python、Java和计算机系统以及计算机视觉深度学习等相关知识，欢迎交流","socials":{"github":"https://github.com/Ac-Accelerator","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_31702515?spm=1000.2115.3001.5343","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/74120250?spm_id_from=333.1007.0.0"},"rss":{"icon":"/svg/rss.svg","link":"atom.xml"},"qq":{"icon":"/svg/QQ.svg","link":"http://tool.gljlw.com/qq/?qq=2583832841"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"STM32入门（一）：认识STM32","uid":"d680335def93df41c247e0c4f534ee20","slug":"STM32入门（一）：认识STM32","date":"2023-07-13T08:31:43.000Z","updated":"2023-07-16T03:52:07.346Z","comments":true,"path":"api/articles/STM32入门（一）：认识STM32.json","keywords":"C++,Pyhton,Java,算法","cover":"/img/STM32cover.png","text":"产品类型STM32分为小容量、中容量、大容量和互联型产品。 小容量产品是指闪存存储器容量在16K至32K字节之间的STM32F101xx、STM32F102xx...","permalink":"/post/STM32入门（一）：认识STM32","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"嵌入式","slug":"嵌入式","count":8,"path":"api/categories/嵌入式.json"}],"tags":[{"name":"STM32","slug":"STM32","count":8,"path":"api/tags/STM32.json"},{"name":"单片机","slug":"单片机","count":8,"path":"api/tags/单片机.json"}],"author":{"name":"Ac-Accelerator","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一位计算机技术爱好者，大学在读，目前正在学习C++、Python、Java和计算机系统以及计算机视觉深度学习等相关知识，欢迎交流","socials":{"github":"https://github.com/Ac-Accelerator","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_31702515?spm=1000.2115.3001.5343","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/74120250?spm_id_from=333.1007.0.0"},"rss":{"icon":"/svg/rss.svg","link":"atom.xml"},"qq":{"icon":"/svg/QQ.svg","link":"http://tool.gljlw.com/qq/?qq=2583832841"}}}},"feature":true},"next_post":{"title":"数据库系统原理（二）","uid":"77e095561161043d7bcb5f0fd932479f","slug":"数据库系统原理（二）","date":"2023-03-29T08:37:00.000Z","updated":"2023-04-06T07:24:25.739Z","comments":true,"path":"api/articles/数据库系统原理（二）.json","keywords":"C++,Pyhton,Java,算法","cover":"/img/db.jpeg","text":"数据的定义与操作SQL概述关系数据库的标准语言是 Structured Query Language，全称的翻译成中文就是结构化查询语言，简称SQL。虽然SQL...","permalink":"/post/数据库系统原理（二）","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"数据库","slug":"数据库","count":2,"path":"api/categories/数据库.json"}],"tags":[{"name":"数据库","slug":"数据库","count":2,"path":"api/tags/数据库.json"},{"name":"学习笔记","slug":"学习笔记","count":2,"path":"api/tags/学习笔记.json"}],"author":{"name":"Ac-Accelerator","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一位计算机技术爱好者，大学在读，目前正在学习C++、Python、Java和计算机系统以及计算机视觉深度学习等相关知识，欢迎交流","socials":{"github":"https://github.com/Ac-Accelerator","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_31702515?spm=1000.2115.3001.5343","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/74120250?spm_id_from=333.1007.0.0"},"rss":{"icon":"/svg/rss.svg","link":"atom.xml"},"qq":{"icon":"/svg/QQ.svg","link":"http://tool.gljlw.com/qq/?qq=2583832841"}}}},"feature":true}}